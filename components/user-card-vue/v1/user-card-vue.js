var B_ = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var xJ = B_((ho, mo) => {
  /**
  * @vue/shared v3.5.24
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  // @__NO_SIDE_EFFECTS__
  function Zl(e) {
    const t = /* @__PURE__ */ Object.create(null);
    for (const n of e.split(",")) t[n] = 1;
    return (n) => n in t;
  }
  const Jt = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {}, zr = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [], It = () => {
  }, C0 = () => !1, zi = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // uppercase letter
  (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), gc = (e) => e.startsWith("onUpdate:"), pn = Object.assign, wv = (e, t) => {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1);
  }, F_ = Object.prototype.hasOwnProperty, Ot = (e, t) => F_.call(e, t), ye = Array.isArray, Za = (e) => Hi(e) === "[object Map]", id = (e) => Hi(e) === "[object Set]", ka = (e) => Hi(e) === "[object Date]", Fe = (e) => typeof e == "function", Ae = (e) => typeof e == "string", Wo = (e) => typeof e == "symbol", ot = (e) => e !== null && typeof e == "object", _a = (e) => (ot(e) || Fe(e)) && Fe(e.then) && Fe(e.catch), S0 = Object.prototype.toString, Hi = (e) => S0.call(e), Cv = (e) => Hi(e).slice(8, -1), si = (e) => Hi(e) === "[object Object]", Sv = (e) => Ae(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Ys = /* @__PURE__ */ Zl(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  ), z_ = /* @__PURE__ */ Zl(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  ), ud = (e) => {
    const t = /* @__PURE__ */ Object.create(null);
    return (n) => t[n] || (t[n] = e(n));
  }, H_ = /-\w/g, In = ud(
    (e) => e.replace(H_, (t) => t.slice(1).toUpperCase())
  ), K_ = /\B([A-Z])/g, gl = ud(
    (e) => e.replace(K_, "-$1").toLowerCase()
  ), Ta = ud((e) => e.charAt(0).toUpperCase() + e.slice(1)), Rl = ud(
    (e) => e ? `on${Ta(e)}` : ""
  ), Sa = (e, t) => !Object.is(e, t), Pr = (e, ...t) => {
    for (let n = 0; n < e.length; n++)
      e[n](...t);
  }, bc = (e, t, n, o = !1) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      writable: o,
      value: n
    });
  }, Ev = (e) => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t;
  }, W_ = (e) => {
    const t = Ae(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t;
  };
  let xm;
  const Ki = () => xm || (xm = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
  function Ue(e) {
    if (ye(e)) {
      const t = {};
      for (let n = 0; n < e.length; n++) {
        const o = e[n], l = Ae(o) ? q_(o) : Ue(o);
        if (l)
          for (const a in l)
            t[a] = l[a];
      }
      return t;
    } else if (Ae(e) || ot(e))
      return e;
  }
  const j_ = /;(?![^(]*\))/g, U_ = /:([^]+)/, Y_ = /\/\*[^]*?\*\//g;
  function q_(e) {
    const t = {};
    return e.replace(Y_, "").split(j_).forEach((n) => {
      if (n) {
        const o = n.split(U_);
        o.length > 1 && (t[o[0].trim()] = o[1].trim());
      }
    }), t;
  }
  function $(e) {
    let t = "";
    if (Ae(e))
      t = e;
    else if (ye(e))
      for (let n = 0; n < e.length; n++) {
        const o = $(e[n]);
        o && (t += o + " ");
      }
    else if (ot(e))
      for (const n in e)
        e[n] && (t += n + " ");
    return t.trim();
  }
  function Bo(e) {
    if (!e) return null;
    let { class: t, style: n } = e;
    return t && !Ae(t) && (e.class = $(t)), n && (e.style = Ue(n)), e;
  }
  const G_ = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", X_ = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", J_ = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", Z_ = /* @__PURE__ */ Zl(G_), Q_ = /* @__PURE__ */ Zl(X_), e2 = /* @__PURE__ */ Zl(J_), t2 = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", n2 = /* @__PURE__ */ Zl(t2);
  function E0(e) {
    return !!e || e === "";
  }
  function o2(e, t) {
    if (e.length !== t.length) return !1;
    let n = !0;
    for (let o = 0; n && o < e.length; o++)
      n = Qr(e[o], t[o]);
    return n;
  }
  function Qr(e, t) {
    if (e === t) return !0;
    let n = ka(e), o = ka(t);
    if (n || o)
      return n && o ? e.getTime() === t.getTime() : !1;
    if (n = Wo(e), o = Wo(t), n || o)
      return e === t;
    if (n = ye(e), o = ye(t), n || o)
      return n && o ? o2(e, t) : !1;
    if (n = ot(e), o = ot(t), n || o) {
      if (!n || !o)
        return !1;
      const l = Object.keys(e).length, a = Object.keys(t).length;
      if (l !== a)
        return !1;
      for (const r in e) {
        const i = e.hasOwnProperty(r), u = t.hasOwnProperty(r);
        if (i && !u || !i && u || !Qr(e[r], t[r]))
          return !1;
      }
    }
    return String(e) === String(t);
  }
  function k0(e, t) {
    return e.findIndex((n) => Qr(n, t));
  }
  const _0 = (e) => !!(e && e.__v_isRef === !0), ke = (e) => Ae(e) ? e : e == null ? "" : ye(e) || ot(e) && (e.toString === S0 || !Fe(e.toString)) ? _0(e) ? ke(e.value) : JSON.stringify(e, T0, 2) : String(e), T0 = (e, t) => _0(t) ? T0(e, t.value) : Za(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce(
      (n, [o, l], a) => (n[rf(o, a) + " =>"] = l, n),
      {}
    )
  } : id(t) ? {
    [`Set(${t.size})`]: [...t.values()].map((n) => rf(n))
  } : Wo(t) ? rf(t) : ot(t) && !ye(t) && !si(t) ? String(t) : t, rf = (e, t = "") => {
    var n;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      Wo(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e
    );
  };
  /**
  * @vue/reactivity v3.5.24
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function yo(e, ...t) {
    console.warn(`[Vue warn] ${e}`, ...t);
  }
  let zn;
  class N0 {
    constructor(t = !1) {
      this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = zn, !t && zn && (this.index = (zn.scopes || (zn.scopes = [])).push(
        this
      ) - 1);
    }
    get active() {
      return this._active;
    }
    pause() {
      if (this._active) {
        this._isPaused = !0;
        let t, n;
        if (this.scopes)
          for (t = 0, n = this.scopes.length; t < n; t++)
            this.scopes[t].pause();
        for (t = 0, n = this.effects.length; t < n; t++)
          this.effects[t].pause();
      }
    }
    /**
     * Resumes the effect scope, including all child scopes and effects.
     */
    resume() {
      if (this._active && this._isPaused) {
        this._isPaused = !1;
        let t, n;
        if (this.scopes)
          for (t = 0, n = this.scopes.length; t < n; t++)
            this.scopes[t].resume();
        for (t = 0, n = this.effects.length; t < n; t++)
          this.effects[t].resume();
      }
    }
    run(t) {
      if (this._active) {
        const n = zn;
        try {
          return zn = this, t();
        } finally {
          zn = n;
        }
      } else process.env.NODE_ENV !== "production" && yo("cannot run an inactive effect scope.");
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      ++this._on === 1 && (this.prevScope = zn, zn = this);
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      this._on > 0 && --this._on === 0 && (zn = this.prevScope, this.prevScope = void 0);
    }
    stop(t) {
      if (this._active) {
        this._active = !1;
        let n, o;
        for (n = 0, o = this.effects.length; n < o; n++)
          this.effects[n].stop();
        for (this.effects.length = 0, n = 0, o = this.cleanups.length; n < o; n++)
          this.cleanups[n]();
        if (this.cleanups.length = 0, this.scopes) {
          for (n = 0, o = this.scopes.length; n < o; n++)
            this.scopes[n].stop(!0);
          this.scopes.length = 0;
        }
        if (!this.detached && this.parent && !t) {
          const l = this.parent.scopes.pop();
          l && l !== this && (this.parent.scopes[this.index] = l, l.index = this.index);
        }
        this.parent = void 0;
      }
    }
  }
  function l2(e) {
    return new N0(e);
  }
  function $0() {
    return zn;
  }
  function O0(e, t = !1) {
    zn ? zn.cleanups.push(e) : process.env.NODE_ENV !== "production" && !t && yo(
      "onScopeDispose() is called when there is no active effect scope to be associated with."
    );
  }
  let Xt;
  const sf = /* @__PURE__ */ new WeakSet();
  class I0 {
    constructor(t) {
      this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, zn && zn.active && zn.effects.push(this);
    }
    pause() {
      this.flags |= 64;
    }
    resume() {
      this.flags & 64 && (this.flags &= -65, sf.has(this) && (sf.delete(this), this.trigger()));
    }
    /**
     * @internal
     */
    notify() {
      this.flags & 2 && !(this.flags & 32) || this.flags & 8 || x0(this);
    }
    run() {
      if (!(this.flags & 1))
        return this.fn();
      this.flags |= 2, Pm(this), P0(this);
      const t = Xt, n = Fo;
      Xt = this, Fo = !0;
      try {
        return this.fn();
      } finally {
        process.env.NODE_ENV !== "production" && Xt !== this && yo(
          "Active effect was not restored correctly - this is likely a Vue internal bug."
        ), R0(this), Xt = t, Fo = n, this.flags &= -3;
      }
    }
    stop() {
      if (this.flags & 1) {
        for (let t = this.deps; t; t = t.nextDep)
          Tv(t);
        this.deps = this.depsTail = void 0, Pm(this), this.onStop && this.onStop(), this.flags &= -2;
      }
    }
    trigger() {
      this.flags & 64 ? sf.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
    }
    /**
     * @internal
     */
    runIfDirty() {
      Xf(this) && this.run();
    }
    get dirty() {
      return Xf(this);
    }
  }
  let M0 = 0, qs, Gs;
  function x0(e, t = !1) {
    if (e.flags |= 8, t) {
      e.next = Gs, Gs = e;
      return;
    }
    e.next = qs, qs = e;
  }
  function kv() {
    M0++;
  }
  function _v() {
    if (--M0 > 0)
      return;
    if (Gs) {
      let t = Gs;
      for (Gs = void 0; t; ) {
        const n = t.next;
        t.next = void 0, t.flags &= -9, t = n;
      }
    }
    let e;
    for (; qs; ) {
      let t = qs;
      for (qs = void 0; t; ) {
        const n = t.next;
        if (t.next = void 0, t.flags &= -9, t.flags & 1)
          try {
            t.trigger();
          } catch (o) {
            e || (e = o);
          }
        t = n;
      }
    }
    if (e) throw e;
  }
  function P0(e) {
    for (let t = e.deps; t; t = t.nextDep)
      t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t;
  }
  function R0(e) {
    let t, n = e.depsTail, o = n;
    for (; o; ) {
      const l = o.prevDep;
      o.version === -1 ? (o === n && (n = l), Tv(o), a2(o)) : t = o, o.dep.activeLink = o.prevActiveLink, o.prevActiveLink = void 0, o = l;
    }
    e.deps = t, e.depsTail = n;
  }
  function Xf(e) {
    for (let t = e.deps; t; t = t.nextDep)
      if (t.dep.version !== t.version || t.dep.computed && (D0(t.dep.computed) || t.dep.version !== t.version))
        return !0;
    return !!e._dirty;
  }
  function D0(e) {
    if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === ii) || (e.globalVersion = ii, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !Xf(e))))
      return;
    e.flags |= 2;
    const t = e.dep, n = Xt, o = Fo;
    Xt = e, Fo = !0;
    try {
      P0(e);
      const l = e.fn(e._value);
      (t.version === 0 || Sa(l, e._value)) && (e.flags |= 128, e._value = l, t.version++);
    } catch (l) {
      throw t.version++, l;
    } finally {
      Xt = n, Fo = o, R0(e), e.flags &= -3;
    }
  }
  function Tv(e, t = !1) {
    const { dep: n, prevSub: o, nextSub: l } = e;
    if (o && (o.nextSub = l, e.prevSub = void 0), l && (l.prevSub = o, e.nextSub = void 0), process.env.NODE_ENV !== "production" && n.subsHead === e && (n.subsHead = l), n.subs === e && (n.subs = o, !o && n.computed)) {
      n.computed.flags &= -5;
      for (let a = n.computed.deps; a; a = a.nextDep)
        Tv(a, !0);
    }
    !t && !--n.sc && n.map && n.map.delete(n.key);
  }
  function a2(e) {
    const { prevDep: t, nextDep: n } = e;
    t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0);
  }
  let Fo = !0;
  const A0 = [];
  function jo() {
    A0.push(Fo), Fo = !1;
  }
  function Uo() {
    const e = A0.pop();
    Fo = e === void 0 ? !0 : e;
  }
  function Pm(e) {
    const { cleanup: t } = e;
    if (e.cleanup = void 0, t) {
      const n = Xt;
      Xt = void 0;
      try {
        t();
      } finally {
        Xt = n;
      }
    }
  }
  let ii = 0, r2 = class {
    constructor(t, n) {
      this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
    }
  };
  class cd {
    // TODO isolatedDeclarations "__v_skip"
    constructor(t) {
      this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0, process.env.NODE_ENV !== "production" && (this.subsHead = void 0);
    }
    track(t) {
      if (!Xt || !Fo || Xt === this.computed)
        return;
      let n = this.activeLink;
      if (n === void 0 || n.sub !== Xt)
        n = this.activeLink = new r2(Xt, this), Xt.deps ? (n.prevDep = Xt.depsTail, Xt.depsTail.nextDep = n, Xt.depsTail = n) : Xt.deps = Xt.depsTail = n, V0(n);
      else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
        const o = n.nextDep;
        o.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = o), n.prevDep = Xt.depsTail, n.nextDep = void 0, Xt.depsTail.nextDep = n, Xt.depsTail = n, Xt.deps === n && (Xt.deps = o);
      }
      return process.env.NODE_ENV !== "production" && Xt.onTrack && Xt.onTrack(
        pn(
          {
            effect: Xt
          },
          t
        )
      ), n;
    }
    trigger(t) {
      this.version++, ii++, this.notify(t);
    }
    notify(t) {
      kv();
      try {
        if (process.env.NODE_ENV !== "production")
          for (let n = this.subsHead; n; n = n.nextSub)
            n.sub.onTrigger && !(n.sub.flags & 8) && n.sub.onTrigger(
              pn(
                {
                  effect: n.sub
                },
                t
              )
            );
        for (let n = this.subs; n; n = n.prevSub)
          n.sub.notify() && n.sub.dep.notify();
      } finally {
        _v();
      }
    }
  }
  function V0(e) {
    if (e.dep.sc++, e.sub.flags & 4) {
      const t = e.dep.computed;
      if (t && !e.dep.subs) {
        t.flags |= 20;
        for (let o = t.deps; o; o = o.nextDep)
          V0(o);
      }
      const n = e.dep.subs;
      n !== e && (e.prevSub = n, n && (n.nextSub = e)), process.env.NODE_ENV !== "production" && e.dep.subsHead === void 0 && (e.dep.subsHead = e), e.dep.subs = e;
    }
  }
  const yc = /* @__PURE__ */ new WeakMap(), Qa = Symbol(
    process.env.NODE_ENV !== "production" ? "Object iterate" : ""
  ), Jf = Symbol(
    process.env.NODE_ENV !== "production" ? "Map keys iterate" : ""
  ), ui = Symbol(
    process.env.NODE_ENV !== "production" ? "Array iterate" : ""
  );
  function Sn(e, t, n) {
    if (Fo && Xt) {
      let o = yc.get(e);
      o || yc.set(e, o = /* @__PURE__ */ new Map());
      let l = o.get(n);
      l || (o.set(n, l = new cd()), l.map = o, l.key = n), process.env.NODE_ENV !== "production" ? l.track({
        target: e,
        type: t,
        key: n
      }) : l.track();
    }
  }
  function il(e, t, n, o, l, a) {
    const r = yc.get(e);
    if (!r) {
      ii++;
      return;
    }
    const i = (u) => {
      u && (process.env.NODE_ENV !== "production" ? u.trigger({
        target: e,
        type: t,
        key: n,
        newValue: o,
        oldValue: l,
        oldTarget: a
      }) : u.trigger());
    };
    if (kv(), t === "clear")
      r.forEach(i);
    else {
      const u = ye(e), c = u && Sv(n);
      if (u && n === "length") {
        const d = Number(o);
        r.forEach((f, v) => {
          (v === "length" || v === ui || !Wo(v) && v >= d) && i(f);
        });
      } else
        switch ((n !== void 0 || r.has(void 0)) && i(r.get(n)), c && i(r.get(ui)), t) {
          case "add":
            u ? c && i(r.get("length")) : (i(r.get(Qa)), Za(e) && i(r.get(Jf)));
            break;
          case "delete":
            u || (i(r.get(Qa)), Za(e) && i(r.get(Jf)));
            break;
          case "set":
            Za(e) && i(r.get(Qa));
            break;
        }
    }
    _v();
  }
  function s2(e, t) {
    const n = yc.get(e);
    return n && n.get(t);
  }
  function kr(e) {
    const t = Pt(e);
    return t === e ? t : (Sn(t, "iterate", ui), eo(e) ? t : t.map(Dn));
  }
  function dd(e) {
    return Sn(e = Pt(e), "iterate", ui), e;
  }
  const i2 = {
    __proto__: null,
    [Symbol.iterator]() {
      return uf(this, Symbol.iterator, Dn);
    },
    concat(...e) {
      return kr(this).concat(
        ...e.map((t) => ye(t) ? kr(t) : t)
      );
    },
    entries() {
      return uf(this, "entries", (e) => (e[1] = Dn(e[1]), e));
    },
    every(e, t) {
      return Ml(this, "every", e, t, void 0, arguments);
    },
    filter(e, t) {
      return Ml(this, "filter", e, t, (n) => n.map(Dn), arguments);
    },
    find(e, t) {
      return Ml(this, "find", e, t, Dn, arguments);
    },
    findIndex(e, t) {
      return Ml(this, "findIndex", e, t, void 0, arguments);
    },
    findLast(e, t) {
      return Ml(this, "findLast", e, t, Dn, arguments);
    },
    findLastIndex(e, t) {
      return Ml(this, "findLastIndex", e, t, void 0, arguments);
    },
    // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
    forEach(e, t) {
      return Ml(this, "forEach", e, t, void 0, arguments);
    },
    includes(...e) {
      return cf(this, "includes", e);
    },
    indexOf(...e) {
      return cf(this, "indexOf", e);
    },
    join(e) {
      return kr(this).join(e);
    },
    // keys() iterator only reads `length`, no optimization required
    lastIndexOf(...e) {
      return cf(this, "lastIndexOf", e);
    },
    map(e, t) {
      return Ml(this, "map", e, t, void 0, arguments);
    },
    pop() {
      return Ms(this, "pop");
    },
    push(...e) {
      return Ms(this, "push", e);
    },
    reduce(e, ...t) {
      return Rm(this, "reduce", e, t);
    },
    reduceRight(e, ...t) {
      return Rm(this, "reduceRight", e, t);
    },
    shift() {
      return Ms(this, "shift");
    },
    // slice could use ARRAY_ITERATE but also seems to beg for range tracking
    some(e, t) {
      return Ml(this, "some", e, t, void 0, arguments);
    },
    splice(...e) {
      return Ms(this, "splice", e);
    },
    toReversed() {
      return kr(this).toReversed();
    },
    toSorted(e) {
      return kr(this).toSorted(e);
    },
    toSpliced(...e) {
      return kr(this).toSpliced(...e);
    },
    unshift(...e) {
      return Ms(this, "unshift", e);
    },
    values() {
      return uf(this, "values", Dn);
    }
  };
  function uf(e, t, n) {
    const o = dd(e), l = o[t]();
    return o !== e && !eo(e) && (l._next = l.next, l.next = () => {
      const a = l._next();
      return a.done || (a.value = n(a.value)), a;
    }), l;
  }
  const u2 = Array.prototype;
  function Ml(e, t, n, o, l, a) {
    const r = dd(e), i = r !== e && !eo(e), u = r[t];
    if (u !== u2[t]) {
      const f = u.apply(e, a);
      return i ? Dn(f) : f;
    }
    let c = n;
    r !== e && (i ? c = function(f, v) {
      return n.call(this, Dn(f), v, e);
    } : n.length > 2 && (c = function(f, v) {
      return n.call(this, f, v, e);
    }));
    const d = u.call(r, c, o);
    return i && l ? l(d) : d;
  }
  function Rm(e, t, n, o) {
    const l = dd(e);
    let a = n;
    return l !== e && (eo(e) ? n.length > 3 && (a = function(r, i, u) {
      return n.call(this, r, i, u, e);
    }) : a = function(r, i, u) {
      return n.call(this, r, Dn(i), u, e);
    }), l[t](a, ...o);
  }
  function cf(e, t, n) {
    const o = Pt(e);
    Sn(o, "iterate", ui);
    const l = o[t](...n);
    return (l === -1 || l === !1) && ci(n[0]) ? (n[0] = Pt(n[0]), o[t](...n)) : l;
  }
  function Ms(e, t, n = []) {
    jo(), kv();
    const o = Pt(e)[t].apply(e, n);
    return _v(), Uo(), o;
  }
  const c2 = /* @__PURE__ */ Zl("__proto__,__v_isRef,__isVue"), L0 = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(Wo)
  );
  function d2(e) {
    Wo(e) || (e = String(e));
    const t = Pt(this);
    return Sn(t, "has", e), t.hasOwnProperty(e);
  }
  class B0 {
    constructor(t = !1, n = !1) {
      this._isReadonly = t, this._isShallow = n;
    }
    get(t, n, o) {
      if (n === "__v_skip") return t.__v_skip;
      const l = this._isReadonly, a = this._isShallow;
      if (n === "__v_isReactive")
        return !l;
      if (n === "__v_isReadonly")
        return l;
      if (n === "__v_isShallow")
        return a;
      if (n === "__v_raw")
        return o === (l ? a ? j0 : W0 : a ? K0 : H0).get(t) || // receiver is not the reactive proxy, but has the same prototype
        // this means the receiver is a user proxy of the reactive proxy
        Object.getPrototypeOf(t) === Object.getPrototypeOf(o) ? t : void 0;
      const r = ye(t);
      if (!l) {
        let u;
        if (r && (u = i2[n]))
          return u;
        if (n === "hasOwnProperty")
          return d2;
      }
      const i = Reflect.get(
        t,
        n,
        // if this is a proxy wrapping a ref, return methods using the raw ref
        // as receiver so that we don't have to call `toRaw` on the ref in all
        // its class methods
        Kt(t) ? t : o
      );
      if ((Wo(n) ? L0.has(n) : c2(n)) || (l || Sn(t, "get", n), a))
        return i;
      if (Kt(i)) {
        const u = r && Sv(n) ? i : i.value;
        return l && ot(u) ? ir(u) : u;
      }
      return ot(i) ? l ? ir(i) : Rt(i) : i;
    }
  }
  class F0 extends B0 {
    constructor(t = !1) {
      super(!1, t);
    }
    set(t, n, o, l) {
      let a = t[n];
      if (!this._isShallow) {
        const u = bl(a);
        if (!eo(o) && !bl(o) && (a = Pt(a), o = Pt(o)), !ye(t) && Kt(a) && !Kt(o))
          return u ? (process.env.NODE_ENV !== "production" && yo(
            `Set operation on key "${String(n)}" failed: target is readonly.`,
            t[n]
          ), !0) : (a.value = o, !0);
      }
      const r = ye(t) && Sv(n) ? Number(n) < t.length : Ot(t, n), i = Reflect.set(
        t,
        n,
        o,
        Kt(t) ? t : l
      );
      return t === Pt(l) && (r ? Sa(o, a) && il(t, "set", n, o, a) : il(t, "add", n, o)), i;
    }
    deleteProperty(t, n) {
      const o = Ot(t, n), l = t[n], a = Reflect.deleteProperty(t, n);
      return a && o && il(t, "delete", n, void 0, l), a;
    }
    has(t, n) {
      const o = Reflect.has(t, n);
      return (!Wo(n) || !L0.has(n)) && Sn(t, "has", n), o;
    }
    ownKeys(t) {
      return Sn(
        t,
        "iterate",
        ye(t) ? "length" : Qa
      ), Reflect.ownKeys(t);
    }
  }
  class z0 extends B0 {
    constructor(t = !1) {
      super(!0, t);
    }
    set(t, n) {
      return process.env.NODE_ENV !== "production" && yo(
        `Set operation on key "${String(n)}" failed: target is readonly.`,
        t
      ), !0;
    }
    deleteProperty(t, n) {
      return process.env.NODE_ENV !== "production" && yo(
        `Delete operation on key "${String(n)}" failed: target is readonly.`,
        t
      ), !0;
    }
  }
  const f2 = /* @__PURE__ */ new F0(), p2 = /* @__PURE__ */ new z0(), v2 = /* @__PURE__ */ new F0(!0), h2 = /* @__PURE__ */ new z0(!0), Zf = (e) => e, Su = (e) => Reflect.getPrototypeOf(e);
  function m2(e, t, n) {
    return function(...o) {
      const l = this.__v_raw, a = Pt(l), r = Za(a), i = e === "entries" || e === Symbol.iterator && r, u = e === "keys" && r, c = l[e](...o), d = n ? Zf : t ? wc : Dn;
      return !t && Sn(
        a,
        "iterate",
        u ? Jf : Qa
      ), {
        // iterator protocol
        next() {
          const { value: f, done: v } = c.next();
          return v ? { value: f, done: v } : {
            value: i ? [d(f[0]), d(f[1])] : d(f),
            done: v
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function Eu(e) {
    return function(...t) {
      if (process.env.NODE_ENV !== "production") {
        const n = t[0] ? `on key "${t[0]}" ` : "";
        yo(
          `${Ta(e)} operation ${n}failed: target is readonly.`,
          Pt(this)
        );
      }
      return e === "delete" ? !1 : e === "clear" ? void 0 : this;
    };
  }
  function g2(e, t) {
    const n = {
      get(l) {
        const a = this.__v_raw, r = Pt(a), i = Pt(l);
        e || (Sa(l, i) && Sn(r, "get", l), Sn(r, "get", i));
        const { has: u } = Su(r), c = t ? Zf : e ? wc : Dn;
        if (u.call(r, l))
          return c(a.get(l));
        if (u.call(r, i))
          return c(a.get(i));
        a !== r && a.get(l);
      },
      get size() {
        const l = this.__v_raw;
        return !e && Sn(Pt(l), "iterate", Qa), l.size;
      },
      has(l) {
        const a = this.__v_raw, r = Pt(a), i = Pt(l);
        return e || (Sa(l, i) && Sn(r, "has", l), Sn(r, "has", i)), l === i ? a.has(l) : a.has(l) || a.has(i);
      },
      forEach(l, a) {
        const r = this, i = r.__v_raw, u = Pt(i), c = t ? Zf : e ? wc : Dn;
        return !e && Sn(u, "iterate", Qa), i.forEach((d, f) => l.call(a, c(d), c(f), r));
      }
    };
    return pn(
      n,
      e ? {
        add: Eu("add"),
        set: Eu("set"),
        delete: Eu("delete"),
        clear: Eu("clear")
      } : {
        add(l) {
          !t && !eo(l) && !bl(l) && (l = Pt(l));
          const a = Pt(this);
          return Su(a).has.call(a, l) || (a.add(l), il(a, "add", l, l)), this;
        },
        set(l, a) {
          !t && !eo(a) && !bl(a) && (a = Pt(a));
          const r = Pt(this), { has: i, get: u } = Su(r);
          let c = i.call(r, l);
          c ? process.env.NODE_ENV !== "production" && Dm(r, i, l) : (l = Pt(l), c = i.call(r, l));
          const d = u.call(r, l);
          return r.set(l, a), c ? Sa(a, d) && il(r, "set", l, a, d) : il(r, "add", l, a), this;
        },
        delete(l) {
          const a = Pt(this), { has: r, get: i } = Su(a);
          let u = r.call(a, l);
          u ? process.env.NODE_ENV !== "production" && Dm(a, r, l) : (l = Pt(l), u = r.call(a, l));
          const c = i ? i.call(a, l) : void 0, d = a.delete(l);
          return u && il(a, "delete", l, void 0, c), d;
        },
        clear() {
          const l = Pt(this), a = l.size !== 0, r = process.env.NODE_ENV !== "production" ? Za(l) ? new Map(l) : new Set(l) : void 0, i = l.clear();
          return a && il(
            l,
            "clear",
            void 0,
            void 0,
            r
          ), i;
        }
      }
    ), [
      "keys",
      "values",
      "entries",
      Symbol.iterator
    ].forEach((l) => {
      n[l] = m2(l, e, t);
    }), n;
  }
  function fd(e, t) {
    const n = g2(e, t);
    return (o, l, a) => l === "__v_isReactive" ? !e : l === "__v_isReadonly" ? e : l === "__v_raw" ? o : Reflect.get(
      Ot(n, l) && l in o ? n : o,
      l,
      a
    );
  }
  const b2 = {
    get: /* @__PURE__ */ fd(!1, !1)
  }, y2 = {
    get: /* @__PURE__ */ fd(!1, !0)
  }, w2 = {
    get: /* @__PURE__ */ fd(!0, !1)
  }, C2 = {
    get: /* @__PURE__ */ fd(!0, !0)
  };
  function Dm(e, t, n) {
    const o = Pt(n);
    if (o !== n && t.call(e, o)) {
      const l = Cv(e);
      yo(
        `Reactive ${l} contains both the raw and reactive versions of the same object${l === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
      );
    }
  }
  const H0 = /* @__PURE__ */ new WeakMap(), K0 = /* @__PURE__ */ new WeakMap(), W0 = /* @__PURE__ */ new WeakMap(), j0 = /* @__PURE__ */ new WeakMap();
  function S2(e) {
    switch (e) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function E2(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : S2(Cv(e));
  }
  function Rt(e) {
    return bl(e) ? e : pd(
      e,
      !1,
      f2,
      b2,
      H0
    );
  }
  function Nv(e) {
    return pd(
      e,
      !1,
      v2,
      y2,
      K0
    );
  }
  function ir(e) {
    return pd(
      e,
      !0,
      p2,
      w2,
      W0
    );
  }
  function ul(e) {
    return pd(
      e,
      !0,
      h2,
      C2,
      j0
    );
  }
  function pd(e, t, n, o, l) {
    if (!ot(e))
      return process.env.NODE_ENV !== "production" && yo(
        `value cannot be made ${t ? "readonly" : "reactive"}: ${String(
          e
        )}`
      ), e;
    if (e.__v_raw && !(t && e.__v_isReactive))
      return e;
    const a = E2(e);
    if (a === 0)
      return e;
    const r = l.get(e);
    if (r)
      return r;
    const i = new Proxy(
      e,
      a === 2 ? o : n
    );
    return l.set(e, i), i;
  }
  function er(e) {
    return bl(e) ? er(e.__v_raw) : !!(e && e.__v_isReactive);
  }
  function bl(e) {
    return !!(e && e.__v_isReadonly);
  }
  function eo(e) {
    return !!(e && e.__v_isShallow);
  }
  function ci(e) {
    return e ? !!e.__v_raw : !1;
  }
  function Pt(e) {
    const t = e && e.__v_raw;
    return t ? Pt(t) : e;
  }
  function zl(e) {
    return !Ot(e, "__v_skip") && Object.isExtensible(e) && bc(e, "__v_skip", !0), e;
  }
  const Dn = (e) => ot(e) ? Rt(e) : e, wc = (e) => ot(e) ? ir(e) : e;
  function Kt(e) {
    return e ? e.__v_isRef === !0 : !1;
  }
  function A(e) {
    return U0(e, !1);
  }
  function Ut(e) {
    return U0(e, !0);
  }
  function U0(e, t) {
    return Kt(e) ? e : new k2(e, t);
  }
  class k2 {
    constructor(t, n) {
      this.dep = new cd(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : Pt(t), this._value = n ? t : Dn(t), this.__v_isShallow = n;
    }
    get value() {
      return process.env.NODE_ENV !== "production" ? this.dep.track({
        target: this,
        type: "get",
        key: "value"
      }) : this.dep.track(), this._value;
    }
    set value(t) {
      const n = this._rawValue, o = this.__v_isShallow || eo(t) || bl(t);
      t = o ? t : Pt(t), Sa(t, n) && (this._rawValue = t, this._value = o ? t : Dn(t), process.env.NODE_ENV !== "production" ? this.dep.trigger({
        target: this,
        type: "set",
        key: "value",
        newValue: t,
        oldValue: n
      }) : this.dep.trigger());
    }
  }
  function ju(e) {
    e.dep && (process.env.NODE_ENV !== "production" ? e.dep.trigger({
      target: e,
      type: "set",
      key: "value",
      newValue: e._value
    }) : e.dep.trigger());
  }
  function s(e) {
    return Kt(e) ? e.value : e;
  }
  const _2 = {
    get: (e, t, n) => t === "__v_raw" ? e : s(Reflect.get(e, t, n)),
    set: (e, t, n, o) => {
      const l = e[t];
      return Kt(l) && !Kt(n) ? (l.value = n, !0) : Reflect.set(e, t, n, o);
    }
  };
  function Y0(e) {
    return er(e) ? e : new Proxy(e, _2);
  }
  class T2 {
    constructor(t) {
      this.__v_isRef = !0, this._value = void 0;
      const n = this.dep = new cd(), { get: o, set: l } = t(n.track.bind(n), n.trigger.bind(n));
      this._get = o, this._set = l;
    }
    get value() {
      return this._value = this._get();
    }
    set value(t) {
      this._set(t);
    }
  }
  function N2(e) {
    return new T2(e);
  }
  function wn(e) {
    process.env.NODE_ENV !== "production" && !ci(e) && yo("toRefs() expects a reactive object but received a plain one.");
    const t = ye(e) ? new Array(e.length) : {};
    for (const n in e)
      t[n] = q0(e, n);
    return t;
  }
  class $2 {
    constructor(t, n, o) {
      this._object = t, this._key = n, this._defaultValue = o, this.__v_isRef = !0, this._value = void 0;
    }
    get value() {
      const t = this._object[this._key];
      return this._value = t === void 0 ? this._defaultValue : t;
    }
    set value(t) {
      this._object[this._key] = t;
    }
    get dep() {
      return s2(Pt(this._object), this._key);
    }
  }
  class O2 {
    constructor(t) {
      this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
    }
    get value() {
      return this._value = this._getter();
    }
  }
  function At(e, t, n) {
    return Kt(e) ? e : Fe(e) ? new O2(e) : ot(e) && arguments.length > 1 ? q0(e, t, n) : A(e);
  }
  function q0(e, t, n) {
    const o = e[t];
    return Kt(o) ? o : new $2(e, t, n);
  }
  class I2 {
    constructor(t, n, o) {
      this.fn = t, this.setter = n, this._value = void 0, this.dep = new cd(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = ii - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = o;
    }
    /**
     * @internal
     */
    notify() {
      if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
      Xt !== this)
        return x0(this, !0), !0;
      process.env.NODE_ENV;
    }
    get value() {
      const t = process.env.NODE_ENV !== "production" ? this.dep.track({
        target: this,
        type: "get",
        key: "value"
      }) : this.dep.track();
      return D0(this), t && (t.version = this.dep.version), this._value;
    }
    set value(t) {
      this.setter ? this.setter(t) : process.env.NODE_ENV !== "production" && yo("Write operation failed: computed value is readonly");
    }
  }
  function M2(e, t, n = !1) {
    let o, l;
    Fe(e) ? o = e : (o = e.get, l = e.set);
    const a = new I2(o, l, n);
    return process.env.NODE_ENV, a;
  }
  const ku = {}, Cc = /* @__PURE__ */ new WeakMap();
  let za;
  function x2(e, t = !1, n = za) {
    if (n) {
      let o = Cc.get(n);
      o || Cc.set(n, o = []), o.push(e);
    } else process.env.NODE_ENV !== "production" && !t && yo(
      "onWatcherCleanup() was called when there was no active watcher to associate with."
    );
  }
  function P2(e, t, n = Jt) {
    const { immediate: o, deep: l, once: a, scheduler: r, augmentJob: i, call: u } = n, c = (E) => {
      (n.onWarn || yo)(
        "Invalid watch source: ",
        E,
        "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
      );
    }, d = (E) => l ? E : eo(E) || l === !1 || l === 0 ? Ll(E, 1) : Ll(E);
    let f, v, p, m, h = !1, g = !1;
    if (Kt(e) ? (v = () => e.value, h = eo(e)) : er(e) ? (v = () => d(e), h = !0) : ye(e) ? (g = !0, h = e.some((E) => er(E) || eo(E)), v = () => e.map((E) => {
      if (Kt(E))
        return E.value;
      if (er(E))
        return d(E);
      if (Fe(E))
        return u ? u(E, 2) : E();
      process.env.NODE_ENV !== "production" && c(E);
    })) : Fe(e) ? t ? v = u ? () => u(e, 2) : e : v = () => {
      if (p) {
        jo();
        try {
          p();
        } finally {
          Uo();
        }
      }
      const E = za;
      za = f;
      try {
        return u ? u(e, 3, [m]) : e(m);
      } finally {
        za = E;
      }
    } : (v = It, process.env.NODE_ENV !== "production" && c(e)), t && l) {
      const E = v, k = l === !0 ? 1 / 0 : l;
      v = () => Ll(E(), k);
    }
    const b = $0(), C = () => {
      f.stop(), b && b.active && wv(b.effects, f);
    };
    if (a && t) {
      const E = t;
      t = (...k) => {
        E(...k), C();
      };
    }
    let w = g ? new Array(e.length).fill(ku) : ku;
    const y = (E) => {
      if (!(!(f.flags & 1) || !f.dirty && !E))
        if (t) {
          const k = f.run();
          if (l || h || (g ? k.some((T, x) => Sa(T, w[x])) : Sa(k, w))) {
            p && p();
            const T = za;
            za = f;
            try {
              const x = [
                k,
                // pass undefined as the old value when it's changed for the first time
                w === ku ? void 0 : g && w[0] === ku ? [] : w,
                m
              ];
              w = k, u ? u(t, 3, x) : (
                // @ts-expect-error
                t(...x)
              );
            } finally {
              za = T;
            }
          }
        } else
          f.run();
    };
    return i && i(y), f = new I0(v), f.scheduler = r ? () => r(y, !1) : y, m = (E) => x2(E, !1, f), p = f.onStop = () => {
      const E = Cc.get(f);
      if (E) {
        if (u)
          u(E, 4);
        else
          for (const k of E) k();
        Cc.delete(f);
      }
    }, process.env.NODE_ENV !== "production" && (f.onTrack = n.onTrack, f.onTrigger = n.onTrigger), t ? o ? y(!0) : w = f.run() : r ? r(y.bind(null, !0), !0) : f.run(), C.pause = f.pause.bind(f), C.resume = f.resume.bind(f), C.stop = C, C;
  }
  function Ll(e, t = 1 / 0, n) {
    if (t <= 0 || !ot(e) || e.__v_skip || (n = n || /* @__PURE__ */ new Map(), (n.get(e) || 0) >= t))
      return e;
    if (n.set(e, t), t--, Kt(e))
      Ll(e.value, t, n);
    else if (ye(e))
      for (let o = 0; o < e.length; o++)
        Ll(e[o], t, n);
    else if (id(e) || Za(e))
      e.forEach((o) => {
        Ll(o, t, n);
      });
    else if (si(e)) {
      for (const o in e)
        Ll(e[o], t, n);
      for (const o of Object.getOwnPropertySymbols(e))
        Object.prototype.propertyIsEnumerable.call(e, o) && Ll(e[o], t, n);
    }
    return e;
  }
  /**
  * @vue/runtime-core v3.5.24
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  const tr = [];
  function Uu(e) {
    tr.push(e);
  }
  function Yu() {
    tr.pop();
  }
  let df = !1;
  function Ge(e, ...t) {
    if (df) return;
    df = !0, jo();
    const n = tr.length ? tr[tr.length - 1].component : null, o = n && n.appContext.config.warnHandler, l = R2();
    if (o)
      gs(
        o,
        n,
        11,
        [
          // eslint-disable-next-line no-restricted-syntax
          e + t.map((a) => {
            var r, i;
            return (i = (r = a.toString) == null ? void 0 : r.call(a)) != null ? i : JSON.stringify(a);
          }).join(""),
          n && n.proxy,
          l.map(
            ({ vnode: a }) => `at <${Cd(n, a.type)}>`
          ).join(`
`),
          l
        ]
      );
    else {
      const a = [`[Vue warn]: ${e}`, ...t];
      l.length && a.push(`
`, ...D2(l)), console.warn(...a);
    }
    Uo(), df = !1;
  }
  function R2() {
    let e = tr[tr.length - 1];
    if (!e)
      return [];
    const t = [];
    for (; e; ) {
      const n = t[0];
      n && n.vnode === e ? n.recurseCount++ : t.push({
        vnode: e,
        recurseCount: 0
      });
      const o = e.component && e.component.parent;
      e = o && o.vnode;
    }
    return t;
  }
  function D2(e) {
    const t = [];
    return e.forEach((n, o) => {
      t.push(...o === 0 ? [] : [`
`], ...A2(n));
    }), t;
  }
  function A2({ vnode: e, recurseCount: t }) {
    const n = t > 0 ? `... (${t} recursive calls)` : "", o = e.component ? e.component.parent == null : !1, l = ` at <${Cd(
      e.component,
      e.type,
      o
    )}`, a = ">" + n;
    return e.props ? [l, ...V2(e.props), a] : [l + a];
  }
  function V2(e) {
    const t = [], n = Object.keys(e);
    return n.slice(0, 3).forEach((o) => {
      t.push(...G0(o, e[o]));
    }), n.length > 3 && t.push(" ..."), t;
  }
  function G0(e, t, n) {
    return Ae(t) ? (t = JSON.stringify(t), n ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? n ? t : [`${e}=${t}`] : Kt(t) ? (t = G0(e, Pt(t.value), !0), n ? t : [`${e}=Ref<`, t, ">"]) : Fe(t) ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`] : (t = Pt(t), n ? t : [`${e}=`, t]);
  }
  function L2(e, t) {
    process.env.NODE_ENV !== "production" && e !== void 0 && (typeof e != "number" ? Ge(`${t} is not a valid number - got ${JSON.stringify(e)}.`) : isNaN(e) && Ge(`${t} is NaN - the duration expression might be incorrect.`));
  }
  const $v = {
    sp: "serverPrefetch hook",
    bc: "beforeCreate hook",
    c: "created hook",
    bm: "beforeMount hook",
    m: "mounted hook",
    bu: "beforeUpdate hook",
    u: "updated",
    bum: "beforeUnmount hook",
    um: "unmounted hook",
    a: "activated hook",
    da: "deactivated hook",
    ec: "errorCaptured hook",
    rtc: "renderTracked hook",
    rtg: "renderTriggered hook",
    0: "setup function",
    1: "render function",
    2: "watcher getter",
    3: "watcher callback",
    4: "watcher cleanup function",
    5: "native event handler",
    6: "component event handler",
    7: "vnode hook",
    8: "directive hook",
    9: "transition hook",
    10: "app errorHandler",
    11: "app warnHandler",
    12: "ref function",
    13: "async component loader",
    14: "scheduler flush",
    15: "component update",
    16: "app unmount cleanup function"
  };
  function gs(e, t, n, o) {
    try {
      return o ? e(...o) : e();
    } catch (l) {
      Wi(l, t, n);
    }
  }
  function Yo(e, t, n, o) {
    if (Fe(e)) {
      const l = gs(e, t, n, o);
      return l && _a(l) && l.catch((a) => {
        Wi(a, t, n);
      }), l;
    }
    if (ye(e)) {
      const l = [];
      for (let a = 0; a < e.length; a++)
        l.push(Yo(e[a], t, n, o));
      return l;
    } else process.env.NODE_ENV !== "production" && Ge(
      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof e}`
    );
  }
  function Wi(e, t, n, o = !0) {
    const l = t ? t.vnode : null, { errorHandler: a, throwUnhandledErrorInProduction: r } = t && t.appContext.config || Jt;
    if (t) {
      let i = t.parent;
      const u = t.proxy, c = process.env.NODE_ENV !== "production" ? $v[n] : `https://vuejs.org/error-reference/#runtime-${n}`;
      for (; i; ) {
        const d = i.ec;
        if (d) {
          for (let f = 0; f < d.length; f++)
            if (d[f](e, u, c) === !1)
              return;
        }
        i = i.parent;
      }
      if (a) {
        jo(), gs(a, null, 10, [
          e,
          u,
          c
        ]), Uo();
        return;
      }
    }
    B2(e, n, l, o, r);
  }
  function B2(e, t, n, o = !0, l = !1) {
    if (process.env.NODE_ENV !== "production") {
      const a = $v[t];
      if (n && Uu(n), Ge(`Unhandled error${a ? ` during execution of ${a}` : ""}`), n && Yu(), o)
        throw e;
      console.error(e);
    } else {
      if (l)
        throw e;
      console.error(e);
    }
  }
  const Jn = [];
  let sl = -1;
  const Hr = [];
  let va = null, Rr = 0;
  const X0 = /* @__PURE__ */ Promise.resolve();
  let Sc = null;
  const F2 = 100;
  function Re(e) {
    const t = Sc || X0;
    return e ? t.then(this ? e.bind(this) : e) : t;
  }
  function z2(e) {
    let t = sl + 1, n = Jn.length;
    for (; t < n; ) {
      const o = t + n >>> 1, l = Jn[o], a = di(l);
      a < e || a === e && l.flags & 2 ? t = o + 1 : n = o;
    }
    return t;
  }
  function vd(e) {
    if (!(e.flags & 1)) {
      const t = di(e), n = Jn[Jn.length - 1];
      !n || // fast path when the job id is larger than the tail
      !(e.flags & 2) && t >= di(n) ? Jn.push(e) : Jn.splice(z2(t), 0, e), e.flags |= 1, J0();
    }
  }
  function J0() {
    Sc || (Sc = X0.then(ew));
  }
  function Z0(e) {
    ye(e) ? Hr.push(...e) : va && e.id === -1 ? va.splice(Rr + 1, 0, e) : e.flags & 1 || (Hr.push(e), e.flags |= 1), J0();
  }
  function Am(e, t, n = sl + 1) {
    for (process.env.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()); n < Jn.length; n++) {
      const o = Jn[n];
      if (o && o.flags & 2) {
        if (e && o.id !== e.uid || process.env.NODE_ENV !== "production" && Ov(t, o))
          continue;
        Jn.splice(n, 1), n--, o.flags & 4 && (o.flags &= -2), o(), o.flags & 4 || (o.flags &= -2);
      }
    }
  }
  function Q0(e) {
    if (Hr.length) {
      const t = [...new Set(Hr)].sort(
        (n, o) => di(n) - di(o)
      );
      if (Hr.length = 0, va) {
        va.push(...t);
        return;
      }
      for (va = t, process.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()), Rr = 0; Rr < va.length; Rr++) {
        const n = va[Rr];
        process.env.NODE_ENV !== "production" && Ov(e, n) || (n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2);
      }
      va = null, Rr = 0;
    }
  }
  const di = (e) => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;
  function ew(e) {
    process.env.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map());
    const t = process.env.NODE_ENV !== "production" ? (n) => Ov(e, n) : It;
    try {
      for (sl = 0; sl < Jn.length; sl++) {
        const n = Jn[sl];
        if (n && !(n.flags & 8)) {
          if (process.env.NODE_ENV !== "production" && t(n))
            continue;
          n.flags & 4 && (n.flags &= -2), gs(
            n,
            n.i,
            n.i ? 15 : 14
          ), n.flags & 4 || (n.flags &= -2);
        }
      }
    } finally {
      for (; sl < Jn.length; sl++) {
        const n = Jn[sl];
        n && (n.flags &= -2);
      }
      sl = -1, Jn.length = 0, Q0(e), Sc = null, (Jn.length || Hr.length) && ew(e);
    }
  }
  function Ov(e, t) {
    const n = e.get(t) || 0;
    if (n > F2) {
      const o = t.i, l = o && zv(o.type);
      return Wi(
        `Maximum recursive updates exceeded${l ? ` in component <${l}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
        null,
        10
      ), !0;
    }
    return e.set(t, n + 1), !1;
  }
  let Vo = !1;
  const qu = /* @__PURE__ */ new Map();
  process.env.NODE_ENV !== "production" && (Ki().__VUE_HMR_RUNTIME__ = {
    createRecord: ff(tw),
    rerender: ff(W2),
    reload: ff(j2)
  });
  const ur = /* @__PURE__ */ new Map();
  function H2(e) {
    const t = e.type.__hmrId;
    let n = ur.get(t);
    n || (tw(t, e.type), n = ur.get(t)), n.instances.add(e);
  }
  function K2(e) {
    ur.get(e.type.__hmrId).instances.delete(e);
  }
  function tw(e, t) {
    return ur.has(e) ? !1 : (ur.set(e, {
      initialDef: Ec(t),
      instances: /* @__PURE__ */ new Set()
    }), !0);
  }
  function Ec(e) {
    return jw(e) ? e.__vccOpts : e;
  }
  function W2(e, t) {
    const n = ur.get(e);
    n && (n.initialDef.render = t, [...n.instances].forEach((o) => {
      t && (o.render = t, Ec(o.type).render = t), o.renderCache = [], Vo = !0, o.job.flags & 8 || o.update(), Vo = !1;
    }));
  }
  function j2(e, t) {
    const n = ur.get(e);
    if (!n) return;
    t = Ec(t), Vm(n.initialDef, t);
    const o = [...n.instances];
    for (let l = 0; l < o.length; l++) {
      const a = o[l], r = Ec(a.type);
      let i = qu.get(r);
      i || (r !== n.initialDef && Vm(r, t), qu.set(r, i = /* @__PURE__ */ new Set())), i.add(a), a.appContext.propsCache.delete(a.type), a.appContext.emitsCache.delete(a.type), a.appContext.optionsCache.delete(a.type), a.ceReload ? (i.add(a), a.ceReload(t.styles), i.delete(a)) : a.parent ? vd(() => {
        a.job.flags & 8 || (Vo = !0, a.parent.update(), Vo = !1, i.delete(a));
      }) : a.appContext.reload ? a.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
        "[HMR] Root or manually mounted instance modified. Full reload required."
      ), a.root.ce && a !== a.root && a.root.ce._removeChildStyle(r);
    }
    Z0(() => {
      qu.clear();
    });
  }
  function Vm(e, t) {
    pn(e, t);
    for (const n in e)
      n !== "__file" && !(n in t) && delete e[n];
  }
  function ff(e) {
    return (t, n) => {
      try {
        return e(t, n);
      } catch (o) {
        console.error(o), console.warn(
          "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
        );
      }
    };
  }
  let Ao, zs = [], Qf = !1;
  function ji(e, ...t) {
    Ao ? Ao.emit(e, ...t) : Qf || zs.push({ event: e, args: t });
  }
  function Iv(e, t) {
    var n, o;
    Ao = e, Ao ? (Ao.enabled = !0, zs.forEach(({ event: l, args: a }) => Ao.emit(l, ...a)), zs = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-syntax
    !((o = (n = window.navigator) == null ? void 0 : n.userAgent) != null && o.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((a) => {
      Iv(a, t);
    }), setTimeout(() => {
      Ao || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Qf = !0, zs = []);
    }, 3e3)) : (Qf = !0, zs = []);
  }
  function U2(e, t) {
    ji("app:init", e, t, {
      Fragment: We,
      Text: Pa,
      Comment: Qt,
      Static: Xu
    });
  }
  function Y2(e) {
    ji("app:unmount", e);
  }
  const q2 = /* @__PURE__ */ Mv(
    "component:added"
    /* COMPONENT_ADDED */
  ), nw = /* @__PURE__ */ Mv(
    "component:updated"
    /* COMPONENT_UPDATED */
  ), G2 = /* @__PURE__ */ Mv(
    "component:removed"
    /* COMPONENT_REMOVED */
  ), X2 = (e) => {
    Ao && typeof Ao.cleanupBuffer == "function" && // remove the component if it wasn't buffered
    !Ao.cleanupBuffer(e) && G2(e);
  };
  // @__NO_SIDE_EFFECTS__
  function Mv(e) {
    return (t) => {
      ji(
        e,
        t.appContext.app,
        t.uid,
        t.parent ? t.parent.uid : void 0,
        t
      );
    };
  }
  const J2 = /* @__PURE__ */ ow(
    "perf:start"
    /* PERFORMANCE_START */
  ), Z2 = /* @__PURE__ */ ow(
    "perf:end"
    /* PERFORMANCE_END */
  );
  function ow(e) {
    return (t, n, o) => {
      ji(e, t.appContext.app, t.uid, t, n, o);
    };
  }
  function Q2(e, t, n) {
    ji(
      "component:emit",
      e.appContext.app,
      e,
      t,
      n
    );
  }
  let yn = null, lw = null;
  function kc(e) {
    const t = yn;
    return yn = e, lw = e && e.type.__scopeId || null, t;
  }
  function Q(e, t = yn, n) {
    if (!t || e._n)
      return e;
    const o = (...l) => {
      o._d && Ic(-1);
      const a = kc(t);
      let r;
      try {
        r = e(...l);
      } finally {
        kc(a), o._d && Ic(1);
      }
      return process.env.NODE_ENV !== "production" && nw(t), r;
    };
    return o._n = !0, o._c = !0, o._d = !0, o;
  }
  function aw(e) {
    z_(e) && Ge("Do not use built-in directive ids as custom directive id: " + e);
  }
  function it(e, t) {
    if (yn === null)
      return process.env.NODE_ENV !== "production" && Ge("withDirectives can only be used inside render functions."), e;
    const n = wd(yn), o = e.dirs || (e.dirs = []);
    for (let l = 0; l < t.length; l++) {
      let [a, r, i, u = Jt] = t[l];
      a && (Fe(a) && (a = {
        mounted: a,
        updated: a
      }), a.deep && Ll(r), o.push({
        dir: a,
        instance: n,
        value: r,
        oldValue: void 0,
        arg: i,
        modifiers: u
      }));
    }
    return e;
  }
  function Va(e, t, n, o) {
    const l = e.dirs, a = t && t.dirs;
    for (let r = 0; r < l.length; r++) {
      const i = l[r];
      a && (i.oldValue = a[r].value);
      let u = i.dir[o];
      u && (jo(), Yo(u, n, 8, [
        e.el,
        i,
        e,
        t
      ]), Uo());
    }
  }
  const rw = Symbol("_vte"), sw = (e) => e.__isTeleport, nr = (e) => e && (e.disabled || e.disabled === ""), Lm = (e) => e && (e.defer || e.defer === ""), Bm = (e) => typeof SVGElement < "u" && e instanceof SVGElement, Fm = (e) => typeof MathMLElement == "function" && e instanceof MathMLElement, ep = (e, t) => {
    const n = e && e.to;
    if (Ae(n))
      if (t) {
        const o = t(n);
        return process.env.NODE_ENV !== "production" && !o && !nr(e) && Ge(
          `Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
        ), o;
      } else
        return process.env.NODE_ENV !== "production" && Ge(
          "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
        ), null;
    else
      return process.env.NODE_ENV !== "production" && !n && !nr(e) && Ge(`Invalid Teleport target: ${n}`), n;
  }, iw = {
    name: "Teleport",
    __isTeleport: !0,
    process(e, t, n, o, l, a, r, i, u, c) {
      const {
        mc: d,
        pc: f,
        pbc: v,
        o: { insert: p, querySelector: m, createText: h, createComment: g }
      } = c, b = nr(t.props);
      let { shapeFlag: C, children: w, dynamicChildren: y } = t;
      if (process.env.NODE_ENV !== "production" && Vo && (u = !1, y = null), e == null) {
        const E = t.el = process.env.NODE_ENV !== "production" ? g("teleport start") : h(""), k = t.anchor = process.env.NODE_ENV !== "production" ? g("teleport end") : h("");
        p(E, n, o), p(k, n, o);
        const T = (I, P) => {
          C & 16 && d(
            w,
            I,
            P,
            l,
            a,
            r,
            i,
            u
          );
        }, x = () => {
          const I = t.target = ep(t.props, m), P = uw(I, t, h, p);
          I ? (r !== "svg" && Bm(I) ? r = "svg" : r !== "mathml" && Fm(I) && (r = "mathml"), l && l.isCE && (l.ce._teleportTargets || (l.ce._teleportTargets = /* @__PURE__ */ new Set())).add(I), b || (T(I, P), Gu(t, !1))) : process.env.NODE_ENV !== "production" && !b && Ge(
            "Invalid Teleport target on mount:",
            I,
            `(${typeof I})`
          );
        };
        b && (T(n, k), Gu(t, !0)), Lm(t.props) ? (t.el.__isMounted = !1, Xn(() => {
          x(), delete t.el.__isMounted;
        }, a)) : x();
      } else {
        if (Lm(t.props) && e.el.__isMounted === !1) {
          Xn(() => {
            iw.process(
              e,
              t,
              n,
              o,
              l,
              a,
              r,
              i,
              u,
              c
            );
          }, a);
          return;
        }
        t.el = e.el, t.targetStart = e.targetStart;
        const E = t.anchor = e.anchor, k = t.target = e.target, T = t.targetAnchor = e.targetAnchor, x = nr(e.props), I = x ? n : k, P = x ? E : T;
        if (r === "svg" || Bm(k) ? r = "svg" : (r === "mathml" || Fm(k)) && (r = "mathml"), y ? (v(
          e.dynamicChildren,
          y,
          I,
          l,
          a,
          r,
          i
        ), Js(e, t, process.env.NODE_ENV === "production")) : u || f(
          e,
          t,
          I,
          P,
          l,
          a,
          r,
          i,
          !1
        ), b)
          x ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : _u(
            t,
            n,
            E,
            c,
            1
          );
        else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
          const O = t.target = ep(
            t.props,
            m
          );
          O ? _u(
            t,
            O,
            null,
            c,
            0
          ) : process.env.NODE_ENV !== "production" && Ge(
            "Invalid Teleport target on update:",
            k,
            `(${typeof k})`
          );
        } else x && _u(
          t,
          k,
          T,
          c,
          1
        );
        Gu(t, b);
      }
    },
    remove(e, t, n, { um: o, o: { remove: l } }, a) {
      const {
        shapeFlag: r,
        children: i,
        anchor: u,
        targetStart: c,
        targetAnchor: d,
        target: f,
        props: v
      } = e;
      if (f && (l(c), l(d)), a && l(u), r & 16) {
        const p = a || !nr(v);
        for (let m = 0; m < i.length; m++) {
          const h = i[m];
          o(
            h,
            t,
            n,
            p,
            !!h.dynamicChildren
          );
        }
      }
    },
    move: _u,
    hydrate: eT
  };
  function _u(e, t, n, { o: { insert: o }, m: l }, a = 2) {
    a === 0 && o(e.targetAnchor, t, n);
    const { el: r, anchor: i, shapeFlag: u, children: c, props: d } = e, f = a === 2;
    if (f && o(r, t, n), (!f || nr(d)) && u & 16)
      for (let v = 0; v < c.length; v++)
        l(
          c[v],
          t,
          n,
          2
        );
    f && o(i, t, n);
  }
  function eT(e, t, n, o, l, a, {
    o: { nextSibling: r, parentNode: i, querySelector: u, insert: c, createText: d }
  }, f) {
    function v(h, g, b, C) {
      g.anchor = f(
        r(h),
        g,
        i(h),
        n,
        o,
        l,
        a
      ), g.targetStart = b, g.targetAnchor = C;
    }
    const p = t.target = ep(
      t.props,
      u
    ), m = nr(t.props);
    if (p) {
      const h = p._lpa || p.firstChild;
      if (t.shapeFlag & 16)
        if (m)
          v(
            e,
            t,
            h,
            h && r(h)
          );
        else {
          t.anchor = r(e);
          let g = h;
          for (; g; ) {
            if (g && g.nodeType === 8) {
              if (g.data === "teleport start anchor")
                t.targetStart = g;
              else if (g.data === "teleport anchor") {
                t.targetAnchor = g, p._lpa = t.targetAnchor && r(t.targetAnchor);
                break;
              }
            }
            g = r(g);
          }
          t.targetAnchor || uw(p, t, d, c), f(
            h && r(h),
            t,
            p,
            n,
            o,
            l,
            a
          );
        }
      Gu(t, m);
    } else m && t.shapeFlag & 16 && v(e, t, e, r(e));
    return t.anchor && r(t.anchor);
  }
  const tT = iw;
  function Gu(e, t) {
    const n = e.ctx;
    if (n && n.ut) {
      let o, l;
      for (t ? (o = e.el, l = e.anchor) : (o = e.targetStart, l = e.targetAnchor); o && o !== l; )
        o.nodeType === 1 && o.setAttribute("data-v-owner", n.uid), o = o.nextSibling;
      n.ut();
    }
  }
  function uw(e, t, n, o) {
    const l = t.targetStart = n(""), a = t.targetAnchor = n("");
    return l[rw] = a, e && (o(l, e), o(a, e)), a;
  }
  const Dl = Symbol("_leaveCb"), Tu = Symbol("_enterCb");
  function cw() {
    const e = {
      isMounted: !1,
      isLeaving: !1,
      isUnmounting: !1,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    return ft(() => {
      e.isMounted = !0;
    }), Bt(() => {
      e.isUnmounting = !0;
    }), e;
  }
  const Eo = [Function, Array], dw = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: Eo,
    onEnter: Eo,
    onAfterEnter: Eo,
    onEnterCancelled: Eo,
    // leave
    onBeforeLeave: Eo,
    onLeave: Eo,
    onAfterLeave: Eo,
    onLeaveCancelled: Eo,
    // appear
    onBeforeAppear: Eo,
    onAppear: Eo,
    onAfterAppear: Eo,
    onAppearCancelled: Eo
  }, fw = (e) => {
    const t = e.subTree;
    return t.component ? fw(t.component) : t;
  }, nT = {
    name: "BaseTransition",
    props: dw,
    setup(e, { slots: t }) {
      const n = dt(), o = cw();
      return () => {
        const l = t.default && xv(t.default(), !0);
        if (!l || !l.length)
          return;
        const a = pw(l), r = Pt(e), { mode: i } = r;
        if (process.env.NODE_ENV !== "production" && i && i !== "in-out" && i !== "out-in" && i !== "default" && Ge(`invalid <transition> mode: ${i}`), o.isLeaving)
          return pf(a);
        const u = zm(a);
        if (!u)
          return pf(a);
        let c = fi(
          u,
          r,
          o,
          n,
          // #11061, ensure enterHooks is fresh after clone
          (f) => c = f
        );
        u.type !== Qt && cr(u, c);
        let d = n.subTree && zm(n.subTree);
        if (d && d.type !== Qt && !Ka(d, u) && fw(n).type !== Qt) {
          let f = fi(
            d,
            r,
            o,
            n
          );
          if (cr(d, f), i === "out-in" && u.type !== Qt)
            return o.isLeaving = !0, f.afterLeave = () => {
              o.isLeaving = !1, n.job.flags & 8 || n.update(), delete f.afterLeave, d = void 0;
            }, pf(a);
          i === "in-out" && u.type !== Qt ? f.delayLeave = (v, p, m) => {
            const h = vw(
              o,
              d
            );
            h[String(d.key)] = d, v[Dl] = () => {
              p(), v[Dl] = void 0, delete c.delayedLeave, d = void 0;
            }, c.delayedLeave = () => {
              m(), delete c.delayedLeave, d = void 0;
            };
          } : d = void 0;
        } else d && (d = void 0);
        return a;
      };
    }
  };
  function pw(e) {
    let t = e[0];
    if (e.length > 1) {
      let n = !1;
      for (const o of e)
        if (o.type !== Qt) {
          if (process.env.NODE_ENV !== "production" && n) {
            Ge(
              "<transition> can only be used on a single element or component. Use <transition-group> for lists."
            );
            break;
          }
          if (t = o, n = !0, process.env.NODE_ENV === "production") break;
        }
    }
    return t;
  }
  const oT = nT;
  function vw(e, t) {
    const { leavingVNodes: n } = e;
    let o = n.get(t.type);
    return o || (o = /* @__PURE__ */ Object.create(null), n.set(t.type, o)), o;
  }
  function fi(e, t, n, o, l) {
    const {
      appear: a,
      mode: r,
      persisted: i = !1,
      onBeforeEnter: u,
      onEnter: c,
      onAfterEnter: d,
      onEnterCancelled: f,
      onBeforeLeave: v,
      onLeave: p,
      onAfterLeave: m,
      onLeaveCancelled: h,
      onBeforeAppear: g,
      onAppear: b,
      onAfterAppear: C,
      onAppearCancelled: w
    } = t, y = String(e.key), E = vw(n, e), k = (I, P) => {
      I && Yo(
        I,
        o,
        9,
        P
      );
    }, T = (I, P) => {
      const O = P[1];
      k(I, P), ye(I) ? I.every((N) => N.length <= 1) && O() : I.length <= 1 && O();
    }, x = {
      mode: r,
      persisted: i,
      beforeEnter(I) {
        let P = u;
        if (!n.isMounted)
          if (a)
            P = g || u;
          else
            return;
        I[Dl] && I[Dl](
          !0
          /* cancelled */
        );
        const O = E[y];
        O && Ka(e, O) && O.el[Dl] && O.el[Dl](), k(P, [I]);
      },
      enter(I) {
        let P = c, O = d, N = f;
        if (!n.isMounted)
          if (a)
            P = b || c, O = C || d, N = w || f;
          else
            return;
        let z = !1;
        const Y = I[Tu] = (G) => {
          z || (z = !0, G ? k(N, [I]) : k(O, [I]), x.delayedLeave && x.delayedLeave(), I[Tu] = void 0);
        };
        P ? T(P, [I, Y]) : Y();
      },
      leave(I, P) {
        const O = String(e.key);
        if (I[Tu] && I[Tu](
          !0
          /* cancelled */
        ), n.isUnmounting)
          return P();
        k(v, [I]);
        let N = !1;
        const z = I[Dl] = (Y) => {
          N || (N = !0, P(), Y ? k(h, [I]) : k(m, [I]), I[Dl] = void 0, E[O] === e && delete E[O]);
        };
        E[O] = e, p ? T(p, [I, z]) : z();
      },
      clone(I) {
        const P = fi(
          I,
          t,
          n,
          o,
          l
        );
        return l && l(P), P;
      }
    };
    return x;
  }
  function pf(e) {
    if (Ui(e))
      return e = qo(e), e.children = null, e;
  }
  function zm(e) {
    if (!Ui(e))
      return sw(e.type) && e.children ? pw(e.children) : e;
    if (e.component)
      return e.component.subTree;
    const { shapeFlag: t, children: n } = e;
    if (n) {
      if (t & 16)
        return n[0];
      if (t & 32 && Fe(n.default))
        return n.default();
    }
  }
  function cr(e, t) {
    e.shapeFlag & 6 && e.component ? (e.transition = t, cr(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
  }
  function xv(e, t = !1, n) {
    let o = [], l = 0;
    for (let a = 0; a < e.length; a++) {
      let r = e[a];
      const i = n == null ? r.key : String(n) + String(r.key != null ? r.key : a);
      r.type === We ? (r.patchFlag & 128 && l++, o = o.concat(
        xv(r.children, t, i)
      )) : (t || r.type !== Qt) && o.push(i != null ? qo(r, { key: i }) : r);
    }
    if (l > 1)
      for (let a = 0; a < o.length; a++)
        o[a].patchFlag = -2;
    return o;
  }
  // @__NO_SIDE_EFFECTS__
  function U(e, t) {
    return Fe(e) ? (
      // #8236: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      pn({ name: e.name }, t, { setup: e })
    ) : e;
  }
  function hw(e) {
    e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
  }
  const Hm = /* @__PURE__ */ new WeakSet(), _c = /* @__PURE__ */ new WeakMap();
  function Xs(e, t, n, o, l = !1) {
    if (ye(e)) {
      e.forEach(
        (h, g) => Xs(
          h,
          t && (ye(t) ? t[g] : t),
          n,
          o,
          l
        )
      );
      return;
    }
    if (Kr(o) && !l) {
      o.shapeFlag & 512 && o.type.__asyncResolved && o.component.subTree.component && Xs(e, t, n, o.component.subTree);
      return;
    }
    const a = o.shapeFlag & 4 ? wd(o.component) : o.el, r = l ? null : a, { i, r: u } = e;
    if (process.env.NODE_ENV !== "production" && !i) {
      Ge(
        "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
      );
      return;
    }
    const c = t && t.r, d = i.refs === Jt ? i.refs = {} : i.refs, f = i.setupState, v = Pt(f), p = f === Jt ? C0 : (h) => process.env.NODE_ENV !== "production" && (Ot(v, h) && !Kt(v[h]) && Ge(
      `Template ref "${h}" used on a non-ref value. It will not work in the production build.`
    ), Hm.has(v[h])) ? !1 : Ot(v, h), m = (h) => process.env.NODE_ENV === "production" || !Hm.has(h);
    if (c != null && c !== u) {
      if (Km(t), Ae(c))
        d[c] = null, p(c) && (f[c] = null);
      else if (Kt(c)) {
        m(c) && (c.value = null);
        const h = t;
        h.k && (d[h.k] = null);
      }
    }
    if (Fe(u))
      gs(u, i, 12, [r, d]);
    else {
      const h = Ae(u), g = Kt(u);
      if (h || g) {
        const b = () => {
          if (e.f) {
            const C = h ? p(u) ? f[u] : d[u] : m(u) || !e.k ? u.value : d[e.k];
            if (l)
              ye(C) && wv(C, a);
            else if (ye(C))
              C.includes(a) || C.push(a);
            else if (h)
              d[u] = [a], p(u) && (f[u] = d[u]);
            else {
              const w = [a];
              m(u) && (u.value = w), e.k && (d[e.k] = w);
            }
          } else h ? (d[u] = r, p(u) && (f[u] = r)) : g ? (m(u) && (u.value = r), e.k && (d[e.k] = r)) : process.env.NODE_ENV !== "production" && Ge("Invalid template ref type:", u, `(${typeof u})`);
        };
        if (r) {
          const C = () => {
            b(), _c.delete(e);
          };
          C.id = -1, _c.set(e, C), Xn(C, n);
        } else
          Km(e), b();
      } else process.env.NODE_ENV !== "production" && Ge("Invalid template ref type:", u, `(${typeof u})`);
    }
  }
  function Km(e) {
    const t = _c.get(e);
    t && (t.flags |= 8, _c.delete(e));
  }
  Ki().requestIdleCallback;
  Ki().cancelIdleCallback;
  const Kr = (e) => !!e.type.__asyncLoader, Ui = (e) => e.type.__isKeepAlive;
  function hd(e, t) {
    gw(e, "a", t);
  }
  function mw(e, t) {
    gw(e, "da", t);
  }
  function gw(e, t, n = On) {
    const o = e.__wdc || (e.__wdc = () => {
      let l = n;
      for (; l; ) {
        if (l.isDeactivated)
          return;
        l = l.parent;
      }
      return e();
    });
    if (md(t, o, n), n) {
      let l = n.parent;
      for (; l && l.parent; )
        Ui(l.parent.vnode) && lT(o, t, n, l), l = l.parent;
    }
  }
  function lT(e, t, n, o) {
    const l = md(
      t,
      e,
      o,
      !0
      /* prepend */
    );
    bs(() => {
      wv(o[t], l);
    }, n);
  }
  function md(e, t, n = On, o = !1) {
    if (n) {
      const l = n[e] || (n[e] = []), a = t.__weh || (t.__weh = (...r) => {
        jo();
        const i = Yi(n), u = Yo(t, n, e, r);
        return i(), Uo(), u;
      });
      return o ? l.unshift(a) : l.push(a), a;
    } else if (process.env.NODE_ENV !== "production") {
      const l = Rl($v[e].replace(/ hook$/, ""));
      Ge(
        `${l} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
      );
    }
  }
  const Ql = (e) => (t, n = On) => {
    (!vi || e === "sp") && md(e, (...o) => t(...o), n);
  }, gd = Ql("bm"), ft = Ql("m"), Pv = Ql(
    "bu"
  ), Qo = Ql("u"), Bt = Ql(
    "bum"
  ), bs = Ql("um"), aT = Ql(
    "sp"
  ), rT = Ql("rtg"), sT = Ql("rtc");
  function iT(e, t = On) {
    md("ec", e, t);
  }
  const Tc = "components", uT = "directives";
  function $t(e, t) {
    return Rv(Tc, e, !0, t) || e;
  }
  const bw = Symbol.for("v-ndc");
  function ct(e) {
    return Ae(e) ? Rv(Tc, e, !1) || e : e || bw;
  }
  function bd(e) {
    return Rv(uT, e);
  }
  function Rv(e, t, n = !0, o = !1) {
    const l = yn || On;
    if (l) {
      const a = l.type;
      if (e === Tc) {
        const i = zv(
          a,
          !1
        );
        if (i && (i === t || i === In(t) || i === Ta(In(t))))
          return a;
      }
      const r = (
        // local registration
        // check instance[type] first which is resolved for options API
        Wm(l[e] || a[e], t) || // global registration
        Wm(l.appContext[e], t)
      );
      if (!r && o)
        return a;
      if (process.env.NODE_ENV !== "production" && n && !r) {
        const i = e === Tc ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
        Ge(`Failed to resolve ${e.slice(0, -1)}: ${t}${i}`);
      }
      return r;
    } else process.env.NODE_ENV !== "production" && Ge(
      `resolve${Ta(e.slice(0, -1))} can only be used in render() or setup().`
    );
  }
  function Wm(e, t) {
    return e && (e[t] || e[In(t)] || e[Ta(In(t))]);
  }
  function bt(e, t, n, o) {
    let l;
    const a = n, r = ye(e);
    if (r || Ae(e)) {
      const i = r && er(e);
      let u = !1, c = !1;
      i && (u = !eo(e), c = bl(e), e = dd(e)), l = new Array(e.length);
      for (let d = 0, f = e.length; d < f; d++)
        l[d] = t(
          u ? c ? wc(Dn(e[d])) : Dn(e[d]) : e[d],
          d,
          void 0,
          a
        );
    } else if (typeof e == "number") {
      process.env.NODE_ENV !== "production" && !Number.isInteger(e) && Ge(`The v-for range expect an integer value but got ${e}.`), l = new Array(e);
      for (let i = 0; i < e; i++)
        l[i] = t(i + 1, i, void 0, a);
    } else if (ot(e))
      if (e[Symbol.iterator])
        l = Array.from(
          e,
          (i, u) => t(i, u, void 0, a)
        );
      else {
        const i = Object.keys(e);
        l = new Array(i.length);
        for (let u = 0, c = i.length; u < c; u++) {
          const d = i[u];
          l[u] = t(e[d], d, u, a);
        }
      }
    else
      l = [];
    return l;
  }
  function io(e, t) {
    for (let n = 0; n < t.length; n++) {
      const o = t[n];
      if (ye(o))
        for (let l = 0; l < o.length; l++)
          e[o[l].name] = o[l].fn;
      else o && (e[o.name] = o.key ? (...l) => {
        const a = o.fn(...l);
        return a && (a.key = o.key), a;
      } : o.fn);
    }
    return e;
  }
  function ee(e, t, n = {}, o, l) {
    if (yn.ce || yn.parent && Kr(yn.parent) && yn.parent.ce) {
      const c = Object.keys(n).length > 0;
      return t !== "default" && (n.name = t), _(), ae(
        We,
        null,
        [q("slot", n, o && o())],
        c ? -2 : 64
      );
    }
    let a = e[t];
    process.env.NODE_ENV !== "production" && a && a.length > 1 && (Ge(
      "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
    ), a = () => []), a && a._c && (a._d = !1), _();
    const r = a && yw(a(n)), i = n.key || // slot content array of a dynamic conditional slot may have a branch
    // key attached in the `createSlots` helper, respect that
    r && r.key, u = ae(
      We,
      {
        key: (i && !Wo(i) ? i : `_${t}`) + // #7256 force differentiate fallback content from actual content
        (!r && o ? "_fb" : "")
      },
      r || (o ? o() : []),
      r && e._ === 1 ? 64 : -2
    );
    return u.scopeId && (u.slotScopeIds = [u.scopeId + "-s"]), a && a._c && (a._d = !0), u;
  }
  function yw(e) {
    return e.some((t) => Wt(t) ? !(t.type === Qt || t.type === We && !yw(t.children)) : !0) ? e : null;
  }
  function cT(e, t) {
    const n = {};
    if (process.env.NODE_ENV !== "production" && !ot(e))
      return Ge("v-on with no argument expects an object value."), n;
    for (const o in e)
      n[Rl(o)] = e[o];
    return n;
  }
  const tp = (e) => e ? Hw(e) ? wd(e) : tp(e.parent) : null, or = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ pn(/* @__PURE__ */ Object.create(null), {
      $: (e) => e,
      $el: (e) => e.vnode.el,
      $data: (e) => e.data,
      $props: (e) => process.env.NODE_ENV !== "production" ? ul(e.props) : e.props,
      $attrs: (e) => process.env.NODE_ENV !== "production" ? ul(e.attrs) : e.attrs,
      $slots: (e) => process.env.NODE_ENV !== "production" ? ul(e.slots) : e.slots,
      $refs: (e) => process.env.NODE_ENV !== "production" ? ul(e.refs) : e.refs,
      $parent: (e) => tp(e.parent),
      $root: (e) => tp(e.root),
      $host: (e) => e.ce,
      $emit: (e) => e.emit,
      $options: (e) => Ew(e),
      $forceUpdate: (e) => e.f || (e.f = () => {
        vd(e.update);
      }),
      $nextTick: (e) => e.n || (e.n = Re.bind(e.proxy)),
      $watch: (e) => HT.bind(e)
    })
  ), Dv = (e) => e === "_" || e === "$", vf = (e, t) => e !== Jt && !e.__isScriptSetup && Ot(e, t), ww = {
    get({ _: e }, t) {
      if (t === "__v_skip")
        return !0;
      const { ctx: n, setupState: o, data: l, props: a, accessCache: r, type: i, appContext: u } = e;
      if (process.env.NODE_ENV !== "production" && t === "__isVue")
        return !0;
      let c;
      if (t[0] !== "$") {
        const p = r[t];
        if (p !== void 0)
          switch (p) {
            case 1:
              return o[t];
            case 2:
              return l[t];
            case 4:
              return n[t];
            case 3:
              return a[t];
          }
        else {
          if (vf(o, t))
            return r[t] = 1, o[t];
          if (l !== Jt && Ot(l, t))
            return r[t] = 2, l[t];
          if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (c = e.propsOptions[0]) && Ot(c, t)
          )
            return r[t] = 3, a[t];
          if (n !== Jt && Ot(n, t))
            return r[t] = 4, n[t];
          np && (r[t] = 0);
        }
      }
      const d = or[t];
      let f, v;
      if (d)
        return t === "$attrs" ? (Sn(e.attrs, "get", ""), process.env.NODE_ENV !== "production" && Oc()) : process.env.NODE_ENV !== "production" && t === "$slots" && Sn(e, "get", t), d(e);
      if (
        // css module (injected by vue-loader)
        (f = i.__cssModules) && (f = f[t])
      )
        return f;
      if (n !== Jt && Ot(n, t))
        return r[t] = 4, n[t];
      if (
        // global properties
        v = u.config.globalProperties, Ot(v, t)
      )
        return v[t];
      process.env.NODE_ENV !== "production" && yn && (!Ae(t) || // #1091 avoid internal isRef/isVNode checks on component instance leading
      // to infinite warning loop
      t.indexOf("__v") !== 0) && (l !== Jt && Dv(t[0]) && Ot(l, t) ? Ge(
        `Property ${JSON.stringify(
          t
        )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
      ) : e === yn && Ge(
        `Property ${JSON.stringify(t)} was accessed during render but is not defined on instance.`
      ));
    },
    set({ _: e }, t, n) {
      const { data: o, setupState: l, ctx: a } = e;
      return vf(l, t) ? (l[t] = n, !0) : process.env.NODE_ENV !== "production" && l.__isScriptSetup && Ot(l, t) ? (Ge(`Cannot mutate <script setup> binding "${t}" from Options API.`), !1) : o !== Jt && Ot(o, t) ? (o[t] = n, !0) : Ot(e.props, t) ? (process.env.NODE_ENV !== "production" && Ge(`Attempting to mutate prop "${t}". Props are readonly.`), !1) : t[0] === "$" && t.slice(1) in e ? (process.env.NODE_ENV !== "production" && Ge(
        `Attempting to mutate public property "${t}". Properties starting with $ are reserved and readonly.`
      ), !1) : (process.env.NODE_ENV !== "production" && t in e.appContext.config.globalProperties ? Object.defineProperty(a, t, {
        enumerable: !0,
        configurable: !0,
        value: n
      }) : a[t] = n, !0);
    },
    has({
      _: { data: e, setupState: t, accessCache: n, ctx: o, appContext: l, propsOptions: a, type: r }
    }, i) {
      let u, c;
      return !!(n[i] || e !== Jt && i[0] !== "$" && Ot(e, i) || vf(t, i) || (u = a[0]) && Ot(u, i) || Ot(o, i) || Ot(or, i) || Ot(l.config.globalProperties, i) || (c = r.__cssModules) && c[i]);
    },
    defineProperty(e, t, n) {
      return n.get != null ? e._.accessCache[t] = 0 : Ot(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n);
    }
  };
  process.env.NODE_ENV !== "production" && (ww.ownKeys = (e) => (Ge(
    "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
  ), Reflect.ownKeys(e)));
  function dT(e) {
    const t = {};
    return Object.defineProperty(t, "_", {
      configurable: !0,
      enumerable: !1,
      get: () => e
    }), Object.keys(or).forEach((n) => {
      Object.defineProperty(t, n, {
        configurable: !0,
        enumerable: !1,
        get: () => or[n](e),
        // intercepted by the proxy so no need for implementation,
        // but needed to prevent set errors
        set: It
      });
    }), t;
  }
  function fT(e) {
    const {
      ctx: t,
      propsOptions: [n]
    } = e;
    n && Object.keys(n).forEach((o) => {
      Object.defineProperty(t, o, {
        enumerable: !0,
        configurable: !0,
        get: () => e.props[o],
        set: It
      });
    });
  }
  function pT(e) {
    const { ctx: t, setupState: n } = e;
    Object.keys(Pt(n)).forEach((o) => {
      if (!n.__isScriptSetup) {
        if (Dv(o[0])) {
          Ge(
            `setup() return property ${JSON.stringify(
              o
            )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
          );
          return;
        }
        Object.defineProperty(t, o, {
          enumerable: !0,
          configurable: !0,
          get: () => n[o],
          set: It
        });
      }
    });
  }
  function hn() {
    return Cw("useSlots").slots;
  }
  function ea() {
    return Cw("useAttrs").attrs;
  }
  function Cw(e) {
    const t = dt();
    return process.env.NODE_ENV !== "production" && !t && Ge(`${e}() called without active instance.`), t.setupContext || (t.setupContext = Ww(t));
  }
  function jm(e) {
    return ye(e) ? e.reduce(
      (t, n) => (t[n] = null, t),
      {}
    ) : e;
  }
  function vT() {
    const e = /* @__PURE__ */ Object.create(null);
    return (t, n) => {
      e[n] ? Ge(`${t} property "${n}" is already defined in ${e[n]}.`) : e[n] = t;
    };
  }
  let np = !0;
  function hT(e) {
    const t = Ew(e), n = e.proxy, o = e.ctx;
    np = !1, t.beforeCreate && Um(t.beforeCreate, e, "bc");
    const {
      // state
      data: l,
      computed: a,
      methods: r,
      watch: i,
      provide: u,
      inject: c,
      // lifecycle
      created: d,
      beforeMount: f,
      mounted: v,
      beforeUpdate: p,
      updated: m,
      activated: h,
      deactivated: g,
      beforeDestroy: b,
      beforeUnmount: C,
      destroyed: w,
      unmounted: y,
      render: E,
      renderTracked: k,
      renderTriggered: T,
      errorCaptured: x,
      serverPrefetch: I,
      // public API
      expose: P,
      inheritAttrs: O,
      // assets
      components: N,
      directives: z,
      filters: Y
    } = t, G = process.env.NODE_ENV !== "production" ? vT() : null;
    if (process.env.NODE_ENV !== "production") {
      const [R] = e.propsOptions;
      if (R)
        for (const D in R)
          G("Props", D);
    }
    if (c && mT(c, o, G), r)
      for (const R in r) {
        const D = r[R];
        Fe(D) ? (process.env.NODE_ENV !== "production" ? Object.defineProperty(o, R, {
          value: D.bind(n),
          configurable: !0,
          enumerable: !0,
          writable: !0
        }) : o[R] = D.bind(n), process.env.NODE_ENV !== "production" && G("Methods", R)) : process.env.NODE_ENV !== "production" && Ge(
          `Method "${R}" has type "${typeof D}" in the component definition. Did you reference the function correctly?`
        );
      }
    if (l) {
      process.env.NODE_ENV !== "production" && !Fe(l) && Ge(
        "The data option must be a function. Plain object usage is no longer supported."
      );
      const R = l.call(n, n);
      if (process.env.NODE_ENV !== "production" && _a(R) && Ge(
        "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
      ), !ot(R))
        process.env.NODE_ENV !== "production" && Ge("data() should return an object.");
      else if (e.data = Rt(R), process.env.NODE_ENV !== "production")
        for (const D in R)
          G("Data", D), Dv(D[0]) || Object.defineProperty(o, D, {
            configurable: !0,
            enumerable: !0,
            get: () => R[D],
            set: It
          });
    }
    if (np = !0, a)
      for (const R in a) {
        const D = a[R], L = Fe(D) ? D.bind(n, n) : Fe(D.get) ? D.get.bind(n, n) : It;
        process.env.NODE_ENV !== "production" && L === It && Ge(`Computed property "${R}" has no getter.`);
        const V = !Fe(D) && Fe(D.set) ? D.set.bind(n) : process.env.NODE_ENV !== "production" ? () => {
          Ge(
            `Write operation failed: computed property "${R}" is readonly.`
          );
        } : It, F = S({
          get: L,
          set: V
        });
        Object.defineProperty(o, R, {
          enumerable: !0,
          configurable: !0,
          get: () => F.value,
          set: (H) => F.value = H
        }), process.env.NODE_ENV !== "production" && G("Computed", R);
      }
    if (i)
      for (const R in i)
        Sw(i[R], o, n, R);
    if (u) {
      const R = Fe(u) ? u.call(n) : u;
      Reflect.ownKeys(R).forEach((D) => {
        yt(D, R[D]);
      });
    }
    d && Um(d, e, "c");
    function M(R, D) {
      ye(D) ? D.forEach((L) => R(L.bind(n))) : D && R(D.bind(n));
    }
    if (M(gd, f), M(ft, v), M(Pv, p), M(Qo, m), M(hd, h), M(mw, g), M(iT, x), M(sT, k), M(rT, T), M(Bt, C), M(bs, y), M(aT, I), ye(P))
      if (P.length) {
        const R = e.exposed || (e.exposed = {});
        P.forEach((D) => {
          Object.defineProperty(R, D, {
            get: () => n[D],
            set: (L) => n[D] = L,
            enumerable: !0
          });
        });
      } else e.exposed || (e.exposed = {});
    E && e.render === It && (e.render = E), O != null && (e.inheritAttrs = O), N && (e.components = N), z && (e.directives = z), I && hw(e);
  }
  function mT(e, t, n = It) {
    ye(e) && (e = op(e));
    for (const o in e) {
      const l = e[o];
      let a;
      ot(l) ? "default" in l ? a = Ve(
        l.from || o,
        l.default,
        !0
      ) : a = Ve(l.from || o) : a = Ve(l), Kt(a) ? Object.defineProperty(t, o, {
        enumerable: !0,
        configurable: !0,
        get: () => a.value,
        set: (r) => a.value = r
      }) : t[o] = a, process.env.NODE_ENV !== "production" && n("Inject", o);
    }
  }
  function Um(e, t, n) {
    Yo(
      ye(e) ? e.map((o) => o.bind(t.proxy)) : e.bind(t.proxy),
      t,
      n
    );
  }
  function Sw(e, t, n, o) {
    let l = o.includes(".") ? Rw(n, o) : () => n[o];
    if (Ae(e)) {
      const a = t[e];
      Fe(a) ? de(l, a) : process.env.NODE_ENV !== "production" && Ge(`Invalid watch handler specified by key "${e}"`, a);
    } else if (Fe(e))
      de(l, e.bind(n));
    else if (ot(e))
      if (ye(e))
        e.forEach((a) => Sw(a, t, n, o));
      else {
        const a = Fe(e.handler) ? e.handler.bind(n) : t[e.handler];
        Fe(a) ? de(l, a, e) : process.env.NODE_ENV !== "production" && Ge(`Invalid watch handler specified by key "${e.handler}"`, a);
      }
    else process.env.NODE_ENV !== "production" && Ge(`Invalid watch option: "${o}"`, e);
  }
  function Ew(e) {
    const t = e.type, { mixins: n, extends: o } = t, {
      mixins: l,
      optionsCache: a,
      config: { optionMergeStrategies: r }
    } = e.appContext, i = a.get(t);
    let u;
    return i ? u = i : !l.length && !n && !o ? u = t : (u = {}, l.length && l.forEach(
      (c) => Nc(u, c, r, !0)
    ), Nc(u, t, r)), ot(t) && a.set(t, u), u;
  }
  function Nc(e, t, n, o = !1) {
    const { mixins: l, extends: a } = t;
    a && Nc(e, a, n, !0), l && l.forEach(
      (r) => Nc(e, r, n, !0)
    );
    for (const r in t)
      if (o && r === "expose")
        process.env.NODE_ENV !== "production" && Ge(
          '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
        );
      else {
        const i = gT[r] || n && n[r];
        e[r] = i ? i(e[r], t[r]) : t[r];
      }
    return e;
  }
  const gT = {
    data: Ym,
    props: qm,
    emits: qm,
    // objects
    methods: Hs,
    computed: Hs,
    // lifecycle
    beforeCreate: Gn,
    created: Gn,
    beforeMount: Gn,
    mounted: Gn,
    beforeUpdate: Gn,
    updated: Gn,
    beforeDestroy: Gn,
    beforeUnmount: Gn,
    destroyed: Gn,
    unmounted: Gn,
    activated: Gn,
    deactivated: Gn,
    errorCaptured: Gn,
    serverPrefetch: Gn,
    // assets
    components: Hs,
    directives: Hs,
    // watch
    watch: yT,
    // provide / inject
    provide: Ym,
    inject: bT
  };
  function Ym(e, t) {
    return t ? e ? function() {
      return pn(
        Fe(e) ? e.call(this, this) : e,
        Fe(t) ? t.call(this, this) : t
      );
    } : t : e;
  }
  function bT(e, t) {
    return Hs(op(e), op(t));
  }
  function op(e) {
    if (ye(e)) {
      const t = {};
      for (let n = 0; n < e.length; n++)
        t[e[n]] = e[n];
      return t;
    }
    return e;
  }
  function Gn(e, t) {
    return e ? [...new Set([].concat(e, t))] : t;
  }
  function Hs(e, t) {
    return e ? pn(/* @__PURE__ */ Object.create(null), e, t) : t;
  }
  function qm(e, t) {
    return e ? ye(e) && ye(t) ? [.../* @__PURE__ */ new Set([...e, ...t])] : pn(
      /* @__PURE__ */ Object.create(null),
      jm(e),
      jm(t ?? {})
    ) : t;
  }
  function yT(e, t) {
    if (!e) return t;
    if (!t) return e;
    const n = pn(/* @__PURE__ */ Object.create(null), e);
    for (const o in t)
      n[o] = Gn(e[o], t[o]);
    return n;
  }
  function kw() {
    return {
      app: null,
      config: {
        isNativeTag: C0,
        performance: !1,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let wT = 0;
  function CT(e, t) {
    return function(o, l = null) {
      Fe(o) || (o = pn({}, o)), l != null && !ot(l) && (process.env.NODE_ENV !== "production" && Ge("root props passed to app.mount() must be an object."), l = null);
      const a = kw(), r = /* @__PURE__ */ new WeakSet(), i = [];
      let u = !1;
      const c = a.app = {
        _uid: wT++,
        _component: o,
        _props: l,
        _container: null,
        _context: a,
        _instance: null,
        version: ag,
        get config() {
          return a.config;
        },
        set config(d) {
          process.env.NODE_ENV !== "production" && Ge(
            "app.config cannot be replaced. Modify individual options instead."
          );
        },
        use(d, ...f) {
          return r.has(d) ? process.env.NODE_ENV !== "production" && Ge("Plugin has already been applied to target app.") : d && Fe(d.install) ? (r.add(d), d.install(c, ...f)) : Fe(d) ? (r.add(d), d(c, ...f)) : process.env.NODE_ENV !== "production" && Ge(
            'A plugin must either be a function or an object with an "install" function.'
          ), c;
        },
        mixin(d) {
          return a.mixins.includes(d) ? process.env.NODE_ENV !== "production" && Ge(
            "Mixin has already been applied to target app" + (d.name ? `: ${d.name}` : "")
          ) : a.mixins.push(d), c;
        },
        component(d, f) {
          return process.env.NODE_ENV !== "production" && ip(d, a.config), f ? (process.env.NODE_ENV !== "production" && a.components[d] && Ge(`Component "${d}" has already been registered in target app.`), a.components[d] = f, c) : a.components[d];
        },
        directive(d, f) {
          return process.env.NODE_ENV !== "production" && aw(d), f ? (process.env.NODE_ENV !== "production" && a.directives[d] && Ge(`Directive "${d}" has already been registered in target app.`), a.directives[d] = f, c) : a.directives[d];
        },
        mount(d, f, v) {
          if (u)
            process.env.NODE_ENV !== "production" && Ge(
              "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
            );
          else {
            process.env.NODE_ENV !== "production" && d.__vue_app__ && Ge(
              "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
            );
            const p = c._ceVNode || q(o, l);
            return p.appContext = a, v === !0 ? v = "svg" : v === !1 && (v = void 0), process.env.NODE_ENV !== "production" && (a.reload = () => {
              const m = qo(p);
              m.el = null, e(m, d, v);
            }), e(p, d, v), u = !0, c._container = d, d.__vue_app__ = c, process.env.NODE_ENV !== "production" && (c._instance = p.component, U2(c, ag)), wd(p.component);
          }
        },
        onUnmount(d) {
          process.env.NODE_ENV !== "production" && typeof d != "function" && Ge(
            `Expected function as first argument to app.onUnmount(), but got ${typeof d}`
          ), i.push(d);
        },
        unmount() {
          u ? (Yo(
            i,
            c._instance,
            16
          ), e(null, c._container), process.env.NODE_ENV !== "production" && (c._instance = null, Y2(c)), delete c._container.__vue_app__) : process.env.NODE_ENV !== "production" && Ge("Cannot unmount an app that is not mounted.");
        },
        provide(d, f) {
          return process.env.NODE_ENV !== "production" && d in a.provides && (Ot(a.provides, d) ? Ge(
            `App already provides property with key "${String(d)}". It will be overwritten with the new value.`
          ) : Ge(
            `App already provides property with key "${String(d)}" inherited from its parent element. It will be overwritten with the new value.`
          )), a.provides[d] = f, c;
        },
        runWithContext(d) {
          const f = Wr;
          Wr = c;
          try {
            return d();
          } finally {
            Wr = f;
          }
        }
      };
      return c;
    };
  }
  let Wr = null;
  function yt(e, t) {
    if (!On)
      process.env.NODE_ENV !== "production" && Ge("provide() can only be used inside setup().");
    else {
      let n = On.provides;
      const o = On.parent && On.parent.provides;
      o === n && (n = On.provides = Object.create(o)), n[e] = t;
    }
  }
  function Ve(e, t, n = !1) {
    const o = dt();
    if (o || Wr) {
      let l = Wr ? Wr._context.provides : o ? o.parent == null || o.ce ? o.vnode.appContext && o.vnode.appContext.provides : o.parent.provides : void 0;
      if (l && e in l)
        return l[e];
      if (arguments.length > 1)
        return n && Fe(t) ? t.call(o && o.proxy) : t;
      process.env.NODE_ENV !== "production" && Ge(`injection "${String(e)}" not found.`);
    } else process.env.NODE_ENV !== "production" && Ge("inject() can only be used inside setup() or functional components.");
  }
  const _w = {}, Tw = () => Object.create(_w), Nw = (e) => Object.getPrototypeOf(e) === _w;
  function ST(e, t, n, o = !1) {
    const l = {}, a = Tw();
    e.propsDefaults = /* @__PURE__ */ Object.create(null), $w(e, t, l, a);
    for (const r in e.propsOptions[0])
      r in l || (l[r] = void 0);
    process.env.NODE_ENV !== "production" && Iw(t || {}, l, e), n ? e.props = o ? l : Nv(l) : e.type.props ? e.props = l : e.props = a, e.attrs = a;
  }
  function ET(e) {
    for (; e; ) {
      if (e.type.__hmrId) return !0;
      e = e.parent;
    }
  }
  function kT(e, t, n, o) {
    const {
      props: l,
      attrs: a,
      vnode: { patchFlag: r }
    } = e, i = Pt(l), [u] = e.propsOptions;
    let c = !1;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      !(process.env.NODE_ENV !== "production" && ET(e)) && (o || r > 0) && !(r & 16)
    ) {
      if (r & 8) {
        const d = e.vnode.dynamicProps;
        for (let f = 0; f < d.length; f++) {
          let v = d[f];
          if (yd(e.emitsOptions, v))
            continue;
          const p = t[v];
          if (u)
            if (Ot(a, v))
              p !== a[v] && (a[v] = p, c = !0);
            else {
              const m = In(v);
              l[m] = lp(
                u,
                i,
                m,
                p,
                e,
                !1
              );
            }
          else
            p !== a[v] && (a[v] = p, c = !0);
        }
      }
    } else {
      $w(e, t, l, a) && (c = !0);
      let d;
      for (const f in i)
        (!t || // for camelCase
        !Ot(t, f) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((d = gl(f)) === f || !Ot(t, d))) && (u ? n && // for camelCase
        (n[f] !== void 0 || // for kebab-case
        n[d] !== void 0) && (l[f] = lp(
          u,
          i,
          f,
          void 0,
          e,
          !0
        )) : delete l[f]);
      if (a !== i)
        for (const f in a)
          (!t || !Ot(t, f)) && (delete a[f], c = !0);
    }
    c && il(e.attrs, "set", ""), process.env.NODE_ENV !== "production" && Iw(t || {}, l, e);
  }
  function $w(e, t, n, o) {
    const [l, a] = e.propsOptions;
    let r = !1, i;
    if (t)
      for (let u in t) {
        if (Ys(u))
          continue;
        const c = t[u];
        let d;
        l && Ot(l, d = In(u)) ? !a || !a.includes(d) ? n[d] = c : (i || (i = {}))[d] = c : yd(e.emitsOptions, u) || (!(u in o) || c !== o[u]) && (o[u] = c, r = !0);
      }
    if (a) {
      const u = Pt(n), c = i || Jt;
      for (let d = 0; d < a.length; d++) {
        const f = a[d];
        n[f] = lp(
          l,
          u,
          f,
          c[f],
          e,
          !Ot(c, f)
        );
      }
    }
    return r;
  }
  function lp(e, t, n, o, l, a) {
    const r = e[n];
    if (r != null) {
      const i = Ot(r, "default");
      if (i && o === void 0) {
        const u = r.default;
        if (r.type !== Function && !r.skipFactory && Fe(u)) {
          const { propsDefaults: c } = l;
          if (n in c)
            o = c[n];
          else {
            const d = Yi(l);
            o = c[n] = u.call(
              null,
              t
            ), d();
          }
        } else
          o = u;
        l.ce && l.ce._setProp(n, o);
      }
      r[
        0
        /* shouldCast */
      ] && (a && !i ? o = !1 : r[
        1
        /* shouldCastTrue */
      ] && (o === "" || o === gl(n)) && (o = !0));
    }
    return o;
  }
  const _T = /* @__PURE__ */ new WeakMap();
  function Ow(e, t, n = !1) {
    const o = n ? _T : t.propsCache, l = o.get(e);
    if (l)
      return l;
    const a = e.props, r = {}, i = [];
    let u = !1;
    if (!Fe(e)) {
      const d = (f) => {
        u = !0;
        const [v, p] = Ow(f, t, !0);
        pn(r, v), p && i.push(...p);
      };
      !n && t.mixins.length && t.mixins.forEach(d), e.extends && d(e.extends), e.mixins && e.mixins.forEach(d);
    }
    if (!a && !u)
      return ot(e) && o.set(e, zr), zr;
    if (ye(a))
      for (let d = 0; d < a.length; d++) {
        process.env.NODE_ENV !== "production" && !Ae(a[d]) && Ge("props must be strings when using array syntax.", a[d]);
        const f = In(a[d]);
        Gm(f) && (r[f] = Jt);
      }
    else if (a) {
      process.env.NODE_ENV !== "production" && !ot(a) && Ge("invalid props options", a);
      for (const d in a) {
        const f = In(d);
        if (Gm(f)) {
          const v = a[d], p = r[f] = ye(v) || Fe(v) ? { type: v } : pn({}, v), m = p.type;
          let h = !1, g = !0;
          if (ye(m))
            for (let b = 0; b < m.length; ++b) {
              const C = m[b], w = Fe(C) && C.name;
              if (w === "Boolean") {
                h = !0;
                break;
              } else w === "String" && (g = !1);
            }
          else
            h = Fe(m) && m.name === "Boolean";
          p[
            0
            /* shouldCast */
          ] = h, p[
            1
            /* shouldCastTrue */
          ] = g, (h || Ot(p, "default")) && i.push(f);
        }
      }
    }
    const c = [r, i];
    return ot(e) && o.set(e, c), c;
  }
  function Gm(e) {
    return e[0] !== "$" && !Ys(e) ? !0 : (process.env.NODE_ENV !== "production" && Ge(`Invalid prop name: "${e}" is a reserved property.`), !1);
  }
  function TT(e) {
    return e === null ? "null" : typeof e == "function" ? e.name || "" : typeof e == "object" && e.constructor && e.constructor.name || "";
  }
  function Iw(e, t, n) {
    const o = Pt(t), l = n.propsOptions[0], a = Object.keys(e).map((r) => In(r));
    for (const r in l) {
      let i = l[r];
      i != null && NT(
        r,
        o[r],
        i,
        process.env.NODE_ENV !== "production" ? ul(o) : o,
        !a.includes(r)
      );
    }
  }
  function NT(e, t, n, o, l) {
    const { type: a, required: r, validator: i, skipCheck: u } = n;
    if (r && l) {
      Ge('Missing required prop: "' + e + '"');
      return;
    }
    if (!(t == null && !r)) {
      if (a != null && a !== !0 && !u) {
        let c = !1;
        const d = ye(a) ? a : [a], f = [];
        for (let v = 0; v < d.length && !c; v++) {
          const { valid: p, expectedType: m } = OT(t, d[v]);
          f.push(m || ""), c = p;
        }
        if (!c) {
          Ge(IT(e, t, f));
          return;
        }
      }
      i && !i(t, o) && Ge('Invalid prop: custom validator check failed for prop "' + e + '".');
    }
  }
  const $T = /* @__PURE__ */ Zl(
    "String,Number,Boolean,Function,Symbol,BigInt"
  );
  function OT(e, t) {
    let n;
    const o = TT(t);
    if (o === "null")
      n = e === null;
    else if ($T(o)) {
      const l = typeof e;
      n = l === o.toLowerCase(), !n && l === "object" && (n = e instanceof t);
    } else o === "Object" ? n = ot(e) : o === "Array" ? n = ye(e) : n = e instanceof t;
    return {
      valid: n,
      expectedType: o
    };
  }
  function IT(e, t, n) {
    if (n.length === 0)
      return `Prop type [] for prop "${e}" won't match anything. Did you mean to use type Array instead?`;
    let o = `Invalid prop: type check failed for prop "${e}". Expected ${n.map(Ta).join(" | ")}`;
    const l = n[0], a = Cv(t), r = Xm(t, l), i = Xm(t, a);
    return n.length === 1 && Jm(l) && !MT(l, a) && (o += ` with value ${r}`), o += `, got ${a} `, Jm(a) && (o += `with value ${i}.`), o;
  }
  function Xm(e, t) {
    return t === "String" ? `"${e}"` : t === "Number" ? `${Number(e)}` : `${e}`;
  }
  function Jm(e) {
    return ["string", "number", "boolean"].some((n) => e.toLowerCase() === n);
  }
  function MT(...e) {
    return e.some((t) => t.toLowerCase() === "boolean");
  }
  const Av = (e) => e === "_" || e === "_ctx" || e === "$stable", Vv = (e) => ye(e) ? e.map(Ro) : [Ro(e)], xT = (e, t, n) => {
    if (t._n)
      return t;
    const o = Q((...l) => (process.env.NODE_ENV !== "production" && On && !(n === null && yn) && !(n && n.root !== On.root) && Ge(
      `Slot "${e}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
    ), Vv(t(...l))), n);
    return o._c = !1, o;
  }, Mw = (e, t, n) => {
    const o = e._ctx;
    for (const l in e) {
      if (Av(l)) continue;
      const a = e[l];
      if (Fe(a))
        t[l] = xT(l, a, o);
      else if (a != null) {
        process.env.NODE_ENV !== "production" && Ge(
          `Non-function value encountered for slot "${l}". Prefer function slots for better performance.`
        );
        const r = Vv(a);
        t[l] = () => r;
      }
    }
  }, xw = (e, t) => {
    process.env.NODE_ENV !== "production" && !Ui(e.vnode) && Ge(
      "Non-function value encountered for default slot. Prefer function slots for better performance."
    );
    const n = Vv(t);
    e.slots.default = () => n;
  }, ap = (e, t, n) => {
    for (const o in t)
      (n || !Av(o)) && (e[o] = t[o]);
  }, PT = (e, t, n) => {
    const o = e.slots = Tw();
    if (e.vnode.shapeFlag & 32) {
      const l = t._;
      l ? (ap(o, t, n), n && bc(o, "_", l, !0)) : Mw(t, o);
    } else t && xw(e, t);
  }, RT = (e, t, n) => {
    const { vnode: o, slots: l } = e;
    let a = !0, r = Jt;
    if (o.shapeFlag & 32) {
      const i = t._;
      i ? process.env.NODE_ENV !== "production" && Vo ? (ap(l, t, n), il(e, "set", "$slots")) : n && i === 1 ? a = !1 : ap(l, t, n) : (a = !t.$stable, Mw(t, l)), r = t;
    } else t && (xw(e, t), r = { default: 1 });
    if (a)
      for (const i in l)
        !Av(i) && r[i] == null && delete l[i];
  };
  let xs, Al;
  function _r(e, t) {
    e.appContext.config.performance && $c() && Al.mark(`vue-${t}-${e.uid}`), process.env.NODE_ENV !== "production" && J2(e, t, $c() ? Al.now() : Date.now());
  }
  function Tr(e, t) {
    if (e.appContext.config.performance && $c()) {
      const n = `vue-${t}-${e.uid}`, o = n + ":end", l = `<${Cd(e, e.type)}> ${t}`;
      Al.mark(o), Al.measure(l, n, o), Al.clearMeasures(l), Al.clearMarks(n), Al.clearMarks(o);
    }
    process.env.NODE_ENV !== "production" && Z2(e, t, $c() ? Al.now() : Date.now());
  }
  function $c() {
    return xs !== void 0 || (typeof window < "u" && window.performance ? (xs = !0, Al = window.performance) : xs = !1), xs;
  }
  function DT() {
    const e = [];
    if (process.env.NODE_ENV !== "production" && e.length) {
      const t = e.length > 1;
      console.warn(
        `Feature flag${t ? "s" : ""} ${e.join(", ")} ${t ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
      );
    }
  }
  const Xn = XT;
  function AT(e) {
    return VT(e);
  }
  function VT(e, t) {
    DT();
    const n = Ki();
    n.__VUE__ = !0, process.env.NODE_ENV !== "production" && Iv(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
    const {
      insert: o,
      remove: l,
      patchProp: a,
      createElement: r,
      createText: i,
      createComment: u,
      setText: c,
      setElementText: d,
      parentNode: f,
      nextSibling: v,
      setScopeId: p = It,
      insertStaticContent: m
    } = e, h = (j, te, ce, ge = null, be = null, Ee = null, Oe = void 0, De = null, we = process.env.NODE_ENV !== "production" && Vo ? !1 : !!te.dynamicChildren) => {
      if (j === te)
        return;
      j && !Ka(j, te) && (ge = re(j), K(j, be, Ee, !0), j = null), te.patchFlag === -2 && (we = !1, te.dynamicChildren = null);
      const { type: me, ref: Pe, shapeFlag: Me } = te;
      switch (me) {
        case Pa:
          g(j, te, ce, ge);
          break;
        case Qt:
          b(j, te, ce, ge);
          break;
        case Xu:
          j == null ? C(te, ce, ge, Oe) : process.env.NODE_ENV !== "production" && w(j, te, ce, Oe);
          break;
        case We:
          z(
            j,
            te,
            ce,
            ge,
            be,
            Ee,
            Oe,
            De,
            we
          );
          break;
        default:
          Me & 1 ? k(
            j,
            te,
            ce,
            ge,
            be,
            Ee,
            Oe,
            De,
            we
          ) : Me & 6 ? Y(
            j,
            te,
            ce,
            ge,
            be,
            Ee,
            Oe,
            De,
            we
          ) : Me & 64 || Me & 128 ? me.process(
            j,
            te,
            ce,
            ge,
            be,
            Ee,
            Oe,
            De,
            we,
            le
          ) : process.env.NODE_ENV !== "production" && Ge("Invalid VNode type:", me, `(${typeof me})`);
      }
      Pe != null && be ? Xs(Pe, j && j.ref, Ee, te || j, !te) : Pe == null && j && j.ref != null && Xs(j.ref, null, Ee, j, !0);
    }, g = (j, te, ce, ge) => {
      if (j == null)
        o(
          te.el = i(te.children),
          ce,
          ge
        );
      else {
        const be = te.el = j.el;
        te.children !== j.children && c(be, te.children);
      }
    }, b = (j, te, ce, ge) => {
      j == null ? o(
        te.el = u(te.children || ""),
        ce,
        ge
      ) : te.el = j.el;
    }, C = (j, te, ce, ge) => {
      [j.el, j.anchor] = m(
        j.children,
        te,
        ce,
        ge,
        j.el,
        j.anchor
      );
    }, w = (j, te, ce, ge) => {
      if (te.children !== j.children) {
        const be = v(j.anchor);
        E(j), [te.el, te.anchor] = m(
          te.children,
          ce,
          be,
          ge
        );
      } else
        te.el = j.el, te.anchor = j.anchor;
    }, y = ({ el: j, anchor: te }, ce, ge) => {
      let be;
      for (; j && j !== te; )
        be = v(j), o(j, ce, ge), j = be;
      o(te, ce, ge);
    }, E = ({ el: j, anchor: te }) => {
      let ce;
      for (; j && j !== te; )
        ce = v(j), l(j), j = ce;
      l(te);
    }, k = (j, te, ce, ge, be, Ee, Oe, De, we) => {
      if (te.type === "svg" ? Oe = "svg" : te.type === "math" && (Oe = "mathml"), j == null)
        T(
          te,
          ce,
          ge,
          be,
          Ee,
          Oe,
          De,
          we
        );
      else {
        const me = j.el && j.el._isVueCE ? j.el : null;
        try {
          me && me._beginPatch(), P(
            j,
            te,
            be,
            Ee,
            Oe,
            De,
            we
          );
        } finally {
          me && me._endPatch();
        }
      }
    }, T = (j, te, ce, ge, be, Ee, Oe, De) => {
      let we, me;
      const { props: Pe, shapeFlag: Me, transition: Be, dirs: pe } = j;
      if (we = j.el = r(
        j.type,
        Ee,
        Pe && Pe.is,
        Pe
      ), Me & 8 ? d(we, j.children) : Me & 16 && I(
        j.children,
        we,
        null,
        ge,
        be,
        hf(j, Ee),
        Oe,
        De
      ), pe && Va(j, null, ge, "created"), x(we, j, j.scopeId, Oe, ge), Pe) {
        for (const Xe in Pe)
          Xe !== "value" && !Ys(Xe) && a(we, Xe, null, Pe[Xe], Ee, ge);
        "value" in Pe && a(we, "value", null, Pe.value, Ee), (me = Pe.onVnodeBeforeMount) && al(me, ge, j);
      }
      process.env.NODE_ENV !== "production" && (bc(we, "__vnode", j, !0), bc(we, "__vueParentComponent", ge, !0)), pe && Va(j, null, ge, "beforeMount");
      const Le = LT(be, Be);
      Le && Be.beforeEnter(we), o(we, te, ce), ((me = Pe && Pe.onVnodeMounted) || Le || pe) && Xn(() => {
        me && al(me, ge, j), Le && Be.enter(we), pe && Va(j, null, ge, "mounted");
      }, be);
    }, x = (j, te, ce, ge, be) => {
      if (ce && p(j, ce), ge)
        for (let Ee = 0; Ee < ge.length; Ee++)
          p(j, ge[Ee]);
      if (be) {
        let Ee = be.subTree;
        if (process.env.NODE_ENV !== "production" && Ee.patchFlag > 0 && Ee.patchFlag & 2048 && (Ee = Bv(Ee.children) || Ee), te === Ee || Vw(Ee.type) && (Ee.ssContent === te || Ee.ssFallback === te)) {
          const Oe = be.vnode;
          x(
            j,
            Oe,
            Oe.scopeId,
            Oe.slotScopeIds,
            be.parent
          );
        }
      }
    }, I = (j, te, ce, ge, be, Ee, Oe, De, we = 0) => {
      for (let me = we; me < j.length; me++) {
        const Pe = j[me] = De ? ha(j[me]) : Ro(j[me]);
        h(
          null,
          Pe,
          te,
          ce,
          ge,
          be,
          Ee,
          Oe,
          De
        );
      }
    }, P = (j, te, ce, ge, be, Ee, Oe) => {
      const De = te.el = j.el;
      process.env.NODE_ENV !== "production" && (De.__vnode = te);
      let { patchFlag: we, dynamicChildren: me, dirs: Pe } = te;
      we |= j.patchFlag & 16;
      const Me = j.props || Jt, Be = te.props || Jt;
      let pe;
      if (ce && La(ce, !1), (pe = Be.onVnodeBeforeUpdate) && al(pe, ce, te, j), Pe && Va(te, j, ce, "beforeUpdate"), ce && La(ce, !0), process.env.NODE_ENV !== "production" && Vo && (we = 0, Oe = !1, me = null), (Me.innerHTML && Be.innerHTML == null || Me.textContent && Be.textContent == null) && d(De, ""), me ? (O(
        j.dynamicChildren,
        me,
        De,
        ce,
        ge,
        hf(te, be),
        Ee
      ), process.env.NODE_ENV !== "production" && Js(j, te)) : Oe || L(
        j,
        te,
        De,
        null,
        ce,
        ge,
        hf(te, be),
        Ee,
        !1
      ), we > 0) {
        if (we & 16)
          N(De, Me, Be, ce, be);
        else if (we & 2 && Me.class !== Be.class && a(De, "class", null, Be.class, be), we & 4 && a(De, "style", Me.style, Be.style, be), we & 8) {
          const Le = te.dynamicProps;
          for (let Xe = 0; Xe < Le.length; Xe++) {
            const ut = Le[Xe], Nt = Me[ut], Ye = Be[ut];
            (Ye !== Nt || ut === "value") && a(De, ut, Nt, Ye, be, ce);
          }
        }
        we & 1 && j.children !== te.children && d(De, te.children);
      } else !Oe && me == null && N(De, Me, Be, ce, be);
      ((pe = Be.onVnodeUpdated) || Pe) && Xn(() => {
        pe && al(pe, ce, te, j), Pe && Va(te, j, ce, "updated");
      }, ge);
    }, O = (j, te, ce, ge, be, Ee, Oe) => {
      for (let De = 0; De < te.length; De++) {
        const we = j[De], me = te[De], Pe = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          we.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (we.type === We || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !Ka(we, me) || // - In the case of a component, it could contain anything.
          we.shapeFlag & 198) ? f(we.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            ce
          )
        );
        h(
          we,
          me,
          Pe,
          null,
          ge,
          be,
          Ee,
          Oe,
          !0
        );
      }
    }, N = (j, te, ce, ge, be) => {
      if (te !== ce) {
        if (te !== Jt)
          for (const Ee in te)
            !Ys(Ee) && !(Ee in ce) && a(
              j,
              Ee,
              te[Ee],
              null,
              be,
              ge
            );
        for (const Ee in ce) {
          if (Ys(Ee)) continue;
          const Oe = ce[Ee], De = te[Ee];
          Oe !== De && Ee !== "value" && a(j, Ee, De, Oe, be, ge);
        }
        "value" in ce && a(j, "value", te.value, ce.value, be);
      }
    }, z = (j, te, ce, ge, be, Ee, Oe, De, we) => {
      const me = te.el = j ? j.el : i(""), Pe = te.anchor = j ? j.anchor : i("");
      let { patchFlag: Me, dynamicChildren: Be, slotScopeIds: pe } = te;
      process.env.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
      (Vo || Me & 2048) && (Me = 0, we = !1, Be = null), pe && (De = De ? De.concat(pe) : pe), j == null ? (o(me, ce, ge), o(Pe, ce, ge), I(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        te.children || [],
        ce,
        Pe,
        be,
        Ee,
        Oe,
        De,
        we
      )) : Me > 0 && Me & 64 && Be && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      j.dynamicChildren ? (O(
        j.dynamicChildren,
        Be,
        ce,
        be,
        Ee,
        Oe,
        De
      ), process.env.NODE_ENV !== "production" ? Js(j, te) : (
        // #2080 if the stable fragment has a key, it's a <template v-for> that may
        //  get moved around. Make sure all root level vnodes inherit el.
        // #2134 or if it's a component root, it may also get moved around
        // as the component is being moved.
        (te.key != null || be && te === be.subTree) && Js(
          j,
          te,
          !0
          /* shallow */
        )
      )) : L(
        j,
        te,
        ce,
        Pe,
        be,
        Ee,
        Oe,
        De,
        we
      );
    }, Y = (j, te, ce, ge, be, Ee, Oe, De, we) => {
      te.slotScopeIds = De, j == null ? te.shapeFlag & 512 ? be.ctx.activate(
        te,
        ce,
        ge,
        Oe,
        we
      ) : G(
        te,
        ce,
        ge,
        be,
        Ee,
        Oe,
        we
      ) : M(j, te, we);
    }, G = (j, te, ce, ge, be, Ee, Oe) => {
      const De = j.component = tN(
        j,
        ge,
        be
      );
      if (process.env.NODE_ENV !== "production" && De.type.__hmrId && H2(De), process.env.NODE_ENV !== "production" && (Uu(j), _r(De, "mount")), Ui(j) && (De.ctx.renderer = le), process.env.NODE_ENV !== "production" && _r(De, "init"), oN(De, !1, Oe), process.env.NODE_ENV !== "production" && Tr(De, "init"), process.env.NODE_ENV !== "production" && Vo && (j.el = null), De.asyncDep) {
        if (be && be.registerDep(De, R, Oe), !j.el) {
          const we = De.subTree = q(Qt);
          b(null, we, te, ce), j.placeholder = we.el;
        }
      } else
        R(
          De,
          j,
          te,
          ce,
          be,
          Ee,
          Oe
        );
      process.env.NODE_ENV !== "production" && (Yu(), Tr(De, "mount"));
    }, M = (j, te, ce) => {
      const ge = te.component = j.component;
      if (qT(j, te, ce))
        if (ge.asyncDep && !ge.asyncResolved) {
          process.env.NODE_ENV !== "production" && Uu(te), D(ge, te, ce), process.env.NODE_ENV !== "production" && Yu();
          return;
        } else
          ge.next = te, ge.update();
      else
        te.el = j.el, ge.vnode = te;
    }, R = (j, te, ce, ge, be, Ee, Oe) => {
      const De = () => {
        if (j.isMounted) {
          let { next: Me, bu: Be, u: pe, parent: Le, vnode: Xe } = j;
          {
            const fe = Pw(j);
            if (fe) {
              Me && (Me.el = Xe.el, D(j, Me, Oe)), fe.asyncDep.then(() => {
                j.isUnmounted || De();
              });
              return;
            }
          }
          let ut = Me, Nt;
          process.env.NODE_ENV !== "production" && Uu(Me || j.vnode), La(j, !1), Me ? (Me.el = Xe.el, D(j, Me, Oe)) : Me = Xe, Be && Pr(Be), (Nt = Me.props && Me.props.onVnodeBeforeUpdate) && al(Nt, Le, Me, Xe), La(j, !0), process.env.NODE_ENV !== "production" && _r(j, "render");
          const Ye = Qm(j);
          process.env.NODE_ENV !== "production" && Tr(j, "render");
          const tt = j.subTree;
          j.subTree = Ye, process.env.NODE_ENV !== "production" && _r(j, "patch"), h(
            tt,
            Ye,
            // parent may have changed if it's in a teleport
            f(tt.el),
            // anchor may have changed if it's in a fragment
            re(tt),
            j,
            be,
            Ee
          ), process.env.NODE_ENV !== "production" && Tr(j, "patch"), Me.el = Ye.el, ut === null && GT(j, Ye.el), pe && Xn(pe, be), (Nt = Me.props && Me.props.onVnodeUpdated) && Xn(
            () => al(Nt, Le, Me, Xe),
            be
          ), process.env.NODE_ENV !== "production" && nw(j), process.env.NODE_ENV !== "production" && Yu();
        } else {
          let Me;
          const { el: Be, props: pe } = te, { bm: Le, m: Xe, parent: ut, root: Nt, type: Ye } = j, tt = Kr(te);
          La(j, !1), Le && Pr(Le), !tt && (Me = pe && pe.onVnodeBeforeMount) && al(Me, ut, te), La(j, !0);
          {
            Nt.ce && // @ts-expect-error _def is private
            Nt.ce._def.shadowRoot !== !1 && Nt.ce._injectChildStyle(Ye), process.env.NODE_ENV !== "production" && _r(j, "render");
            const fe = j.subTree = Qm(j);
            process.env.NODE_ENV !== "production" && Tr(j, "render"), process.env.NODE_ENV !== "production" && _r(j, "patch"), h(
              null,
              fe,
              ce,
              ge,
              j,
              be,
              Ee
            ), process.env.NODE_ENV !== "production" && Tr(j, "patch"), te.el = fe.el;
          }
          if (Xe && Xn(Xe, be), !tt && (Me = pe && pe.onVnodeMounted)) {
            const fe = te;
            Xn(
              () => al(Me, ut, fe),
              be
            );
          }
          (te.shapeFlag & 256 || ut && Kr(ut.vnode) && ut.vnode.shapeFlag & 256) && j.a && Xn(j.a, be), j.isMounted = !0, process.env.NODE_ENV !== "production" && q2(j), te = ce = ge = null;
        }
      };
      j.scope.on();
      const we = j.effect = new I0(De);
      j.scope.off();
      const me = j.update = we.run.bind(we), Pe = j.job = we.runIfDirty.bind(we);
      Pe.i = j, Pe.id = j.uid, we.scheduler = () => vd(Pe), La(j, !0), process.env.NODE_ENV !== "production" && (we.onTrack = j.rtc ? (Me) => Pr(j.rtc, Me) : void 0, we.onTrigger = j.rtg ? (Me) => Pr(j.rtg, Me) : void 0), me();
    }, D = (j, te, ce) => {
      te.component = j;
      const ge = j.vnode.props;
      j.vnode = te, j.next = null, kT(j, te.props, ge, ce), RT(j, te.children, ce), jo(), Am(j), Uo();
    }, L = (j, te, ce, ge, be, Ee, Oe, De, we = !1) => {
      const me = j && j.children, Pe = j ? j.shapeFlag : 0, Me = te.children, { patchFlag: Be, shapeFlag: pe } = te;
      if (Be > 0) {
        if (Be & 128) {
          F(
            me,
            Me,
            ce,
            ge,
            be,
            Ee,
            Oe,
            De,
            we
          );
          return;
        } else if (Be & 256) {
          V(
            me,
            Me,
            ce,
            ge,
            be,
            Ee,
            Oe,
            De,
            we
          );
          return;
        }
      }
      pe & 8 ? (Pe & 16 && ue(me, be, Ee), Me !== me && d(ce, Me)) : Pe & 16 ? pe & 16 ? F(
        me,
        Me,
        ce,
        ge,
        be,
        Ee,
        Oe,
        De,
        we
      ) : ue(me, be, Ee, !0) : (Pe & 8 && d(ce, ""), pe & 16 && I(
        Me,
        ce,
        ge,
        be,
        Ee,
        Oe,
        De,
        we
      ));
    }, V = (j, te, ce, ge, be, Ee, Oe, De, we) => {
      j = j || zr, te = te || zr;
      const me = j.length, Pe = te.length, Me = Math.min(me, Pe);
      let Be;
      for (Be = 0; Be < Me; Be++) {
        const pe = te[Be] = we ? ha(te[Be]) : Ro(te[Be]);
        h(
          j[Be],
          pe,
          ce,
          null,
          be,
          Ee,
          Oe,
          De,
          we
        );
      }
      me > Pe ? ue(
        j,
        be,
        Ee,
        !0,
        !1,
        Me
      ) : I(
        te,
        ce,
        ge,
        be,
        Ee,
        Oe,
        De,
        we,
        Me
      );
    }, F = (j, te, ce, ge, be, Ee, Oe, De, we) => {
      let me = 0;
      const Pe = te.length;
      let Me = j.length - 1, Be = Pe - 1;
      for (; me <= Me && me <= Be; ) {
        const pe = j[me], Le = te[me] = we ? ha(te[me]) : Ro(te[me]);
        if (Ka(pe, Le))
          h(
            pe,
            Le,
            ce,
            null,
            be,
            Ee,
            Oe,
            De,
            we
          );
        else
          break;
        me++;
      }
      for (; me <= Me && me <= Be; ) {
        const pe = j[Me], Le = te[Be] = we ? ha(te[Be]) : Ro(te[Be]);
        if (Ka(pe, Le))
          h(
            pe,
            Le,
            ce,
            null,
            be,
            Ee,
            Oe,
            De,
            we
          );
        else
          break;
        Me--, Be--;
      }
      if (me > Me) {
        if (me <= Be) {
          const pe = Be + 1, Le = pe < Pe ? te[pe].el : ge;
          for (; me <= Be; )
            h(
              null,
              te[me] = we ? ha(te[me]) : Ro(te[me]),
              ce,
              Le,
              be,
              Ee,
              Oe,
              De,
              we
            ), me++;
        }
      } else if (me > Be)
        for (; me <= Me; )
          K(j[me], be, Ee, !0), me++;
      else {
        const pe = me, Le = me, Xe = /* @__PURE__ */ new Map();
        for (me = Le; me <= Be; me++) {
          const ve = te[me] = we ? ha(te[me]) : Ro(te[me]);
          ve.key != null && (process.env.NODE_ENV !== "production" && Xe.has(ve.key) && Ge(
            "Duplicate keys found during update:",
            JSON.stringify(ve.key),
            "Make sure keys are unique."
          ), Xe.set(ve.key, me));
        }
        let ut, Nt = 0;
        const Ye = Be - Le + 1;
        let tt = !1, fe = 0;
        const He = new Array(Ye);
        for (me = 0; me < Ye; me++) He[me] = 0;
        for (me = pe; me <= Me; me++) {
          const ve = j[me];
          if (Nt >= Ye) {
            K(ve, be, Ee, !0);
            continue;
          }
          let Ke;
          if (ve.key != null)
            Ke = Xe.get(ve.key);
          else
            for (ut = Le; ut <= Be; ut++)
              if (He[ut - Le] === 0 && Ka(ve, te[ut])) {
                Ke = ut;
                break;
              }
          Ke === void 0 ? K(ve, be, Ee, !0) : (He[Ke - Le] = me + 1, Ke >= fe ? fe = Ke : tt = !0, h(
            ve,
            te[Ke],
            ce,
            null,
            be,
            Ee,
            Oe,
            De,
            we
          ), Nt++);
        }
        const Qe = tt ? BT(He) : zr;
        for (ut = Qe.length - 1, me = Ye - 1; me >= 0; me--) {
          const ve = Le + me, Ke = te[ve], St = te[ve + 1], Ft = ve + 1 < Pe ? (
            // #13559, fallback to el placeholder for unresolved async component
            St.el || St.placeholder
          ) : ge;
          He[me] === 0 ? h(
            null,
            Ke,
            ce,
            Ft,
            be,
            Ee,
            Oe,
            De,
            we
          ) : tt && (ut < 0 || me !== Qe[ut] ? H(Ke, ce, Ft, 2) : ut--);
        }
      }
    }, H = (j, te, ce, ge, be = null) => {
      const { el: Ee, type: Oe, transition: De, children: we, shapeFlag: me } = j;
      if (me & 6) {
        H(j.component.subTree, te, ce, ge);
        return;
      }
      if (me & 128) {
        j.suspense.move(te, ce, ge);
        return;
      }
      if (me & 64) {
        Oe.move(j, te, ce, le);
        return;
      }
      if (Oe === We) {
        o(Ee, te, ce);
        for (let Me = 0; Me < we.length; Me++)
          H(we[Me], te, ce, ge);
        o(j.anchor, te, ce);
        return;
      }
      if (Oe === Xu) {
        y(j, te, ce);
        return;
      }
      if (ge !== 2 && me & 1 && De)
        if (ge === 0)
          De.beforeEnter(Ee), o(Ee, te, ce), Xn(() => De.enter(Ee), be);
        else {
          const { leave: Me, delayLeave: Be, afterLeave: pe } = De, Le = () => {
            j.ctx.isUnmounted ? l(Ee) : o(Ee, te, ce);
          }, Xe = () => {
            Ee._isLeaving && Ee[Dl](
              !0
              /* cancelled */
            ), Me(Ee, () => {
              Le(), pe && pe();
            });
          };
          Be ? Be(Ee, Le, Xe) : Xe();
        }
      else
        o(Ee, te, ce);
    }, K = (j, te, ce, ge = !1, be = !1) => {
      const {
        type: Ee,
        props: Oe,
        ref: De,
        children: we,
        dynamicChildren: me,
        shapeFlag: Pe,
        patchFlag: Me,
        dirs: Be,
        cacheIndex: pe
      } = j;
      if (Me === -2 && (be = !1), De != null && (jo(), Xs(De, null, ce, j, !0), Uo()), pe != null && (te.renderCache[pe] = void 0), Pe & 256) {
        te.ctx.deactivate(j);
        return;
      }
      const Le = Pe & 1 && Be, Xe = !Kr(j);
      let ut;
      if (Xe && (ut = Oe && Oe.onVnodeBeforeUnmount) && al(ut, te, j), Pe & 6)
        ie(j.component, ce, ge);
      else {
        if (Pe & 128) {
          j.suspense.unmount(ce, ge);
          return;
        }
        Le && Va(j, null, te, "beforeUnmount"), Pe & 64 ? j.type.remove(
          j,
          te,
          ce,
          le,
          ge
        ) : me && // #5154
        // when v-once is used inside a block, setBlockTracking(-1) marks the
        // parent block with hasOnce: true
        // so that it doesn't take the fast path during unmount - otherwise
        // components nested in v-once are never unmounted.
        !me.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (Ee !== We || Me > 0 && Me & 64) ? ue(
          me,
          te,
          ce,
          !1,
          !0
        ) : (Ee === We && Me & 384 || !be && Pe & 16) && ue(we, te, ce), ge && Z(j);
      }
      (Xe && (ut = Oe && Oe.onVnodeUnmounted) || Le) && Xn(() => {
        ut && al(ut, te, j), Le && Va(j, null, te, "unmounted");
      }, ce);
    }, Z = (j) => {
      const { type: te, el: ce, anchor: ge, transition: be } = j;
      if (te === We) {
        process.env.NODE_ENV !== "production" && j.patchFlag > 0 && j.patchFlag & 2048 && be && !be.persisted ? j.children.forEach((Oe) => {
          Oe.type === Qt ? l(Oe.el) : Z(Oe);
        }) : J(ce, ge);
        return;
      }
      if (te === Xu) {
        E(j);
        return;
      }
      const Ee = () => {
        l(ce), be && !be.persisted && be.afterLeave && be.afterLeave();
      };
      if (j.shapeFlag & 1 && be && !be.persisted) {
        const { leave: Oe, delayLeave: De } = be, we = () => Oe(ce, Ee);
        De ? De(j.el, Ee, we) : we();
      } else
        Ee();
    }, J = (j, te) => {
      let ce;
      for (; j !== te; )
        ce = v(j), l(j), j = ce;
      l(te);
    }, ie = (j, te, ce) => {
      process.env.NODE_ENV !== "production" && j.type.__hmrId && K2(j);
      const { bum: ge, scope: be, job: Ee, subTree: Oe, um: De, m: we, a: me } = j;
      Zm(we), Zm(me), ge && Pr(ge), be.stop(), Ee && (Ee.flags |= 8, K(Oe, j, te, ce)), De && Xn(De, te), Xn(() => {
        j.isUnmounted = !0;
      }, te), process.env.NODE_ENV !== "production" && X2(j);
    }, ue = (j, te, ce, ge = !1, be = !1, Ee = 0) => {
      for (let Oe = Ee; Oe < j.length; Oe++)
        K(j[Oe], te, ce, ge, be);
    }, re = (j) => {
      if (j.shapeFlag & 6)
        return re(j.component.subTree);
      if (j.shapeFlag & 128)
        return j.suspense.next();
      const te = v(j.anchor || j.el), ce = te && te[rw];
      return ce ? v(ce) : te;
    };
    let se = !1;
    const ne = (j, te, ce) => {
      j == null ? te._vnode && K(te._vnode, null, null, !0) : h(
        te._vnode || null,
        j,
        te,
        null,
        null,
        null,
        ce
      ), te._vnode = j, se || (se = !0, Am(), Q0(), se = !1);
    }, le = {
      p: h,
      um: K,
      m: H,
      r: Z,
      mt: G,
      mc: I,
      pc: L,
      pbc: O,
      n: re,
      o: e
    };
    return {
      render: ne,
      hydrate: void 0,
      createApp: CT(ne)
    };
  }
  function hf({ type: e, props: t }, n) {
    return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n;
  }
  function La({ effect: e, job: t }, n) {
    n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5);
  }
  function LT(e, t) {
    return (!e || e && !e.pendingBranch) && t && !t.persisted;
  }
  function Js(e, t, n = !1) {
    const o = e.children, l = t.children;
    if (ye(o) && ye(l))
      for (let a = 0; a < o.length; a++) {
        const r = o[a];
        let i = l[a];
        i.shapeFlag & 1 && !i.dynamicChildren && ((i.patchFlag <= 0 || i.patchFlag === 32) && (i = l[a] = ha(l[a]), i.el = r.el), !n && i.patchFlag !== -2 && Js(r, i)), i.type === Pa && // avoid cached text nodes retaining detached dom nodes
        i.patchFlag !== -1 && (i.el = r.el), i.type === Qt && !i.el && (i.el = r.el), process.env.NODE_ENV !== "production" && i.el && (i.el.__vnode = i);
      }
  }
  function BT(e) {
    const t = e.slice(), n = [0];
    let o, l, a, r, i;
    const u = e.length;
    for (o = 0; o < u; o++) {
      const c = e[o];
      if (c !== 0) {
        if (l = n[n.length - 1], e[l] < c) {
          t[o] = l, n.push(o);
          continue;
        }
        for (a = 0, r = n.length - 1; a < r; )
          i = a + r >> 1, e[n[i]] < c ? a = i + 1 : r = i;
        c < e[n[a]] && (a > 0 && (t[o] = n[a - 1]), n[a] = o);
      }
    }
    for (a = n.length, r = n[a - 1]; a-- > 0; )
      n[a] = r, r = t[r];
    return n;
  }
  function Pw(e) {
    const t = e.subTree.component;
    if (t)
      return t.asyncDep && !t.asyncResolved ? t : Pw(t);
  }
  function Zm(e) {
    if (e)
      for (let t = 0; t < e.length; t++)
        e[t].flags |= 8;
  }
  const FT = Symbol.for("v-scx"), zT = () => {
    {
      const e = Ve(FT);
      return e || process.env.NODE_ENV !== "production" && Ge(
        "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
      ), e;
    }
  };
  function to(e, t) {
    return Lv(e, null, t);
  }
  function de(e, t, n) {
    return process.env.NODE_ENV !== "production" && !Fe(t) && Ge(
      "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
    ), Lv(e, t, n);
  }
  function Lv(e, t, n = Jt) {
    const { immediate: o, deep: l, flush: a, once: r } = n;
    process.env.NODE_ENV !== "production" && !t && (o !== void 0 && Ge(
      'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
    ), l !== void 0 && Ge(
      'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
    ), r !== void 0 && Ge(
      'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
    ));
    const i = pn({}, n);
    process.env.NODE_ENV !== "production" && (i.onWarn = Ge);
    const u = t && o || !t && a !== "post";
    let c;
    if (vi) {
      if (a === "sync") {
        const p = zT();
        c = p.__watcherHandles || (p.__watcherHandles = []);
      } else if (!u) {
        const p = () => {
        };
        return p.stop = It, p.resume = It, p.pause = It, p;
      }
    }
    const d = On;
    i.call = (p, m, h) => Yo(p, d, m, h);
    let f = !1;
    a === "post" ? i.scheduler = (p) => {
      Xn(p, d && d.suspense);
    } : a !== "sync" && (f = !0, i.scheduler = (p, m) => {
      m ? p() : vd(p);
    }), i.augmentJob = (p) => {
      t && (p.flags |= 4), f && (p.flags |= 2, d && (p.id = d.uid, p.i = d));
    };
    const v = P2(e, t, i);
    return vi && (c ? c.push(v) : u && v()), v;
  }
  function HT(e, t, n) {
    const o = this.proxy, l = Ae(e) ? e.includes(".") ? Rw(o, e) : () => o[e] : e.bind(o, o);
    let a;
    Fe(t) ? a = t : (a = t.handler, n = t);
    const r = Yi(this), i = Lv(l, a.bind(o), n);
    return r(), i;
  }
  function Rw(e, t) {
    const n = t.split(".");
    return () => {
      let o = e;
      for (let l = 0; l < n.length && o; l++)
        o = o[n[l]];
      return o;
    };
  }
  const KT = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${In(t)}Modifiers`] || e[`${gl(t)}Modifiers`];
  function WT(e, t, ...n) {
    if (e.isUnmounted) return;
    const o = e.vnode.props || Jt;
    if (process.env.NODE_ENV !== "production") {
      const {
        emitsOptions: d,
        propsOptions: [f]
      } = e;
      if (d)
        if (!(t in d))
          (!f || !(Rl(In(t)) in f)) && Ge(
            `Component emitted event "${t}" but it is neither declared in the emits option nor as an "${Rl(In(t))}" prop.`
          );
        else {
          const v = d[t];
          Fe(v) && (v(...n) || Ge(
            `Invalid event arguments: event validation failed for event "${t}".`
          ));
        }
    }
    let l = n;
    const a = t.startsWith("update:"), r = a && KT(o, t.slice(7));
    if (r && (r.trim && (l = n.map((d) => Ae(d) ? d.trim() : d)), r.number && (l = n.map(Ev))), process.env.NODE_ENV !== "production" && Q2(e, t, l), process.env.NODE_ENV !== "production") {
      const d = t.toLowerCase();
      d !== t && o[Rl(d)] && Ge(
        `Event "${d}" is emitted in component ${Cd(
          e,
          e.type
        )} but the handler is registered for "${t}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${gl(
          t
        )}" instead of "${t}".`
      );
    }
    let i, u = o[i = Rl(t)] || // also try camelCase event handler (#2249)
    o[i = Rl(In(t))];
    !u && a && (u = o[i = Rl(gl(t))]), u && Yo(
      u,
      e,
      6,
      l
    );
    const c = o[i + "Once"];
    if (c) {
      if (!e.emitted)
        e.emitted = {};
      else if (e.emitted[i])
        return;
      e.emitted[i] = !0, Yo(
        c,
        e,
        6,
        l
      );
    }
  }
  const jT = /* @__PURE__ */ new WeakMap();
  function Dw(e, t, n = !1) {
    const o = n ? jT : t.emitsCache, l = o.get(e);
    if (l !== void 0)
      return l;
    const a = e.emits;
    let r = {}, i = !1;
    if (!Fe(e)) {
      const u = (c) => {
        const d = Dw(c, t, !0);
        d && (i = !0, pn(r, d));
      };
      !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u);
    }
    return !a && !i ? (ot(e) && o.set(e, null), null) : (ye(a) ? a.forEach((u) => r[u] = null) : pn(r, a), ot(e) && o.set(e, r), r);
  }
  function yd(e, t) {
    return !e || !zi(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), Ot(e, t[0].toLowerCase() + t.slice(1)) || Ot(e, gl(t)) || Ot(e, t));
  }
  let rp = !1;
  function Oc() {
    rp = !0;
  }
  function Qm(e) {
    const {
      type: t,
      vnode: n,
      proxy: o,
      withProxy: l,
      propsOptions: [a],
      slots: r,
      attrs: i,
      emit: u,
      render: c,
      renderCache: d,
      props: f,
      data: v,
      setupState: p,
      ctx: m,
      inheritAttrs: h
    } = e, g = kc(e);
    let b, C;
    process.env.NODE_ENV !== "production" && (rp = !1);
    try {
      if (n.shapeFlag & 4) {
        const E = l || o, k = process.env.NODE_ENV !== "production" && p.__isScriptSetup ? new Proxy(E, {
          get(T, x, I) {
            return Ge(
              `Property '${String(
                x
              )}' was accessed via 'this'. Avoid using 'this' in templates.`
            ), Reflect.get(T, x, I);
          }
        }) : E;
        b = Ro(
          c.call(
            k,
            E,
            d,
            process.env.NODE_ENV !== "production" ? ul(f) : f,
            p,
            v,
            m
          )
        ), C = i;
      } else {
        const E = t;
        process.env.NODE_ENV !== "production" && i === f && Oc(), b = Ro(
          E.length > 1 ? E(
            process.env.NODE_ENV !== "production" ? ul(f) : f,
            process.env.NODE_ENV !== "production" ? {
              get attrs() {
                return Oc(), ul(i);
              },
              slots: r,
              emit: u
            } : { attrs: i, slots: r, emit: u }
          ) : E(
            process.env.NODE_ENV !== "production" ? ul(f) : f,
            null
          )
        ), C = t.props ? i : UT(i);
      }
    } catch (E) {
      Zs.length = 0, Wi(E, e, 1), b = q(Qt);
    }
    let w = b, y;
    if (process.env.NODE_ENV !== "production" && b.patchFlag > 0 && b.patchFlag & 2048 && ([w, y] = Aw(b)), C && h !== !1) {
      const E = Object.keys(C), { shapeFlag: k } = w;
      if (E.length) {
        if (k & 7)
          a && E.some(gc) && (C = YT(
            C,
            a
          )), w = qo(w, C, !1, !0);
        else if (process.env.NODE_ENV !== "production" && !rp && w.type !== Qt) {
          const T = Object.keys(i), x = [], I = [];
          for (let P = 0, O = T.length; P < O; P++) {
            const N = T[P];
            zi(N) ? gc(N) || x.push(N[2].toLowerCase() + N.slice(3)) : I.push(N);
          }
          I.length && Ge(
            `Extraneous non-props attributes (${I.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
          ), x.length && Ge(
            `Extraneous non-emits event listeners (${x.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
          );
        }
      }
    }
    return n.dirs && (process.env.NODE_ENV !== "production" && !eg(w) && Ge(
      "Runtime directive used on component with non-element root node. The directives will not function as intended."
    ), w = qo(w, null, !1, !0), w.dirs = w.dirs ? w.dirs.concat(n.dirs) : n.dirs), n.transition && (process.env.NODE_ENV !== "production" && !eg(w) && Ge(
      "Component inside <Transition> renders non-element root node that cannot be animated."
    ), cr(w, n.transition)), process.env.NODE_ENV !== "production" && y ? y(w) : b = w, kc(g), b;
  }
  const Aw = (e) => {
    const t = e.children, n = e.dynamicChildren, o = Bv(t, !1);
    if (o) {
      if (process.env.NODE_ENV !== "production" && o.patchFlag > 0 && o.patchFlag & 2048)
        return Aw(o);
    } else return [e, void 0];
    const l = t.indexOf(o), a = n ? n.indexOf(o) : -1, r = (i) => {
      t[l] = i, n && (a > -1 ? n[a] = i : i.patchFlag > 0 && (e.dynamicChildren = [...n, i]));
    };
    return [Ro(o), r];
  };
  function Bv(e, t = !0) {
    let n;
    for (let o = 0; o < e.length; o++) {
      const l = e[o];
      if (Wt(l)) {
        if (l.type !== Qt || l.children === "v-if") {
          if (n)
            return;
          if (n = l, process.env.NODE_ENV !== "production" && t && n.patchFlag > 0 && n.patchFlag & 2048)
            return Bv(n.children);
        }
      } else
        return;
    }
    return n;
  }
  const UT = (e) => {
    let t;
    for (const n in e)
      (n === "class" || n === "style" || zi(n)) && ((t || (t = {}))[n] = e[n]);
    return t;
  }, YT = (e, t) => {
    const n = {};
    for (const o in e)
      (!gc(o) || !(o.slice(9) in t)) && (n[o] = e[o]);
    return n;
  }, eg = (e) => e.shapeFlag & 7 || e.type === Qt;
  function qT(e, t, n) {
    const { props: o, children: l, component: a } = e, { props: r, children: i, patchFlag: u } = t, c = a.emitsOptions;
    if (process.env.NODE_ENV !== "production" && (l || i) && Vo || t.dirs || t.transition)
      return !0;
    if (n && u >= 0) {
      if (u & 1024)
        return !0;
      if (u & 16)
        return o ? tg(o, r, c) : !!r;
      if (u & 8) {
        const d = t.dynamicProps;
        for (let f = 0; f < d.length; f++) {
          const v = d[f];
          if (r[v] !== o[v] && !yd(c, v))
            return !0;
        }
      }
    } else
      return (l || i) && (!i || !i.$stable) ? !0 : o === r ? !1 : o ? r ? tg(o, r, c) : !0 : !!r;
    return !1;
  }
  function tg(e, t, n) {
    const o = Object.keys(t);
    if (o.length !== Object.keys(e).length)
      return !0;
    for (let l = 0; l < o.length; l++) {
      const a = o[l];
      if (t[a] !== e[a] && !yd(n, a))
        return !0;
    }
    return !1;
  }
  function GT({ vnode: e, parent: t }, n) {
    for (; t; ) {
      const o = t.subTree;
      if (o.suspense && o.suspense.activeBranch === e && (o.el = e.el), o === e)
        (e = t.vnode).el = n, t = t.parent;
      else
        break;
    }
  }
  const Vw = (e) => e.__isSuspense;
  function XT(e, t) {
    t && t.pendingBranch ? ye(e) ? t.effects.push(...e) : t.effects.push(e) : Z0(e);
  }
  const We = Symbol.for("v-fgt"), Pa = Symbol.for("v-txt"), Qt = Symbol.for("v-cmt"), Xu = Symbol.for("v-stc"), Zs = [];
  let po = null;
  function _(e = !1) {
    Zs.push(po = e ? null : []);
  }
  function JT() {
    Zs.pop(), po = Zs[Zs.length - 1] || null;
  }
  let pi = 1;
  function Ic(e, t = !1) {
    pi += e, e < 0 && po && t && (po.hasOnce = !0);
  }
  function Lw(e) {
    return e.dynamicChildren = pi > 0 ? po || zr : null, JT(), pi > 0 && po && po.push(e), e;
  }
  function B(e, t, n, o, l, a) {
    return Lw(
      W(
        e,
        t,
        n,
        o,
        l,
        a,
        !0
      )
    );
  }
  function ae(e, t, n, o, l) {
    return Lw(
      q(
        e,
        t,
        n,
        o,
        l,
        !0
      )
    );
  }
  function Wt(e) {
    return e ? e.__v_isVNode === !0 : !1;
  }
  function Ka(e, t) {
    if (process.env.NODE_ENV !== "production" && t.shapeFlag & 6 && e.component) {
      const n = qu.get(t.type);
      if (n && n.has(e.component))
        return e.shapeFlag &= -257, t.shapeFlag &= -513, !1;
    }
    return e.type === t.type && e.key === t.key;
  }
  const ZT = (...e) => Fw(
    ...e
  ), Bw = ({ key: e }) => e ?? null, Ju = ({
    ref: e,
    ref_key: t,
    ref_for: n
  }) => (typeof e == "number" && (e = "" + e), e != null ? Ae(e) || Kt(e) || Fe(e) ? { i: yn, r: e, k: t, f: !!n } : e : null);
  function W(e, t = null, n = null, o = 0, l = null, a = e === We ? 0 : 1, r = !1, i = !1) {
    const u = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e,
      props: t,
      key: t && Bw(t),
      ref: t && Ju(t),
      scopeId: lw,
      slotScopeIds: null,
      children: n,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag: a,
      patchFlag: o,
      dynamicProps: l,
      dynamicChildren: null,
      appContext: null,
      ctx: yn
    };
    return i ? (Fv(u, n), a & 128 && e.normalize(u)) : n && (u.shapeFlag |= Ae(n) ? 8 : 16), process.env.NODE_ENV !== "production" && u.key !== u.key && Ge("VNode created with invalid key (NaN). VNode type:", u.type), pi > 0 && // avoid a block node from tracking itself
    !r && // has current parent block
    po && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (u.patchFlag > 0 || a & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    u.patchFlag !== 32 && po.push(u), u;
  }
  const q = process.env.NODE_ENV !== "production" ? ZT : Fw;
  function Fw(e, t = null, n = null, o = 0, l = null, a = !1) {
    if ((!e || e === bw) && (process.env.NODE_ENV !== "production" && !e && Ge(`Invalid vnode type when creating vnode: ${e}.`), e = Qt), Wt(e)) {
      const i = qo(
        e,
        t,
        !0
        /* mergeRef: true */
      );
      return n && Fv(i, n), pi > 0 && !a && po && (i.shapeFlag & 6 ? po[po.indexOf(e)] = i : po.push(i)), i.patchFlag = -2, i;
    }
    if (jw(e) && (e = e.__vccOpts), t) {
      t = fl(t);
      let { class: i, style: u } = t;
      i && !Ae(i) && (t.class = $(i)), ot(u) && (ci(u) && !ye(u) && (u = pn({}, u)), t.style = Ue(u));
    }
    const r = Ae(e) ? 1 : Vw(e) ? 128 : sw(e) ? 64 : ot(e) ? 4 : Fe(e) ? 2 : 0;
    return process.env.NODE_ENV !== "production" && r & 4 && ci(e) && (e = Pt(e), Ge(
      "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
      `
Component that was made reactive: `,
      e
    )), W(
      e,
      t,
      n,
      o,
      l,
      r,
      a,
      !0
    );
  }
  function fl(e) {
    return e ? ci(e) || Nw(e) ? pn({}, e) : e : null;
  }
  function qo(e, t, n = !1, o = !1) {
    const { props: l, ref: a, patchFlag: r, children: i, transition: u } = e, c = t ? pt(l || {}, t) : l, d = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: e.type,
      props: c,
      key: c && Bw(c),
      ref: t && t.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        n && a ? ye(a) ? a.concat(Ju(t)) : [a, Ju(t)] : Ju(t)
      ) : a,
      scopeId: e.scopeId,
      slotScopeIds: e.slotScopeIds,
      children: process.env.NODE_ENV !== "production" && r === -1 && ye(i) ? i.map(zw) : i,
      target: e.target,
      targetStart: e.targetStart,
      targetAnchor: e.targetAnchor,
      staticCount: e.staticCount,
      shapeFlag: e.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: t && e.type !== We ? r === -1 ? 16 : r | 16 : r,
      dynamicProps: e.dynamicProps,
      dynamicChildren: e.dynamicChildren,
      appContext: e.appContext,
      dirs: e.dirs,
      transition: u,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: e.component,
      suspense: e.suspense,
      ssContent: e.ssContent && qo(e.ssContent),
      ssFallback: e.ssFallback && qo(e.ssFallback),
      placeholder: e.placeholder,
      el: e.el,
      anchor: e.anchor,
      ctx: e.ctx,
      ce: e.ce
    };
    return u && o && cr(
      d,
      u.clone(d)
    ), d;
  }
  function zw(e) {
    const t = qo(e);
    return ye(e.children) && (t.children = e.children.map(zw)), t;
  }
  function Ct(e = " ", t = 0) {
    return q(Pa, null, e, t);
  }
  function oe(e = "", t = !1) {
    return t ? (_(), ae(Qt, null, e)) : q(Qt, null, e);
  }
  function Ro(e) {
    return e == null || typeof e == "boolean" ? q(Qt) : ye(e) ? q(
      We,
      null,
      // #3666, avoid reference pollution when reusing vnode
      e.slice()
    ) : Wt(e) ? ha(e) : q(Pa, null, String(e));
  }
  function ha(e) {
    return e.el === null && e.patchFlag !== -1 || e.memo ? e : qo(e);
  }
  function Fv(e, t) {
    let n = 0;
    const { shapeFlag: o } = e;
    if (t == null)
      t = null;
    else if (ye(t))
      n = 16;
    else if (typeof t == "object")
      if (o & 65) {
        const l = t.default;
        l && (l._c && (l._d = !1), Fv(e, l()), l._c && (l._d = !0));
        return;
      } else {
        n = 32;
        const l = t._;
        !l && !Nw(t) ? t._ctx = yn : l === 3 && yn && (yn.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
      }
    else Fe(t) ? (t = { default: t, _ctx: yn }, n = 32) : (t = String(t), o & 64 ? (n = 16, t = [Ct(t)]) : n = 8);
    e.children = t, e.shapeFlag |= n;
  }
  function pt(...e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const o = e[n];
      for (const l in o)
        if (l === "class")
          t.class !== o.class && (t.class = $([t.class, o.class]));
        else if (l === "style")
          t.style = Ue([t.style, o.style]);
        else if (zi(l)) {
          const a = t[l], r = o[l];
          r && a !== r && !(ye(a) && a.includes(r)) && (t[l] = a ? [].concat(a, r) : r);
        } else l !== "" && (t[l] = o[l]);
    }
    return t;
  }
  function al(e, t, n, o = null) {
    Yo(e, t, 7, [
      n,
      o
    ]);
  }
  const QT = kw();
  let eN = 0;
  function tN(e, t, n) {
    const o = e.type, l = (t ? t.appContext : e.appContext) || QT, a = {
      uid: eN++,
      vnode: e,
      type: o,
      parent: t,
      appContext: l,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      job: null,
      scope: new N0(
        !0
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: t ? t.provides : Object.create(l.provides),
      ids: t ? t.ids : ["", 0, 0],
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: Ow(o, l),
      emitsOptions: Dw(o, l),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: Jt,
      // inheritAttrs
      inheritAttrs: o.inheritAttrs,
      // state
      ctx: Jt,
      data: Jt,
      props: Jt,
      attrs: Jt,
      slots: Jt,
      refs: Jt,
      setupState: Jt,
      setupContext: null,
      // suspense related
      suspense: n,
      suspenseId: n ? n.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    return process.env.NODE_ENV !== "production" ? a.ctx = dT(a) : a.ctx = { _: a }, a.root = t ? t.root : a, a.emit = WT.bind(null, a), e.ce && e.ce(a), a;
  }
  let On = null;
  const dt = () => On || yn;
  let Mc, sp;
  {
    const e = Ki(), t = (n, o) => {
      let l;
      return (l = e[n]) || (l = e[n] = []), l.push(o), (a) => {
        l.length > 1 ? l.forEach((r) => r(a)) : l[0](a);
      };
    };
    Mc = t(
      "__VUE_INSTANCE_SETTERS__",
      (n) => On = n
    ), sp = t(
      "__VUE_SSR_SETTERS__",
      (n) => vi = n
    );
  }
  const Yi = (e) => {
    const t = On;
    return Mc(e), e.scope.on(), () => {
      e.scope.off(), Mc(t);
    };
  }, ng = () => {
    On && On.scope.off(), Mc(null);
  }, nN = /* @__PURE__ */ Zl("slot,component");
  function ip(e, { isNativeTag: t }) {
    (nN(e) || t(e)) && Ge(
      "Do not use built-in or reserved HTML elements as component id: " + e
    );
  }
  function Hw(e) {
    return e.vnode.shapeFlag & 4;
  }
  let vi = !1;
  function oN(e, t = !1, n = !1) {
    t && sp(t);
    const { props: o, children: l } = e.vnode, a = Hw(e);
    ST(e, o, a, t), PT(e, l, n || t);
    const r = a ? lN(e, t) : void 0;
    return t && sp(!1), r;
  }
  function lN(e, t) {
    var n;
    const o = e.type;
    if (process.env.NODE_ENV !== "production") {
      if (o.name && ip(o.name, e.appContext.config), o.components) {
        const a = Object.keys(o.components);
        for (let r = 0; r < a.length; r++)
          ip(a[r], e.appContext.config);
      }
      if (o.directives) {
        const a = Object.keys(o.directives);
        for (let r = 0; r < a.length; r++)
          aw(a[r]);
      }
      o.compilerOptions && aN() && Ge(
        '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
      );
    }
    e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = new Proxy(e.ctx, ww), process.env.NODE_ENV !== "production" && fT(e);
    const { setup: l } = o;
    if (l) {
      jo();
      const a = e.setupContext = l.length > 1 ? Ww(e) : null, r = Yi(e), i = gs(
        l,
        e,
        0,
        [
          process.env.NODE_ENV !== "production" ? ul(e.props) : e.props,
          a
        ]
      ), u = _a(i);
      if (Uo(), r(), (u || e.sp) && !Kr(e) && hw(e), u) {
        if (i.then(ng, ng), t)
          return i.then((c) => {
            og(e, c, t);
          }).catch((c) => {
            Wi(c, e, 0);
          });
        if (e.asyncDep = i, process.env.NODE_ENV !== "production" && !e.suspense) {
          const c = (n = o.name) != null ? n : "Anonymous";
          Ge(
            `Component <${c}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
          );
        }
      } else
        og(e, i, t);
    } else
      Kw(e, t);
  }
  function og(e, t, n) {
    Fe(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : ot(t) ? (process.env.NODE_ENV !== "production" && Wt(t) && Ge(
      "setup() should not return VNodes directly - return a render function instead."
    ), process.env.NODE_ENV !== "production" && (e.devtoolsRawSetupState = t), e.setupState = Y0(t), process.env.NODE_ENV !== "production" && pT(e)) : process.env.NODE_ENV !== "production" && t !== void 0 && Ge(
      `setup() should return an object. Received: ${t === null ? "null" : typeof t}`
    ), Kw(e, n);
  }
  const aN = () => !0;
  function Kw(e, t, n) {
    const o = e.type;
    e.render || (e.render = o.render || It);
    {
      const l = Yi(e);
      jo();
      try {
        hT(e);
      } finally {
        Uo(), l();
      }
    }
    process.env.NODE_ENV !== "production" && !o.render && e.render === It && !t && (o.template ? Ge(
      'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
    ) : Ge("Component is missing template or render function: ", o));
  }
  const lg = process.env.NODE_ENV !== "production" ? {
    get(e, t) {
      return Oc(), Sn(e, "get", ""), e[t];
    },
    set() {
      return Ge("setupContext.attrs is readonly."), !1;
    },
    deleteProperty() {
      return Ge("setupContext.attrs is readonly."), !1;
    }
  } : {
    get(e, t) {
      return Sn(e, "get", ""), e[t];
    }
  };
  function rN(e) {
    return new Proxy(e.slots, {
      get(t, n) {
        return Sn(e, "get", "$slots"), t[n];
      }
    });
  }
  function Ww(e) {
    const t = (n) => {
      if (process.env.NODE_ENV !== "production" && (e.exposed && Ge("expose() should be called only once per setup()."), n != null)) {
        let o = typeof n;
        o === "object" && (ye(n) ? o = "array" : Kt(n) && (o = "ref")), o !== "object" && Ge(
          `expose() should be passed a plain object, received ${o}.`
        );
      }
      e.exposed = n || {};
    };
    if (process.env.NODE_ENV !== "production") {
      let n, o;
      return Object.freeze({
        get attrs() {
          return n || (n = new Proxy(e.attrs, lg));
        },
        get slots() {
          return o || (o = rN(e));
        },
        get emit() {
          return (l, ...a) => e.emit(l, ...a);
        },
        expose: t
      });
    } else
      return {
        attrs: new Proxy(e.attrs, lg),
        slots: e.slots,
        emit: e.emit,
        expose: t
      };
  }
  function wd(e) {
    return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Y0(zl(e.exposed)), {
      get(t, n) {
        if (n in t)
          return t[n];
        if (n in or)
          return or[n](e);
      },
      has(t, n) {
        return n in t || n in or;
      }
    })) : e.proxy;
  }
  const sN = /(?:^|[-_])\w/g, iN = (e) => e.replace(sN, (t) => t.toUpperCase()).replace(/[-_]/g, "");
  function zv(e, t = !0) {
    return Fe(e) ? e.displayName || e.name : e.name || t && e.__name;
  }
  function Cd(e, t, n = !1) {
    let o = zv(t);
    if (!o && t.__file) {
      const l = t.__file.match(/([^/\\]+)\.\w+$/);
      l && (o = l[1]);
    }
    if (!o && e && e.parent) {
      const l = (a) => {
        for (const r in a)
          if (a[r] === t)
            return r;
      };
      o = l(
        e.components || e.parent.type.components
      ) || l(e.appContext.components);
    }
    return o ? iN(o) : n ? "App" : "Anonymous";
  }
  function jw(e) {
    return Fe(e) && "__vccOpts" in e;
  }
  const S = (e, t) => {
    const n = M2(e, t, vi);
    if (process.env.NODE_ENV !== "production") {
      const o = dt();
      o && o.appContext.config.warnRecursiveComputed && (n._warnRecursive = !0);
    }
    return n;
  };
  function qe(e, t, n) {
    try {
      Ic(-1);
      const o = arguments.length;
      return o === 2 ? ot(t) && !ye(t) ? Wt(t) ? q(e, null, [t]) : q(e, t) : q(e, null, t) : (o > 3 ? n = Array.prototype.slice.call(arguments, 2) : o === 3 && Wt(n) && (n = [n]), q(e, t, n));
    } finally {
      Ic(1);
    }
  }
  function uN() {
    if (process.env.NODE_ENV === "production" || typeof window > "u")
      return;
    const e = { style: "color:#3ba776" }, t = { style: "color:#1677ff" }, n = { style: "color:#f5222d" }, o = { style: "color:#eb2f96" }, l = {
      __vue_custom_formatter: !0,
      header(f) {
        if (!ot(f))
          return null;
        if (f.__isVue)
          return ["div", e, "VueInstance"];
        if (Kt(f)) {
          jo();
          const v = f.value;
          return Uo(), [
            "div",
            {},
            ["span", e, d(f)],
            "<",
            i(v),
            ">"
          ];
        } else {
          if (er(f))
            return [
              "div",
              {},
              ["span", e, eo(f) ? "ShallowReactive" : "Reactive"],
              "<",
              i(f),
              `>${bl(f) ? " (readonly)" : ""}`
            ];
          if (bl(f))
            return [
              "div",
              {},
              ["span", e, eo(f) ? "ShallowReadonly" : "Readonly"],
              "<",
              i(f),
              ">"
            ];
        }
        return null;
      },
      hasBody(f) {
        return f && f.__isVue;
      },
      body(f) {
        if (f && f.__isVue)
          return [
            "div",
            {},
            ...a(f.$)
          ];
      }
    };
    function a(f) {
      const v = [];
      f.type.props && f.props && v.push(r("props", Pt(f.props))), f.setupState !== Jt && v.push(r("setup", f.setupState)), f.data !== Jt && v.push(r("data", Pt(f.data)));
      const p = u(f, "computed");
      p && v.push(r("computed", p));
      const m = u(f, "inject");
      return m && v.push(r("injected", m)), v.push([
        "div",
        {},
        [
          "span",
          {
            style: o.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: f }]
      ]), v;
    }
    function r(f, v) {
      return v = pn({}, v), Object.keys(v).length ? [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          f
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(v).map((p) => [
            "div",
            {},
            ["span", o, p + ": "],
            i(v[p], !1)
          ])
        ]
      ] : ["span", {}];
    }
    function i(f, v = !0) {
      return typeof f == "number" ? ["span", t, f] : typeof f == "string" ? ["span", n, JSON.stringify(f)] : typeof f == "boolean" ? ["span", o, f] : ot(f) ? ["object", { object: v ? Pt(f) : f }] : ["span", n, String(f)];
    }
    function u(f, v) {
      const p = f.type;
      if (Fe(p))
        return;
      const m = {};
      for (const h in f.ctx)
        c(p, h, v) && (m[h] = f.ctx[h]);
      return m;
    }
    function c(f, v, p) {
      const m = f[p];
      if (ye(m) && m.includes(v) || ot(m) && v in m || f.extends && c(f.extends, v, p) || f.mixins && f.mixins.some((h) => c(h, v, p)))
        return !0;
    }
    function d(f) {
      return eo(f) ? "ShallowRef" : f.effect ? "ComputedRef" : "Ref";
    }
    window.devtoolsFormatters ? window.devtoolsFormatters.push(l) : window.devtoolsFormatters = [l];
  }
  const ag = "3.5.24", zo = process.env.NODE_ENV !== "production" ? Ge : It;
  process.env.NODE_ENV;
  process.env.NODE_ENV;
  /**
  * @vue/runtime-dom v3.5.24
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  let up;
  const rg = typeof window < "u" && window.trustedTypes;
  if (rg)
    try {
      up = /* @__PURE__ */ rg.createPolicy("vue", {
        createHTML: (e) => e
      });
    } catch (e) {
      process.env.NODE_ENV !== "production" && zo(`Error creating trusted types policy: ${e}`);
    }
  const Uw = up ? (e) => up.createHTML(e) : (e) => e, cN = "http://www.w3.org/2000/svg", dN = "http://www.w3.org/1998/Math/MathML", Pl = typeof document < "u" ? document : null, sg = Pl && /* @__PURE__ */ Pl.createElement("template"), fN = {
    insert: (e, t, n) => {
      t.insertBefore(e, n || null);
    },
    remove: (e) => {
      const t = e.parentNode;
      t && t.removeChild(e);
    },
    createElement: (e, t, n, o) => {
      const l = t === "svg" ? Pl.createElementNS(cN, e) : t === "mathml" ? Pl.createElementNS(dN, e) : n ? Pl.createElement(e, { is: n }) : Pl.createElement(e);
      return e === "select" && o && o.multiple != null && l.setAttribute("multiple", o.multiple), l;
    },
    createText: (e) => Pl.createTextNode(e),
    createComment: (e) => Pl.createComment(e),
    setText: (e, t) => {
      e.nodeValue = t;
    },
    setElementText: (e, t) => {
      e.textContent = t;
    },
    parentNode: (e) => e.parentNode,
    nextSibling: (e) => e.nextSibling,
    querySelector: (e) => Pl.querySelector(e),
    setScopeId(e, t) {
      e.setAttribute(t, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(e, t, n, o, l, a) {
      const r = n ? n.previousSibling : t.lastChild;
      if (l && (l === a || l.nextSibling))
        for (; t.insertBefore(l.cloneNode(!0), n), !(l === a || !(l = l.nextSibling)); )
          ;
      else {
        sg.innerHTML = Uw(
          o === "svg" ? `<svg>${e}</svg>` : o === "mathml" ? `<math>${e}</math>` : e
        );
        const i = sg.content;
        if (o === "svg" || o === "mathml") {
          const u = i.firstChild;
          for (; u.firstChild; )
            i.appendChild(u.firstChild);
          i.removeChild(u);
        }
        t.insertBefore(i, n);
      }
      return [
        // first
        r ? r.nextSibling : t.firstChild,
        // last
        n ? n.previousSibling : t.lastChild
      ];
    }
  }, ia = "transition", Ps = "animation", es = Symbol("_vtc"), Yw = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  }, qw = /* @__PURE__ */ pn(
    {},
    dw,
    Yw
  ), pN = (e) => (e.displayName = "Transition", e.props = qw, e), Mn = /* @__PURE__ */ pN(
    (e, { slots: t }) => qe(oT, Gw(e), t)
  ), Ba = (e, t = []) => {
    ye(e) ? e.forEach((n) => n(...t)) : e && e(...t);
  }, ig = (e) => e ? ye(e) ? e.some((t) => t.length > 1) : e.length > 1 : !1;
  function Gw(e) {
    const t = {};
    for (const N in e)
      N in Yw || (t[N] = e[N]);
    if (e.css === !1)
      return t;
    const {
      name: n = "v",
      type: o,
      duration: l,
      enterFromClass: a = `${n}-enter-from`,
      enterActiveClass: r = `${n}-enter-active`,
      enterToClass: i = `${n}-enter-to`,
      appearFromClass: u = a,
      appearActiveClass: c = r,
      appearToClass: d = i,
      leaveFromClass: f = `${n}-leave-from`,
      leaveActiveClass: v = `${n}-leave-active`,
      leaveToClass: p = `${n}-leave-to`
    } = e, m = vN(l), h = m && m[0], g = m && m[1], {
      onBeforeEnter: b,
      onEnter: C,
      onEnterCancelled: w,
      onLeave: y,
      onLeaveCancelled: E,
      onBeforeAppear: k = b,
      onAppear: T = C,
      onAppearCancelled: x = w
    } = t, I = (N, z, Y, G) => {
      N._enterCancelled = G, ca(N, z ? d : i), ca(N, z ? c : r), Y && Y();
    }, P = (N, z) => {
      N._isLeaving = !1, ca(N, f), ca(N, p), ca(N, v), z && z();
    }, O = (N) => (z, Y) => {
      const G = N ? T : C, M = () => I(z, N, Y);
      Ba(G, [z, M]), ug(() => {
        ca(z, N ? u : a), rl(z, N ? d : i), ig(G) || cg(z, o, h, M);
      });
    };
    return pn(t, {
      onBeforeEnter(N) {
        Ba(b, [N]), rl(N, a), rl(N, r);
      },
      onBeforeAppear(N) {
        Ba(k, [N]), rl(N, u), rl(N, c);
      },
      onEnter: O(!1),
      onAppear: O(!0),
      onLeave(N, z) {
        N._isLeaving = !0;
        const Y = () => P(N, z);
        rl(N, f), N._enterCancelled ? (rl(N, v), cp(N)) : (cp(N), rl(N, v)), ug(() => {
          N._isLeaving && (ca(N, f), rl(N, p), ig(y) || cg(N, o, g, Y));
        }), Ba(y, [N, Y]);
      },
      onEnterCancelled(N) {
        I(N, !1, void 0, !0), Ba(w, [N]);
      },
      onAppearCancelled(N) {
        I(N, !0, void 0, !0), Ba(x, [N]);
      },
      onLeaveCancelled(N) {
        P(N), Ba(E, [N]);
      }
    });
  }
  function vN(e) {
    if (e == null)
      return null;
    if (ot(e))
      return [mf(e.enter), mf(e.leave)];
    {
      const t = mf(e);
      return [t, t];
    }
  }
  function mf(e) {
    const t = W_(e);
    return process.env.NODE_ENV !== "production" && L2(t, "<transition> explicit duration"), t;
  }
  function rl(e, t) {
    t.split(/\s+/).forEach((n) => n && e.classList.add(n)), (e[es] || (e[es] = /* @__PURE__ */ new Set())).add(t);
  }
  function ca(e, t) {
    t.split(/\s+/).forEach((o) => o && e.classList.remove(o));
    const n = e[es];
    n && (n.delete(t), n.size || (e[es] = void 0));
  }
  function ug(e) {
    requestAnimationFrame(() => {
      requestAnimationFrame(e);
    });
  }
  let hN = 0;
  function cg(e, t, n, o) {
    const l = e._endId = ++hN, a = () => {
      l === e._endId && o();
    };
    if (n != null)
      return setTimeout(a, n);
    const { type: r, timeout: i, propCount: u } = Xw(e, t);
    if (!r)
      return o();
    const c = r + "end";
    let d = 0;
    const f = () => {
      e.removeEventListener(c, v), a();
    }, v = (p) => {
      p.target === e && ++d >= u && f();
    };
    setTimeout(() => {
      d < u && f();
    }, i + 1), e.addEventListener(c, v);
  }
  function Xw(e, t) {
    const n = window.getComputedStyle(e), o = (m) => (n[m] || "").split(", "), l = o(`${ia}Delay`), a = o(`${ia}Duration`), r = dg(l, a), i = o(`${Ps}Delay`), u = o(`${Ps}Duration`), c = dg(i, u);
    let d = null, f = 0, v = 0;
    t === ia ? r > 0 && (d = ia, f = r, v = a.length) : t === Ps ? c > 0 && (d = Ps, f = c, v = u.length) : (f = Math.max(r, c), d = f > 0 ? r > c ? ia : Ps : null, v = d ? d === ia ? a.length : u.length : 0);
    const p = d === ia && /\b(?:transform|all)(?:,|$)/.test(
      o(`${ia}Property`).toString()
    );
    return {
      type: d,
      timeout: f,
      propCount: v,
      hasTransform: p
    };
  }
  function dg(e, t) {
    for (; e.length < t.length; )
      e = e.concat(e);
    return Math.max(...t.map((n, o) => fg(n) + fg(e[o])));
  }
  function fg(e) {
    return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function cp(e) {
    return (e ? e.ownerDocument : document).body.offsetHeight;
  }
  function mN(e, t, n) {
    const o = e[es];
    o && (t = (t ? [t, ...o] : [...o]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t;
  }
  const xc = Symbol("_vod"), Jw = Symbol("_vsh"), Mt = {
    // used for prop mismatch check during hydration
    name: "show",
    beforeMount(e, { value: t }, { transition: n }) {
      e[xc] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : Rs(e, t);
    },
    mounted(e, { value: t }, { transition: n }) {
      n && t && n.enter(e);
    },
    updated(e, { value: t, oldValue: n }, { transition: o }) {
      !t != !n && (o ? t ? (o.beforeEnter(e), Rs(e, !0), o.enter(e)) : o.leave(e, () => {
        Rs(e, !1);
      }) : Rs(e, t));
    },
    beforeUnmount(e, { value: t }) {
      Rs(e, t);
    }
  };
  function Rs(e, t) {
    e.style.display = t ? e[xc] : "none", e[Jw] = !t;
  }
  const gN = Symbol(process.env.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : ""), bN = /(?:^|;)\s*display\s*:/;
  function yN(e, t, n) {
    const o = e.style, l = Ae(n);
    let a = !1;
    if (n && !l) {
      if (t)
        if (Ae(t))
          for (const r of t.split(";")) {
            const i = r.slice(0, r.indexOf(":")).trim();
            n[i] == null && Zu(o, i, "");
          }
        else
          for (const r in t)
            n[r] == null && Zu(o, r, "");
      for (const r in n)
        r === "display" && (a = !0), Zu(o, r, n[r]);
    } else if (l) {
      if (t !== n) {
        const r = o[gN];
        r && (n += ";" + r), o.cssText = n, a = bN.test(n);
      }
    } else t && e.removeAttribute("style");
    xc in e && (e[xc] = a ? o.display : "", e[Jw] && (o.display = "none"));
  }
  const wN = /[^\\];\s*$/, pg = /\s*!important$/;
  function Zu(e, t, n) {
    if (ye(n))
      n.forEach((o) => Zu(e, t, o));
    else if (n == null && (n = ""), process.env.NODE_ENV !== "production" && wN.test(n) && zo(
      `Unexpected semicolon at the end of '${t}' style value: '${n}'`
    ), t.startsWith("--"))
      e.setProperty(t, n);
    else {
      const o = CN(e, t);
      pg.test(n) ? e.setProperty(
        gl(o),
        n.replace(pg, ""),
        "important"
      ) : e[o] = n;
    }
  }
  const vg = ["Webkit", "Moz", "ms"], gf = {};
  function CN(e, t) {
    const n = gf[t];
    if (n)
      return n;
    let o = In(t);
    if (o !== "filter" && o in e)
      return gf[t] = o;
    o = Ta(o);
    for (let l = 0; l < vg.length; l++) {
      const a = vg[l] + o;
      if (a in e)
        return gf[t] = a;
    }
    return t;
  }
  const hg = "http://www.w3.org/1999/xlink";
  function mg(e, t, n, o, l, a = n2(t)) {
    o && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(hg, t.slice(6, t.length)) : e.setAttributeNS(hg, t, n) : n == null || a && !E0(n) ? e.removeAttribute(t) : e.setAttribute(
      t,
      a ? "" : Wo(n) ? String(n) : n
    );
  }
  function gg(e, t, n, o, l) {
    if (t === "innerHTML" || t === "textContent") {
      n != null && (e[t] = t === "innerHTML" ? Uw(n) : n);
      return;
    }
    const a = e.tagName;
    if (t === "value" && a !== "PROGRESS" && // custom elements may use _value internally
    !a.includes("-")) {
      const i = a === "OPTION" ? e.getAttribute("value") || "" : e.value, u = n == null ? (
        // #11647: value should be set as empty string for null and undefined,
        // but <input type="checkbox"> should be set as 'on'.
        e.type === "checkbox" ? "on" : ""
      ) : String(n);
      (i !== u || !("_value" in e)) && (e.value = u), n == null && e.removeAttribute(t), e._value = n;
      return;
    }
    let r = !1;
    if (n === "" || n == null) {
      const i = typeof e[t];
      i === "boolean" ? n = E0(n) : n == null && i === "string" ? (n = "", r = !0) : i === "number" && (n = 0, r = !0);
    }
    try {
      e[t] = n;
    } catch (i) {
      process.env.NODE_ENV !== "production" && !r && zo(
        `Failed setting prop "${t}" on <${a.toLowerCase()}>: value ${n} is invalid.`,
        i
      );
    }
    r && e.removeAttribute(l || t);
  }
  function ma(e, t, n, o) {
    e.addEventListener(t, n, o);
  }
  function SN(e, t, n, o) {
    e.removeEventListener(t, n, o);
  }
  const bg = Symbol("_vei");
  function EN(e, t, n, o, l = null) {
    const a = e[bg] || (e[bg] = {}), r = a[t];
    if (o && r)
      r.value = process.env.NODE_ENV !== "production" ? wg(o, t) : o;
    else {
      const [i, u] = kN(t);
      if (o) {
        const c = a[t] = NN(
          process.env.NODE_ENV !== "production" ? wg(o, t) : o,
          l
        );
        ma(e, i, c, u);
      } else r && (SN(e, i, r, u), a[t] = void 0);
    }
  }
  const yg = /(?:Once|Passive|Capture)$/;
  function kN(e) {
    let t;
    if (yg.test(e)) {
      t = {};
      let o;
      for (; o = e.match(yg); )
        e = e.slice(0, e.length - o[0].length), t[o[0].toLowerCase()] = !0;
    }
    return [e[2] === ":" ? e.slice(3) : gl(e.slice(2)), t];
  }
  let bf = 0;
  const _N = /* @__PURE__ */ Promise.resolve(), TN = () => bf || (_N.then(() => bf = 0), bf = Date.now());
  function NN(e, t) {
    const n = (o) => {
      if (!o._vts)
        o._vts = Date.now();
      else if (o._vts <= n.attached)
        return;
      Yo(
        $N(o, n.value),
        t,
        5,
        [o]
      );
    };
    return n.value = e, n.attached = TN(), n;
  }
  function wg(e, t) {
    return Fe(e) || ye(e) ? e : (zo(
      `Wrong type passed as event handler to ${t} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof e}.`
    ), It);
  }
  function $N(e, t) {
    if (ye(t)) {
      const n = e.stopImmediatePropagation;
      return e.stopImmediatePropagation = () => {
        n.call(e), e._stopped = !0;
      }, t.map(
        (o) => (l) => !l._stopped && o && o(l)
      );
    } else
      return t;
  }
  const Cg = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // lowercase letter
  e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, ON = (e, t, n, o, l, a) => {
    const r = l === "svg";
    t === "class" ? mN(e, o, r) : t === "style" ? yN(e, n, o) : zi(t) ? gc(t) || EN(e, t, n, o, a) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : IN(e, t, o, r)) ? (gg(e, t, o), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && mg(e, t, o, r, a, t !== "value")) : /* #11081 force set props for possible async custom element */ e._isVueCE && (/[A-Z]/.test(t) || !Ae(o)) ? gg(e, In(t), o, a, t) : (t === "true-value" ? e._trueValue = o : t === "false-value" && (e._falseValue = o), mg(e, t, o, r));
  };
  function IN(e, t, n, o) {
    if (o)
      return !!(t === "innerHTML" || t === "textContent" || t in e && Cg(t) && Fe(n));
    if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "sandbox" && e.tagName === "IFRAME" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
      return !1;
    if (t === "width" || t === "height") {
      const l = e.tagName;
      if (l === "IMG" || l === "VIDEO" || l === "CANVAS" || l === "SOURCE")
        return !1;
    }
    return Cg(t) && Ae(n) ? !1 : t in e;
  }
  const Zw = /* @__PURE__ */ new WeakMap(), Qw = /* @__PURE__ */ new WeakMap(), Pc = Symbol("_moveCb"), Sg = Symbol("_enterCb"), MN = (e) => (delete e.props.mode, e), xN = /* @__PURE__ */ MN({
    name: "TransitionGroup",
    props: /* @__PURE__ */ pn({}, qw, {
      tag: String,
      moveClass: String
    }),
    setup(e, { slots: t }) {
      const n = dt(), o = cw();
      let l, a;
      return Qo(() => {
        if (!l.length)
          return;
        const r = e.moveClass || `${e.name || "v"}-move`;
        if (!AN(
          l[0].el,
          n.vnode.el,
          r
        )) {
          l = [];
          return;
        }
        l.forEach(PN), l.forEach(RN);
        const i = l.filter(DN);
        cp(n.vnode.el), i.forEach((u) => {
          const c = u.el, d = c.style;
          rl(c, r), d.transform = d.webkitTransform = d.transitionDuration = "";
          const f = c[Pc] = (v) => {
            v && v.target !== c || (!v || v.propertyName.endsWith("transform")) && (c.removeEventListener("transitionend", f), c[Pc] = null, ca(c, r));
          };
          c.addEventListener("transitionend", f);
        }), l = [];
      }), () => {
        const r = Pt(e), i = Gw(r);
        let u = r.tag || We;
        if (l = [], a)
          for (let c = 0; c < a.length; c++) {
            const d = a[c];
            d.el && d.el instanceof Element && (l.push(d), cr(
              d,
              fi(
                d,
                i,
                o,
                n
              )
            ), Zw.set(d, {
              left: d.el.offsetLeft,
              top: d.el.offsetTop
            }));
          }
        a = t.default ? xv(t.default()) : [];
        for (let c = 0; c < a.length; c++) {
          const d = a[c];
          d.key != null ? cr(
            d,
            fi(d, i, o, n)
          ) : process.env.NODE_ENV !== "production" && d.type !== Pa && zo("<TransitionGroup> children must be keyed.");
        }
        return q(u, null, a);
      };
    }
  }), e1 = xN;
  function PN(e) {
    const t = e.el;
    t[Pc] && t[Pc](), t[Sg] && t[Sg]();
  }
  function RN(e) {
    Qw.set(e, {
      left: e.el.offsetLeft,
      top: e.el.offsetTop
    });
  }
  function DN(e) {
    const t = Zw.get(e), n = Qw.get(e), o = t.left - n.left, l = t.top - n.top;
    if (o || l) {
      const a = e.el.style;
      return a.transform = a.webkitTransform = `translate(${o}px,${l}px)`, a.transitionDuration = "0s", e;
    }
  }
  function AN(e, t, n) {
    const o = e.cloneNode(), l = e[es];
    l && l.forEach((i) => {
      i.split(/\s+/).forEach((u) => u && o.classList.remove(u));
    }), n.split(/\s+/).forEach((i) => i && o.classList.add(i)), o.style.display = "none";
    const a = t.nodeType === 1 ? t : t.parentNode;
    a.appendChild(o);
    const { hasTransform: r } = Xw(o);
    return a.removeChild(o), r;
  }
  const ts = (e) => {
    const t = e.props["onUpdate:modelValue"] || !1;
    return ye(t) ? (n) => Pr(t, n) : t;
  };
  function VN(e) {
    e.target.composing = !0;
  }
  function Eg(e) {
    const t = e.target;
    t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")));
  }
  const Hl = Symbol("_assign");
  function kg(e, t, n) {
    return t && (e = e.trim()), n && (e = Ev(e)), e;
  }
  const Sd = {
    created(e, { modifiers: { lazy: t, trim: n, number: o } }, l) {
      e[Hl] = ts(l);
      const a = o || l.props && l.props.type === "number";
      ma(e, t ? "change" : "input", (r) => {
        r.target.composing || e[Hl](kg(e.value, n, a));
      }), (n || a) && ma(e, "change", () => {
        e.value = kg(e.value, n, a);
      }), t || (ma(e, "compositionstart", VN), ma(e, "compositionend", Eg), ma(e, "change", Eg));
    },
    // set value on mounted so it's after min/max for type="range"
    mounted(e, { value: t }) {
      e.value = t ?? "";
    },
    beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: o, trim: l, number: a } }, r) {
      if (e[Hl] = ts(r), e.composing) return;
      const i = (a || e.type === "number") && !/^0\d/.test(e.value) ? Ev(e.value) : e.value, u = t ?? "";
      i !== u && (document.activeElement === e && e.type !== "range" && (o && t === n || l && e.value.trim() === u) || (e.value = u));
    }
  }, t1 = {
    // #4096 array checkboxes need to be deep traversed
    deep: !0,
    created(e, t, n) {
      e[Hl] = ts(n), ma(e, "change", () => {
        const o = e._modelValue, l = o1(e), a = e.checked, r = e[Hl];
        if (ye(o)) {
          const i = k0(o, l), u = i !== -1;
          if (a && !u)
            r(o.concat(l));
          else if (!a && u) {
            const c = [...o];
            c.splice(i, 1), r(c);
          }
        } else if (id(o)) {
          const i = new Set(o);
          a ? i.add(l) : i.delete(l), r(i);
        } else
          r(l1(e, a));
      });
    },
    // set initial checked on mount to wait for true-value/false-value
    mounted: _g,
    beforeUpdate(e, t, n) {
      e[Hl] = ts(n), _g(e, t, n);
    }
  };
  function _g(e, { value: t, oldValue: n }, o) {
    e._modelValue = t;
    let l;
    if (ye(t))
      l = k0(t, o.props.value) > -1;
    else if (id(t))
      l = t.has(o.props.value);
    else {
      if (t === n) return;
      l = Qr(t, l1(e, !0));
    }
    e.checked !== l && (e.checked = l);
  }
  const n1 = {
    created(e, { value: t }, n) {
      e.checked = Qr(t, n.props.value), e[Hl] = ts(n), ma(e, "change", () => {
        e[Hl](o1(e));
      });
    },
    beforeUpdate(e, { value: t, oldValue: n }, o) {
      e[Hl] = ts(o), t !== n && (e.checked = Qr(t, o.props.value));
    }
  };
  function o1(e) {
    return "_value" in e ? e._value : e.value;
  }
  function l1(e, t) {
    const n = t ? "_trueValue" : "_falseValue";
    return n in e ? e[n] : t;
  }
  const LN = ["ctrl", "shift", "alt", "meta"], BN = {
    stop: (e) => e.stopPropagation(),
    prevent: (e) => e.preventDefault(),
    self: (e) => e.target !== e.currentTarget,
    ctrl: (e) => !e.ctrlKey,
    shift: (e) => !e.shiftKey,
    alt: (e) => !e.altKey,
    meta: (e) => !e.metaKey,
    left: (e) => "button" in e && e.button !== 0,
    middle: (e) => "button" in e && e.button !== 1,
    right: (e) => "button" in e && e.button !== 2,
    exact: (e, t) => LN.some((n) => e[`${n}Key`] && !t.includes(n))
  }, Ze = (e, t) => {
    const n = e._withMods || (e._withMods = {}), o = t.join(".");
    return n[o] || (n[o] = (l, ...a) => {
      for (let r = 0; r < t.length; r++) {
        const i = BN[t[r]];
        if (i && i(l, t)) return;
      }
      return e(l, ...a);
    });
  }, FN = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  }, on = (e, t) => {
    const n = e._withKeys || (e._withKeys = {}), o = t.join(".");
    return n[o] || (n[o] = (l) => {
      if (!("key" in l))
        return;
      const a = gl(l.key);
      if (t.some(
        (r) => r === a || FN[r] === a
      ))
        return e(l);
    });
  }, zN = /* @__PURE__ */ pn({ patchProp: ON }, fN);
  let Tg;
  function a1() {
    return Tg || (Tg = AT(zN));
  }
  const Na = (...e) => {
    a1().render(...e);
  }, r1 = (...e) => {
    const t = a1().createApp(...e);
    process.env.NODE_ENV !== "production" && (KN(t), WN(t));
    const { mount: n } = t;
    return t.mount = (o) => {
      const l = jN(o);
      if (!l) return;
      const a = t._component;
      !Fe(a) && !a.render && !a.template && (a.template = l.innerHTML), l.nodeType === 1 && (l.textContent = "");
      const r = n(l, !1, HN(l));
      return l instanceof Element && (l.removeAttribute("v-cloak"), l.setAttribute("data-v-app", "")), r;
    }, t;
  };
  function HN(e) {
    if (e instanceof SVGElement)
      return "svg";
    if (typeof MathMLElement == "function" && e instanceof MathMLElement)
      return "mathml";
  }
  function KN(e) {
    Object.defineProperty(e.config, "isNativeTag", {
      value: (t) => Z_(t) || Q_(t) || e2(t),
      writable: !1
    });
  }
  function WN(e) {
    {
      const t = e.config.isCustomElement;
      Object.defineProperty(e.config, "isCustomElement", {
        get() {
          return t;
        },
        set() {
          zo(
            "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
          );
        }
      });
      const n = e.config.compilerOptions, o = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
      Object.defineProperty(e.config, "compilerOptions", {
        get() {
          return zo(o), n;
        },
        set() {
          zo(o);
        }
      });
    }
  }
  function jN(e) {
    if (Ae(e)) {
      const t = document.querySelector(e);
      return process.env.NODE_ENV !== "production" && !t && zo(
        `Failed to mount app: mount target selector "${e}" returned null.`
      ), t;
    }
    return process.env.NODE_ENV !== "production" && window.ShadowRoot && e instanceof window.ShadowRoot && e.mode === "closed" && zo(
      'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
    ), e;
  }
  /**
  * vue v3.5.24
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **/
  function UN() {
    uN();
  }
  process.env.NODE_ENV !== "production" && UN();
  const YN = { style: { "text-align": "center", "margin-bottom": "16px" } }, qN = { style: { "margin-top": "12px", color: "#fff" } }, GN = { style: { color: "#fff" } }, XN = { style: { color: "#fff" } }, JN = { style: { "margin-top": "16px" } }, ZN = { href: "https://element-plus.org" }, QN = {
    __name: "UserCard",
    props: {
      name: { type: String, default: "unknown" },
      age: { type: [String, Number], default: 0 },
      listData: { type: Array, default: () => [] }
    },
    setup(e) {
      const t = A(260);
      let n = null;
      return ft(() => {
        n = setInterval(() => {
          t.value += 10;
        }, 1e3);
      }), Bt(() => {
        n && clearInterval(n);
      }), (o, l) => {
        const a = $t("el-avatar"), r = $t("el-descriptions-item"), i = $t("el-descriptions"), u = $t("el-card");
        return _(), ae(u, {
          style: Ue({
            width: "260px",
            height: t.value + "px",
            borderRadius: "16px",
            boxShadow: "0 8px 20px rgba(0,0,0,0.15)",
            transition: "height 0.5s ease",
            background: "linear-gradient(135deg, #f6d365 0%, #fda085 100%)",
            overflow: "hidden"
          })
        }, {
          default: Q(() => [
            W("div", YN, [
              q(a, {
                size: 64,
                icon: "User"
              }),
              W("h3", qN, ke(e.name), 1)
            ]),
            q(i, {
              column: 1,
              size: "small",
              style: { background: "rgba(255,255,255,0.2)", "border-radius": "8px" }
            }, {
              default: Q(() => [
                q(r, { label: "Name" }, {
                  default: Q(() => [
                    W("span", GN, ke(e.name), 1)
                  ]),
                  _: 1
                }),
                q(r, { label: "Age" }, {
                  default: Q(() => [
                    W("span", XN, ke(e.age), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            W("div", JN, [
              (_(!0), B(We, null, bt(e.listData, (c) => (_(), B("div", {
                key: c.title,
                style: { display: "flex", "align-items": "center", padding: "8px 0" }
              }, [
                q(a, {
                  icon: "User",
                  style: { "margin-right": "8px" }
                }),
                W("div", null, [
                  W("a", ZN, ke(c.title), 1),
                  l[0] || (l[0] = W("div", { style: { "font-size": "12px", opacity: "0.7" } }, " Element Plus example description... ", -1))
                ])
              ]))), 128))
            ])
          ]),
          _: 1
        }, 8, ["style"]);
      };
    }
  }, e$ = "2.11.8", Ng = Symbol("INSTALLED_KEY"), s1 = Symbol(), Qs = "el", t$ = "is-", Fa = (e, t, n, o, l) => {
    let a = `${e}-${t}`;
    return n && (a += `-${n}`), o && (a += `__${o}`), l && (a += `--${l}`), a;
  }, i1 = Symbol("namespaceContextKey"), Hv = (e) => {
    const t = e || (dt() ? Ve(i1, A(Qs)) : A(Qs));
    return S(() => s(t) || Qs);
  }, he = (e, t) => {
    const n = Hv(t);
    return {
      namespace: n,
      b: (h = "") => Fa(n.value, e, h, "", ""),
      e: (h) => h ? Fa(n.value, e, "", h, "") : "",
      m: (h) => h ? Fa(n.value, e, "", "", h) : "",
      be: (h, g) => h && g ? Fa(n.value, e, h, g, "") : "",
      em: (h, g) => h && g ? Fa(n.value, e, "", h, g) : "",
      bm: (h, g) => h && g ? Fa(n.value, e, h, "", g) : "",
      bem: (h, g, b) => h && g && b ? Fa(n.value, e, h, g, b) : "",
      is: (h, ...g) => {
        const b = g.length >= 1 ? g[0] : !0;
        return h && b ? `${t$}${h}` : "";
      },
      cssVar: (h) => {
        const g = {};
        for (const b in h)
          h[b] && (g[`--${n.value}-${b}`] = h[b]);
        return g;
      },
      cssVarName: (h) => `--${n.value}-${h}`,
      cssVarBlock: (h) => {
        const g = {};
        for (const b in h)
          h[b] && (g[`--${n.value}-${e}-${b}`] = h[b]);
        return g;
      },
      cssVarBlockName: (h) => `--${n.value}-${e}-${h}`
    };
  };
  var u1 = typeof global == "object" && global && global.Object === Object && global, n$ = typeof self == "object" && self && self.Object === Object && self, el = u1 || n$ || Function("return this")(), $o = el.Symbol, c1 = Object.prototype, o$ = c1.hasOwnProperty, l$ = c1.toString, Ds = $o ? $o.toStringTag : void 0;
  function a$(e) {
    var t = o$.call(e, Ds), n = e[Ds];
    try {
      e[Ds] = void 0;
      var o = !0;
    } catch {
    }
    var l = l$.call(e);
    return o && (t ? e[Ds] = n : delete e[Ds]), l;
  }
  var r$ = Object.prototype, s$ = r$.toString;
  function i$(e) {
    return s$.call(e);
  }
  var u$ = "[object Null]", c$ = "[object Undefined]", $g = $o ? $o.toStringTag : void 0;
  function br(e) {
    return e == null ? e === void 0 ? c$ : u$ : $g && $g in Object(e) ? a$(e) : i$(e);
  }
  function yl(e) {
    return e != null && typeof e == "object";
  }
  var d$ = "[object Symbol]";
  function Ed(e) {
    return typeof e == "symbol" || yl(e) && br(e) == d$;
  }
  function Kv(e, t) {
    for (var n = -1, o = e == null ? 0 : e.length, l = Array(o); ++n < o; )
      l[n] = t(e[n], n, e);
    return l;
  }
  var no = Array.isArray, Og = $o ? $o.prototype : void 0, Ig = Og ? Og.toString : void 0;
  function d1(e) {
    if (typeof e == "string")
      return e;
    if (no(e))
      return Kv(e, d1) + "";
    if (Ed(e))
      return Ig ? Ig.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
  }
  var f$ = /\s/;
  function p$(e) {
    for (var t = e.length; t-- && f$.test(e.charAt(t)); )
      ;
    return t;
  }
  var v$ = /^\s+/;
  function h$(e) {
    return e && e.slice(0, p$(e) + 1).replace(v$, "");
  }
  function oo(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  var Mg = NaN, m$ = /^[-+]0x[0-9a-f]+$/i, g$ = /^0b[01]+$/i, b$ = /^0o[0-7]+$/i, y$ = parseInt;
  function ei(e) {
    if (typeof e == "number")
      return e;
    if (Ed(e))
      return Mg;
    if (oo(e)) {
      var t = typeof e.valueOf == "function" ? e.valueOf() : e;
      e = oo(t) ? t + "" : t;
    }
    if (typeof e != "string")
      return e === 0 ? e : +e;
    e = h$(e);
    var n = g$.test(e);
    return n || b$.test(e) ? y$(e.slice(2), n ? 2 : 8) : m$.test(e) ? Mg : +e;
  }
  function Wv(e) {
    return e;
  }
  var w$ = "[object AsyncFunction]", C$ = "[object Function]", S$ = "[object GeneratorFunction]", E$ = "[object Proxy]";
  function jv(e) {
    if (!oo(e))
      return !1;
    var t = br(e);
    return t == C$ || t == S$ || t == w$ || t == E$;
  }
  var yf = el["__core-js_shared__"], xg = function() {
    var e = /[^.]+$/.exec(yf && yf.keys && yf.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : "";
  }();
  function k$(e) {
    return !!xg && xg in e;
  }
  var _$ = Function.prototype, T$ = _$.toString;
  function yr(e) {
    if (e != null) {
      try {
        return T$.call(e);
      } catch {
      }
      try {
        return e + "";
      } catch {
      }
    }
    return "";
  }
  var N$ = /[\\^$.*+?()[\]{}|]/g, $$ = /^\[object .+?Constructor\]$/, O$ = Function.prototype, I$ = Object.prototype, M$ = O$.toString, x$ = I$.hasOwnProperty, P$ = RegExp(
    "^" + M$.call(x$).replace(N$, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function R$(e) {
    if (!oo(e) || k$(e))
      return !1;
    var t = jv(e) ? P$ : $$;
    return t.test(yr(e));
  }
  function D$(e, t) {
    return e == null ? void 0 : e[t];
  }
  function wr(e, t) {
    var n = D$(e, t);
    return R$(n) ? n : void 0;
  }
  var dp = wr(el, "WeakMap"), Pg = Object.create, A$ = /* @__PURE__ */ function() {
    function e() {
    }
    return function(t) {
      if (!oo(t))
        return {};
      if (Pg)
        return Pg(t);
      e.prototype = t;
      var n = new e();
      return e.prototype = void 0, n;
    };
  }();
  function V$(e, t, n) {
    switch (n.length) {
      case 0:
        return e.call(t);
      case 1:
        return e.call(t, n[0]);
      case 2:
        return e.call(t, n[0], n[1]);
      case 3:
        return e.call(t, n[0], n[1], n[2]);
    }
    return e.apply(t, n);
  }
  function L$() {
  }
  function f1(e, t) {
    var n = -1, o = e.length;
    for (t || (t = Array(o)); ++n < o; )
      t[n] = e[n];
    return t;
  }
  var B$ = 800, F$ = 16, z$ = Date.now;
  function H$(e) {
    var t = 0, n = 0;
    return function() {
      var o = z$(), l = F$ - (o - n);
      if (n = o, l > 0) {
        if (++t >= B$)
          return arguments[0];
      } else
        t = 0;
      return e.apply(void 0, arguments);
    };
  }
  function K$(e) {
    return function() {
      return e;
    };
  }
  var Rc = function() {
    try {
      var e = wr(Object, "defineProperty");
      return e({}, "", {}), e;
    } catch {
    }
  }(), W$ = Rc ? function(e, t) {
    return Rc(e, "toString", {
      configurable: !0,
      enumerable: !1,
      value: K$(t),
      writable: !0
    });
  } : Wv, p1 = H$(W$);
  function j$(e, t) {
    for (var n = -1, o = e == null ? 0 : e.length; ++n < o && t(e[n], n, e) !== !1; )
      ;
    return e;
  }
  function v1(e, t, n, o) {
    for (var l = e.length, a = n + (o ? 1 : -1); o ? a-- : ++a < l; )
      if (t(e[a], a, e))
        return a;
    return -1;
  }
  function U$(e) {
    return e !== e;
  }
  function Y$(e, t, n) {
    for (var o = n - 1, l = e.length; ++o < l; )
      if (e[o] === t)
        return o;
    return -1;
  }
  function q$(e, t, n) {
    return t === t ? Y$(e, t, n) : v1(e, U$, n);
  }
  function G$(e, t) {
    var n = e == null ? 0 : e.length;
    return !!n && q$(e, t, 0) > -1;
  }
  var X$ = 9007199254740991, J$ = /^(?:0|[1-9]\d*)$/;
  function kd(e, t) {
    var n = typeof e;
    return t = t ?? X$, !!t && (n == "number" || n != "symbol" && J$.test(e)) && e > -1 && e % 1 == 0 && e < t;
  }
  function Uv(e, t, n) {
    t == "__proto__" && Rc ? Rc(e, t, {
      configurable: !0,
      enumerable: !0,
      value: n,
      writable: !0
    }) : e[t] = n;
  }
  function qi(e, t) {
    return e === t || e !== e && t !== t;
  }
  var Z$ = Object.prototype, Q$ = Z$.hasOwnProperty;
  function Yv(e, t, n) {
    var o = e[t];
    (!(Q$.call(e, t) && qi(o, n)) || n === void 0 && !(t in e)) && Uv(e, t, n);
  }
  function ys(e, t, n, o) {
    var l = !n;
    n || (n = {});
    for (var a = -1, r = t.length; ++a < r; ) {
      var i = t[a], u = void 0;
      u === void 0 && (u = e[i]), l ? Uv(n, i, u) : Yv(n, i, u);
    }
    return n;
  }
  var Rg = Math.max;
  function h1(e, t, n) {
    return t = Rg(t === void 0 ? e.length - 1 : t, 0), function() {
      for (var o = arguments, l = -1, a = Rg(o.length - t, 0), r = Array(a); ++l < a; )
        r[l] = o[t + l];
      l = -1;
      for (var i = Array(t + 1); ++l < t; )
        i[l] = o[l];
      return i[t] = n(r), V$(e, this, i);
    };
  }
  function m1(e, t) {
    return p1(h1(e, t, Wv), e + "");
  }
  var eO = 9007199254740991;
  function qv(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= eO;
  }
  function ws(e) {
    return e != null && qv(e.length) && !jv(e);
  }
  function tO(e, t, n) {
    if (!oo(n))
      return !1;
    var o = typeof t;
    return (o == "number" ? ws(n) && kd(t, n.length) : o == "string" && t in n) ? qi(n[t], e) : !1;
  }
  function nO(e) {
    return m1(function(t, n) {
      var o = -1, l = n.length, a = l > 1 ? n[l - 1] : void 0, r = l > 2 ? n[2] : void 0;
      for (a = e.length > 3 && typeof a == "function" ? (l--, a) : void 0, r && tO(n[0], n[1], r) && (a = l < 3 ? void 0 : a, l = 1), t = Object(t); ++o < l; ) {
        var i = n[o];
        i && e(t, i, o, a);
      }
      return t;
    });
  }
  var oO = Object.prototype;
  function Gv(e) {
    var t = e && e.constructor, n = typeof t == "function" && t.prototype || oO;
    return e === n;
  }
  function lO(e, t) {
    for (var n = -1, o = Array(e); ++n < e; )
      o[n] = t(n);
    return o;
  }
  var aO = "[object Arguments]";
  function Dg(e) {
    return yl(e) && br(e) == aO;
  }
  var g1 = Object.prototype, rO = g1.hasOwnProperty, sO = g1.propertyIsEnumerable, hi = Dg(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Dg : function(e) {
    return yl(e) && rO.call(e, "callee") && !sO.call(e, "callee");
  };
  function iO() {
    return !1;
  }
  var b1 = typeof ho == "object" && ho && !ho.nodeType && ho, Ag = b1 && typeof mo == "object" && mo && !mo.nodeType && mo, uO = Ag && Ag.exports === b1, Vg = uO ? el.Buffer : void 0, cO = Vg ? Vg.isBuffer : void 0, mi = cO || iO, dO = "[object Arguments]", fO = "[object Array]", pO = "[object Boolean]", vO = "[object Date]", hO = "[object Error]", mO = "[object Function]", gO = "[object Map]", bO = "[object Number]", yO = "[object Object]", wO = "[object RegExp]", CO = "[object Set]", SO = "[object String]", EO = "[object WeakMap]", kO = "[object ArrayBuffer]", _O = "[object DataView]", TO = "[object Float32Array]", NO = "[object Float64Array]", $O = "[object Int8Array]", OO = "[object Int16Array]", IO = "[object Int32Array]", MO = "[object Uint8Array]", xO = "[object Uint8ClampedArray]", PO = "[object Uint16Array]", RO = "[object Uint32Array]", un = {};
  un[TO] = un[NO] = un[$O] = un[OO] = un[IO] = un[MO] = un[xO] = un[PO] = un[RO] = !0;
  un[dO] = un[fO] = un[kO] = un[pO] = un[_O] = un[vO] = un[hO] = un[mO] = un[gO] = un[bO] = un[yO] = un[wO] = un[CO] = un[SO] = un[EO] = !1;
  function DO(e) {
    return yl(e) && qv(e.length) && !!un[br(e)];
  }
  function Xv(e) {
    return function(t) {
      return e(t);
    };
  }
  var y1 = typeof ho == "object" && ho && !ho.nodeType && ho, ti = y1 && typeof mo == "object" && mo && !mo.nodeType && mo, AO = ti && ti.exports === y1, wf = AO && u1.process, ns = function() {
    try {
      var e = ti && ti.require && ti.require("util").types;
      return e || wf && wf.binding && wf.binding("util");
    } catch {
    }
  }(), Lg = ns && ns.isTypedArray, Jv = Lg ? Xv(Lg) : DO, VO = Object.prototype, LO = VO.hasOwnProperty;
  function w1(e, t) {
    var n = no(e), o = !n && hi(e), l = !n && !o && mi(e), a = !n && !o && !l && Jv(e), r = n || o || l || a, i = r ? lO(e.length, String) : [], u = i.length;
    for (var c in e)
      (t || LO.call(e, c)) && !(r && // Safari 9 has enumerable `arguments.length` in strict mode.
      (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      l && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      a && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
      kd(c, u))) && i.push(c);
    return i;
  }
  function C1(e, t) {
    return function(n) {
      return e(t(n));
    };
  }
  var BO = C1(Object.keys, Object), FO = Object.prototype, zO = FO.hasOwnProperty;
  function HO(e) {
    if (!Gv(e))
      return BO(e);
    var t = [];
    for (var n in Object(e))
      zO.call(e, n) && n != "constructor" && t.push(n);
    return t;
  }
  function Gi(e) {
    return ws(e) ? w1(e) : HO(e);
  }
  function KO(e) {
    var t = [];
    if (e != null)
      for (var n in Object(e))
        t.push(n);
    return t;
  }
  var WO = Object.prototype, jO = WO.hasOwnProperty;
  function UO(e) {
    if (!oo(e))
      return KO(e);
    var t = Gv(e), n = [];
    for (var o in e)
      o == "constructor" && (t || !jO.call(e, o)) || n.push(o);
    return n;
  }
  function Xi(e) {
    return ws(e) ? w1(e, !0) : UO(e);
  }
  var YO = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, qO = /^\w*$/;
  function Zv(e, t) {
    if (no(e))
      return !1;
    var n = typeof e;
    return n == "number" || n == "symbol" || n == "boolean" || e == null || Ed(e) ? !0 : qO.test(e) || !YO.test(e) || t != null && e in Object(t);
  }
  var gi = wr(Object, "create");
  function GO() {
    this.__data__ = gi ? gi(null) : {}, this.size = 0;
  }
  function XO(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t;
  }
  var JO = "__lodash_hash_undefined__", ZO = Object.prototype, QO = ZO.hasOwnProperty;
  function eI(e) {
    var t = this.__data__;
    if (gi) {
      var n = t[e];
      return n === JO ? void 0 : n;
    }
    return QO.call(t, e) ? t[e] : void 0;
  }
  var tI = Object.prototype, nI = tI.hasOwnProperty;
  function oI(e) {
    var t = this.__data__;
    return gi ? t[e] !== void 0 : nI.call(t, e);
  }
  var lI = "__lodash_hash_undefined__";
  function aI(e, t) {
    var n = this.__data__;
    return this.size += this.has(e) ? 0 : 1, n[e] = gi && t === void 0 ? lI : t, this;
  }
  function dr(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var o = e[t];
      this.set(o[0], o[1]);
    }
  }
  dr.prototype.clear = GO;
  dr.prototype.delete = XO;
  dr.prototype.get = eI;
  dr.prototype.has = oI;
  dr.prototype.set = aI;
  function rI() {
    this.__data__ = [], this.size = 0;
  }
  function _d(e, t) {
    for (var n = e.length; n--; )
      if (qi(e[n][0], t))
        return n;
    return -1;
  }
  var sI = Array.prototype, iI = sI.splice;
  function uI(e) {
    var t = this.__data__, n = _d(t, e);
    if (n < 0)
      return !1;
    var o = t.length - 1;
    return n == o ? t.pop() : iI.call(t, n, 1), --this.size, !0;
  }
  function cI(e) {
    var t = this.__data__, n = _d(t, e);
    return n < 0 ? void 0 : t[n][1];
  }
  function dI(e) {
    return _d(this.__data__, e) > -1;
  }
  function fI(e, t) {
    var n = this.__data__, o = _d(n, e);
    return o < 0 ? (++this.size, n.push([e, t])) : n[o][1] = t, this;
  }
  function ta(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var o = e[t];
      this.set(o[0], o[1]);
    }
  }
  ta.prototype.clear = rI;
  ta.prototype.delete = uI;
  ta.prototype.get = cI;
  ta.prototype.has = dI;
  ta.prototype.set = fI;
  var bi = wr(el, "Map");
  function pI() {
    this.size = 0, this.__data__ = {
      hash: new dr(),
      map: new (bi || ta)(),
      string: new dr()
    };
  }
  function vI(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
  }
  function Td(e, t) {
    var n = e.__data__;
    return vI(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
  }
  function hI(e) {
    var t = Td(this, e).delete(e);
    return this.size -= t ? 1 : 0, t;
  }
  function mI(e) {
    return Td(this, e).get(e);
  }
  function gI(e) {
    return Td(this, e).has(e);
  }
  function bI(e, t) {
    var n = Td(this, e), o = n.size;
    return n.set(e, t), this.size += n.size == o ? 0 : 1, this;
  }
  function na(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var o = e[t];
      this.set(o[0], o[1]);
    }
  }
  na.prototype.clear = pI;
  na.prototype.delete = hI;
  na.prototype.get = mI;
  na.prototype.has = gI;
  na.prototype.set = bI;
  var yI = "Expected a function";
  function Nd(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
      throw new TypeError(yI);
    var n = function() {
      var o = arguments, l = t ? t.apply(this, o) : o[0], a = n.cache;
      if (a.has(l))
        return a.get(l);
      var r = e.apply(this, o);
      return n.cache = a.set(l, r) || a, r;
    };
    return n.cache = new (Nd.Cache || na)(), n;
  }
  Nd.Cache = na;
  var wI = 500;
  function CI(e) {
    var t = Nd(e, function(o) {
      return n.size === wI && n.clear(), o;
    }), n = t.cache;
    return t;
  }
  var SI = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, EI = /\\(\\)?/g, kI = CI(function(e) {
    var t = [];
    return e.charCodeAt(0) === 46 && t.push(""), e.replace(SI, function(n, o, l, a) {
      t.push(l ? a.replace(EI, "$1") : o || n);
    }), t;
  });
  function _I(e) {
    return e == null ? "" : d1(e);
  }
  function Cs(e, t) {
    return no(e) ? e : Zv(e, t) ? [e] : kI(_I(e));
  }
  function Ss(e) {
    if (typeof e == "string" || Ed(e))
      return e;
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
  }
  function $d(e, t) {
    t = Cs(t, e);
    for (var n = 0, o = t.length; e != null && n < o; )
      e = e[Ss(t[n++])];
    return n && n == o ? e : void 0;
  }
  function dn(e, t, n) {
    var o = e == null ? void 0 : $d(e, t);
    return o === void 0 ? n : o;
  }
  function Qv(e, t) {
    for (var n = -1, o = t.length, l = e.length; ++n < o; )
      e[l + n] = t[n];
    return e;
  }
  var Bg = $o ? $o.isConcatSpreadable : void 0;
  function TI(e) {
    return no(e) || hi(e) || !!(Bg && e && e[Bg]);
  }
  function Ji(e, t, n, o, l) {
    var a = -1, r = e.length;
    for (n || (n = TI), l || (l = []); ++a < r; ) {
      var i = e[a];
      t > 0 && n(i) ? t > 1 ? Ji(i, t - 1, n, o, l) : Qv(l, i) : o || (l[l.length] = i);
    }
    return l;
  }
  function S1(e) {
    var t = e == null ? 0 : e.length;
    return t ? Ji(e, 1) : [];
  }
  function E1(e) {
    return p1(h1(e, void 0, S1), e + "");
  }
  var eh = C1(Object.getPrototypeOf, Object), NI = "[object Object]", $I = Function.prototype, OI = Object.prototype, k1 = $I.toString, II = OI.hasOwnProperty, MI = k1.call(Object);
  function _1(e) {
    if (!yl(e) || br(e) != NI)
      return !1;
    var t = eh(e);
    if (t === null)
      return !0;
    var n = II.call(t, "constructor") && t.constructor;
    return typeof n == "function" && n instanceof n && k1.call(n) == MI;
  }
  function xI(e, t, n) {
    var o = -1, l = e.length;
    t < 0 && (t = -t > l ? 0 : l + t), n = n > l ? l : n, n < 0 && (n += l), l = t > n ? 0 : n - t >>> 0, t >>>= 0;
    for (var a = Array(l); ++o < l; )
      a[o] = e[o + t];
    return a;
  }
  function En() {
    if (!arguments.length)
      return [];
    var e = arguments[0];
    return no(e) ? e : [e];
  }
  function PI(e, t, n) {
    return e === e && (n !== void 0 && (e = e <= n ? e : n), t !== void 0 && (e = e >= t ? e : t)), e;
  }
  function Od(e, t, n) {
    return n === void 0 && (n = t, t = void 0), n !== void 0 && (n = ei(n), n = n === n ? n : 0), t !== void 0 && (t = ei(t), t = t === t ? t : 0), PI(ei(e), t, n);
  }
  function RI() {
    this.__data__ = new ta(), this.size = 0;
  }
  function DI(e) {
    var t = this.__data__, n = t.delete(e);
    return this.size = t.size, n;
  }
  function AI(e) {
    return this.__data__.get(e);
  }
  function VI(e) {
    return this.__data__.has(e);
  }
  var LI = 200;
  function BI(e, t) {
    var n = this.__data__;
    if (n instanceof ta) {
      var o = n.__data__;
      if (!bi || o.length < LI - 1)
        return o.push([e, t]), this.size = ++n.size, this;
      n = this.__data__ = new na(o);
    }
    return n.set(e, t), this.size = n.size, this;
  }
  function Ho(e) {
    var t = this.__data__ = new ta(e);
    this.size = t.size;
  }
  Ho.prototype.clear = RI;
  Ho.prototype.delete = DI;
  Ho.prototype.get = AI;
  Ho.prototype.has = VI;
  Ho.prototype.set = BI;
  function FI(e, t) {
    return e && ys(t, Gi(t), e);
  }
  function zI(e, t) {
    return e && ys(t, Xi(t), e);
  }
  var T1 = typeof ho == "object" && ho && !ho.nodeType && ho, Fg = T1 && typeof mo == "object" && mo && !mo.nodeType && mo, HI = Fg && Fg.exports === T1, zg = HI ? el.Buffer : void 0, Hg = zg ? zg.allocUnsafe : void 0;
  function N1(e, t) {
    if (t)
      return e.slice();
    var n = e.length, o = Hg ? Hg(n) : new e.constructor(n);
    return e.copy(o), o;
  }
  function KI(e, t) {
    for (var n = -1, o = e == null ? 0 : e.length, l = 0, a = []; ++n < o; ) {
      var r = e[n];
      t(r, n, e) && (a[l++] = r);
    }
    return a;
  }
  function $1() {
    return [];
  }
  var WI = Object.prototype, jI = WI.propertyIsEnumerable, Kg = Object.getOwnPropertySymbols, th = Kg ? function(e) {
    return e == null ? [] : (e = Object(e), KI(Kg(e), function(t) {
      return jI.call(e, t);
    }));
  } : $1;
  function UI(e, t) {
    return ys(e, th(e), t);
  }
  var YI = Object.getOwnPropertySymbols, O1 = YI ? function(e) {
    for (var t = []; e; )
      Qv(t, th(e)), e = eh(e);
    return t;
  } : $1;
  function qI(e, t) {
    return ys(e, O1(e), t);
  }
  function I1(e, t, n) {
    var o = t(e);
    return no(e) ? o : Qv(o, n(e));
  }
  function fp(e) {
    return I1(e, Gi, th);
  }
  function M1(e) {
    return I1(e, Xi, O1);
  }
  var pp = wr(el, "DataView"), vp = wr(el, "Promise"), jr = wr(el, "Set"), Wg = "[object Map]", GI = "[object Object]", jg = "[object Promise]", Ug = "[object Set]", Yg = "[object WeakMap]", qg = "[object DataView]", XI = yr(pp), JI = yr(bi), ZI = yr(vp), QI = yr(jr), eM = yr(dp), Do = br;
  (pp && Do(new pp(new ArrayBuffer(1))) != qg || bi && Do(new bi()) != Wg || vp && Do(vp.resolve()) != jg || jr && Do(new jr()) != Ug || dp && Do(new dp()) != Yg) && (Do = function(e) {
    var t = br(e), n = t == GI ? e.constructor : void 0, o = n ? yr(n) : "";
    if (o)
      switch (o) {
        case XI:
          return qg;
        case JI:
          return Wg;
        case ZI:
          return jg;
        case QI:
          return Ug;
        case eM:
          return Yg;
      }
    return t;
  });
  var tM = Object.prototype, nM = tM.hasOwnProperty;
  function oM(e) {
    var t = e.length, n = new e.constructor(t);
    return t && typeof e[0] == "string" && nM.call(e, "index") && (n.index = e.index, n.input = e.input), n;
  }
  var Dc = el.Uint8Array;
  function nh(e) {
    var t = new e.constructor(e.byteLength);
    return new Dc(t).set(new Dc(e)), t;
  }
  function lM(e, t) {
    var n = t ? nh(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.byteLength);
  }
  var aM = /\w*$/;
  function rM(e) {
    var t = new e.constructor(e.source, aM.exec(e));
    return t.lastIndex = e.lastIndex, t;
  }
  var Gg = $o ? $o.prototype : void 0, Xg = Gg ? Gg.valueOf : void 0;
  function sM(e) {
    return Xg ? Object(Xg.call(e)) : {};
  }
  function x1(e, t) {
    var n = t ? nh(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.length);
  }
  var iM = "[object Boolean]", uM = "[object Date]", cM = "[object Map]", dM = "[object Number]", fM = "[object RegExp]", pM = "[object Set]", vM = "[object String]", hM = "[object Symbol]", mM = "[object ArrayBuffer]", gM = "[object DataView]", bM = "[object Float32Array]", yM = "[object Float64Array]", wM = "[object Int8Array]", CM = "[object Int16Array]", SM = "[object Int32Array]", EM = "[object Uint8Array]", kM = "[object Uint8ClampedArray]", _M = "[object Uint16Array]", TM = "[object Uint32Array]";
  function NM(e, t, n) {
    var o = e.constructor;
    switch (t) {
      case mM:
        return nh(e);
      case iM:
      case uM:
        return new o(+e);
      case gM:
        return lM(e, n);
      case bM:
      case yM:
      case wM:
      case CM:
      case SM:
      case EM:
      case kM:
      case _M:
      case TM:
        return x1(e, n);
      case cM:
        return new o();
      case dM:
      case vM:
        return new o(e);
      case fM:
        return rM(e);
      case pM:
        return new o();
      case hM:
        return sM(e);
    }
  }
  function P1(e) {
    return typeof e.constructor == "function" && !Gv(e) ? A$(eh(e)) : {};
  }
  var $M = "[object Map]";
  function OM(e) {
    return yl(e) && Do(e) == $M;
  }
  var Jg = ns && ns.isMap, IM = Jg ? Xv(Jg) : OM, MM = "[object Set]";
  function xM(e) {
    return yl(e) && Do(e) == MM;
  }
  var Zg = ns && ns.isSet, PM = Zg ? Xv(Zg) : xM, RM = 1, DM = 2, AM = 4, R1 = "[object Arguments]", VM = "[object Array]", LM = "[object Boolean]", BM = "[object Date]", FM = "[object Error]", D1 = "[object Function]", zM = "[object GeneratorFunction]", HM = "[object Map]", KM = "[object Number]", A1 = "[object Object]", WM = "[object RegExp]", jM = "[object Set]", UM = "[object String]", YM = "[object Symbol]", qM = "[object WeakMap]", GM = "[object ArrayBuffer]", XM = "[object DataView]", JM = "[object Float32Array]", ZM = "[object Float64Array]", QM = "[object Int8Array]", ex = "[object Int16Array]", tx = "[object Int32Array]", nx = "[object Uint8Array]", ox = "[object Uint8ClampedArray]", lx = "[object Uint16Array]", ax = "[object Uint32Array]", rn = {};
  rn[R1] = rn[VM] = rn[GM] = rn[XM] = rn[LM] = rn[BM] = rn[JM] = rn[ZM] = rn[QM] = rn[ex] = rn[tx] = rn[HM] = rn[KM] = rn[A1] = rn[WM] = rn[jM] = rn[UM] = rn[YM] = rn[nx] = rn[ox] = rn[lx] = rn[ax] = !0;
  rn[FM] = rn[D1] = rn[qM] = !1;
  function Ur(e, t, n, o, l, a) {
    var r, i = t & RM, u = t & DM, c = t & AM;
    if (n && (r = l ? n(e, o, l, a) : n(e)), r !== void 0)
      return r;
    if (!oo(e))
      return e;
    var d = no(e);
    if (d) {
      if (r = oM(e), !i)
        return f1(e, r);
    } else {
      var f = Do(e), v = f == D1 || f == zM;
      if (mi(e))
        return N1(e, i);
      if (f == A1 || f == R1 || v && !l) {
        if (r = u || v ? {} : P1(e), !i)
          return u ? qI(e, zI(r, e)) : UI(e, FI(r, e));
      } else {
        if (!rn[f])
          return l ? e : {};
        r = NM(e, f, i);
      }
    }
    a || (a = new Ho());
    var p = a.get(e);
    if (p)
      return p;
    a.set(e, r), PM(e) ? e.forEach(function(g) {
      r.add(Ur(g, t, n, g, e, a));
    }) : IM(e) && e.forEach(function(g, b) {
      r.set(b, Ur(g, t, n, b, e, a));
    });
    var m = c ? u ? M1 : fp : u ? Xi : Gi, h = d ? void 0 : m(e);
    return j$(h || e, function(g, b) {
      h && (b = g, g = e[b]), Yv(r, b, Ur(g, t, n, b, e, a));
    }), r;
  }
  var rx = 4;
  function Qg(e) {
    return Ur(e, rx);
  }
  var sx = 1, ix = 4;
  function Ac(e) {
    return Ur(e, sx | ix);
  }
  var ux = "__lodash_hash_undefined__";
  function cx(e) {
    return this.__data__.set(e, ux), this;
  }
  function dx(e) {
    return this.__data__.has(e);
  }
  function yi(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.__data__ = new na(); ++t < n; )
      this.add(e[t]);
  }
  yi.prototype.add = yi.prototype.push = cx;
  yi.prototype.has = dx;
  function fx(e, t) {
    for (var n = -1, o = e == null ? 0 : e.length; ++n < o; )
      if (t(e[n], n, e))
        return !0;
    return !1;
  }
  function V1(e, t) {
    return e.has(t);
  }
  var px = 1, vx = 2;
  function L1(e, t, n, o, l, a) {
    var r = n & px, i = e.length, u = t.length;
    if (i != u && !(r && u > i))
      return !1;
    var c = a.get(e), d = a.get(t);
    if (c && d)
      return c == t && d == e;
    var f = -1, v = !0, p = n & vx ? new yi() : void 0;
    for (a.set(e, t), a.set(t, e); ++f < i; ) {
      var m = e[f], h = t[f];
      if (o)
        var g = r ? o(h, m, f, t, e, a) : o(m, h, f, e, t, a);
      if (g !== void 0) {
        if (g)
          continue;
        v = !1;
        break;
      }
      if (p) {
        if (!fx(t, function(b, C) {
          if (!V1(p, C) && (m === b || l(m, b, n, o, a)))
            return p.push(C);
        })) {
          v = !1;
          break;
        }
      } else if (!(m === h || l(m, h, n, o, a))) {
        v = !1;
        break;
      }
    }
    return a.delete(e), a.delete(t), v;
  }
  function hx(e) {
    var t = -1, n = Array(e.size);
    return e.forEach(function(o, l) {
      n[++t] = [l, o];
    }), n;
  }
  function oh(e) {
    var t = -1, n = Array(e.size);
    return e.forEach(function(o) {
      n[++t] = o;
    }), n;
  }
  var mx = 1, gx = 2, bx = "[object Boolean]", yx = "[object Date]", wx = "[object Error]", Cx = "[object Map]", Sx = "[object Number]", Ex = "[object RegExp]", kx = "[object Set]", _x = "[object String]", Tx = "[object Symbol]", Nx = "[object ArrayBuffer]", $x = "[object DataView]", eb = $o ? $o.prototype : void 0, Cf = eb ? eb.valueOf : void 0;
  function Ox(e, t, n, o, l, a, r) {
    switch (n) {
      case $x:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
          return !1;
        e = e.buffer, t = t.buffer;
      case Nx:
        return !(e.byteLength != t.byteLength || !a(new Dc(e), new Dc(t)));
      case bx:
      case yx:
      case Sx:
        return qi(+e, +t);
      case wx:
        return e.name == t.name && e.message == t.message;
      case Ex:
      case _x:
        return e == t + "";
      case Cx:
        var i = hx;
      case kx:
        var u = o & mx;
        if (i || (i = oh), e.size != t.size && !u)
          return !1;
        var c = r.get(e);
        if (c)
          return c == t;
        o |= gx, r.set(e, t);
        var d = L1(i(e), i(t), o, l, a, r);
        return r.delete(e), d;
      case Tx:
        if (Cf)
          return Cf.call(e) == Cf.call(t);
    }
    return !1;
  }
  var Ix = 1, Mx = Object.prototype, xx = Mx.hasOwnProperty;
  function Px(e, t, n, o, l, a) {
    var r = n & Ix, i = fp(e), u = i.length, c = fp(t), d = c.length;
    if (u != d && !r)
      return !1;
    for (var f = u; f--; ) {
      var v = i[f];
      if (!(r ? v in t : xx.call(t, v)))
        return !1;
    }
    var p = a.get(e), m = a.get(t);
    if (p && m)
      return p == t && m == e;
    var h = !0;
    a.set(e, t), a.set(t, e);
    for (var g = r; ++f < u; ) {
      v = i[f];
      var b = e[v], C = t[v];
      if (o)
        var w = r ? o(C, b, v, t, e, a) : o(b, C, v, e, t, a);
      if (!(w === void 0 ? b === C || l(b, C, n, o, a) : w)) {
        h = !1;
        break;
      }
      g || (g = v == "constructor");
    }
    if (h && !g) {
      var y = e.constructor, E = t.constructor;
      y != E && "constructor" in e && "constructor" in t && !(typeof y == "function" && y instanceof y && typeof E == "function" && E instanceof E) && (h = !1);
    }
    return a.delete(e), a.delete(t), h;
  }
  var Rx = 1, tb = "[object Arguments]", nb = "[object Array]", Nu = "[object Object]", Dx = Object.prototype, ob = Dx.hasOwnProperty;
  function Ax(e, t, n, o, l, a) {
    var r = no(e), i = no(t), u = r ? nb : Do(e), c = i ? nb : Do(t);
    u = u == tb ? Nu : u, c = c == tb ? Nu : c;
    var d = u == Nu, f = c == Nu, v = u == c;
    if (v && mi(e)) {
      if (!mi(t))
        return !1;
      r = !0, d = !1;
    }
    if (v && !d)
      return a || (a = new Ho()), r || Jv(e) ? L1(e, t, n, o, l, a) : Ox(e, t, u, n, o, l, a);
    if (!(n & Rx)) {
      var p = d && ob.call(e, "__wrapped__"), m = f && ob.call(t, "__wrapped__");
      if (p || m) {
        var h = p ? e.value() : e, g = m ? t.value() : t;
        return a || (a = new Ho()), l(h, g, n, o, a);
      }
    }
    return v ? (a || (a = new Ho()), Px(e, t, n, o, l, a)) : !1;
  }
  function Id(e, t, n, o, l) {
    return e === t ? !0 : e == null || t == null || !yl(e) && !yl(t) ? e !== e && t !== t : Ax(e, t, n, o, Id, l);
  }
  var Vx = 1, Lx = 2;
  function Bx(e, t, n, o) {
    var l = n.length, a = l;
    if (e == null)
      return !a;
    for (e = Object(e); l--; ) {
      var r = n[l];
      if (r[2] ? r[1] !== e[r[0]] : !(r[0] in e))
        return !1;
    }
    for (; ++l < a; ) {
      r = n[l];
      var i = r[0], u = e[i], c = r[1];
      if (r[2]) {
        if (u === void 0 && !(i in e))
          return !1;
      } else {
        var d = new Ho(), f;
        if (!(f === void 0 ? Id(c, u, Vx | Lx, o, d) : f))
          return !1;
      }
    }
    return !0;
  }
  function B1(e) {
    return e === e && !oo(e);
  }
  function Fx(e) {
    for (var t = Gi(e), n = t.length; n--; ) {
      var o = t[n], l = e[o];
      t[n] = [o, l, B1(l)];
    }
    return t;
  }
  function F1(e, t) {
    return function(n) {
      return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
    };
  }
  function zx(e) {
    var t = Fx(e);
    return t.length == 1 && t[0][2] ? F1(t[0][0], t[0][1]) : function(n) {
      return n === e || Bx(n, e, t);
    };
  }
  function Hx(e, t) {
    return e != null && t in Object(e);
  }
  function Kx(e, t, n) {
    t = Cs(t, e);
    for (var o = -1, l = t.length, a = !1; ++o < l; ) {
      var r = Ss(t[o]);
      if (!(a = e != null && n(e, r)))
        break;
      e = e[r];
    }
    return a || ++o != l ? a : (l = e == null ? 0 : e.length, !!l && qv(l) && kd(r, l) && (no(e) || hi(e)));
  }
  function z1(e, t) {
    return e != null && Kx(e, t, Hx);
  }
  var Wx = 1, jx = 2;
  function Ux(e, t) {
    return Zv(e) && B1(t) ? F1(Ss(e), t) : function(n) {
      var o = dn(n, e);
      return o === void 0 && o === t ? z1(n, e) : Id(t, o, Wx | jx);
    };
  }
  function Yx(e) {
    return function(t) {
      return t == null ? void 0 : t[e];
    };
  }
  function qx(e) {
    return function(t) {
      return $d(t, e);
    };
  }
  function Gx(e) {
    return Zv(e) ? Yx(Ss(e)) : qx(e);
  }
  function H1(e) {
    return typeof e == "function" ? e : e == null ? Wv : typeof e == "object" ? no(e) ? Ux(e[0], e[1]) : zx(e) : Gx(e);
  }
  function Xx(e) {
    return function(t, n, o) {
      for (var l = -1, a = Object(t), r = o(t), i = r.length; i--; ) {
        var u = r[++l];
        if (n(a[u], u, a) === !1)
          break;
      }
      return t;
    };
  }
  var K1 = Xx();
  function Jx(e, t) {
    return e && K1(e, t, Gi);
  }
  function Zx(e, t) {
    return function(n, o) {
      if (n == null)
        return n;
      if (!ws(n))
        return e(n, o);
      for (var l = n.length, a = -1, r = Object(n); ++a < l && o(r[a], a, r) !== !1; )
        ;
      return n;
    };
  }
  var Qx = Zx(Jx), Sf = function() {
    return el.Date.now();
  }, eP = "Expected a function", tP = Math.max, nP = Math.min;
  function wl(e, t, n) {
    var o, l, a, r, i, u, c = 0, d = !1, f = !1, v = !0;
    if (typeof e != "function")
      throw new TypeError(eP);
    t = ei(t) || 0, oo(n) && (d = !!n.leading, f = "maxWait" in n, a = f ? tP(ei(n.maxWait) || 0, t) : a, v = "trailing" in n ? !!n.trailing : v);
    function p(k) {
      var T = o, x = l;
      return o = l = void 0, c = k, r = e.apply(x, T), r;
    }
    function m(k) {
      return c = k, i = setTimeout(b, t), d ? p(k) : r;
    }
    function h(k) {
      var T = k - u, x = k - c, I = t - T;
      return f ? nP(I, a - x) : I;
    }
    function g(k) {
      var T = k - u, x = k - c;
      return u === void 0 || T >= t || T < 0 || f && x >= a;
    }
    function b() {
      var k = Sf();
      if (g(k))
        return C(k);
      i = setTimeout(b, h(k));
    }
    function C(k) {
      return i = void 0, v && o ? p(k) : (o = l = void 0, r);
    }
    function w() {
      i !== void 0 && clearTimeout(i), c = 0, o = u = l = i = void 0;
    }
    function y() {
      return i === void 0 ? r : C(Sf());
    }
    function E() {
      var k = Sf(), T = g(k);
      if (o = arguments, l = this, u = k, T) {
        if (i === void 0)
          return m(u);
        if (f)
          return clearTimeout(i), i = setTimeout(b, t), p(u);
      }
      return i === void 0 && (i = setTimeout(b, t)), r;
    }
    return E.cancel = w, E.flush = y, E;
  }
  function hp(e, t, n) {
    (n !== void 0 && !qi(e[t], n) || n === void 0 && !(t in e)) && Uv(e, t, n);
  }
  function W1(e) {
    return yl(e) && ws(e);
  }
  function mp(e, t) {
    if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
      return e[t];
  }
  function oP(e) {
    return ys(e, Xi(e));
  }
  function lP(e, t, n, o, l, a, r) {
    var i = mp(e, n), u = mp(t, n), c = r.get(u);
    if (c) {
      hp(e, n, c);
      return;
    }
    var d = a ? a(i, u, n + "", e, t, r) : void 0, f = d === void 0;
    if (f) {
      var v = no(u), p = !v && mi(u), m = !v && !p && Jv(u);
      d = u, v || p || m ? no(i) ? d = i : W1(i) ? d = f1(i) : p ? (f = !1, d = N1(u, !0)) : m ? (f = !1, d = x1(u, !0)) : d = [] : _1(u) || hi(u) ? (d = i, hi(i) ? d = oP(i) : (!oo(i) || jv(i)) && (d = P1(u))) : f = !1;
    }
    f && (r.set(u, d), l(d, u, o, a, r), r.delete(u)), hp(e, n, d);
  }
  function j1(e, t, n, o, l) {
    e !== t && K1(t, function(a, r) {
      if (l || (l = new Ho()), oo(a))
        lP(e, t, r, n, j1, o, l);
      else {
        var i = o ? o(mp(e, r), a, r + "", e, t, l) : void 0;
        i === void 0 && (i = a), hp(e, r, i);
      }
    }, Xi);
  }
  function aP(e) {
    var t = e == null ? 0 : e.length;
    return t ? e[t - 1] : void 0;
  }
  function U1(e, t, n) {
    var o = e == null ? 0 : e.length;
    if (!o)
      return -1;
    var l = o - 1;
    return v1(e, H1(t), l, !0);
  }
  function rP(e, t) {
    var n = -1, o = ws(e) ? Array(e.length) : [];
    return Qx(e, function(l, a, r) {
      o[++n] = t(l, a, r);
    }), o;
  }
  function sP(e, t) {
    var n = no(e) ? Kv : rP;
    return n(e, H1(t));
  }
  function Y1(e, t) {
    return Ji(sP(e, t), 1);
  }
  var iP = 1 / 0;
  function uP(e) {
    var t = e == null ? 0 : e.length;
    return t ? Ji(e, iP) : [];
  }
  function wi(e) {
    for (var t = -1, n = e == null ? 0 : e.length, o = {}; ++t < n; ) {
      var l = e[t];
      o[l[0]] = l[1];
    }
    return o;
  }
  function cP(e, t) {
    return t.length < 2 ? e : $d(e, xI(t, 0, -1));
  }
  function ln(e, t) {
    return Id(e, t);
  }
  function cn(e) {
    return e == null;
  }
  function Zi(e) {
    return e === null;
  }
  function dP(e) {
    return e === void 0;
  }
  var q1 = nO(function(e, t, n) {
    j1(e, t, n);
  });
  function fP(e, t) {
    return t = Cs(t, e), e = cP(e, t), e == null || delete e[Ss(aP(t))];
  }
  function pP(e) {
    return _1(e) ? void 0 : e;
  }
  var vP = 1, hP = 2, mP = 4, Md = E1(function(e, t) {
    var n = {};
    if (e == null)
      return n;
    var o = !1;
    t = Kv(t, function(a) {
      return a = Cs(a, e), o || (o = a.length > 1), a;
    }), ys(e, M1(e), n), o && (n = Ur(n, vP | hP | mP, pP));
    for (var l = t.length; l--; )
      fP(n, t[l]);
    return n;
  });
  function G1(e, t, n, o) {
    if (!oo(e))
      return e;
    t = Cs(t, e);
    for (var l = -1, a = t.length, r = a - 1, i = e; i != null && ++l < a; ) {
      var u = Ss(t[l]), c = n;
      if (u === "__proto__" || u === "constructor" || u === "prototype")
        return e;
      if (l != r) {
        var d = i[u];
        c = void 0, c === void 0 && (c = oo(d) ? d : kd(t[l + 1]) ? [] : {});
      }
      Yv(i, u, c), i = i[u];
    }
    return e;
  }
  function gP(e, t, n) {
    for (var o = -1, l = t.length, a = {}; ++o < l; ) {
      var r = t[o], i = $d(e, r);
      n(i, r) && G1(a, Cs(r, e), i);
    }
    return a;
  }
  function bP(e, t) {
    return gP(e, t, function(n, o) {
      return z1(e, o);
    });
  }
  var jl = E1(function(e, t) {
    return e == null ? {} : bP(e, t);
  });
  function yP(e, t, n) {
    return e == null ? e : G1(e, t, n);
  }
  var wP = "Expected a function";
  function lr(e, t, n) {
    var o = !0, l = !0;
    if (typeof e != "function")
      throw new TypeError(wP);
    return oo(n) && (o = "leading" in n ? !!n.leading : o, l = "trailing" in n ? !!n.trailing : l), wl(e, t, {
      leading: o,
      maxWait: t,
      trailing: l
    });
  }
  var CP = 1 / 0, SP = jr && 1 / oh(new jr([, -0]))[1] == CP ? function(e) {
    return new jr(e);
  } : L$, EP = 200;
  function kP(e, t, n) {
    var o = -1, l = G$, a = e.length, r = !0, i = [], u = i;
    if (a >= EP) {
      var c = SP(e);
      if (c)
        return oh(c);
      r = !1, l = V1, u = new yi();
    } else
      u = i;
    e:
      for (; ++o < a; ) {
        var d = e[o], f = d;
        if (d = d !== 0 ? d : 0, r && f === f) {
          for (var v = u.length; v--; )
            if (u[v] === f)
              continue e;
          i.push(d);
        } else l(u, f, n) || (u !== i && u.push(f), i.push(d));
      }
    return i;
  }
  var Ef = m1(function(e) {
    return kP(Ji(e, 1, W1, !0));
  });
  const kt = (e) => e === void 0, Vt = (e) => typeof e == "boolean", je = (e) => typeof e == "number", Zn = (e) => !e && e !== 0 || ye(e) && e.length === 0 || ot(e) && !Object.keys(e).length, Qn = (e) => typeof Element > "u" ? !1 : e instanceof Element, go = (e) => cn(e), _P = (e) => Ae(e) ? !Number.isNaN(Number(e)) : !1, Qi = (e) => e === window;
  var TP = Object.defineProperty, NP = Object.defineProperties, $P = Object.getOwnPropertyDescriptors, lb = Object.getOwnPropertySymbols, OP = Object.prototype.hasOwnProperty, IP = Object.prototype.propertyIsEnumerable, ab = (e, t, n) => t in e ? TP(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, MP = (e, t) => {
    for (var n in t || (t = {}))
      OP.call(t, n) && ab(e, n, t[n]);
    if (lb)
      for (var n of lb(t))
        IP.call(t, n) && ab(e, n, t[n]);
    return e;
  }, xP = (e, t) => NP(e, $P(t));
  function Vc(e, t) {
    var n;
    const o = Ut();
    return to(() => {
      o.value = e();
    }, xP(MP({}, t), {
      flush: (n = void 0) != null ? n : "sync"
    })), ir(o);
  }
  var rb;
  const xt = typeof window < "u", PP = (e) => typeof e < "u", gp = (e) => typeof e == "function", RP = (e) => typeof e == "string", X1 = (e, t, n) => Math.min(n, Math.max(t, e)), Kl = () => {
  }, Lc = xt && ((rb = window == null ? void 0 : window.navigator) == null ? void 0 : rb.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
  function $a(e) {
    return typeof e == "function" ? e() : s(e);
  }
  function J1(e, t) {
    function n(...o) {
      return new Promise((l, a) => {
        Promise.resolve(e(() => t.apply(this, o), { fn: t, thisArg: this, args: o })).then(l).catch(a);
      });
    }
    return n;
  }
  function DP(e, t = {}) {
    let n, o, l = Kl;
    const a = (i) => {
      clearTimeout(i), l(), l = Kl;
    };
    return (i) => {
      const u = $a(e), c = $a(t.maxWait);
      return n && a(n), u <= 0 || c !== void 0 && c <= 0 ? (o && (a(o), o = null), Promise.resolve(i())) : new Promise((d, f) => {
        l = t.rejectOnCancel ? f : d, c && !o && (o = setTimeout(() => {
          n && a(n), o = null, d(i());
        }, c)), n = setTimeout(() => {
          o && a(o), o = null, d(i());
        }, u);
      });
    };
  }
  function AP(e, t = !0, n = !0, o = !1) {
    let l = 0, a, r = !0, i = Kl, u;
    const c = () => {
      a && (clearTimeout(a), a = void 0, i(), i = Kl);
    };
    return (f) => {
      const v = $a(e), p = Date.now() - l, m = () => u = f();
      return c(), v <= 0 ? (l = Date.now(), m()) : (p > v && (n || !r) ? (l = Date.now(), m()) : t && (u = new Promise((h, g) => {
        i = o ? g : h, a = setTimeout(() => {
          l = Date.now(), r = !0, h(m()), c();
        }, Math.max(0, v - p));
      })), !n && !a && (a = setTimeout(() => r = !0, v)), r = !1, u);
    };
  }
  function VP(e) {
    return e;
  }
  function LP(e, t) {
    let n, o, l;
    const a = A(!0), r = () => {
      a.value = !0, l();
    };
    de(e, r, { flush: "sync" });
    const i = gp(t) ? t : t.get, u = gp(t) ? void 0 : t.set, c = N2((d, f) => (o = d, l = f, {
      get() {
        return a.value && (n = i(), a.value = !1), o(), n;
      },
      set(v) {
        u == null || u(v);
      }
    }));
    return Object.isExtensible(c) && (c.trigger = r), c;
  }
  function Es(e) {
    return $0() ? (O0(e), !0) : !1;
  }
  function BP(e) {
    if (!Kt(e))
      return Rt(e);
    const t = new Proxy({}, {
      get(n, o, l) {
        return s(Reflect.get(e.value, o, l));
      },
      set(n, o, l) {
        return Kt(e.value[o]) && !Kt(l) ? e.value[o].value = l : e.value[o] = l, !0;
      },
      deleteProperty(n, o) {
        return Reflect.deleteProperty(e.value, o);
      },
      has(n, o) {
        return Reflect.has(e.value, o);
      },
      ownKeys() {
        return Object.keys(e.value);
      },
      getOwnPropertyDescriptor() {
        return {
          enumerable: !0,
          configurable: !0
        };
      }
    });
    return Rt(t);
  }
  function FP(e) {
    return BP(S(e));
  }
  function eu(e, t = 200, n = {}) {
    return J1(DP(t, n), e);
  }
  function zP(e, t = 200, n = {}) {
    const o = A(e.value), l = eu(() => {
      o.value = e.value;
    }, t, n);
    return de(e, () => l()), o;
  }
  function Z1(e, t = 200, n = !1, o = !0, l = !1) {
    return J1(AP(t, n, o, l), e);
  }
  function lh(e, t = !0) {
    dt() ? ft(e) : t ? e() : Re(e);
  }
  function os(e, t, n = {}) {
    const {
      immediate: o = !0
    } = n, l = A(!1);
    let a = null;
    function r() {
      a && (clearTimeout(a), a = null);
    }
    function i() {
      l.value = !1, r();
    }
    function u(...c) {
      r(), l.value = !0, a = setTimeout(() => {
        l.value = !1, a = null, e(...c);
      }, $a(t));
    }
    return o && (l.value = !0, xt && u()), Es(i), {
      isPending: ir(l),
      start: u,
      stop: i
    };
  }
  function kn(e) {
    var t;
    const n = $a(e);
    return (t = n == null ? void 0 : n.$el) != null ? t : n;
  }
  const _l = xt ? window : void 0, HP = xt ? window.document : void 0;
  function Dt(...e) {
    let t, n, o, l;
    if (RP(e[0]) || Array.isArray(e[0]) ? ([n, o, l] = e, t = _l) : [t, n, o, l] = e, !t)
      return Kl;
    Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]);
    const a = [], r = () => {
      a.forEach((d) => d()), a.length = 0;
    }, i = (d, f, v, p) => (d.addEventListener(f, v, p), () => d.removeEventListener(f, v, p)), u = de(() => [kn(t), $a(l)], ([d, f]) => {
      r(), d && a.push(...n.flatMap((v) => o.map((p) => i(d, v, p, f))));
    }, { immediate: !0, flush: "post" }), c = () => {
      u(), r();
    };
    return Es(c), c;
  }
  let sb = !1;
  function ah(e, t, n = {}) {
    const { window: o = _l, ignore: l = [], capture: a = !0, detectIframe: r = !1 } = n;
    if (!o)
      return;
    Lc && !sb && (sb = !0, Array.from(o.document.body.children).forEach((v) => v.addEventListener("click", Kl)));
    let i = !0;
    const u = (v) => l.some((p) => {
      if (typeof p == "string")
        return Array.from(o.document.querySelectorAll(p)).some((m) => m === v.target || v.composedPath().includes(m));
      {
        const m = kn(p);
        return m && (v.target === m || v.composedPath().includes(m));
      }
    }), d = [
      Dt(o, "click", (v) => {
        const p = kn(e);
        if (!(!p || p === v.target || v.composedPath().includes(p))) {
          if (v.detail === 0 && (i = !u(v)), !i) {
            i = !0;
            return;
          }
          t(v);
        }
      }, { passive: !0, capture: a }),
      Dt(o, "pointerdown", (v) => {
        const p = kn(e);
        p && (i = !v.composedPath().includes(p) && !u(v));
      }, { passive: !0 }),
      r && Dt(o, "blur", (v) => {
        var p;
        const m = kn(e);
        ((p = o.document.activeElement) == null ? void 0 : p.tagName) === "IFRAME" && !(m != null && m.contains(o.document.activeElement)) && t(v);
      })
    ].filter(Boolean);
    return () => d.forEach((v) => v());
  }
  function KP(e = {}) {
    var t;
    const { window: n = _l } = e, o = (t = e.document) != null ? t : n == null ? void 0 : n.document, l = LP(() => null, () => o == null ? void 0 : o.activeElement);
    return n && (Dt(n, "blur", (a) => {
      a.relatedTarget === null && l.trigger();
    }, !0), Dt(n, "focus", l.trigger, !0)), l;
  }
  function rh(e, t = !1) {
    const n = A(), o = () => n.value = !!e();
    return o(), lh(o, t), n;
  }
  function WP(e) {
    return JSON.parse(JSON.stringify(e));
  }
  const ib = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, ub = "__vueuse_ssr_handlers__";
  ib[ub] = ib[ub] || {};
  function jP(e, t, { window: n = _l, initialValue: o = "" } = {}) {
    const l = A(o), a = S(() => {
      var r;
      return kn(t) || ((r = n == null ? void 0 : n.document) == null ? void 0 : r.documentElement);
    });
    return de([a, () => $a(e)], ([r, i]) => {
      var u;
      if (r && n) {
        const c = (u = n.getComputedStyle(r).getPropertyValue(i)) == null ? void 0 : u.trim();
        l.value = c || o;
      }
    }, { immediate: !0 }), de(l, (r) => {
      var i;
      (i = a.value) != null && i.style && a.value.style.setProperty($a(e), r);
    }), l;
  }
  function UP({ document: e = HP } = {}) {
    if (!e)
      return A("visible");
    const t = A(e.visibilityState);
    return Dt(e, "visibilitychange", () => {
      t.value = e.visibilityState;
    }), t;
  }
  var cb = Object.getOwnPropertySymbols, YP = Object.prototype.hasOwnProperty, qP = Object.prototype.propertyIsEnumerable, GP = (e, t) => {
    var n = {};
    for (var o in e)
      YP.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
    if (e != null && cb)
      for (var o of cb(e))
        t.indexOf(o) < 0 && qP.call(e, o) && (n[o] = e[o]);
    return n;
  };
  function qt(e, t, n = {}) {
    const o = n, { window: l = _l } = o, a = GP(o, ["window"]);
    let r;
    const i = rh(() => l && "ResizeObserver" in l), u = () => {
      r && (r.disconnect(), r = void 0);
    }, c = de(() => kn(e), (f) => {
      u(), i.value && l && f && (r = new ResizeObserver(t), r.observe(f, a));
    }, { immediate: !0, flush: "post" }), d = () => {
      u(), c();
    };
    return Es(d), {
      isSupported: i,
      stop: d
    };
  }
  function db(e, t = {}) {
    const {
      reset: n = !0,
      windowResize: o = !0,
      windowScroll: l = !0,
      immediate: a = !0
    } = t, r = A(0), i = A(0), u = A(0), c = A(0), d = A(0), f = A(0), v = A(0), p = A(0);
    function m() {
      const h = kn(e);
      if (!h) {
        n && (r.value = 0, i.value = 0, u.value = 0, c.value = 0, d.value = 0, f.value = 0, v.value = 0, p.value = 0);
        return;
      }
      const g = h.getBoundingClientRect();
      r.value = g.height, i.value = g.bottom, u.value = g.left, c.value = g.right, d.value = g.top, f.value = g.width, v.value = g.x, p.value = g.y;
    }
    return qt(e, m), de(() => kn(e), (h) => !h && m()), l && Dt("scroll", m, { capture: !0, passive: !0 }), o && Dt("resize", m, { passive: !0 }), lh(() => {
      a && m();
    }), {
      height: r,
      bottom: i,
      left: u,
      right: c,
      top: d,
      width: f,
      x: v,
      y: p,
      update: m
    };
  }
  function bp(e, t = { width: 0, height: 0 }, n = {}) {
    const { window: o = _l, box: l = "content-box" } = n, a = S(() => {
      var u, c;
      return (c = (u = kn(e)) == null ? void 0 : u.namespaceURI) == null ? void 0 : c.includes("svg");
    }), r = A(t.width), i = A(t.height);
    return qt(e, ([u]) => {
      const c = l === "border-box" ? u.borderBoxSize : l === "content-box" ? u.contentBoxSize : u.devicePixelContentBoxSize;
      if (o && a.value) {
        const d = kn(e);
        if (d) {
          const f = o.getComputedStyle(d);
          r.value = parseFloat(f.width), i.value = parseFloat(f.height);
        }
      } else if (c) {
        const d = Array.isArray(c) ? c : [c];
        r.value = d.reduce((f, { inlineSize: v }) => f + v, 0), i.value = d.reduce((f, { blockSize: v }) => f + v, 0);
      } else
        r.value = u.contentRect.width, i.value = u.contentRect.height;
    }, n), de(() => kn(e), (u) => {
      r.value = u ? t.width : 0, i.value = u ? t.height : 0;
    }), {
      width: r,
      height: i
    };
  }
  function XP(e, t, n = {}) {
    const {
      root: o,
      rootMargin: l = "0px",
      threshold: a = 0.1,
      window: r = _l
    } = n, i = rh(() => r && "IntersectionObserver" in r);
    let u = Kl;
    const c = i.value ? de(() => ({
      el: kn(e),
      root: kn(o)
    }), ({ el: f, root: v }) => {
      if (u(), !f)
        return;
      const p = new IntersectionObserver(t, {
        root: v,
        rootMargin: l,
        threshold: a
      });
      p.observe(f), u = () => {
        p.disconnect(), u = Kl;
      };
    }, { immediate: !0, flush: "post" }) : Kl, d = () => {
      u(), c();
    };
    return Es(d), {
      isSupported: i,
      stop: d
    };
  }
  var fb = Object.getOwnPropertySymbols, JP = Object.prototype.hasOwnProperty, ZP = Object.prototype.propertyIsEnumerable, QP = (e, t) => {
    var n = {};
    for (var o in e)
      JP.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
    if (e != null && fb)
      for (var o of fb(e))
        t.indexOf(o) < 0 && ZP.call(e, o) && (n[o] = e[o]);
    return n;
  };
  function Q1(e, t, n = {}) {
    const o = n, { window: l = _l } = o, a = QP(o, ["window"]);
    let r;
    const i = rh(() => l && "MutationObserver" in l), u = () => {
      r && (r.disconnect(), r = void 0);
    }, c = de(() => kn(e), (f) => {
      u(), i.value && l && f && (r = new MutationObserver(t), r.observe(f, a));
    }, { immediate: !0 }), d = () => {
      u(), c();
    };
    return Es(d), {
      isSupported: i,
      stop: d
    };
  }
  var pb;
  (function(e) {
    e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE";
  })(pb || (pb = {}));
  var eR = Object.defineProperty, vb = Object.getOwnPropertySymbols, tR = Object.prototype.hasOwnProperty, nR = Object.prototype.propertyIsEnumerable, hb = (e, t, n) => t in e ? eR(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, oR = (e, t) => {
    for (var n in t || (t = {}))
      tR.call(t, n) && hb(e, n, t[n]);
    if (vb)
      for (var n of vb(t))
        nR.call(t, n) && hb(e, n, t[n]);
    return e;
  };
  const lR = {
    easeInSine: [0.12, 0, 0.39, 0],
    easeOutSine: [0.61, 1, 0.88, 1],
    easeInOutSine: [0.37, 0, 0.63, 1],
    easeInQuad: [0.11, 0, 0.5, 0],
    easeOutQuad: [0.5, 1, 0.89, 1],
    easeInOutQuad: [0.45, 0, 0.55, 1],
    easeInCubic: [0.32, 0, 0.67, 0],
    easeOutCubic: [0.33, 1, 0.68, 1],
    easeInOutCubic: [0.65, 0, 0.35, 1],
    easeInQuart: [0.5, 0, 0.75, 0],
    easeOutQuart: [0.25, 1, 0.5, 1],
    easeInOutQuart: [0.76, 0, 0.24, 1],
    easeInQuint: [0.64, 0, 0.78, 0],
    easeOutQuint: [0.22, 1, 0.36, 1],
    easeInOutQuint: [0.83, 0, 0.17, 1],
    easeInExpo: [0.7, 0, 0.84, 0],
    easeOutExpo: [0.16, 1, 0.3, 1],
    easeInOutExpo: [0.87, 0, 0.13, 1],
    easeInCirc: [0.55, 0, 1, 0.45],
    easeOutCirc: [0, 0.55, 0.45, 1],
    easeInOutCirc: [0.85, 0, 0.15, 1],
    easeInBack: [0.36, 0, 0.66, -0.56],
    easeOutBack: [0.34, 1.56, 0.64, 1],
    easeInOutBack: [0.68, -0.6, 0.32, 1.6]
  };
  oR({
    linear: VP
  }, lR);
  function eC(e, t, n, o = {}) {
    var l, a, r;
    const {
      clone: i = !1,
      passive: u = !1,
      eventName: c,
      deep: d = !1,
      defaultValue: f
    } = o, v = dt(), p = n || (v == null ? void 0 : v.emit) || ((l = v == null ? void 0 : v.$emit) == null ? void 0 : l.bind(v)) || ((r = (a = v == null ? void 0 : v.proxy) == null ? void 0 : a.$emit) == null ? void 0 : r.bind(v == null ? void 0 : v.proxy));
    let m = c;
    t || (t = "modelValue"), m = c || m || `update:${t.toString()}`;
    const h = (b) => i ? gp(i) ? i(b) : WP(b) : b, g = () => PP(e[t]) ? h(e[t]) : f;
    if (u) {
      const b = g(), C = A(b);
      return de(() => e[t], (w) => C.value = h(w)), de(C, (w) => {
        (w !== e[t] || d) && p(m, w);
      }, { deep: d }), C;
    } else
      return S({
        get() {
          return g();
        },
        set(b) {
          p(m, b);
        }
      });
  }
  function aR({ window: e = _l } = {}) {
    if (!e)
      return A(!1);
    const t = A(e.document.hasFocus());
    return Dt(e, "blur", () => {
      t.value = !1;
    }), Dt(e, "focus", () => {
      t.value = !0;
    }), t;
  }
  function sh(e = {}) {
    const {
      window: t = _l,
      initialWidth: n = 1 / 0,
      initialHeight: o = 1 / 0,
      listenOrientation: l = !0,
      includeScrollbar: a = !0
    } = e, r = A(n), i = A(o), u = () => {
      t && (a ? (r.value = t.innerWidth, i.value = t.innerHeight) : (r.value = t.document.documentElement.clientWidth, i.value = t.document.documentElement.clientHeight));
    };
    return u(), lh(u), Dt("resize", u, { passive: !0 }), l && Dt("orientationchange", u, { passive: !0 }), { width: r, height: i };
  }
  class tC extends Error {
    constructor(t) {
      super(t), this.name = "ElementPlusError";
    }
  }
  function Zt(e, t) {
    throw new tC(`[${e}] ${t}`);
  }
  function vt(e, t) {
    if (typeof process < "u" && process.env.NODE_ENV !== "production") {
      const n = Ae(e) ? new tC(`[${e}] ${t}`) : e;
      console.warn(n);
    }
  }
  const mb = {
    current: 0
  }, gb = A(0), nC = 2e3, bb = Symbol("elZIndexContextKey"), oC = Symbol("zIndexContextKey"), tu = (e) => {
    const t = dt() ? Ve(bb, mb) : mb, n = e || (dt() ? Ve(oC, void 0) : void 0), o = S(() => {
      const r = s(n);
      return je(r) ? r : nC;
    }), l = S(() => o.value + gb.value), a = () => (t.current++, gb.value = t.current, l.value);
    return !xt && !Ve(bb) && vt("ZIndexInjection", `Looks like you are using server rendering, you must provide a z-index provider to ensure the hydration process to be succeed
usage: app.provide(ZINDEX_INJECTION_KEY, { current: 0 })`), {
      initialZIndex: o,
      currentZIndex: l,
      nextZIndex: a
    };
  };
  var rR = {
    name: "en",
    el: {
      breadcrumb: {
        label: "Breadcrumb"
      },
      colorpicker: {
        confirm: "OK",
        clear: "Clear",
        defaultLabel: "color picker",
        description: "current color is {color}. press enter to select a new color.",
        alphaLabel: "pick alpha value",
        alphaDescription: "alpha {alpha}, current color is {color}",
        hueLabel: "pick hue value",
        hueDescription: "hue {hue}, current color is {color}",
        svLabel: "pick saturation and brightness value",
        svDescription: "saturation {saturation}, brightness {brightness}, current color is {color}",
        predefineDescription: "select {value} as the color"
      },
      datepicker: {
        now: "Now",
        today: "Today",
        cancel: "Cancel",
        clear: "Clear",
        confirm: "OK",
        dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
        monthTablePrompt: "Use the arrow keys and enter to select the month",
        yearTablePrompt: "Use the arrow keys and enter to select the year",
        selectedDate: "Selected date",
        selectDate: "Select date",
        selectTime: "Select time",
        startDate: "Start Date",
        startTime: "Start Time",
        endDate: "End Date",
        endTime: "End Time",
        prevYear: "Previous Year",
        nextYear: "Next Year",
        prevMonth: "Previous Month",
        nextMonth: "Next Month",
        year: "",
        month1: "January",
        month2: "February",
        month3: "March",
        month4: "April",
        month5: "May",
        month6: "June",
        month7: "July",
        month8: "August",
        month9: "September",
        month10: "October",
        month11: "November",
        month12: "December",
        weeks: {
          sun: "Sun",
          mon: "Mon",
          tue: "Tue",
          wed: "Wed",
          thu: "Thu",
          fri: "Fri",
          sat: "Sat"
        },
        weeksFull: {
          sun: "Sunday",
          mon: "Monday",
          tue: "Tuesday",
          wed: "Wednesday",
          thu: "Thursday",
          fri: "Friday",
          sat: "Saturday"
        },
        months: {
          jan: "Jan",
          feb: "Feb",
          mar: "Mar",
          apr: "Apr",
          may: "May",
          jun: "Jun",
          jul: "Jul",
          aug: "Aug",
          sep: "Sep",
          oct: "Oct",
          nov: "Nov",
          dec: "Dec"
        }
      },
      inputNumber: {
        decrease: "decrease number",
        increase: "increase number"
      },
      select: {
        loading: "Loading",
        noMatch: "No matching data",
        noData: "No data",
        placeholder: "Select"
      },
      mention: {
        loading: "Loading"
      },
      dropdown: {
        toggleDropdown: "Toggle Dropdown"
      },
      cascader: {
        noMatch: "No matching data",
        loading: "Loading",
        placeholder: "Select",
        noData: "No data"
      },
      pagination: {
        goto: "Go to",
        pagesize: "/page",
        total: "Total {total}",
        pageClassifier: "",
        page: "Page",
        prev: "Go to previous page",
        next: "Go to next page",
        currentPage: "page {pager}",
        prevPages: "Previous {pager} pages",
        nextPages: "Next {pager} pages",
        deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
      },
      dialog: {
        close: "Close this dialog"
      },
      drawer: {
        close: "Close this dialog"
      },
      messagebox: {
        title: "Message",
        confirm: "OK",
        cancel: "Cancel",
        error: "Illegal input",
        close: "Close this dialog"
      },
      upload: {
        deleteTip: "press delete to remove",
        delete: "Delete",
        preview: "Preview",
        continue: "Continue"
      },
      slider: {
        defaultLabel: "slider between {min} and {max}",
        defaultRangeStartLabel: "pick start value",
        defaultRangeEndLabel: "pick end value"
      },
      table: {
        emptyText: "No Data",
        confirmFilter: "Confirm",
        resetFilter: "Reset",
        clearFilter: "All",
        sumText: "Sum"
      },
      tour: {
        next: "Next",
        previous: "Previous",
        finish: "Finish",
        close: "Close this dialog"
      },
      tree: {
        emptyText: "No Data"
      },
      transfer: {
        noMatch: "No matching data",
        noData: "No data",
        titles: ["List 1", "List 2"],
        filterPlaceholder: "Enter keyword",
        noCheckedFormat: "{total} items",
        hasCheckedFormat: "{checked}/{total} checked"
      },
      image: {
        error: "FAILED"
      },
      pageHeader: {
        title: "Back"
      },
      popconfirm: {
        confirmButtonText: "Yes",
        cancelButtonText: "No"
      },
      carousel: {
        leftArrow: "Carousel arrow left",
        rightArrow: "Carousel arrow right",
        indicator: "Carousel switch to index {index}"
      }
    }
  };
  const sR = (e) => (t, n) => iR(t, n, s(e)), iR = (e, t, n) => dn(n, e, e).replace(/\{(\w+)\}/g, (o, l) => {
    var a;
    return `${(a = t == null ? void 0 : t[l]) != null ? a : `{${l}}`}`;
  }), uR = (e) => {
    const t = S(() => s(e).name), n = Kt(e) ? e : A(e);
    return {
      lang: t,
      locale: n,
      t: sR(e)
    };
  }, lC = Symbol("localeContextKey"), _t = (e) => {
    const t = e || Ve(lC, A());
    return uR(S(() => t.value || rR));
  }, aC = "__epPropKey", X = (e) => e, cR = (e) => ot(e) && !!e[aC], tl = (e, t) => {
    if (!ot(e) || cR(e))
      return e;
    const { values: n, required: o, default: l, type: a, validator: r } = e, u = {
      type: a,
      required: !!o,
      validator: n || r ? (c) => {
        let d = !1, f = [];
        if (n && (f = Array.from(n), Ot(e, "default") && f.push(l), d || (d = f.includes(c))), r && (d || (d = r(c))), !d && f.length > 0) {
          const v = [...new Set(f)].map((p) => JSON.stringify(p)).join(", ");
          zo(`Invalid prop: validation failed${t ? ` for prop "${t}"` : ""}. Expected one of [${v}], got value ${JSON.stringify(c)}.`);
        }
        return d;
      } : void 0,
      [aC]: !0
    };
    return Ot(e, "default") && (u.default = l), u;
  }, Te = (e) => wi(Object.entries(e).map(([t, n]) => [
    t,
    tl(n, t)
  ])), Tl = ["", "default", "small", "large"], mn = tl({
    type: String,
    values: Tl,
    required: !1
  }), rC = Symbol("size"), sC = () => {
    const e = Ve(rC, {});
    return S(() => s(e.size) || "");
  }, iC = Symbol("emptyValuesContextKey"), dR = "use-empty-values", fR = ["", void 0, null], pR = void 0, Cr = Te({
    emptyValues: Array,
    valueOnClear: {
      type: X([
        String,
        Number,
        Boolean,
        Function
      ]),
      default: void 0,
      validator: (e) => (e = Fe(e) ? e() : e, ye(e) ? e.every((t) => !t) : !e)
    }
  }), nu = (e, t) => {
    const n = dt() ? Ve(iC, A({})) : A({}), o = S(() => e.emptyValues || n.value.emptyValues || fR), l = S(() => Fe(e.valueOnClear) ? e.valueOnClear() : e.valueOnClear !== void 0 ? e.valueOnClear : Fe(n.value.valueOnClear) ? n.value.valueOnClear() : n.value.valueOnClear !== void 0 ? n.value.valueOnClear : t !== void 0 ? t : pR), a = (r) => {
      let i = !0;
      return ye(r) ? i = o.value.some((u) => ln(r, u)) : i = o.value.includes(r), i;
    };
    return a(l.value) || vt(dR, "value-on-clear should be a value of empty-values"), {
      emptyValues: o,
      valueOnClear: l,
      isEmptyValue: a
    };
  }, Ci = (e) => Object.keys(e), uC = (e) => Object.entries(e), ni = (e, t, n) => ({
    get value() {
      return dn(e, t, n);
    },
    set value(o) {
      yP(e, t, o);
    }
  }), Bc = A();
  function ks(e, t = void 0) {
    const n = dt() ? Ve(s1, Bc) : Bc;
    return e ? S(() => {
      var o, l;
      return (l = (o = n.value) == null ? void 0 : o[e]) != null ? l : t;
    }) : n;
  }
  function xd(e, t) {
    const n = ks(), o = he(e, S(() => {
      var i;
      return ((i = n.value) == null ? void 0 : i.namespace) || Qs;
    })), l = _t(S(() => {
      var i;
      return (i = n.value) == null ? void 0 : i.locale;
    })), a = tu(S(() => {
      var i;
      return ((i = n.value) == null ? void 0 : i.zIndex) || nC;
    })), r = S(() => {
      var i;
      return s(t) || ((i = n.value) == null ? void 0 : i.size) || "";
    });
    return ih(S(() => s(n) || {})), {
      ns: o,
      locale: l,
      zIndex: a,
      size: r
    };
  }
  const ih = (e, t, n = !1) => {
    var o;
    const l = !!dt(), a = l ? ks() : void 0, r = (o = t == null ? void 0 : t.provide) != null ? o : l ? yt : void 0;
    if (!r) {
      vt("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
      return;
    }
    const i = S(() => {
      const u = s(e);
      return a != null && a.value ? vR(a.value, u) : u;
    });
    return r(s1, i), r(lC, S(() => i.value.locale)), r(i1, S(() => i.value.namespace)), r(oC, S(() => i.value.zIndex)), r(rC, {
      size: S(() => i.value.size || "")
    }), r(iC, S(() => ({
      emptyValues: i.value.emptyValues,
      valueOnClear: i.value.valueOnClear
    }))), (n || !Bc.value) && (Bc.value = i.value), i;
  }, vR = (e, t) => {
    const n = [.../* @__PURE__ */ new Set([...Ci(e), ...Ci(t)])], o = {};
    for (const l of n)
      o[l] = t[l] !== void 0 ? t[l] : e[l];
    return o;
  }, hR = (e = []) => ({
    version: e$,
    install: (n, o) => {
      n[Ng] || (n[Ng] = !0, e.forEach((l) => n.use(l)), o && ih(o, n, !0));
    }
  }), et = "update:modelValue", gt = "change", fn = "input", mR = Te({
    zIndex: {
      type: X([Number, String]),
      default: 100
    },
    target: {
      type: String,
      default: ""
    },
    offset: {
      type: Number,
      default: 0
    },
    position: {
      type: String,
      values: ["top", "bottom"],
      default: "top"
    }
  }), gR = {
    scroll: ({ scrollTop: e, fixed: t }) => je(e) && Vt(t),
    [gt]: (e) => Vt(e)
  };
  var Ne = (e, t) => {
    const n = e.__vccOpts || e;
    for (const [o, l] of t)
      n[o] = l;
    return n;
  };
  function bR(e, t, n, o) {
    const l = n - t;
    return e /= o / 2, e < 1 ? l / 2 * e * e * e + t : l / 2 * ((e -= 2) * e * e + 2) + t;
  }
  const Ul = (e) => xt ? window.requestAnimationFrame(e) : setTimeout(e, 16), Yl = (e) => xt ? window.cancelAnimationFrame(e) : clearTimeout(e), yR = "utils/dom/style", cC = (e = "") => e.split(" ").filter((t) => !!t.trim()), Lo = (e, t) => {
    if (!e || !t)
      return !1;
    if (t.includes(" "))
      throw new Error("className should not contain space.");
    return e.classList.contains(t);
  }, _o = (e, t) => {
    !e || !t.trim() || e.classList.add(...cC(t));
  }, jn = (e, t) => {
    !e || !t.trim() || e.classList.remove(...cC(t));
  }, Bl = (e, t) => {
    var n;
    if (!xt || !e || !t)
      return "";
    let o = In(t);
    o === "float" && (o = "cssFloat");
    try {
      const l = e.style[o];
      if (l)
        return l;
      const a = (n = document.defaultView) == null ? void 0 : n.getComputedStyle(e, "");
      return a ? a[o] : "";
    } catch {
      return e.style[o];
    }
  }, dC = (e, t, n) => {
    if (!(!e || !t))
      if (ot(t))
        uC(t).forEach(([o, l]) => dC(e, o, l));
      else {
        const o = In(t);
        e.style[o] = n;
      }
  };
  function tn(e, t = "px") {
    if (!e)
      return "";
    if (je(e) || _P(e))
      return `${e}${t}`;
    if (Ae(e))
      return e;
    vt(yR, "binding value must be a string or number");
  }
  const wR = (e, t) => {
    if (!xt)
      return !1;
    const n = {
      undefined: "overflow",
      true: "overflow-y",
      false: "overflow-x"
    }[String(t)], o = Bl(e, n);
    return ["scroll", "auto", "overlay"].some((l) => o.includes(l));
  }, uh = (e, t) => {
    if (!xt)
      return;
    let n = e;
    for (; n; ) {
      if ([window, document, document.documentElement].includes(n))
        return window;
      if (wR(n, t))
        return n;
      n = n.parentNode;
    }
    return n;
  };
  let $u;
  const fC = (e) => {
    var t;
    if (!xt)
      return 0;
    if ($u !== void 0)
      return $u;
    const n = document.createElement("div");
    n.className = `${e}-scrollbar__wrap`, n.style.visibility = "hidden", n.style.width = "100px", n.style.position = "absolute", n.style.top = "-9999px", document.body.appendChild(n);
    const o = n.offsetWidth;
    n.style.overflow = "scroll";
    const l = document.createElement("div");
    l.style.width = "100%", n.appendChild(l);
    const a = l.offsetWidth;
    return (t = n.parentNode) == null || t.removeChild(n), $u = o - a, $u;
  };
  function ch(e, t) {
    if (!xt)
      return;
    if (!t) {
      e.scrollTop = 0;
      return;
    }
    const n = [];
    let o = t.offsetParent;
    for (; o !== null && e !== o && e.contains(o); )
      n.push(o), o = o.offsetParent;
    const l = t.offsetTop + n.reduce((u, c) => u + c.offsetTop, 0), a = l + t.offsetHeight, r = e.scrollTop, i = r + e.clientHeight;
    l < r ? e.scrollTop = l : a > i && (e.scrollTop = a - e.clientHeight);
  }
  function CR(e, t, n, o, l) {
    const a = Date.now();
    let r;
    const i = () => {
      const c = Date.now() - a, d = bR(c > o ? o : c, t, n, o);
      Qi(e) ? e.scrollTo(window.pageXOffset, d) : e.scrollTop = d, c < o ? r = Ul(i) : Fe(l) && l();
    };
    return i(), () => {
      r && Yl(r);
    };
  }
  const yb = (e, t) => Qi(t) ? e.ownerDocument.documentElement : t, wb = (e) => Qi(e) ? window.scrollY : e.scrollTop, pC = "ElAffix", SR = /* @__PURE__ */ U({
    name: pC
  }), ER = /* @__PURE__ */ U({
    ...SR,
    props: mR,
    emits: gR,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = he("affix"), a = Ut(), r = Ut(), i = Ut(), { height: u } = sh(), {
        height: c,
        width: d,
        top: f,
        bottom: v,
        update: p
      } = db(r, { windowScroll: !1 }), m = db(a), h = A(!1), g = A(0), b = A(0), C = S(() => ({
        height: h.value ? `${c.value}px` : "",
        width: h.value ? `${d.value}px` : ""
      })), w = S(() => {
        if (!h.value)
          return {};
        const T = o.offset ? tn(o.offset) : 0;
        return {
          height: `${c.value}px`,
          width: `${d.value}px`,
          top: o.position === "top" ? T : "",
          bottom: o.position === "bottom" ? T : "",
          transform: b.value ? `translateY(${b.value}px)` : "",
          zIndex: o.zIndex
        };
      }), y = () => {
        if (!i.value)
          return;
        g.value = i.value instanceof Window ? document.documentElement.scrollTop : i.value.scrollTop || 0;
        const { position: T, target: x, offset: I } = o, P = I + c.value;
        if (T === "top")
          if (x) {
            const O = m.bottom.value - P;
            h.value = I > f.value && m.bottom.value > 0, b.value = O < 0 ? O : 0;
          } else
            h.value = I > f.value;
        else if (x) {
          const O = u.value - m.top.value - P;
          h.value = u.value - I < v.value && u.value > m.top.value, b.value = O < 0 ? -O : 0;
        } else
          h.value = u.value - I < v.value;
      }, E = async () => {
        if (!h.value) {
          p();
          return;
        }
        h.value = !1, await Re(), p(), h.value = !0;
      }, k = async () => {
        p(), await Re(), n("scroll", {
          scrollTop: g.value,
          fixed: h.value
        });
      };
      return de(h, (T) => n(gt, T)), ft(() => {
        var T;
        o.target ? (a.value = (T = document.querySelector(o.target)) != null ? T : void 0, a.value || Zt(pC, `Target does not exist: ${o.target}`)) : a.value = document.documentElement, i.value = uh(r.value, !0), p();
      }), Dt(i, "scroll", k), to(y), t({
        update: y,
        updateRoot: E
      }), (T, x) => (_(), B("div", {
        ref_key: "root",
        ref: r,
        class: $(s(l).b()),
        style: Ue(s(C))
      }, [
        W("div", {
          class: $({ [s(l).m("fixed")]: h.value }),
          style: Ue(s(w))
        }, [
          ee(T.$slots, "default")
        ], 6)
      ], 6));
    }
  });
  var kR = /* @__PURE__ */ Ne(ER, [["__file", "affix.vue"]]);
  const rt = (e, t) => {
    if (e.install = (n) => {
      for (const o of [e, ...Object.values(t ?? {})])
        n.component(o.name, o);
    }, t)
      for (const [n, o] of Object.entries(t))
        e[n] = o;
    return e;
  }, vC = (e, t) => (e.install = (n) => {
    e._context = n._context, n.config.globalProperties[t] = e;
  }, e), _R = (e, t) => (e.install = (n) => {
    n.directive(t, e);
  }, e), nn = (e) => (e.install = It, e), TR = rt(kR), NR = Te({
    size: {
      type: X([Number, String])
    },
    color: {
      type: String
    }
  }), $R = /* @__PURE__ */ U({
    name: "ElIcon",
    inheritAttrs: !1
  }), OR = /* @__PURE__ */ U({
    ...$R,
    props: NR,
    setup(e) {
      const t = e, n = he("icon"), o = S(() => {
        const { size: l, color: a } = t;
        return !l && !a ? {} : {
          fontSize: kt(l) ? void 0 : tn(l),
          "--color": a
        };
      });
      return (l, a) => (_(), B("i", pt({
        class: s(n).b(),
        style: s(o)
      }, l.$attrs), [
        ee(l.$slots, "default")
      ], 16));
    }
  });
  var IR = /* @__PURE__ */ Ne(OR, [["__file", "icon.vue"]]);
  const ze = rt(IR);
  function Cb() {
    let e;
    const t = (o, l) => {
      n(), e = window.setTimeout(o, l);
    }, n = () => window.clearTimeout(e);
    return Es(() => n()), {
      registerTimeout: t,
      cancelTimeout: n
    };
  }
  const hC = Te({
    showAfter: {
      type: Number,
      default: 0
    },
    hideAfter: {
      type: Number,
      default: 200
    },
    autoClose: {
      type: Number,
      default: 0
    }
  }), mC = ({
    showAfter: e,
    hideAfter: t,
    autoClose: n,
    open: o,
    close: l
  }) => {
    const { registerTimeout: a } = Cb(), {
      registerTimeout: r,
      cancelTimeout: i
    } = Cb();
    return {
      onOpen: (d, f = s(e)) => {
        a(() => {
          o(d);
          const v = s(n);
          je(v) && v > 0 && r(() => {
            l(d);
          }, v);
        }, f);
      },
      onClose: (d, f = s(t)) => {
        i(), a(() => {
          l(d);
        }, f);
      }
    };
  };
  /*! Element Plus Icons Vue v2.3.2 */
  var MR = /* @__PURE__ */ U({
    name: "ArrowDown",
    __name: "arrow-down",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M831.872 340.864 512 652.672 192.128 340.864a30.59 30.59 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.59 30.59 0 0 0-42.752 0z"
        })
      ]));
    }
  }), Nl = MR, xR = /* @__PURE__ */ U({
    name: "ArrowLeft",
    __name: "arrow-left",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.59 30.59 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.59 30.59 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0"
        })
      ]));
    }
  }), ql = xR, PR = /* @__PURE__ */ U({
    name: "ArrowRight",
    __name: "arrow-right",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M340.864 149.312a30.59 30.59 0 0 0 0 42.752L652.736 512 340.864 831.872a30.59 30.59 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
        })
      ]));
    }
  }), Un = PR, RR = /* @__PURE__ */ U({
    name: "ArrowUp",
    __name: "arrow-up",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0"
        })
      ]));
    }
  }), Pd = RR, DR = /* @__PURE__ */ U({
    name: "Back",
    __name: "back",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M224 480h640a32 32 0 1 1 0 64H224a32 32 0 0 1 0-64"
        }),
        W("path", {
          fill: "currentColor",
          d: "m237.248 512 265.408 265.344a32 32 0 0 1-45.312 45.312l-288-288a32 32 0 0 1 0-45.312l288-288a32 32 0 1 1 45.312 45.312z"
        })
      ]));
    }
  }), AR = DR, VR = /* @__PURE__ */ U({
    name: "Calendar",
    __name: "calendar",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64m0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64"
        })
      ]));
    }
  }), LR = VR, BR = /* @__PURE__ */ U({
    name: "CaretRight",
    __name: "caret-right",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M384 192v640l384-320.064z"
        })
      ]));
    }
  }), gC = BR, FR = /* @__PURE__ */ U({
    name: "CaretTop",
    __name: "caret-top",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M512 320 192 704h639.936z"
        })
      ]));
    }
  }), zR = FR, HR = /* @__PURE__ */ U({
    name: "Check",
    __name: "check",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M406.656 706.944 195.84 496.256a32 32 0 1 0-45.248 45.248l256 256 512-512a32 32 0 0 0-45.248-45.248L406.592 706.944z"
        })
      ]));
    }
  }), ou = HR, KR = /* @__PURE__ */ U({
    name: "CircleCheckFilled",
    __name: "circle-check-filled",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.27 38.27 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
        })
      ]));
    }
  }), WR = KR, jR = /* @__PURE__ */ U({
    name: "CircleCheck",
    __name: "circle-check",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
        }),
        W("path", {
          fill: "currentColor",
          d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752z"
        })
      ]));
    }
  }), dh = jR, UR = /* @__PURE__ */ U({
    name: "CircleCloseFilled",
    __name: "circle-close-filled",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336z"
        })
      ]));
    }
  }), fh = UR, YR = /* @__PURE__ */ U({
    name: "CircleClose",
    __name: "circle-close",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248z"
        }),
        W("path", {
          fill: "currentColor",
          d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
        })
      ]));
    }
  }), oa = YR, qR = /* @__PURE__ */ U({
    name: "Clock",
    __name: "clock",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768m0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896"
        }),
        W("path", {
          fill: "currentColor",
          d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32"
        }),
        W("path", {
          fill: "currentColor",
          d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32"
        })
      ]));
    }
  }), bC = qR, GR = /* @__PURE__ */ U({
    name: "Close",
    __name: "close",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
        })
      ]));
    }
  }), Oo = GR, XR = /* @__PURE__ */ U({
    name: "DArrowLeft",
    __name: "d-arrow-left",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.59 30.59 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.59 30.59 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672zm256 0a29.12 29.12 0 0 1 41.728 0 30.59 30.59 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.59 30.59 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672z"
        })
      ]));
    }
  }), Oa = XR, JR = /* @__PURE__ */ U({
    name: "DArrowRight",
    __name: "d-arrow-right",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.59 30.59 0 0 1 0-42.752L764.736 512 452.864 192a30.59 30.59 0 0 1 0-42.688m-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.59 30.59 0 0 1 0-42.752L508.736 512 196.864 192a30.59 30.59 0 0 1 0-42.688"
        })
      ]));
    }
  }), Ia = JR, ZR = /* @__PURE__ */ U({
    name: "Delete",
    __name: "delete",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M160 256H96a32 32 0 0 1 0-64h256V95.936a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V192h256a32 32 0 1 1 0 64h-64v672a32 32 0 0 1-32 32H192a32 32 0 0 1-32-32zm448-64v-64H416v64zM224 896h576V256H224zm192-128a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32m192 0a32 32 0 0 1-32-32V416a32 32 0 0 1 64 0v320a32 32 0 0 1-32 32"
        })
      ]));
    }
  }), QR = ZR, eD = /* @__PURE__ */ U({
    name: "Document",
    __name: "document",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M832 384H576V128H192v768h640zm-26.496-64L640 154.496V320zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32m160 448h384v64H320zm0-192h160v64H320zm0 384h384v64H320z"
        })
      ]));
    }
  }), tD = eD, nD = /* @__PURE__ */ U({
    name: "FullScreen",
    __name: "full-screen",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "m160 96.064 192 .192a32 32 0 0 1 0 64l-192-.192V352a32 32 0 0 1-64 0V96h64zm0 831.872V928H96V672a32 32 0 1 1 64 0v191.936l192-.192a32 32 0 1 1 0 64zM864 96.064V96h64v256a32 32 0 1 1-64 0V160.064l-192 .192a32 32 0 1 1 0-64zm0 831.872-192-.192a32 32 0 0 1 0-64l192 .192V672a32 32 0 1 1 64 0v256h-64z"
        })
      ]));
    }
  }), oD = nD, lD = /* @__PURE__ */ U({
    name: "Hide",
    __name: "hide",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4s-12.8-9.6-22.4-9.6-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176S0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4s3.2 16 9.6 22.4 12.8 9.6 22.4 9.6 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4m-646.4 528Q115.2 579.2 76.8 512q43.2-72 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4m140.8-96Q352 555.2 352 512c0-44.8 16-83.2 48-112s67.2-48 112-48c28.8 0 54.4 6.4 73.6 19.2zM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6q-43.2 72-153.6 172.8c-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176S1024 528 1024 512s-48.001-73.6-134.401-176"
        }),
        W("path", {
          fill: "currentColor",
          d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112s-67.2 48-112 48"
        })
      ]));
    }
  }), aD = lD, rD = /* @__PURE__ */ U({
    name: "InfoFilled",
    __name: "info-filled",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64m67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344M590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.99 12.99 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
        })
      ]));
    }
  }), Si = rD, sD = /* @__PURE__ */ U({
    name: "Loading",
    __name: "loading",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32m0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32m448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32m-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32M195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248m452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248M828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0m-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0"
        })
      ]));
    }
  }), Cl = sD, iD = /* @__PURE__ */ U({
    name: "Minus",
    __name: "minus",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M128 544h768a32 32 0 1 0 0-64H128a32 32 0 0 0 0 64"
        })
      ]));
    }
  }), uD = iD, cD = /* @__PURE__ */ U({
    name: "MoreFilled",
    __name: "more-filled",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M176 416a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224m336 0a112 112 0 1 1 0 224 112 112 0 0 1 0-224"
        })
      ]));
    }
  }), Sb = cD, dD = /* @__PURE__ */ U({
    name: "More",
    __name: "more",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96m336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224m0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96"
        })
      ]));
    }
  }), fD = dD, pD = /* @__PURE__ */ U({
    name: "PictureFilled",
    __name: "picture-filled",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M96 896a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h832a32 32 0 0 1 32 32v704a32 32 0 0 1-32 32zm315.52-228.48-68.928-68.928a32 32 0 0 0-45.248 0L128 768.064h778.688l-242.112-290.56a32 32 0 0 0-49.216 0L458.752 665.408a32 32 0 0 1-47.232 2.112M256 384a96 96 0 1 0 192.064-.064A96 96 0 0 0 256 384"
        })
      ]));
    }
  }), vD = pD, hD = /* @__PURE__ */ U({
    name: "Plus",
    __name: "plus",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
        })
      ]));
    }
  }), yC = hD, mD = /* @__PURE__ */ U({
    name: "QuestionFilled",
    __name: "question-filled",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m23.744 191.488c-52.096 0-92.928 14.784-123.2 44.352-30.976 29.568-45.76 70.4-45.76 122.496h80.256c0-29.568 5.632-52.8 17.6-68.992 13.376-19.712 35.2-28.864 66.176-28.864 23.936 0 42.944 6.336 56.32 19.712 12.672 13.376 19.712 31.68 19.712 54.912 0 17.6-6.336 34.496-19.008 49.984l-8.448 9.856c-45.76 40.832-73.216 70.4-82.368 89.408-9.856 19.008-14.08 42.24-14.08 68.992v9.856h80.96v-9.856c0-16.896 3.52-31.68 10.56-45.76 6.336-12.672 15.488-24.64 28.16-35.2 33.792-29.568 54.208-48.576 60.544-55.616 16.896-22.528 26.048-51.392 26.048-86.592q0-64.416-42.24-101.376c-28.16-25.344-65.472-37.312-111.232-37.312m-12.672 406.208a54.27 54.27 0 0 0-38.72 14.784 49.4 49.4 0 0 0-15.488 38.016c0 15.488 4.928 28.16 15.488 38.016A54.85 54.85 0 0 0 523.072 768c15.488 0 28.16-4.928 38.72-14.784a51.52 51.52 0 0 0 16.192-38.72 51.97 51.97 0 0 0-15.488-38.016 55.94 55.94 0 0 0-39.424-14.784"
        })
      ]));
    }
  }), gD = mD, bD = /* @__PURE__ */ U({
    name: "RefreshLeft",
    __name: "refresh-left",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M289.088 296.704h92.992a32 32 0 0 1 0 64H232.96a32 32 0 0 1-32-32V179.712a32 32 0 0 1 64 0v50.56a384 384 0 0 1 643.84 282.88 384 384 0 0 1-383.936 384 384 384 0 0 1-384-384h64a320 320 0 1 0 640 0 320 320 0 0 0-555.712-216.448z"
        })
      ]));
    }
  }), yD = bD, wD = /* @__PURE__ */ U({
    name: "RefreshRight",
    __name: "refresh-right",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M784.512 230.272v-50.56a32 32 0 1 1 64 0v149.056a32 32 0 0 1-32 32H667.52a32 32 0 1 1 0-64h92.992A320 320 0 1 0 524.8 833.152a320 320 0 0 0 320-320h64a384 384 0 0 1-384 384 384 384 0 0 1-384-384 384 384 0 0 1 643.712-282.88"
        })
      ]));
    }
  }), CD = wD, SD = /* @__PURE__ */ U({
    name: "ScaleToOriginal",
    __name: "scale-to-original",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M813.176 180.706a60.235 60.235 0 0 1 60.236 60.235v481.883a60.235 60.235 0 0 1-60.236 60.235H210.824a60.235 60.235 0 0 1-60.236-60.235V240.94a60.235 60.235 0 0 1 60.236-60.235h602.352zm0-60.235H210.824A120.47 120.47 0 0 0 90.353 240.94v481.883a120.47 120.47 0 0 0 120.47 120.47h602.353a120.47 120.47 0 0 0 120.471-120.47V240.94a120.47 120.47 0 0 0-120.47-120.47zm-120.47 180.705a30.12 30.12 0 0 0-30.118 30.118v301.177a30.118 30.118 0 0 0 60.236 0V331.294a30.12 30.12 0 0 0-30.118-30.118m-361.412 0a30.12 30.12 0 0 0-30.118 30.118v301.177a30.118 30.118 0 1 0 60.236 0V331.294a30.12 30.12 0 0 0-30.118-30.118M512 361.412a30.12 30.12 0 0 0-30.118 30.117v30.118a30.118 30.118 0 0 0 60.236 0V391.53A30.12 30.12 0 0 0 512 361.412M512 512a30.12 30.12 0 0 0-30.118 30.118v30.117a30.118 30.118 0 0 0 60.236 0v-30.117A30.12 30.12 0 0 0 512 512"
        })
      ]));
    }
  }), ED = SD, kD = /* @__PURE__ */ U({
    name: "Search",
    __name: "search",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704"
        })
      ]));
    }
  }), _D = kD, TD = /* @__PURE__ */ U({
    name: "SortDown",
    __name: "sort-down",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M576 96v709.568L333.312 562.816A32 32 0 1 0 288 608l297.408 297.344A32 32 0 0 0 640 882.688V96a32 32 0 0 0-64 0"
        })
      ]));
    }
  }), ND = TD, $D = /* @__PURE__ */ U({
    name: "SortUp",
    __name: "sort-up",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M384 141.248V928a32 32 0 1 0 64 0V218.56l242.688 242.688A32 32 0 1 0 736 416L438.592 118.656A32 32 0 0 0 384 141.248"
        })
      ]));
    }
  }), OD = $D, ID = /* @__PURE__ */ U({
    name: "StarFilled",
    __name: "star-filled",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M313.6 924.48a70.4 70.4 0 0 1-74.152-5.365 70.4 70.4 0 0 1-27.992-68.875l37.888-220.928L88.96 472.96a70.4 70.4 0 0 1 3.788-104.225A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 100.246-28.595 70.4 70.4 0 0 1 25.962 28.595l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
        })
      ]));
    }
  }), Ou = ID, MD = /* @__PURE__ */ U({
    name: "Star",
    __name: "star",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "m512 747.84 228.16 119.936a6.4 6.4 0 0 0 9.28-6.72l-43.52-254.08 184.512-179.904a6.4 6.4 0 0 0-3.52-10.88l-255.104-37.12L517.76 147.904a6.4 6.4 0 0 0-11.52 0L392.192 379.072l-255.104 37.12a6.4 6.4 0 0 0-3.52 10.88L318.08 606.976l-43.584 254.08a6.4 6.4 0 0 0 9.28 6.72zM313.6 924.48a70.4 70.4 0 0 1-102.144-74.24l37.888-220.928L88.96 472.96A70.4 70.4 0 0 1 128 352.896l221.76-32.256 99.2-200.96a70.4 70.4 0 0 1 126.208 0l99.2 200.96 221.824 32.256a70.4 70.4 0 0 1 39.04 120.064L774.72 629.376l37.888 220.928a70.4 70.4 0 0 1-102.144 74.24L512 820.096l-198.4 104.32z"
        })
      ]));
    }
  }), xD = MD, PD = /* @__PURE__ */ U({
    name: "SuccessFilled",
    __name: "success-filled",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.27 38.27 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336z"
        })
      ]));
    }
  }), wC = PD, RD = /* @__PURE__ */ U({
    name: "View",
    __name: "view",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352m0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288m0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448m0 64a160.19 160.19 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160"
        })
      ]));
    }
  }), DD = RD, AD = /* @__PURE__ */ U({
    name: "WarningFilled",
    __name: "warning-filled",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896m0 192a58.43 58.43 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.43 58.43 0 0 0 512 256m0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4"
        })
      ]));
    }
  }), Rd = AD, VD = /* @__PURE__ */ U({
    name: "ZoomIn",
    __name: "zoom-in",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704m-32-384v-96a32 32 0 0 1 64 0v96h96a32 32 0 0 1 0 64h-96v96a32 32 0 0 1-64 0v-96h-96a32 32 0 0 1 0-64z"
        })
      ]));
    }
  }), CC = VD, LD = /* @__PURE__ */ U({
    name: "ZoomOut",
    __name: "zoom-out",
    setup(e) {
      return (t, n) => (_(), B("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [
        W("path", {
          fill: "currentColor",
          d: "m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704M352 448h256a32 32 0 0 1 0 64H352a32 32 0 0 1 0-64"
        })
      ]));
    }
  }), BD = LD;
  const Lt = X([
    String,
    Object,
    Function
  ]), SC = {
    Close: Oo
  }, ph = {
    Close: Oo,
    SuccessFilled: wC,
    InfoFilled: Si,
    WarningFilled: Rd,
    CircleCloseFilled: fh
  }, Ma = {
    primary: Si,
    success: wC,
    warning: Rd,
    error: fh,
    info: Si
  }, Dd = {
    validating: Cl,
    success: dh,
    error: oa
  }, FD = ["light", "dark"], zD = Te({
    title: {
      type: String,
      default: ""
    },
    description: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      values: Ci(Ma),
      default: "info"
    },
    closable: {
      type: Boolean,
      default: !0
    },
    closeText: {
      type: String,
      default: ""
    },
    showIcon: Boolean,
    center: Boolean,
    effect: {
      type: String,
      values: FD,
      default: "light"
    },
    ...hC,
    showAfter: Number
  }), HD = {
    open: () => !0,
    close: (e) => kt(e) || e instanceof Event
  }, KD = /* @__PURE__ */ U({
    name: "ElAlert"
  }), WD = /* @__PURE__ */ U({
    ...KD,
    props: zD,
    emits: HD,
    setup(e, { emit: t }) {
      const n = e, { Close: o } = ph, l = hn(), a = he("alert"), r = A(kt(n.showAfter)), i = S(() => Ma[n.type]), u = S(() => !!(n.description || l.default)), c = () => {
        r.value = !0, t("open");
      }, d = (p) => {
        r.value = !1, t("close", p);
      }, { onOpen: f, onClose: v } = mC({
        showAfter: At(n, "showAfter", 0),
        hideAfter: At(n, "hideAfter"),
        autoClose: At(n, "autoClose"),
        open: c,
        close: d
      });
      return xt && f(), (p, m) => (_(), ae(Mn, {
        name: s(a).b("fade"),
        persisted: ""
      }, {
        default: Q(() => [
          it(W("div", {
            class: $([s(a).b(), s(a).m(p.type), s(a).is("center", p.center), s(a).is(p.effect)]),
            role: "alert"
          }, [
            p.showIcon && (p.$slots.icon || s(i)) ? (_(), ae(s(ze), {
              key: 0,
              class: $([s(a).e("icon"), s(a).is("big", s(u))])
            }, {
              default: Q(() => [
                ee(p.$slots, "icon", {}, () => [
                  (_(), ae(ct(s(i))))
                ])
              ]),
              _: 3
            }, 8, ["class"])) : oe("v-if", !0),
            W("div", {
              class: $(s(a).e("content"))
            }, [
              p.title || p.$slots.title ? (_(), B("span", {
                key: 0,
                class: $([s(a).e("title"), { "with-description": s(u) }])
              }, [
                ee(p.$slots, "title", {}, () => [
                  Ct(ke(p.title), 1)
                ])
              ], 2)) : oe("v-if", !0),
              s(u) ? (_(), B("p", {
                key: 1,
                class: $(s(a).e("description"))
              }, [
                ee(p.$slots, "default", {}, () => [
                  Ct(ke(p.description), 1)
                ])
              ], 2)) : oe("v-if", !0),
              p.closable ? (_(), B(We, { key: 2 }, [
                p.closeText ? (_(), B("div", {
                  key: 0,
                  class: $([s(a).e("close-btn"), s(a).is("customed")]),
                  onClick: d
                }, ke(p.closeText), 3)) : (_(), ae(s(ze), {
                  key: 1,
                  class: $(s(a).e("close-btn")),
                  onClick: s(v)
                }, {
                  default: Q(() => [
                    q(s(o))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"]))
              ], 64)) : oe("v-if", !0)
            ], 2)
          ], 2), [
            [Mt, r.value]
          ])
        ]),
        _: 3
      }, 8, ["name"]));
    }
  });
  var jD = /* @__PURE__ */ Ne(WD, [["__file", "alert.vue"]]);
  const UD = rt(jD), vh = () => xt && /firefox/i.test(window.navigator.userAgent), EC = () => xt && /android/i.test(window.navigator.userAgent);
  let lo;
  const YD = {
    height: "0",
    visibility: "hidden",
    overflow: vh() ? "" : "hidden",
    position: "absolute",
    "z-index": "-1000",
    top: "0",
    right: "0"
  }, qD = [
    "letter-spacing",
    "line-height",
    "padding-top",
    "padding-bottom",
    "font-family",
    "font-weight",
    "font-size",
    "text-rendering",
    "text-transform",
    "width",
    "text-indent",
    "padding-left",
    "padding-right",
    "border-width",
    "box-sizing",
    "word-break"
  ], Eb = (e) => {
    const t = Number.parseFloat(e);
    return Number.isNaN(t) ? e : t;
  };
  function GD(e) {
    const t = window.getComputedStyle(e), n = t.getPropertyValue("box-sizing"), o = Number.parseFloat(t.getPropertyValue("padding-bottom")) + Number.parseFloat(t.getPropertyValue("padding-top")), l = Number.parseFloat(t.getPropertyValue("border-bottom-width")) + Number.parseFloat(t.getPropertyValue("border-top-width"));
    return { contextStyle: qD.map((r) => [
      r,
      t.getPropertyValue(r)
    ]), paddingSize: o, borderSize: l, boxSizing: n };
  }
  function kb(e, t = 1, n) {
    var o, l;
    lo || (lo = document.createElement("textarea"), ((o = e.parentNode) != null ? o : document.body).appendChild(lo));
    const { paddingSize: a, borderSize: r, boxSizing: i, contextStyle: u } = GD(e);
    u.forEach(([v, p]) => lo == null ? void 0 : lo.style.setProperty(v, p)), Object.entries(YD).forEach(([v, p]) => lo == null ? void 0 : lo.style.setProperty(v, p, "important")), lo.value = e.value || e.placeholder || "";
    let c = lo.scrollHeight;
    const d = {};
    i === "border-box" ? c = c + r : i === "content-box" && (c = c - a), lo.value = "";
    const f = lo.scrollHeight - a;
    if (je(t)) {
      let v = f * t;
      i === "border-box" && (v = v + a + r), c = Math.max(v, c), d.minHeight = `${v}px`;
    }
    if (je(n)) {
      let v = f * n;
      i === "border-box" && (v = v + a + r), c = Math.min(v, c);
    }
    return d.height = `${c}px`, (l = lo.parentNode) == null || l.removeChild(lo), lo = void 0, d;
  }
  const en = (e) => e, XD = Te({
    ariaLabel: String,
    ariaOrientation: {
      type: String,
      values: ["horizontal", "vertical", "undefined"]
    },
    ariaControls: String
  }), Yn = (e) => jl(XD, e), lu = Te({
    id: {
      type: String,
      default: void 0
    },
    size: mn,
    disabled: Boolean,
    modelValue: {
      type: X([
        String,
        Number,
        Object
      ]),
      default: ""
    },
    modelModifiers: {
      type: X(Object),
      default: () => ({})
    },
    maxlength: {
      type: [String, Number]
    },
    minlength: {
      type: [String, Number]
    },
    type: {
      type: X(String),
      default: "text"
    },
    resize: {
      type: String,
      values: ["none", "both", "horizontal", "vertical"]
    },
    autosize: {
      type: X([Boolean, Object]),
      default: !1
    },
    autocomplete: {
      type: X(String),
      default: "off"
    },
    formatter: {
      type: Function
    },
    parser: {
      type: Function
    },
    placeholder: {
      type: String
    },
    form: {
      type: String
    },
    readonly: Boolean,
    clearable: Boolean,
    clearIcon: {
      type: Lt,
      default: oa
    },
    showPassword: Boolean,
    showWordLimit: Boolean,
    wordLimitPosition: {
      type: String,
      values: ["inside", "outside"],
      default: "inside"
    },
    suffixIcon: {
      type: Lt
    },
    prefixIcon: {
      type: Lt
    },
    containerRole: {
      type: String,
      default: void 0
    },
    tabindex: {
      type: [String, Number],
      default: 0
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    inputStyle: {
      type: X([Object, Array, String]),
      default: () => en({})
    },
    autofocus: Boolean,
    rows: {
      type: Number,
      default: 2
    },
    ...Yn(["ariaLabel"]),
    inputmode: {
      type: X(String),
      default: void 0
    },
    name: String
  }), JD = {
    [et]: (e) => Ae(e),
    input: (e) => Ae(e),
    change: (e) => Ae(e),
    focus: (e) => e instanceof FocusEvent,
    blur: (e) => e instanceof FocusEvent,
    clear: () => !0,
    mouseleave: (e) => e instanceof MouseEvent,
    mouseenter: (e) => e instanceof MouseEvent,
    keydown: (e) => e instanceof Event,
    compositionstart: (e) => e instanceof CompositionEvent,
    compositionupdate: (e) => e instanceof CompositionEvent,
    compositionend: (e) => e instanceof CompositionEvent
  }, ZD = ["class", "style"], QD = /^on[A-Z]/, Ad = (e = {}) => {
    const { excludeListeners: t = !1, excludeKeys: n } = e, o = S(() => ((n == null ? void 0 : n.value) || []).concat(ZD)), l = dt();
    return l ? S(() => {
      var a;
      return wi(Object.entries((a = l.proxy) == null ? void 0 : a.$attrs).filter(([r]) => !o.value.includes(r) && !(t && QD.test(r))));
    }) : (vt("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function"), S(() => ({})));
  }, yp = {
    prefix: Math.floor(Math.random() * 1e4),
    current: 0
  }, eA = Symbol("elIdInjection"), hh = () => dt() ? Ve(eA, yp) : yp, xn = (e) => {
    const t = hh();
    !xt && t === yp && vt("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
    const n = Hv();
    return Vc(() => s(e) || `${n.value}-id-${t.prefix}-${t.current++}`);
  }, Sr = Symbol("formContextKey"), Sl = Symbol("formItemContextKey"), Nn = () => {
    const e = Ve(Sr, void 0), t = Ve(Sl, void 0);
    return {
      form: e,
      formItem: t
    };
  }, wo = (e, {
    formItemContext: t,
    disableIdGeneration: n,
    disableIdManagement: o
  }) => {
    n || (n = A(!1)), o || (o = A(!1));
    const l = dt(), a = () => {
      let c = l == null ? void 0 : l.parent;
      for (; c; ) {
        if (c.type.name === "ElFormItem")
          return !1;
        if (c.type.name === "ElLabelWrap")
          return !0;
        c = c.parent;
      }
      return !1;
    }, r = A();
    let i;
    const u = S(() => {
      var c;
      return !!(!(e.label || e.ariaLabel) && t && t.inputIds && ((c = t.inputIds) == null ? void 0 : c.length) <= 1);
    });
    return ft(() => {
      i = de([At(e, "id"), n], ([c, d]) => {
        const f = c ?? (d ? void 0 : xn().value);
        f !== r.value && (t != null && t.removeInputId && !a() && (r.value && t.removeInputId(r.value), !(o != null && o.value) && !d && f && t.addInputId(f)), r.value = f);
      }, { immediate: !0 });
    }), bs(() => {
      i && i(), t != null && t.removeInputId && r.value && t.removeInputId(r.value);
    }), {
      isLabeledByFormItem: u,
      inputId: r
    };
  }, kC = (e) => {
    const t = dt();
    return S(() => {
      var n, o;
      return (o = (n = t == null ? void 0 : t.proxy) == null ? void 0 : n.$props) == null ? void 0 : o[e];
    });
  }, vn = (e, t = {}) => {
    const n = A(void 0), o = t.prop ? n : kC("size"), l = t.global ? n : sC(), a = t.form ? { size: void 0 } : Ve(Sr, void 0), r = t.formItem ? { size: void 0 } : Ve(Sl, void 0);
    return S(() => o.value || s(e) || (r == null ? void 0 : r.size) || (a == null ? void 0 : a.size) || l.value || "");
  }, Cn = (e) => {
    const t = kC("disabled"), n = Ve(Sr, void 0);
    return S(() => t.value || s(e) || (n == null ? void 0 : n.disabled) || !1);
  }, tA = 'a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])', _b = (e) => typeof Element > "u" ? !1 : e instanceof Element, nA = (e) => typeof process < "u" && process.env.NODE_ENV === "test" ? !0 : getComputedStyle(e).position === "fixed" ? !1 : e.offsetParent !== null, Tb = (e) => Array.from(e.querySelectorAll(tA)).filter((t) => Ei(t) && nA(t)), Ei = (e) => {
    if (e.tabIndex > 0 || e.tabIndex === 0 && e.getAttribute("tabIndex") !== null)
      return !0;
    if (e.tabIndex < 0 || e.hasAttribute("disabled") || e.getAttribute("aria-disabled") === "true")
      return !1;
    switch (e.nodeName) {
      case "A":
        return !!e.href && e.rel !== "ignore";
      case "INPUT":
        return !(e.type === "hidden" || e.type === "file");
      case "BUTTON":
      case "SELECT":
      case "TEXTAREA":
        return !0;
      default:
        return !1;
    }
  }, Qu = function(e, t, ...n) {
    let o;
    t.includes("mouse") || t.includes("click") ? o = "MouseEvents" : t.includes("key") ? o = "KeyboardEvent" : o = "HTMLEvents";
    const l = document.createEvent(o);
    return l.initEvent(t, ...n), e.dispatchEvent(l), e;
  }, _C = (e) => !e.getAttribute("aria-owns"), TC = (e, t, n) => {
    const { parentNode: o } = e;
    if (!o)
      return null;
    const l = o.querySelectorAll(n), a = Array.prototype.indexOf.call(l, e);
    return l[a + t] || null;
  }, au = (e, t) => {
    if (!e || !e.focus)
      return;
    let n = !1;
    _b(e) && !Ei(e) && !e.getAttribute("tabindex") && (e.setAttribute("tabindex", "-1"), n = !0), e.focus(t), _b(e) && n && e.removeAttribute("tabindex");
  }, ec = (e) => {
    e && (au(e), !_C(e) && e.click());
  };
  function la(e, {
    disabled: t,
    beforeFocus: n,
    afterFocus: o,
    beforeBlur: l,
    afterBlur: a
  } = {}) {
    const r = dt(), { emit: i } = r, u = Ut(), c = A(!1), d = (p) => {
      const m = Fe(n) ? n(p) : !1;
      s(t) || c.value || m || (c.value = !0, i("focus", p), o == null || o());
    }, f = (p) => {
      var m;
      const h = Fe(l) ? l(p) : !1;
      s(t) || p.relatedTarget && ((m = u.value) != null && m.contains(p.relatedTarget)) || h || (c.value = !1, i("blur", p), a == null || a());
    }, v = (p) => {
      var m, h;
      s(t) || Ei(p.target) || (m = u.value) != null && m.contains(document.activeElement) && u.value !== document.activeElement || (h = e.value) == null || h.focus();
    };
    return de([u, () => s(t)], ([p, m]) => {
      p && (m ? p.removeAttribute("tabindex") : p.setAttribute("tabindex", "-1"));
    }), Dt(u, "focus", d, !0), Dt(u, "blur", f, !0), Dt(u, "click", v, !0), typeof process < "u" && process.env.NODE_ENV === "test" && ft(() => {
      const p = Qn(e.value) ? e.value : document.querySelector("input,textarea");
      p && (Dt(p, "focus", d, !0), Dt(p, "blur", f, !0));
    }), {
      isFocused: c,
      wrapperRef: u,
      handleFocus: d,
      handleBlur: f
    };
  }
  const oA = (e) => /([\uAC00-\uD7AF\u3130-\u318F])+/gi.test(e);
  function ru({
    afterComposition: e,
    emit: t
  }) {
    const n = A(!1), o = (i) => {
      t == null || t("compositionstart", i), n.value = !0;
    }, l = (i) => {
      var u;
      t == null || t("compositionupdate", i);
      const c = (u = i.target) == null ? void 0 : u.value, d = c[c.length - 1] || "";
      n.value = !oA(d);
    }, a = (i) => {
      t == null || t("compositionend", i), n.value && (n.value = !1, Re(() => e(i)));
    };
    return {
      isComposing: n,
      handleComposition: (i) => {
        i.type === "compositionend" ? a(i) : l(i);
      },
      handleCompositionStart: o,
      handleCompositionUpdate: l,
      handleCompositionEnd: a
    };
  }
  function lA(e) {
    let t;
    function n() {
      if (e.value == null)
        return;
      const { selectionStart: l, selectionEnd: a, value: r } = e.value;
      if (l == null || a == null)
        return;
      const i = r.slice(0, Math.max(0, l)), u = r.slice(Math.max(0, a));
      t = {
        selectionStart: l,
        selectionEnd: a,
        value: r,
        beforeTxt: i,
        afterTxt: u
      };
    }
    function o() {
      if (e.value == null || t == null)
        return;
      const { value: l } = e.value, { beforeTxt: a, afterTxt: r, selectionStart: i } = t;
      if (a == null || r == null || i == null)
        return;
      let u = l.length;
      if (l.endsWith(r))
        u = l.length - r.length;
      else if (l.startsWith(a))
        u = a.length;
      else {
        const c = a[i - 1], d = l.indexOf(c, i - 1);
        d !== -1 && (u = d + 1);
      }
      e.value.setSelectionRange(u, u);
    }
    return [n, o];
  }
  const NC = "ElInput", aA = /* @__PURE__ */ U({
    name: NC,
    inheritAttrs: !1
  }), rA = /* @__PURE__ */ U({
    ...aA,
    props: lu,
    emits: JD,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = ea(), a = Ad(), r = hn(), i = S(() => [
        o.type === "textarea" ? h.b() : m.b(),
        m.m(v.value),
        m.is("disabled", p.value),
        m.is("exceed", H.value),
        {
          [m.b("group")]: r.prepend || r.append,
          [m.m("prefix")]: r.prefix || o.prefixIcon,
          [m.m("suffix")]: r.suffix || o.suffixIcon || o.clearable || o.showPassword,
          [m.bm("suffix", "password-clear")]: D.value && L.value,
          [m.b("hidden")]: o.type === "hidden"
        },
        l.class
      ]), u = S(() => [
        m.e("wrapper"),
        m.is("focus", x.value)
      ]), { form: c, formItem: d } = Nn(), { inputId: f } = wo(o, {
        formItemContext: d
      }), v = vn(), p = Cn(), m = he("input"), h = he("textarea"), g = Ut(), b = Ut(), C = A(!1), w = A(!1), y = A(), E = Ut(o.inputStyle), k = S(() => g.value || b.value), { wrapperRef: T, isFocused: x, handleFocus: I, handleBlur: P } = la(k, {
        disabled: p,
        afterBlur() {
          var pe;
          o.validateEvent && ((pe = d == null ? void 0 : d.validate) == null || pe.call(d, "blur").catch((Le) => vt(Le)));
        }
      }), O = S(() => {
        var pe;
        return (pe = c == null ? void 0 : c.statusIcon) != null ? pe : !1;
      }), N = S(() => (d == null ? void 0 : d.validateState) || ""), z = S(() => N.value && Dd[N.value]), Y = S(() => w.value ? DD : aD), G = S(() => [
        l.style
      ]), M = S(() => [
        o.inputStyle,
        E.value,
        { resize: o.resize }
      ]), R = S(() => cn(o.modelValue) ? "" : String(o.modelValue)), D = S(() => o.clearable && !p.value && !o.readonly && !!R.value && (x.value || C.value)), L = S(() => o.showPassword && !p.value && !!R.value), V = S(() => o.showWordLimit && !!o.maxlength && (o.type === "text" || o.type === "textarea") && !p.value && !o.readonly && !o.showPassword), F = S(() => R.value.length), H = S(() => !!V.value && F.value > Number(o.maxlength)), K = S(() => !!r.suffix || !!o.suffixIcon || D.value || o.showPassword || V.value || !!N.value && O.value), Z = S(() => !!Object.keys(o.modelModifiers).length), [J, ie] = lA(g);
      qt(b, (pe) => {
        if (se(), !V.value || o.resize !== "both")
          return;
        const Le = pe[0], { width: Xe } = Le.contentRect;
        y.value = {
          right: `calc(100% - ${Xe + 15 + 6}px)`
        };
      });
      const ue = () => {
        const { type: pe, autosize: Le } = o;
        if (!(!xt || pe !== "textarea" || !b.value))
          if (Le) {
            const Xe = ot(Le) ? Le.minRows : void 0, ut = ot(Le) ? Le.maxRows : void 0, Nt = kb(b.value, Xe, ut);
            E.value = {
              overflowY: "hidden",
              ...Nt
            }, Re(() => {
              b.value.offsetHeight, E.value = Nt;
            });
          } else
            E.value = {
              minHeight: kb(b.value).minHeight
            };
      }, se = ((pe) => {
        let Le = !1;
        return () => {
          var Xe;
          if (Le || !o.autosize)
            return;
          ((Xe = b.value) == null ? void 0 : Xe.offsetParent) === null || (setTimeout(pe), Le = !0);
        };
      })(ue), ne = () => {
        const pe = k.value, Le = o.formatter ? o.formatter(R.value) : R.value;
        !pe || pe.value === Le || (pe.value = Le);
      }, le = (pe) => {
        const { trim: Le, number: Xe } = o.modelModifiers;
        return Le && (pe = pe.trim()), Xe && (pe = `${Eb(pe)}`), o.formatter && o.parser && (pe = o.parser(pe)), pe;
      }, Ce = async (pe) => {
        if (te.value)
          return;
        const { lazy: Le } = o.modelModifiers;
        let { value: Xe } = pe.target;
        if (Le) {
          n(fn, Xe);
          return;
        }
        if (Xe = le(Xe), String(Xe) === R.value) {
          o.formatter && ne();
          return;
        }
        J(), n(et, Xe), n(fn, Xe), await Re(), (o.formatter && o.parser || !Z.value) && ne(), ie();
      }, j = async (pe) => {
        let { value: Le } = pe.target;
        Le = le(Le), o.modelModifiers.lazy && n(et, Le), n(gt, Le), await Re(), ne();
      }, {
        isComposing: te,
        handleCompositionStart: ce,
        handleCompositionUpdate: ge,
        handleCompositionEnd: be
      } = ru({ emit: n, afterComposition: Ce }), Ee = () => {
        w.value = !w.value;
      }, Oe = () => {
        var pe;
        return (pe = k.value) == null ? void 0 : pe.focus();
      }, De = () => {
        var pe;
        return (pe = k.value) == null ? void 0 : pe.blur();
      }, we = (pe) => {
        C.value = !1, n("mouseleave", pe);
      }, me = (pe) => {
        C.value = !0, n("mouseenter", pe);
      }, Pe = (pe) => {
        n("keydown", pe);
      }, Me = () => {
        var pe;
        (pe = k.value) == null || pe.select();
      }, Be = () => {
        n(et, ""), n(gt, ""), n("clear"), n(fn, "");
      };
      return de(() => o.modelValue, () => {
        var pe;
        Re(() => ue()), o.validateEvent && ((pe = d == null ? void 0 : d.validate) == null || pe.call(d, "change").catch((Le) => vt(Le)));
      }), de(R, (pe) => {
        if (!k.value)
          return;
        const { trim: Le, number: Xe } = o.modelModifiers, ut = k.value.value, Nt = (Xe || o.type === "number") && !/^0\d/.test(ut) ? `${Eb(ut)}` : ut;
        Nt !== pe && (document.activeElement === k.value && k.value.type !== "range" && Le && Nt.trim() === pe || ne());
      }), de(() => o.type, async () => {
        await Re(), ne(), ue();
      }), ft(() => {
        !o.formatter && o.parser && vt(NC, "If you set the parser, you also need to set the formatter."), ne(), Re(ue);
      }), t({
        input: g,
        textarea: b,
        ref: k,
        textareaStyle: M,
        autosize: At(o, "autosize"),
        isComposing: te,
        focus: Oe,
        blur: De,
        select: Me,
        clear: Be,
        resizeTextarea: ue
      }), (pe, Le) => (_(), B("div", {
        class: $([
          s(i),
          {
            [s(m).bm("group", "append")]: pe.$slots.append,
            [s(m).bm("group", "prepend")]: pe.$slots.prepend
          }
        ]),
        style: Ue(s(G)),
        onMouseenter: me,
        onMouseleave: we
      }, [
        oe(" input "),
        pe.type !== "textarea" ? (_(), B(We, { key: 0 }, [
          oe(" prepend slot "),
          pe.$slots.prepend ? (_(), B("div", {
            key: 0,
            class: $(s(m).be("group", "prepend"))
          }, [
            ee(pe.$slots, "prepend")
          ], 2)) : oe("v-if", !0),
          W("div", {
            ref_key: "wrapperRef",
            ref: T,
            class: $(s(u))
          }, [
            oe(" prefix slot "),
            pe.$slots.prefix || pe.prefixIcon ? (_(), B("span", {
              key: 0,
              class: $(s(m).e("prefix"))
            }, [
              W("span", {
                class: $(s(m).e("prefix-inner"))
              }, [
                ee(pe.$slots, "prefix"),
                pe.prefixIcon ? (_(), ae(s(ze), {
                  key: 0,
                  class: $(s(m).e("icon"))
                }, {
                  default: Q(() => [
                    (_(), ae(ct(pe.prefixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : oe("v-if", !0)
              ], 2)
            ], 2)) : oe("v-if", !0),
            W("input", pt({
              id: s(f),
              ref_key: "input",
              ref: g,
              class: s(m).e("inner")
            }, s(a), {
              name: pe.name,
              minlength: pe.minlength,
              maxlength: pe.maxlength,
              type: pe.showPassword ? w.value ? "text" : "password" : pe.type,
              disabled: s(p),
              readonly: pe.readonly,
              autocomplete: pe.autocomplete,
              tabindex: pe.tabindex,
              "aria-label": pe.ariaLabel,
              placeholder: pe.placeholder,
              style: pe.inputStyle,
              form: pe.form,
              autofocus: pe.autofocus,
              role: pe.containerRole,
              inputmode: pe.inputmode,
              onCompositionstart: s(ce),
              onCompositionupdate: s(ge),
              onCompositionend: s(be),
              onInput: Ce,
              onChange: j,
              onKeydown: Pe
            }), null, 16, ["id", "name", "minlength", "maxlength", "type", "disabled", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder", "form", "autofocus", "role", "inputmode", "onCompositionstart", "onCompositionupdate", "onCompositionend"]),
            oe(" suffix slot "),
            s(K) ? (_(), B("span", {
              key: 1,
              class: $(s(m).e("suffix"))
            }, [
              W("span", {
                class: $(s(m).e("suffix-inner"))
              }, [
                !s(D) || !s(L) || !s(V) ? (_(), B(We, { key: 0 }, [
                  ee(pe.$slots, "suffix"),
                  pe.suffixIcon ? (_(), ae(s(ze), {
                    key: 0,
                    class: $(s(m).e("icon"))
                  }, {
                    default: Q(() => [
                      (_(), ae(ct(pe.suffixIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : oe("v-if", !0)
                ], 64)) : oe("v-if", !0),
                s(D) ? (_(), ae(s(ze), {
                  key: 1,
                  class: $([s(m).e("icon"), s(m).e("clear")]),
                  onMousedown: Ze(s(It), ["prevent"]),
                  onClick: Be
                }, {
                  default: Q(() => [
                    (_(), ae(ct(pe.clearIcon)))
                  ]),
                  _: 1
                }, 8, ["class", "onMousedown"])) : oe("v-if", !0),
                s(L) ? (_(), ae(s(ze), {
                  key: 2,
                  class: $([s(m).e("icon"), s(m).e("password")]),
                  onClick: Ee,
                  onMousedown: Ze(s(It), ["prevent"]),
                  onMouseup: Ze(s(It), ["prevent"])
                }, {
                  default: Q(() => [
                    (_(), ae(ct(s(Y))))
                  ]),
                  _: 1
                }, 8, ["class", "onMousedown", "onMouseup"])) : oe("v-if", !0),
                s(V) ? (_(), B("span", {
                  key: 3,
                  class: $([
                    s(m).e("count"),
                    s(m).is("outside", pe.wordLimitPosition === "outside")
                  ])
                }, [
                  W("span", {
                    class: $(s(m).e("count-inner"))
                  }, ke(s(F)) + " / " + ke(pe.maxlength), 3)
                ], 2)) : oe("v-if", !0),
                s(N) && s(z) && s(O) ? (_(), ae(s(ze), {
                  key: 4,
                  class: $([
                    s(m).e("icon"),
                    s(m).e("validateIcon"),
                    s(m).is("loading", s(N) === "validating")
                  ])
                }, {
                  default: Q(() => [
                    (_(), ae(ct(s(z))))
                  ]),
                  _: 1
                }, 8, ["class"])) : oe("v-if", !0)
              ], 2)
            ], 2)) : oe("v-if", !0)
          ], 2),
          oe(" append slot "),
          pe.$slots.append ? (_(), B("div", {
            key: 1,
            class: $(s(m).be("group", "append"))
          }, [
            ee(pe.$slots, "append")
          ], 2)) : oe("v-if", !0)
        ], 64)) : (_(), B(We, { key: 1 }, [
          oe(" textarea "),
          W("textarea", pt({
            id: s(f),
            ref_key: "textarea",
            ref: b,
            class: [s(h).e("inner"), s(m).is("focus", s(x))]
          }, s(a), {
            name: pe.name,
            minlength: pe.minlength,
            maxlength: pe.maxlength,
            tabindex: pe.tabindex,
            disabled: s(p),
            readonly: pe.readonly,
            autocomplete: pe.autocomplete,
            style: s(M),
            "aria-label": pe.ariaLabel,
            placeholder: pe.placeholder,
            form: pe.form,
            autofocus: pe.autofocus,
            rows: pe.rows,
            role: pe.containerRole,
            onCompositionstart: s(ce),
            onCompositionupdate: s(ge),
            onCompositionend: s(be),
            onInput: Ce,
            onFocus: s(I),
            onBlur: s(P),
            onChange: j,
            onKeydown: Pe
          }), null, 16, ["id", "name", "minlength", "maxlength", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder", "form", "autofocus", "rows", "role", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onFocus", "onBlur"]),
          s(V) ? (_(), B("span", {
            key: 0,
            style: Ue(y.value),
            class: $([
              s(m).e("count"),
              s(m).is("outside", pe.wordLimitPosition === "outside")
            ])
          }, ke(s(F)) + " / " + ke(pe.maxlength), 7)) : oe("v-if", !0)
        ], 64))
      ], 38));
    }
  });
  var sA = /* @__PURE__ */ Ne(rA, [["__file", "input.vue"]]);
  const Wn = rt(sA), Nr = 4, $C = {
    vertical: {
      offset: "offsetHeight",
      scroll: "scrollTop",
      scrollSize: "scrollHeight",
      size: "height",
      key: "vertical",
      axis: "Y",
      client: "clientY",
      direction: "top"
    },
    horizontal: {
      offset: "offsetWidth",
      scroll: "scrollLeft",
      scrollSize: "scrollWidth",
      size: "width",
      key: "horizontal",
      axis: "X",
      client: "clientX",
      direction: "left"
    }
  }, iA = ({
    move: e,
    size: t,
    bar: n
  }) => ({
    [n.size]: t,
    transform: `translate${n.axis}(${e}%)`
  }), mh = Symbol("scrollbarContextKey"), uA = Te({
    vertical: Boolean,
    size: String,
    move: Number,
    ratio: {
      type: Number,
      required: !0
    },
    always: Boolean
  }), cA = "Thumb", dA = /* @__PURE__ */ U({
    __name: "thumb",
    props: uA,
    setup(e) {
      const t = e, n = Ve(mh), o = he("scrollbar");
      n || Zt(cA, "can not inject scrollbar context");
      const l = A(), a = A(), r = A({}), i = A(!1);
      let u = !1, c = !1, d = 0, f = 0, v = xt ? document.onselectstart : null;
      const p = S(() => $C[t.vertical ? "vertical" : "horizontal"]), m = S(() => iA({
        size: t.size,
        move: t.move,
        bar: p.value
      })), h = S(() => l.value[p.value.offset] ** 2 / n.wrapElement[p.value.scrollSize] / t.ratio / a.value[p.value.offset]), g = (x) => {
        var I;
        if (x.stopPropagation(), x.ctrlKey || [1, 2].includes(x.button))
          return;
        (I = window.getSelection()) == null || I.removeAllRanges(), C(x);
        const P = x.currentTarget;
        P && (r.value[p.value.axis] = P[p.value.offset] - (x[p.value.client] - P.getBoundingClientRect()[p.value.direction]));
      }, b = (x) => {
        if (!a.value || !l.value || !n.wrapElement)
          return;
        const I = Math.abs(x.target.getBoundingClientRect()[p.value.direction] - x[p.value.client]), P = a.value[p.value.offset] / 2, O = (I - P) * 100 * h.value / l.value[p.value.offset];
        n.wrapElement[p.value.scroll] = O * n.wrapElement[p.value.scrollSize] / 100;
      }, C = (x) => {
        x.stopImmediatePropagation(), u = !0, d = n.wrapElement.scrollHeight, f = n.wrapElement.scrollWidth, document.addEventListener("mousemove", w), document.addEventListener("mouseup", y), v = document.onselectstart, document.onselectstart = () => !1;
      }, w = (x) => {
        if (!l.value || !a.value || u === !1)
          return;
        const I = r.value[p.value.axis];
        if (!I)
          return;
        const P = (l.value.getBoundingClientRect()[p.value.direction] - x[p.value.client]) * -1, O = a.value[p.value.offset] - I, N = (P - O) * 100 * h.value / l.value[p.value.offset];
        p.value.scroll === "scrollLeft" ? n.wrapElement[p.value.scroll] = N * f / 100 : n.wrapElement[p.value.scroll] = N * d / 100;
      }, y = () => {
        u = !1, r.value[p.value.axis] = 0, document.removeEventListener("mousemove", w), document.removeEventListener("mouseup", y), T(), c && (i.value = !1);
      }, E = () => {
        c = !1, i.value = !!t.size;
      }, k = () => {
        c = !0, i.value = u;
      };
      Bt(() => {
        T(), document.removeEventListener("mouseup", y);
      });
      const T = () => {
        document.onselectstart !== v && (document.onselectstart = v);
      };
      return Dt(At(n, "scrollbarElement"), "mousemove", E), Dt(At(n, "scrollbarElement"), "mouseleave", k), (x, I) => (_(), ae(Mn, {
        name: s(o).b("fade"),
        persisted: ""
      }, {
        default: Q(() => [
          it(W("div", {
            ref_key: "instance",
            ref: l,
            class: $([s(o).e("bar"), s(o).is(s(p).key)]),
            onMousedown: b,
            onClick: Ze(() => {
            }, ["stop"])
          }, [
            W("div", {
              ref_key: "thumb",
              ref: a,
              class: $(s(o).e("thumb")),
              style: Ue(s(m)),
              onMousedown: g
            }, null, 38)
          ], 42, ["onClick"]), [
            [Mt, x.always || i.value]
          ])
        ]),
        _: 1
      }, 8, ["name"]));
    }
  });
  var Nb = /* @__PURE__ */ Ne(dA, [["__file", "thumb.vue"]]);
  const fA = Te({
    always: {
      type: Boolean,
      default: !0
    },
    minSize: {
      type: Number,
      required: !0
    }
  }), pA = /* @__PURE__ */ U({
    __name: "bar",
    props: fA,
    setup(e, { expose: t }) {
      const n = e, o = Ve(mh), l = A(0), a = A(0), r = A(""), i = A(""), u = A(1), c = A(1);
      return t({
        handleScroll: (v) => {
          if (v) {
            const p = v.offsetHeight - Nr, m = v.offsetWidth - Nr;
            a.value = v.scrollTop * 100 / p * u.value, l.value = v.scrollLeft * 100 / m * c.value;
          }
        },
        update: () => {
          const v = o == null ? void 0 : o.wrapElement;
          if (!v)
            return;
          const p = v.offsetHeight - Nr, m = v.offsetWidth - Nr, h = p ** 2 / v.scrollHeight, g = m ** 2 / v.scrollWidth, b = Math.max(h, n.minSize), C = Math.max(g, n.minSize);
          u.value = h / (p - h) / (b / (p - b)), c.value = g / (m - g) / (C / (m - C)), i.value = b + Nr < p ? `${b}px` : "", r.value = C + Nr < m ? `${C}px` : "";
        }
      }), (v, p) => (_(), B(We, null, [
        q(Nb, {
          move: l.value,
          ratio: c.value,
          size: r.value,
          always: v.always
        }, null, 8, ["move", "ratio", "size", "always"]),
        q(Nb, {
          move: a.value,
          ratio: u.value,
          size: i.value,
          vertical: "",
          always: v.always
        }, null, 8, ["move", "ratio", "size", "always"])
      ], 64));
    }
  });
  var vA = /* @__PURE__ */ Ne(pA, [["__file", "bar.vue"]]);
  const hA = Te({
    distance: {
      type: Number,
      default: 0
    },
    height: {
      type: [String, Number],
      default: ""
    },
    maxHeight: {
      type: [String, Number],
      default: ""
    },
    native: Boolean,
    wrapStyle: {
      type: X([String, Object, Array]),
      default: ""
    },
    wrapClass: {
      type: [String, Array],
      default: ""
    },
    viewClass: {
      type: [String, Array],
      default: ""
    },
    viewStyle: {
      type: [String, Array, Object],
      default: ""
    },
    noresize: Boolean,
    tag: {
      type: String,
      default: "div"
    },
    always: Boolean,
    minSize: {
      type: Number,
      default: 20
    },
    tabindex: {
      type: [String, Number],
      default: void 0
    },
    id: String,
    role: String,
    ...Yn(["ariaLabel", "ariaOrientation"])
  }), OC = {
    "end-reached": (e) => ["left", "right", "top", "bottom"].includes(e),
    scroll: ({
      scrollTop: e,
      scrollLeft: t
    }) => [e, t].every(je)
  }, wp = "ElScrollbar", mA = /* @__PURE__ */ U({
    name: wp
  }), gA = /* @__PURE__ */ U({
    ...mA,
    props: hA,
    emits: OC,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = he("scrollbar");
      let a, r, i, u = 0, c = 0, d = "";
      const f = {
        bottom: !1,
        top: !1,
        right: !1,
        left: !1
      }, v = A(), p = A(), m = A(), h = A(), g = S(() => {
        const O = {};
        return o.height && (O.height = tn(o.height)), o.maxHeight && (O.maxHeight = tn(o.maxHeight)), [o.wrapStyle, O];
      }), b = S(() => [
        o.wrapClass,
        l.e("wrap"),
        { [l.em("wrap", "hidden-default")]: !o.native }
      ]), C = S(() => [l.e("view"), o.viewClass]), w = (O) => {
        var N;
        return (N = f[O]) != null ? N : !1;
      }, y = {
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
      }, E = (O) => {
        const N = y[d];
        if (!N)
          return;
        const z = O[d], Y = O[N];
        z && !f[d] && (f[d] = !0), !Y && f[N] && (f[N] = !1);
      }, k = () => {
        var O;
        if (p.value) {
          (O = h.value) == null || O.handleScroll(p.value);
          const N = u, z = c;
          u = p.value.scrollTop, c = p.value.scrollLeft;
          const Y = {
            bottom: u + p.value.clientHeight >= p.value.scrollHeight - o.distance,
            top: u <= o.distance && N !== 0,
            right: c + p.value.clientWidth >= p.value.scrollWidth - o.distance && z !== c,
            left: c <= o.distance && z !== 0
          };
          if (n("scroll", {
            scrollTop: u,
            scrollLeft: c
          }), N !== u && (d = u > N ? "bottom" : "top"), z !== c && (d = c > z ? "right" : "left"), o.distance > 0) {
            if (w(d))
              return;
            E(Y);
          }
          Y[d] && n("end-reached", d);
        }
      };
      function T(O, N) {
        ot(O) ? p.value.scrollTo(O) : je(O) && je(N) && p.value.scrollTo(O, N);
      }
      const x = (O) => {
        if (!je(O)) {
          vt(wp, "value must be a number");
          return;
        }
        p.value.scrollTop = O;
      }, I = (O) => {
        if (!je(O)) {
          vt(wp, "value must be a number");
          return;
        }
        p.value.scrollLeft = O;
      }, P = () => {
        var O;
        (O = h.value) == null || O.update(), f[d] = !1;
      };
      return de(() => o.noresize, (O) => {
        O ? (a == null || a(), r == null || r(), i == null || i()) : ({ stop: a } = qt(m, P), { stop: r } = qt(p, P), i = Dt("resize", P));
      }, { immediate: !0 }), de(() => [o.maxHeight, o.height], () => {
        o.native || Re(() => {
          var O;
          P(), p.value && ((O = h.value) == null || O.handleScroll(p.value));
        });
      }), yt(mh, Rt({
        scrollbarElement: v,
        wrapElement: p
      })), hd(() => {
        p.value && (p.value.scrollTop = u, p.value.scrollLeft = c);
      }), ft(() => {
        o.native || Re(() => {
          P();
        });
      }), Qo(() => P()), t({
        wrapRef: p,
        update: P,
        scrollTo: T,
        setScrollTop: x,
        setScrollLeft: I,
        handleScroll: k
      }), (O, N) => (_(), B("div", {
        ref_key: "scrollbarRef",
        ref: v,
        class: $(s(l).b())
      }, [
        W("div", {
          ref_key: "wrapRef",
          ref: p,
          class: $(s(b)),
          style: Ue(s(g)),
          tabindex: O.tabindex,
          onScroll: k
        }, [
          (_(), ae(ct(O.tag), {
            id: O.id,
            ref_key: "resizeRef",
            ref: m,
            class: $(s(C)),
            style: Ue(O.viewStyle),
            role: O.role,
            "aria-label": O.ariaLabel,
            "aria-orientation": O.ariaOrientation
          }, {
            default: Q(() => [
              ee(O.$slots, "default")
            ]),
            _: 3
          }, 8, ["id", "class", "style", "role", "aria-label", "aria-orientation"]))
        ], 46, ["tabindex"]),
        O.native ? oe("v-if", !0) : (_(), ae(vA, {
          key: 0,
          ref_key: "barRef",
          ref: h,
          always: O.always,
          "min-size": O.minSize
        }, null, 8, ["always", "min-size"]))
      ], 2));
    }
  });
  var bA = /* @__PURE__ */ Ne(gA, [["__file", "scrollbar.vue"]]);
  const Go = rt(bA), gh = Symbol("popper"), IC = Symbol("popperContent"), MC = [
    "dialog",
    "grid",
    "group",
    "listbox",
    "menu",
    "navigation",
    "tooltip",
    "tree"
  ], xC = Te({
    role: {
      type: String,
      values: MC,
      default: "tooltip"
    }
  }), yA = /* @__PURE__ */ U({
    name: "ElPopper",
    inheritAttrs: !1
  }), wA = /* @__PURE__ */ U({
    ...yA,
    props: xC,
    setup(e, { expose: t }) {
      const n = e, o = A(), l = A(), a = A(), r = A(), i = S(() => n.role), u = {
        triggerRef: o,
        popperInstanceRef: l,
        contentRef: a,
        referenceRef: r,
        role: i
      };
      return t(u), yt(gh, u), (c, d) => ee(c.$slots, "default");
    }
  });
  var CA = /* @__PURE__ */ Ne(wA, [["__file", "popper.vue"]]);
  const SA = /* @__PURE__ */ U({
    name: "ElPopperArrow",
    inheritAttrs: !1
  }), EA = /* @__PURE__ */ U({
    ...SA,
    setup(e, { expose: t }) {
      const n = he("popper"), { arrowRef: o, arrowStyle: l } = Ve(IC, void 0);
      return Bt(() => {
        o.value = void 0;
      }), t({
        arrowRef: o
      }), (a, r) => (_(), B("span", {
        ref_key: "arrowRef",
        ref: o,
        class: $(s(n).e("arrow")),
        style: Ue(s(l)),
        "data-popper-arrow": ""
      }, null, 6));
    }
  });
  var kA = /* @__PURE__ */ Ne(EA, [["__file", "arrow.vue"]]);
  const PC = Te({
    virtualRef: {
      type: X(Object)
    },
    virtualTriggering: Boolean,
    onMouseenter: {
      type: X(Function)
    },
    onMouseleave: {
      type: X(Function)
    },
    onClick: {
      type: X(Function)
    },
    onKeydown: {
      type: X(Function)
    },
    onFocus: {
      type: X(Function)
    },
    onBlur: {
      type: X(Function)
    },
    onContextmenu: {
      type: X(Function)
    },
    id: String,
    open: Boolean
  }), RC = Symbol("elForwardRef"), _A = (e) => {
    yt(RC, {
      setForwardRef: (n) => {
        e.value = n;
      }
    });
  }, TA = (e) => ({
    mounted(t) {
      e(t);
    },
    updated(t) {
      e(t);
    },
    unmounted() {
      e(null);
    }
  }), kf = "ElOnlyChild", DC = /* @__PURE__ */ U({
    name: kf,
    setup(e, {
      slots: t,
      attrs: n
    }) {
      var o;
      const l = Ve(RC), a = TA((o = l == null ? void 0 : l.setForwardRef) != null ? o : It);
      return () => {
        var r;
        const i = (r = t.default) == null ? void 0 : r.call(t, n);
        if (!i)
          return null;
        const [u, c] = AC(i);
        return u ? (c > 1 && vt(kf, "requires exact only one valid child."), it(qo(u, n), [[a]])) : (vt(kf, "no valid child node found"), null);
      };
    }
  });
  function AC(e) {
    if (!e)
      return [null, 0];
    const t = e, n = t.filter((o) => o.type !== Qt).length;
    for (const o of t) {
      if (ot(o))
        switch (o.type) {
          case Qt:
            continue;
          case Pa:
          case "svg":
            return [$b(o), n];
          case We:
            return AC(o.children);
          default:
            return [o, n];
        }
      return [$b(o), n];
    }
    return [null, 0];
  }
  function $b(e) {
    const t = he("only-child");
    return q("span", {
      class: t.e("content")
    }, [e]);
  }
  const NA = /* @__PURE__ */ U({
    name: "ElPopperTrigger",
    inheritAttrs: !1
  }), $A = /* @__PURE__ */ U({
    ...NA,
    props: PC,
    setup(e, { expose: t }) {
      const n = e, { role: o, triggerRef: l } = Ve(gh, void 0);
      _A(l);
      const a = S(() => i.value ? n.id : void 0), r = S(() => {
        if (o && o.value === "tooltip")
          return n.open && n.id ? n.id : void 0;
      }), i = S(() => {
        if (o && o.value !== "tooltip")
          return o.value;
      }), u = S(() => i.value ? `${n.open}` : void 0);
      let c;
      const d = [
        "onMouseenter",
        "onMouseleave",
        "onClick",
        "onKeydown",
        "onFocus",
        "onBlur",
        "onContextmenu"
      ];
      return ft(() => {
        de(() => n.virtualRef, (f) => {
          f && (l.value = kn(f));
        }, {
          immediate: !0
        }), de(l, (f, v) => {
          c == null || c(), c = void 0, Qn(v) && d.forEach((p) => {
            const m = n[p];
            m && v.removeEventListener(p.slice(2).toLowerCase(), m, ["onFocus", "onBlur"].includes(p));
          }), Qn(f) && (d.forEach((p) => {
            const m = n[p];
            m && f.addEventListener(p.slice(2).toLowerCase(), m, ["onFocus", "onBlur"].includes(p));
          }), Ei(f) && (c = de([a, r, i, u], (p) => {
            [
              "aria-controls",
              "aria-describedby",
              "aria-haspopup",
              "aria-expanded"
            ].forEach((m, h) => {
              cn(p[h]) ? f.removeAttribute(m) : f.setAttribute(m, p[h]);
            });
          }, { immediate: !0 }))), Qn(v) && Ei(v) && [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((p) => v.removeAttribute(p));
        }, {
          immediate: !0
        });
      }), Bt(() => {
        if (c == null || c(), c = void 0, l.value && Qn(l.value)) {
          const f = l.value;
          d.forEach((v) => {
            const p = n[v];
            p && f.removeEventListener(v.slice(2).toLowerCase(), p, ["onFocus", "onBlur"].includes(v));
          }), l.value = void 0;
        }
      }), t({
        triggerRef: l
      }), (f, v) => f.virtualTriggering ? oe("v-if", !0) : (_(), ae(s(DC), pt({ key: 0 }, f.$attrs, {
        "aria-controls": s(a),
        "aria-describedby": s(r),
        "aria-expanded": s(u),
        "aria-haspopup": s(i)
      }), {
        default: Q(() => [
          ee(f.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"]));
    }
  });
  var OA = /* @__PURE__ */ Ne($A, [["__file", "trigger.vue"]]);
  const _f = "focus-trap.focus-after-trapped", Tf = "focus-trap.focus-after-released", IA = "focus-trap.focusout-prevented", Ob = {
    cancelable: !0,
    bubbles: !1
  }, MA = {
    cancelable: !0,
    bubbles: !1
  }, Ib = "focusAfterTrapped", Mb = "focusAfterReleased", VC = Symbol("elFocusTrap"), bh = A(), Vd = A(0), yh = A(0);
  let Iu = 0;
  const LC = (e) => {
    const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (o) => {
        const l = o.tagName === "INPUT" && o.type === "hidden";
        return o.disabled || o.hidden || l ? NodeFilter.FILTER_SKIP : o.tabIndex >= 0 || o === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; n.nextNode(); )
      t.push(n.currentNode);
    return t;
  }, xb = (e, t) => {
    for (const n of e)
      if (!xA(n, t))
        return n;
  }, xA = (e, t) => {
    if (typeof process < "u" && process.env.NODE_ENV === "test")
      return !1;
    if (getComputedStyle(e).visibility === "hidden")
      return !0;
    for (; e; ) {
      if (t && e === t)
        return !1;
      if (getComputedStyle(e).display === "none")
        return !0;
      e = e.parentElement;
    }
    return !1;
  }, PA = (e) => {
    const t = LC(e), n = xb(t, e), o = xb(t.reverse(), e);
    return [n, o];
  }, RA = (e) => e instanceof HTMLInputElement && "select" in e, da = (e, t) => {
    if (e) {
      const n = document.activeElement;
      au(e, { preventScroll: !0 }), yh.value = window.performance.now(), e !== n && RA(e) && t && e.select();
    }
  };
  function Pb(e, t) {
    const n = [...e], o = e.indexOf(t);
    return o !== -1 && n.splice(o, 1), n;
  }
  const DA = () => {
    let e = [];
    return {
      push: (o) => {
        const l = e[0];
        l && o !== l && l.pause(), e = Pb(e, o), e.unshift(o);
      },
      remove: (o) => {
        var l, a;
        e = Pb(e, o), (a = (l = e[0]) == null ? void 0 : l.resume) == null || a.call(l);
      }
    };
  }, AA = (e, t = !1) => {
    const n = document.activeElement;
    for (const o of e)
      if (da(o, t), document.activeElement !== n)
        return;
  }, Rb = DA(), VA = () => Vd.value > yh.value, Mu = () => {
    bh.value = "pointer", Vd.value = window.performance.now();
  }, Db = () => {
    bh.value = "keyboard", Vd.value = window.performance.now();
  }, LA = () => (ft(() => {
    Iu === 0 && (document.addEventListener("mousedown", Mu), document.addEventListener("touchstart", Mu), document.addEventListener("keydown", Db)), Iu++;
  }), Bt(() => {
    Iu--, Iu <= 0 && (document.removeEventListener("mousedown", Mu), document.removeEventListener("touchstart", Mu), document.removeEventListener("keydown", Db));
  }), {
    focusReason: bh,
    lastUserFocusTimestamp: Vd,
    lastAutomatedFocusTimestamp: yh
  }), xu = (e) => new CustomEvent(IA, {
    ...MA,
    detail: e
  }), _e = {
    tab: "Tab",
    enter: "Enter",
    space: "Space",
    left: "ArrowLeft",
    up: "ArrowUp",
    right: "ArrowRight",
    down: "ArrowDown",
    esc: "Escape",
    delete: "Delete",
    backspace: "Backspace",
    numpadEnter: "NumpadEnter",
    pageUp: "PageUp",
    pageDown: "PageDown",
    home: "Home",
    end: "End"
  }, bn = (e, t, { checkForDefaultPrevented: n = !0 } = {}) => (l) => {
    const a = e == null ? void 0 : e(l);
    if (n === !1 || !a)
      return t == null ? void 0 : t(l);
  }, Ab = (e) => (t) => t.pointerType === "mouse" ? e(t) : void 0, Ht = (e) => {
    if (e.code && e.code !== "Unidentified")
      return e.code;
    const t = BC(e);
    if (t) {
      if (Object.values(_e).includes(t))
        return t;
      switch (t) {
        case " ":
          return _e.space;
        default:
          return "";
      }
    }
    return "";
  }, BC = (e) => {
    let t = e.key && e.key !== "Unidentified" ? e.key : "";
    if (!t && e.type === "keyup" && EC()) {
      const n = e.target;
      t = n.value.charAt(n.selectionStart - 1);
    }
    return t;
  };
  let Dr = [];
  const Vb = (e) => {
    Ht(e) === _e.esc && Dr.forEach((n) => n(e));
  }, BA = (e) => {
    ft(() => {
      Dr.length === 0 && document.addEventListener("keydown", Vb), xt && Dr.push(e);
    }), Bt(() => {
      Dr = Dr.filter((t) => t !== e), Dr.length === 0 && xt && document.removeEventListener("keydown", Vb);
    });
  }, FA = /* @__PURE__ */ U({
    name: "ElFocusTrap",
    inheritAttrs: !1,
    props: {
      loop: Boolean,
      trapped: Boolean,
      focusTrapEl: Object,
      focusStartEl: {
        type: [Object, String],
        default: "first"
      }
    },
    emits: [
      Ib,
      Mb,
      "focusin",
      "focusout",
      "focusout-prevented",
      "release-requested"
    ],
    setup(e, { emit: t }) {
      const n = A();
      let o, l;
      const { focusReason: a } = LA();
      BA((m) => {
        e.trapped && !r.paused && t("release-requested", m);
      });
      const r = {
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        }
      }, i = (m) => {
        if (!e.loop && !e.trapped || r.paused)
          return;
        const { altKey: h, ctrlKey: g, metaKey: b, currentTarget: C, shiftKey: w } = m, { loop: y } = e, k = Ht(m) === _e.tab && !h && !g && !b, T = document.activeElement;
        if (k && T) {
          const x = C, [I, P] = PA(x);
          if (I && P) {
            if (!w && T === P) {
              const N = xu({
                focusReason: a.value
              });
              t("focusout-prevented", N), N.defaultPrevented || (m.preventDefault(), y && da(I, !0));
            } else if (w && [I, x].includes(T)) {
              const N = xu({
                focusReason: a.value
              });
              t("focusout-prevented", N), N.defaultPrevented || (m.preventDefault(), y && da(P, !0));
            }
          } else if (T === x) {
            const N = xu({
              focusReason: a.value
            });
            t("focusout-prevented", N), N.defaultPrevented || m.preventDefault();
          }
        }
      };
      yt(VC, {
        focusTrapRef: n,
        onKeydown: i
      }), de(() => e.focusTrapEl, (m) => {
        m && (n.value = m);
      }, { immediate: !0 }), de([n], ([m], [h]) => {
        m && (m.addEventListener("keydown", i), m.addEventListener("focusin", d), m.addEventListener("focusout", f)), h && (h.removeEventListener("keydown", i), h.removeEventListener("focusin", d), h.removeEventListener("focusout", f));
      });
      const u = (m) => {
        t(Ib, m);
      }, c = (m) => t(Mb, m), d = (m) => {
        const h = s(n);
        if (!h)
          return;
        const g = m.target, b = m.relatedTarget, C = g && h.contains(g);
        e.trapped || b && h.contains(b) || (o = b), C && t("focusin", m), !r.paused && e.trapped && (C ? l = g : da(l, !0));
      }, f = (m) => {
        const h = s(n);
        if (!(r.paused || !h))
          if (e.trapped) {
            const g = m.relatedTarget;
            !cn(g) && !h.contains(g) && setTimeout(() => {
              if (!r.paused && e.trapped) {
                const b = xu({
                  focusReason: a.value
                });
                t("focusout-prevented", b), b.defaultPrevented || da(l, !0);
              }
            }, 0);
          } else {
            const g = m.target;
            g && h.contains(g) || t("focusout", m);
          }
      };
      async function v() {
        await Re();
        const m = s(n);
        if (m) {
          Rb.push(r);
          const h = m.contains(document.activeElement) ? o : document.activeElement;
          if (o = h, !m.contains(h)) {
            const b = new Event(_f, Ob);
            m.addEventListener(_f, u), m.dispatchEvent(b), b.defaultPrevented || Re(() => {
              let C = e.focusStartEl;
              Ae(C) || (da(C), document.activeElement !== C && (C = "first")), C === "first" && AA(LC(m), !0), (document.activeElement === h || C === "container") && da(m);
            });
          }
        }
      }
      function p() {
        const m = s(n);
        if (m) {
          m.removeEventListener(_f, u);
          const h = new CustomEvent(Tf, {
            ...Ob,
            detail: {
              focusReason: a.value
            }
          });
          m.addEventListener(Tf, c), m.dispatchEvent(h), !h.defaultPrevented && (a.value == "keyboard" || !VA() || m.contains(document.activeElement)) && da(o ?? document.body), m.removeEventListener(Tf, c), Rb.remove(r), o = null, l = null;
        }
      }
      return ft(() => {
        e.trapped && v(), de(() => e.trapped, (m) => {
          m ? v() : p();
        });
      }), Bt(() => {
        e.trapped && p(), n.value && (n.value.removeEventListener("keydown", i), n.value.removeEventListener("focusin", d), n.value.removeEventListener("focusout", f), n.value = void 0);
      }), {
        onKeydown: i
      };
    }
  });
  function zA(e, t, n, o, l, a) {
    return ee(e.$slots, "default", { handleKeydown: e.onKeydown });
  }
  var _s = /* @__PURE__ */ Ne(FA, [["render", zA], ["__file", "focus-trap.vue"]]), ro = "top", Io = "bottom", Mo = "right", so = "left", wh = "auto", su = [ro, Io, Mo, so], ls = "start", ki = "end", HA = "clippingParents", FC = "viewport", As = "popper", KA = "reference", Lb = su.reduce(function(e, t) {
    return e.concat([t + "-" + ls, t + "-" + ki]);
  }, []), aa = [].concat(su, [wh]).reduce(function(e, t) {
    return e.concat([t, t + "-" + ls, t + "-" + ki]);
  }, []), WA = "beforeRead", jA = "read", UA = "afterRead", YA = "beforeMain", qA = "main", GA = "afterMain", XA = "beforeWrite", JA = "write", ZA = "afterWrite", QA = [WA, jA, UA, YA, qA, GA, XA, JA, ZA];
  function El(e) {
    return e ? (e.nodeName || "").toLowerCase() : null;
  }
  function nl(e) {
    if (e == null) return window;
    if (e.toString() !== "[object Window]") {
      var t = e.ownerDocument;
      return t && t.defaultView || window;
    }
    return e;
  }
  function as(e) {
    var t = nl(e).Element;
    return e instanceof t || e instanceof Element;
  }
  function No(e) {
    var t = nl(e).HTMLElement;
    return e instanceof t || e instanceof HTMLElement;
  }
  function Ch(e) {
    if (typeof ShadowRoot > "u") return !1;
    var t = nl(e).ShadowRoot;
    return e instanceof t || e instanceof ShadowRoot;
  }
  function eV(e) {
    var t = e.state;
    Object.keys(t.elements).forEach(function(n) {
      var o = t.styles[n] || {}, l = t.attributes[n] || {}, a = t.elements[n];
      !No(a) || !El(a) || (Object.assign(a.style, o), Object.keys(l).forEach(function(r) {
        var i = l[r];
        i === !1 ? a.removeAttribute(r) : a.setAttribute(r, i === !0 ? "" : i);
      }));
    });
  }
  function tV(e) {
    var t = e.state, n = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
    return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function() {
      Object.keys(t.elements).forEach(function(o) {
        var l = t.elements[o], a = t.attributes[o] || {}, r = Object.keys(t.styles.hasOwnProperty(o) ? t.styles[o] : n[o]), i = r.reduce(function(u, c) {
          return u[c] = "", u;
        }, {});
        !No(l) || !El(l) || (Object.assign(l.style, i), Object.keys(a).forEach(function(u) {
          l.removeAttribute(u);
        }));
      });
    };
  }
  var zC = { name: "applyStyles", enabled: !0, phase: "write", fn: eV, effect: tV, requires: ["computeStyles"] };
  function pl(e) {
    return e.split("-")[0];
  }
  var ar = Math.max, Fc = Math.min, rs = Math.round;
  function ss(e, t) {
    t === void 0 && (t = !1);
    var n = e.getBoundingClientRect(), o = 1, l = 1;
    if (No(e) && t) {
      var a = e.offsetHeight, r = e.offsetWidth;
      r > 0 && (o = rs(n.width) / r || 1), a > 0 && (l = rs(n.height) / a || 1);
    }
    return { width: n.width / o, height: n.height / l, top: n.top / l, right: n.right / o, bottom: n.bottom / l, left: n.left / o, x: n.left / o, y: n.top / l };
  }
  function Sh(e) {
    var t = ss(e), n = e.offsetWidth, o = e.offsetHeight;
    return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - o) <= 1 && (o = t.height), { x: e.offsetLeft, y: e.offsetTop, width: n, height: o };
  }
  function HC(e, t) {
    var n = t.getRootNode && t.getRootNode();
    if (e.contains(t)) return !0;
    if (n && Ch(n)) {
      var o = t;
      do {
        if (o && e.isSameNode(o)) return !0;
        o = o.parentNode || o.host;
      } while (o);
    }
    return !1;
  }
  function Gl(e) {
    return nl(e).getComputedStyle(e);
  }
  function nV(e) {
    return ["table", "td", "th"].indexOf(El(e)) >= 0;
  }
  function Ra(e) {
    return ((as(e) ? e.ownerDocument : e.document) || window.document).documentElement;
  }
  function Ld(e) {
    return El(e) === "html" ? e : e.assignedSlot || e.parentNode || (Ch(e) ? e.host : null) || Ra(e);
  }
  function Bb(e) {
    return !No(e) || Gl(e).position === "fixed" ? null : e.offsetParent;
  }
  function oV(e) {
    var t = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
    if (n && No(e)) {
      var o = Gl(e);
      if (o.position === "fixed") return null;
    }
    var l = Ld(e);
    for (Ch(l) && (l = l.host); No(l) && ["html", "body"].indexOf(El(l)) < 0; ) {
      var a = Gl(l);
      if (a.transform !== "none" || a.perspective !== "none" || a.contain === "paint" || ["transform", "perspective"].indexOf(a.willChange) !== -1 || t && a.willChange === "filter" || t && a.filter && a.filter !== "none") return l;
      l = l.parentNode;
    }
    return null;
  }
  function iu(e) {
    for (var t = nl(e), n = Bb(e); n && nV(n) && Gl(n).position === "static"; ) n = Bb(n);
    return n && (El(n) === "html" || El(n) === "body" && Gl(n).position === "static") ? t : n || oV(e) || t;
  }
  function Eh(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y";
  }
  function oi(e, t, n) {
    return ar(e, Fc(t, n));
  }
  function lV(e, t, n) {
    var o = oi(e, t, n);
    return o > n ? n : o;
  }
  function KC() {
    return { top: 0, right: 0, bottom: 0, left: 0 };
  }
  function WC(e) {
    return Object.assign({}, KC(), e);
  }
  function jC(e, t) {
    return t.reduce(function(n, o) {
      return n[o] = e, n;
    }, {});
  }
  var aV = function(e, t) {
    return e = typeof e == "function" ? e(Object.assign({}, t.rects, { placement: t.placement })) : e, WC(typeof e != "number" ? e : jC(e, su));
  };
  function rV(e) {
    var t, n = e.state, o = e.name, l = e.options, a = n.elements.arrow, r = n.modifiersData.popperOffsets, i = pl(n.placement), u = Eh(i), c = [so, Mo].indexOf(i) >= 0, d = c ? "height" : "width";
    if (!(!a || !r)) {
      var f = aV(l.padding, n), v = Sh(a), p = u === "y" ? ro : so, m = u === "y" ? Io : Mo, h = n.rects.reference[d] + n.rects.reference[u] - r[u] - n.rects.popper[d], g = r[u] - n.rects.reference[u], b = iu(a), C = b ? u === "y" ? b.clientHeight || 0 : b.clientWidth || 0 : 0, w = h / 2 - g / 2, y = f[p], E = C - v[d] - f[m], k = C / 2 - v[d] / 2 + w, T = oi(y, k, E), x = u;
      n.modifiersData[o] = (t = {}, t[x] = T, t.centerOffset = T - k, t);
    }
  }
  function sV(e) {
    var t = e.state, n = e.options, o = n.element, l = o === void 0 ? "[data-popper-arrow]" : o;
    l != null && (typeof l == "string" && (l = t.elements.popper.querySelector(l), !l) || !HC(t.elements.popper, l) || (t.elements.arrow = l));
  }
  var iV = { name: "arrow", enabled: !0, phase: "main", fn: rV, effect: sV, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
  function is(e) {
    return e.split("-")[1];
  }
  var uV = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
  function cV(e) {
    var t = e.x, n = e.y, o = window, l = o.devicePixelRatio || 1;
    return { x: rs(t * l) / l || 0, y: rs(n * l) / l || 0 };
  }
  function Fb(e) {
    var t, n = e.popper, o = e.popperRect, l = e.placement, a = e.variation, r = e.offsets, i = e.position, u = e.gpuAcceleration, c = e.adaptive, d = e.roundOffsets, f = e.isFixed, v = r.x, p = v === void 0 ? 0 : v, m = r.y, h = m === void 0 ? 0 : m, g = typeof d == "function" ? d({ x: p, y: h }) : { x: p, y: h };
    p = g.x, h = g.y;
    var b = r.hasOwnProperty("x"), C = r.hasOwnProperty("y"), w = so, y = ro, E = window;
    if (c) {
      var k = iu(n), T = "clientHeight", x = "clientWidth";
      if (k === nl(n) && (k = Ra(n), Gl(k).position !== "static" && i === "absolute" && (T = "scrollHeight", x = "scrollWidth")), k = k, l === ro || (l === so || l === Mo) && a === ki) {
        y = Io;
        var I = f && k === E && E.visualViewport ? E.visualViewport.height : k[T];
        h -= I - o.height, h *= u ? 1 : -1;
      }
      if (l === so || (l === ro || l === Io) && a === ki) {
        w = Mo;
        var P = f && k === E && E.visualViewport ? E.visualViewport.width : k[x];
        p -= P - o.width, p *= u ? 1 : -1;
      }
    }
    var O = Object.assign({ position: i }, c && uV), N = d === !0 ? cV({ x: p, y: h }) : { x: p, y: h };
    if (p = N.x, h = N.y, u) {
      var z;
      return Object.assign({}, O, (z = {}, z[y] = C ? "0" : "", z[w] = b ? "0" : "", z.transform = (E.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + h + "px)" : "translate3d(" + p + "px, " + h + "px, 0)", z));
    }
    return Object.assign({}, O, (t = {}, t[y] = C ? h + "px" : "", t[w] = b ? p + "px" : "", t.transform = "", t));
  }
  function dV(e) {
    var t = e.state, n = e.options, o = n.gpuAcceleration, l = o === void 0 ? !0 : o, a = n.adaptive, r = a === void 0 ? !0 : a, i = n.roundOffsets, u = i === void 0 ? !0 : i, c = { placement: pl(t.placement), variation: is(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: l, isFixed: t.options.strategy === "fixed" };
    t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Fb(Object.assign({}, c, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: r, roundOffsets: u })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Fb(Object.assign({}, c, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: u })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement });
  }
  var UC = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: dV, data: {} }, Pu = { passive: !0 };
  function fV(e) {
    var t = e.state, n = e.instance, o = e.options, l = o.scroll, a = l === void 0 ? !0 : l, r = o.resize, i = r === void 0 ? !0 : r, u = nl(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return a && c.forEach(function(d) {
      d.addEventListener("scroll", n.update, Pu);
    }), i && u.addEventListener("resize", n.update, Pu), function() {
      a && c.forEach(function(d) {
        d.removeEventListener("scroll", n.update, Pu);
      }), i && u.removeEventListener("resize", n.update, Pu);
    };
  }
  var YC = { name: "eventListeners", enabled: !0, phase: "write", fn: function() {
  }, effect: fV, data: {} }, pV = { left: "right", right: "left", bottom: "top", top: "bottom" };
  function tc(e) {
    return e.replace(/left|right|bottom|top/g, function(t) {
      return pV[t];
    });
  }
  var vV = { start: "end", end: "start" };
  function zb(e) {
    return e.replace(/start|end/g, function(t) {
      return vV[t];
    });
  }
  function kh(e) {
    var t = nl(e), n = t.pageXOffset, o = t.pageYOffset;
    return { scrollLeft: n, scrollTop: o };
  }
  function _h(e) {
    return ss(Ra(e)).left + kh(e).scrollLeft;
  }
  function hV(e) {
    var t = nl(e), n = Ra(e), o = t.visualViewport, l = n.clientWidth, a = n.clientHeight, r = 0, i = 0;
    return o && (l = o.width, a = o.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (r = o.offsetLeft, i = o.offsetTop)), { width: l, height: a, x: r + _h(e), y: i };
  }
  function mV(e) {
    var t, n = Ra(e), o = kh(e), l = (t = e.ownerDocument) == null ? void 0 : t.body, a = ar(n.scrollWidth, n.clientWidth, l ? l.scrollWidth : 0, l ? l.clientWidth : 0), r = ar(n.scrollHeight, n.clientHeight, l ? l.scrollHeight : 0, l ? l.clientHeight : 0), i = -o.scrollLeft + _h(e), u = -o.scrollTop;
    return Gl(l || n).direction === "rtl" && (i += ar(n.clientWidth, l ? l.clientWidth : 0) - a), { width: a, height: r, x: i, y: u };
  }
  function Th(e) {
    var t = Gl(e), n = t.overflow, o = t.overflowX, l = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + l + o);
  }
  function qC(e) {
    return ["html", "body", "#document"].indexOf(El(e)) >= 0 ? e.ownerDocument.body : No(e) && Th(e) ? e : qC(Ld(e));
  }
  function li(e, t) {
    var n;
    t === void 0 && (t = []);
    var o = qC(e), l = o === ((n = e.ownerDocument) == null ? void 0 : n.body), a = nl(o), r = l ? [a].concat(a.visualViewport || [], Th(o) ? o : []) : o, i = t.concat(r);
    return l ? i : i.concat(li(Ld(r)));
  }
  function Cp(e) {
    return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height });
  }
  function gV(e) {
    var t = ss(e);
    return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t;
  }
  function Hb(e, t) {
    return t === FC ? Cp(hV(e)) : as(t) ? gV(t) : Cp(mV(Ra(e)));
  }
  function bV(e) {
    var t = li(Ld(e)), n = ["absolute", "fixed"].indexOf(Gl(e).position) >= 0, o = n && No(e) ? iu(e) : e;
    return as(o) ? t.filter(function(l) {
      return as(l) && HC(l, o) && El(l) !== "body";
    }) : [];
  }
  function yV(e, t, n) {
    var o = t === "clippingParents" ? bV(e) : [].concat(t), l = [].concat(o, [n]), a = l[0], r = l.reduce(function(i, u) {
      var c = Hb(e, u);
      return i.top = ar(c.top, i.top), i.right = Fc(c.right, i.right), i.bottom = Fc(c.bottom, i.bottom), i.left = ar(c.left, i.left), i;
    }, Hb(e, a));
    return r.width = r.right - r.left, r.height = r.bottom - r.top, r.x = r.left, r.y = r.top, r;
  }
  function GC(e) {
    var t = e.reference, n = e.element, o = e.placement, l = o ? pl(o) : null, a = o ? is(o) : null, r = t.x + t.width / 2 - n.width / 2, i = t.y + t.height / 2 - n.height / 2, u;
    switch (l) {
      case ro:
        u = { x: r, y: t.y - n.height };
        break;
      case Io:
        u = { x: r, y: t.y + t.height };
        break;
      case Mo:
        u = { x: t.x + t.width, y: i };
        break;
      case so:
        u = { x: t.x - n.width, y: i };
        break;
      default:
        u = { x: t.x, y: t.y };
    }
    var c = l ? Eh(l) : null;
    if (c != null) {
      var d = c === "y" ? "height" : "width";
      switch (a) {
        case ls:
          u[c] = u[c] - (t[d] / 2 - n[d] / 2);
          break;
        case ki:
          u[c] = u[c] + (t[d] / 2 - n[d] / 2);
          break;
      }
    }
    return u;
  }
  function _i(e, t) {
    t === void 0 && (t = {});
    var n = t, o = n.placement, l = o === void 0 ? e.placement : o, a = n.boundary, r = a === void 0 ? HA : a, i = n.rootBoundary, u = i === void 0 ? FC : i, c = n.elementContext, d = c === void 0 ? As : c, f = n.altBoundary, v = f === void 0 ? !1 : f, p = n.padding, m = p === void 0 ? 0 : p, h = WC(typeof m != "number" ? m : jC(m, su)), g = d === As ? KA : As, b = e.rects.popper, C = e.elements[v ? g : d], w = yV(as(C) ? C : C.contextElement || Ra(e.elements.popper), r, u), y = ss(e.elements.reference), E = GC({ reference: y, element: b, placement: l }), k = Cp(Object.assign({}, b, E)), T = d === As ? k : y, x = { top: w.top - T.top + h.top, bottom: T.bottom - w.bottom + h.bottom, left: w.left - T.left + h.left, right: T.right - w.right + h.right }, I = e.modifiersData.offset;
    if (d === As && I) {
      var P = I[l];
      Object.keys(x).forEach(function(O) {
        var N = [Mo, Io].indexOf(O) >= 0 ? 1 : -1, z = [ro, Io].indexOf(O) >= 0 ? "y" : "x";
        x[O] += P[z] * N;
      });
    }
    return x;
  }
  function wV(e, t) {
    t === void 0 && (t = {});
    var n = t, o = n.placement, l = n.boundary, a = n.rootBoundary, r = n.padding, i = n.flipVariations, u = n.allowedAutoPlacements, c = u === void 0 ? aa : u, d = is(o), f = d ? i ? Lb : Lb.filter(function(m) {
      return is(m) === d;
    }) : su, v = f.filter(function(m) {
      return c.indexOf(m) >= 0;
    });
    v.length === 0 && (v = f);
    var p = v.reduce(function(m, h) {
      return m[h] = _i(e, { placement: h, boundary: l, rootBoundary: a, padding: r })[pl(h)], m;
    }, {});
    return Object.keys(p).sort(function(m, h) {
      return p[m] - p[h];
    });
  }
  function CV(e) {
    if (pl(e) === wh) return [];
    var t = tc(e);
    return [zb(e), t, zb(t)];
  }
  function SV(e) {
    var t = e.state, n = e.options, o = e.name;
    if (!t.modifiersData[o]._skip) {
      for (var l = n.mainAxis, a = l === void 0 ? !0 : l, r = n.altAxis, i = r === void 0 ? !0 : r, u = n.fallbackPlacements, c = n.padding, d = n.boundary, f = n.rootBoundary, v = n.altBoundary, p = n.flipVariations, m = p === void 0 ? !0 : p, h = n.allowedAutoPlacements, g = t.options.placement, b = pl(g), C = b === g, w = u || (C || !m ? [tc(g)] : CV(g)), y = [g].concat(w).reduce(function(Z, J) {
        return Z.concat(pl(J) === wh ? wV(t, { placement: J, boundary: d, rootBoundary: f, padding: c, flipVariations: m, allowedAutoPlacements: h }) : J);
      }, []), E = t.rects.reference, k = t.rects.popper, T = /* @__PURE__ */ new Map(), x = !0, I = y[0], P = 0; P < y.length; P++) {
        var O = y[P], N = pl(O), z = is(O) === ls, Y = [ro, Io].indexOf(N) >= 0, G = Y ? "width" : "height", M = _i(t, { placement: O, boundary: d, rootBoundary: f, altBoundary: v, padding: c }), R = Y ? z ? Mo : so : z ? Io : ro;
        E[G] > k[G] && (R = tc(R));
        var D = tc(R), L = [];
        if (a && L.push(M[N] <= 0), i && L.push(M[R] <= 0, M[D] <= 0), L.every(function(Z) {
          return Z;
        })) {
          I = O, x = !1;
          break;
        }
        T.set(O, L);
      }
      if (x) for (var V = m ? 3 : 1, F = function(Z) {
        var J = y.find(function(ie) {
          var ue = T.get(ie);
          if (ue) return ue.slice(0, Z).every(function(re) {
            return re;
          });
        });
        if (J) return I = J, "break";
      }, H = V; H > 0; H--) {
        var K = F(H);
        if (K === "break") break;
      }
      t.placement !== I && (t.modifiersData[o]._skip = !0, t.placement = I, t.reset = !0);
    }
  }
  var EV = { name: "flip", enabled: !0, phase: "main", fn: SV, requiresIfExists: ["offset"], data: { _skip: !1 } };
  function Kb(e, t, n) {
    return n === void 0 && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x };
  }
  function Wb(e) {
    return [ro, Mo, Io, so].some(function(t) {
      return e[t] >= 0;
    });
  }
  function kV(e) {
    var t = e.state, n = e.name, o = t.rects.reference, l = t.rects.popper, a = t.modifiersData.preventOverflow, r = _i(t, { elementContext: "reference" }), i = _i(t, { altBoundary: !0 }), u = Kb(r, o), c = Kb(i, l, a), d = Wb(u), f = Wb(c);
    t.modifiersData[n] = { referenceClippingOffsets: u, popperEscapeOffsets: c, isReferenceHidden: d, hasPopperEscaped: f }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": d, "data-popper-escaped": f });
  }
  var _V = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: kV };
  function TV(e, t, n) {
    var o = pl(e), l = [so, ro].indexOf(o) >= 0 ? -1 : 1, a = typeof n == "function" ? n(Object.assign({}, t, { placement: e })) : n, r = a[0], i = a[1];
    return r = r || 0, i = (i || 0) * l, [so, Mo].indexOf(o) >= 0 ? { x: i, y: r } : { x: r, y: i };
  }
  function NV(e) {
    var t = e.state, n = e.options, o = e.name, l = n.offset, a = l === void 0 ? [0, 0] : l, r = aa.reduce(function(d, f) {
      return d[f] = TV(f, t.rects, a), d;
    }, {}), i = r[t.placement], u = i.x, c = i.y;
    t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += u, t.modifiersData.popperOffsets.y += c), t.modifiersData[o] = r;
  }
  var $V = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: NV };
  function OV(e) {
    var t = e.state, n = e.name;
    t.modifiersData[n] = GC({ reference: t.rects.reference, element: t.rects.popper, placement: t.placement });
  }
  var XC = { name: "popperOffsets", enabled: !0, phase: "read", fn: OV, data: {} };
  function IV(e) {
    return e === "x" ? "y" : "x";
  }
  function MV(e) {
    var t = e.state, n = e.options, o = e.name, l = n.mainAxis, a = l === void 0 ? !0 : l, r = n.altAxis, i = r === void 0 ? !1 : r, u = n.boundary, c = n.rootBoundary, d = n.altBoundary, f = n.padding, v = n.tether, p = v === void 0 ? !0 : v, m = n.tetherOffset, h = m === void 0 ? 0 : m, g = _i(t, { boundary: u, rootBoundary: c, padding: f, altBoundary: d }), b = pl(t.placement), C = is(t.placement), w = !C, y = Eh(b), E = IV(y), k = t.modifiersData.popperOffsets, T = t.rects.reference, x = t.rects.popper, I = typeof h == "function" ? h(Object.assign({}, t.rects, { placement: t.placement })) : h, P = typeof I == "number" ? { mainAxis: I, altAxis: I } : Object.assign({ mainAxis: 0, altAxis: 0 }, I), O = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, N = { x: 0, y: 0 };
    if (k) {
      if (a) {
        var z, Y = y === "y" ? ro : so, G = y === "y" ? Io : Mo, M = y === "y" ? "height" : "width", R = k[y], D = R + g[Y], L = R - g[G], V = p ? -x[M] / 2 : 0, F = C === ls ? T[M] : x[M], H = C === ls ? -x[M] : -T[M], K = t.elements.arrow, Z = p && K ? Sh(K) : { width: 0, height: 0 }, J = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : KC(), ie = J[Y], ue = J[G], re = oi(0, T[M], Z[M]), se = w ? T[M] / 2 - V - re - ie - P.mainAxis : F - re - ie - P.mainAxis, ne = w ? -T[M] / 2 + V + re + ue + P.mainAxis : H + re + ue + P.mainAxis, le = t.elements.arrow && iu(t.elements.arrow), Ce = le ? y === "y" ? le.clientTop || 0 : le.clientLeft || 0 : 0, j = (z = O == null ? void 0 : O[y]) != null ? z : 0, te = R + se - j - Ce, ce = R + ne - j, ge = oi(p ? Fc(D, te) : D, R, p ? ar(L, ce) : L);
        k[y] = ge, N[y] = ge - R;
      }
      if (i) {
        var be, Ee = y === "x" ? ro : so, Oe = y === "x" ? Io : Mo, De = k[E], we = E === "y" ? "height" : "width", me = De + g[Ee], Pe = De - g[Oe], Me = [ro, so].indexOf(b) !== -1, Be = (be = O == null ? void 0 : O[E]) != null ? be : 0, pe = Me ? me : De - T[we] - x[we] - Be + P.altAxis, Le = Me ? De + T[we] + x[we] - Be - P.altAxis : Pe, Xe = p && Me ? lV(pe, De, Le) : oi(p ? pe : me, De, p ? Le : Pe);
        k[E] = Xe, N[E] = Xe - De;
      }
      t.modifiersData[o] = N;
    }
  }
  var xV = { name: "preventOverflow", enabled: !0, phase: "main", fn: MV, requiresIfExists: ["offset"] };
  function PV(e) {
    return { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop };
  }
  function RV(e) {
    return e === nl(e) || !No(e) ? kh(e) : PV(e);
  }
  function DV(e) {
    var t = e.getBoundingClientRect(), n = rs(t.width) / e.offsetWidth || 1, o = rs(t.height) / e.offsetHeight || 1;
    return n !== 1 || o !== 1;
  }
  function AV(e, t, n) {
    n === void 0 && (n = !1);
    var o = No(t), l = No(t) && DV(t), a = Ra(t), r = ss(e, l), i = { scrollLeft: 0, scrollTop: 0 }, u = { x: 0, y: 0 };
    return (o || !o && !n) && ((El(t) !== "body" || Th(a)) && (i = RV(t)), No(t) ? (u = ss(t, !0), u.x += t.clientLeft, u.y += t.clientTop) : a && (u.x = _h(a))), { x: r.left + i.scrollLeft - u.x, y: r.top + i.scrollTop - u.y, width: r.width, height: r.height };
  }
  function VV(e) {
    var t = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), o = [];
    e.forEach(function(a) {
      t.set(a.name, a);
    });
    function l(a) {
      n.add(a.name);
      var r = [].concat(a.requires || [], a.requiresIfExists || []);
      r.forEach(function(i) {
        if (!n.has(i)) {
          var u = t.get(i);
          u && l(u);
        }
      }), o.push(a);
    }
    return e.forEach(function(a) {
      n.has(a.name) || l(a);
    }), o;
  }
  function LV(e) {
    var t = VV(e);
    return QA.reduce(function(n, o) {
      return n.concat(t.filter(function(l) {
        return l.phase === o;
      }));
    }, []);
  }
  function BV(e) {
    var t;
    return function() {
      return t || (t = new Promise(function(n) {
        Promise.resolve().then(function() {
          t = void 0, n(e());
        });
      })), t;
    };
  }
  function FV(e) {
    var t = e.reduce(function(n, o) {
      var l = n[o.name];
      return n[o.name] = l ? Object.assign({}, l, o, { options: Object.assign({}, l.options, o.options), data: Object.assign({}, l.data, o.data) }) : o, n;
    }, {});
    return Object.keys(t).map(function(n) {
      return t[n];
    });
  }
  var jb = { placement: "bottom", modifiers: [], strategy: "absolute" };
  function Ub() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
    return !t.some(function(o) {
      return !(o && typeof o.getBoundingClientRect == "function");
    });
  }
  function Nh(e) {
    e === void 0 && (e = {});
    var t = e, n = t.defaultModifiers, o = n === void 0 ? [] : n, l = t.defaultOptions, a = l === void 0 ? jb : l;
    return function(r, i, u) {
      u === void 0 && (u = a);
      var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, jb, a), modifiersData: {}, elements: { reference: r, popper: i }, attributes: {}, styles: {} }, d = [], f = !1, v = { state: c, setOptions: function(h) {
        var g = typeof h == "function" ? h(c.options) : h;
        m(), c.options = Object.assign({}, a, c.options, g), c.scrollParents = { reference: as(r) ? li(r) : r.contextElement ? li(r.contextElement) : [], popper: li(i) };
        var b = LV(FV([].concat(o, c.options.modifiers)));
        return c.orderedModifiers = b.filter(function(C) {
          return C.enabled;
        }), p(), v.update();
      }, forceUpdate: function() {
        if (!f) {
          var h = c.elements, g = h.reference, b = h.popper;
          if (Ub(g, b)) {
            c.rects = { reference: AV(g, iu(b), c.options.strategy === "fixed"), popper: Sh(b) }, c.reset = !1, c.placement = c.options.placement, c.orderedModifiers.forEach(function(x) {
              return c.modifiersData[x.name] = Object.assign({}, x.data);
            });
            for (var C = 0; C < c.orderedModifiers.length; C++) {
              if (c.reset === !0) {
                c.reset = !1, C = -1;
                continue;
              }
              var w = c.orderedModifiers[C], y = w.fn, E = w.options, k = E === void 0 ? {} : E, T = w.name;
              typeof y == "function" && (c = y({ state: c, options: k, name: T, instance: v }) || c);
            }
          }
        }
      }, update: BV(function() {
        return new Promise(function(h) {
          v.forceUpdate(), h(c);
        });
      }), destroy: function() {
        m(), f = !0;
      } };
      if (!Ub(r, i)) return v;
      v.setOptions(u).then(function(h) {
        !f && u.onFirstUpdate && u.onFirstUpdate(h);
      });
      function p() {
        c.orderedModifiers.forEach(function(h) {
          var g = h.name, b = h.options, C = b === void 0 ? {} : b, w = h.effect;
          if (typeof w == "function") {
            var y = w({ state: c, name: g, instance: v, options: C }), E = function() {
            };
            d.push(y || E);
          }
        });
      }
      function m() {
        d.forEach(function(h) {
          return h();
        }), d = [];
      }
      return v;
    };
  }
  Nh();
  var zV = [YC, XC, UC, zC];
  Nh({ defaultModifiers: zV });
  var HV = [YC, XC, UC, zC, $V, EV, xV, iV, _V], KV = Nh({ defaultModifiers: HV });
  const JC = Te({
    arrowOffset: {
      type: Number,
      default: 5
    }
  }), WV = ["fixed", "absolute"], jV = Te({
    boundariesPadding: {
      type: Number,
      default: 0
    },
    fallbackPlacements: {
      type: X(Array),
      default: void 0
    },
    gpuAcceleration: {
      type: Boolean,
      default: !0
    },
    offset: {
      type: Number,
      default: 12
    },
    placement: {
      type: String,
      values: aa,
      default: "bottom"
    },
    popperOptions: {
      type: X(Object),
      default: () => ({})
    },
    strategy: {
      type: String,
      values: WV,
      default: "absolute"
    }
  }), ZC = Te({
    ...jV,
    ...JC,
    id: String,
    style: {
      type: X([String, Array, Object])
    },
    className: {
      type: X([String, Array, Object])
    },
    effect: {
      type: X(String),
      default: "dark"
    },
    visible: Boolean,
    enterable: {
      type: Boolean,
      default: !0
    },
    pure: Boolean,
    focusOnShow: Boolean,
    trapping: Boolean,
    popperClass: {
      type: X([String, Array, Object])
    },
    popperStyle: {
      type: X([String, Array, Object])
    },
    referenceEl: {
      type: X(Object)
    },
    triggerTargetEl: {
      type: X(Object)
    },
    stopPopperMouseEvent: {
      type: Boolean,
      default: !0
    },
    virtualTriggering: Boolean,
    zIndex: Number,
    ...Yn(["ariaLabel"]),
    loop: Boolean
  }), UV = {
    mouseenter: (e) => e instanceof MouseEvent,
    mouseleave: (e) => e instanceof MouseEvent,
    focus: () => !0,
    blur: () => !0,
    close: () => !0
  }, YV = (e, t) => {
    const n = A(!1), o = A();
    return {
      focusStartRef: o,
      trapped: n,
      onFocusAfterReleased: (c) => {
        var d;
        ((d = c.detail) == null ? void 0 : d.focusReason) !== "pointer" && (o.value = "first", t("blur"));
      },
      onFocusAfterTrapped: () => {
        t("focus");
      },
      onFocusInTrap: (c) => {
        e.visible && !n.value && (c.target && (o.value = c.target), n.value = !0);
      },
      onFocusoutPrevented: (c) => {
        e.trapping || (c.detail.focusReason === "pointer" && c.preventDefault(), n.value = !1);
      },
      onReleaseRequested: () => {
        n.value = !1, t("close");
      }
    };
  }, qV = (e, t = []) => {
    const { placement: n, strategy: o, popperOptions: l } = e, a = {
      placement: n,
      strategy: o,
      ...l,
      modifiers: [...XV(e), ...t]
    };
    return JV(a, l == null ? void 0 : l.modifiers), a;
  }, GV = (e) => {
    if (xt)
      return kn(e);
  };
  function XV(e) {
    const { offset: t, gpuAcceleration: n, fallbackPlacements: o } = e;
    return [
      {
        name: "offset",
        options: {
          offset: [0, t ?? 12]
        }
      },
      {
        name: "preventOverflow",
        options: {
          padding: {
            top: 0,
            bottom: 0,
            left: 0,
            right: 0
          }
        }
      },
      {
        name: "flip",
        options: {
          padding: 5,
          fallbackPlacements: o
        }
      },
      {
        name: "computeStyles",
        options: {
          gpuAcceleration: n
        }
      }
    ];
  }
  function JV(e, t) {
    t && (e.modifiers = [...e.modifiers, ...t ?? []]);
  }
  const ZV = (e, t, n = {}) => {
    const o = {
      name: "updateState",
      enabled: !0,
      phase: "write",
      fn: ({ state: u }) => {
        const c = QV(u);
        Object.assign(r.value, c);
      },
      requires: ["computeStyles"]
    }, l = S(() => {
      const { onFirstUpdate: u, placement: c, strategy: d, modifiers: f } = s(n);
      return {
        onFirstUpdate: u,
        placement: c || "bottom",
        strategy: d || "absolute",
        modifiers: [
          ...f || [],
          o,
          { name: "applyStyles", enabled: !1 }
        ]
      };
    }), a = Ut(), r = A({
      styles: {
        popper: {
          position: s(l).strategy,
          left: "0",
          top: "0"
        },
        arrow: {
          position: "absolute"
        }
      },
      attributes: {}
    }), i = () => {
      a.value && (a.value.destroy(), a.value = void 0);
    };
    return de(l, (u) => {
      const c = s(a);
      c && c.setOptions(u);
    }, {
      deep: !0
    }), de([e, t], ([u, c]) => {
      i(), !(!u || !c) && (a.value = KV(u, c, s(l)));
    }), Bt(() => {
      i();
    }), {
      state: S(() => {
        var u;
        return { ...((u = s(a)) == null ? void 0 : u.state) || {} };
      }),
      styles: S(() => s(r).styles),
      attributes: S(() => s(r).attributes),
      update: () => {
        var u;
        return (u = s(a)) == null ? void 0 : u.update();
      },
      forceUpdate: () => {
        var u;
        return (u = s(a)) == null ? void 0 : u.forceUpdate();
      },
      instanceRef: S(() => s(a))
    };
  };
  function QV(e) {
    const t = Object.keys(e.elements), n = wi(t.map((l) => [l, e.styles[l] || {}])), o = wi(t.map((l) => [l, e.attributes[l]]));
    return {
      styles: n,
      attributes: o
    };
  }
  const e4 = 0, t4 = (e) => {
    const { popperInstanceRef: t, contentRef: n, triggerRef: o, role: l } = Ve(gh, void 0), a = A(), r = S(() => e.arrowOffset), i = S(() => ({
      name: "eventListeners",
      enabled: !!e.visible
    })), u = S(() => {
      var b;
      const C = s(a), w = (b = s(r)) != null ? b : e4;
      return {
        name: "arrow",
        enabled: !dP(C),
        options: {
          element: C,
          padding: w
        }
      };
    }), c = S(() => ({
      onFirstUpdate: () => {
        m();
      },
      ...qV(e, [
        s(u),
        s(i)
      ])
    })), d = S(() => GV(e.referenceEl) || s(o)), { attributes: f, state: v, styles: p, update: m, forceUpdate: h, instanceRef: g } = ZV(d, n, c);
    return de(g, (b) => t.value = b, {
      flush: "sync"
    }), ft(() => {
      de(() => {
        var b, C;
        return (C = (b = s(d)) == null ? void 0 : b.getBoundingClientRect) == null ? void 0 : C.call(b);
      }, () => {
        m();
      });
    }), {
      attributes: f,
      arrowRef: a,
      contentRef: n,
      instanceRef: g,
      state: v,
      styles: p,
      role: l,
      forceUpdate: h,
      update: m
    };
  }, n4 = (e, {
    attributes: t,
    styles: n,
    role: o
  }) => {
    const { nextZIndex: l } = tu(), a = he("popper"), r = S(() => s(t).popper), i = A(je(e.zIndex) ? e.zIndex : l()), u = S(() => [
      a.b(),
      a.is("pure", e.pure),
      a.is(e.effect),
      e.popperClass
    ]), c = S(() => [
      { zIndex: s(i) },
      s(n).popper,
      e.popperStyle || {}
    ]), d = S(() => o.value === "dialog" ? "false" : void 0), f = S(() => s(n).arrow || {});
    return {
      ariaModal: d,
      arrowStyle: f,
      contentAttrs: r,
      contentClass: u,
      contentStyle: c,
      contentZIndex: i,
      updateZIndex: () => {
        i.value = je(e.zIndex) ? e.zIndex : l();
      }
    };
  }, o4 = /* @__PURE__ */ U({
    name: "ElPopperContent"
  }), l4 = /* @__PURE__ */ U({
    ...o4,
    props: ZC,
    emits: UV,
    setup(e, { expose: t, emit: n }) {
      const o = e, {
        focusStartRef: l,
        trapped: a,
        onFocusAfterReleased: r,
        onFocusAfterTrapped: i,
        onFocusInTrap: u,
        onFocusoutPrevented: c,
        onReleaseRequested: d
      } = YV(o, n), { attributes: f, arrowRef: v, contentRef: p, styles: m, instanceRef: h, role: g, update: b } = t4(o), {
        ariaModal: C,
        arrowStyle: w,
        contentAttrs: y,
        contentClass: E,
        contentStyle: k,
        updateZIndex: T
      } = n4(o, {
        styles: m,
        attributes: f,
        role: g
      }), x = Ve(Sl, void 0);
      yt(IC, {
        arrowStyle: w,
        arrowRef: v
      }), x && yt(Sl, {
        ...x,
        addInputId: It,
        removeInputId: It
      });
      let I;
      const P = (N = !0) => {
        b(), N && T();
      }, O = () => {
        P(!1), o.visible && o.focusOnShow ? a.value = !0 : o.visible === !1 && (a.value = !1);
      };
      return ft(() => {
        de(() => o.triggerTargetEl, (N, z) => {
          I == null || I(), I = void 0;
          const Y = s(N || p.value), G = s(z || p.value);
          Qn(Y) && (I = de([g, () => o.ariaLabel, C, () => o.id], (M) => {
            ["role", "aria-label", "aria-modal", "id"].forEach((R, D) => {
              cn(M[D]) ? Y.removeAttribute(R) : Y.setAttribute(R, M[D]);
            });
          }, { immediate: !0 })), G !== Y && Qn(G) && ["role", "aria-label", "aria-modal", "id"].forEach((M) => {
            G.removeAttribute(M);
          });
        }, { immediate: !0 }), de(() => o.visible, O, { immediate: !0 });
      }), Bt(() => {
        I == null || I(), I = void 0;
      }), t({
        popperContentRef: p,
        popperInstanceRef: h,
        updatePopper: P,
        contentStyle: k
      }), (N, z) => (_(), B("div", pt({
        ref_key: "contentRef",
        ref: p
      }, s(y), {
        style: s(k),
        class: s(E),
        tabindex: "-1",
        onMouseenter: (Y) => N.$emit("mouseenter", Y),
        onMouseleave: (Y) => N.$emit("mouseleave", Y)
      }), [
        q(s(_s), {
          loop: N.loop,
          trapped: s(a),
          "trap-on-focus-in": !0,
          "focus-trap-el": s(p),
          "focus-start-el": s(l),
          onFocusAfterTrapped: s(i),
          onFocusAfterReleased: s(r),
          onFocusin: s(u),
          onFocusoutPrevented: s(c),
          onReleaseRequested: s(d)
        }, {
          default: Q(() => [
            ee(N.$slots, "default")
          ]),
          _: 3
        }, 8, ["loop", "trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusin", "onFocusoutPrevented", "onReleaseRequested"])
      ], 16, ["onMouseenter", "onMouseleave"]));
    }
  });
  var a4 = /* @__PURE__ */ Ne(l4, [["__file", "content.vue"]]);
  const QC = rt(CA), $h = Symbol("elTooltip"), Bd = Te({
    to: {
      type: X([String, Object]),
      required: !0
    },
    disabled: Boolean
  }), zt = Te({
    ...hC,
    ...ZC,
    appendTo: {
      type: Bd.to.type
    },
    content: {
      type: String,
      default: ""
    },
    rawContent: Boolean,
    persistent: Boolean,
    visible: {
      type: X(Boolean),
      default: null
    },
    transition: String,
    teleported: {
      type: Boolean,
      default: !0
    },
    disabled: Boolean,
    ...Yn(["ariaLabel"])
  }), vl = Te({
    ...PC,
    disabled: Boolean,
    trigger: {
      type: X([String, Array]),
      default: "hover"
    },
    triggerKeys: {
      type: X(Array),
      default: () => [_e.enter, _e.numpadEnter, _e.space]
    },
    focusOnTarget: Boolean
  }), r4 = tl({
    type: X(Boolean),
    default: null
  }), s4 = tl({
    type: X(Function)
  }), i4 = (e) => {
    const t = `update:${e}`, n = `onUpdate:${e}`, o = [t], l = {
      [e]: r4,
      [n]: s4
    };
    return {
      useModelToggle: ({
        indicator: r,
        toggleReason: i,
        shouldHideWhenRouteChanges: u,
        shouldProceed: c,
        onShow: d,
        onHide: f
      }) => {
        const v = dt(), { emit: p } = v, m = v.props, h = S(() => Fe(m[n])), g = S(() => m[e] === null), b = (T) => {
          r.value !== !0 && (r.value = !0, i && (i.value = T), Fe(d) && d(T));
        }, C = (T) => {
          r.value !== !1 && (r.value = !1, i && (i.value = T), Fe(f) && f(T));
        }, w = (T) => {
          if (m.disabled === !0 || Fe(c) && !c())
            return;
          const x = h.value && xt;
          x && p(t, !0), (g.value || !x) && b(T);
        }, y = (T) => {
          if (m.disabled === !0 || !xt)
            return;
          const x = h.value && xt;
          x && p(t, !1), (g.value || !x) && C(T);
        }, E = (T) => {
          Vt(T) && (m.disabled && T ? h.value && p(t, !1) : r.value !== T && (T ? b() : C()));
        }, k = () => {
          r.value ? y() : w();
        };
        return de(() => m[e], E), u && v.appContext.config.globalProperties.$route !== void 0 && de(() => ({
          ...v.proxy.$route
        }), () => {
          u.value && r.value && y();
        }), ft(() => {
          E(m[e]);
        }), {
          hide: y,
          show: w,
          toggle: k,
          hasUpdateHandler: h
        };
      },
      useModelToggleProps: l,
      useModelToggleEmits: o
    };
  }, {
    useModelToggleProps: u4,
    useModelToggleEmits: c4,
    useModelToggle: d4
  } = i4("visible"), f4 = Te({
    ...xC,
    ...u4,
    ...zt,
    ...vl,
    ...JC,
    showArrow: {
      type: Boolean,
      default: !0
    }
  }), p4 = [
    ...c4,
    "before-show",
    "before-hide",
    "show",
    "hide",
    "open",
    "close"
  ], Sp = (e, t) => ye(e) ? e.includes(t) : e === t, $r = (e, t, n) => (o) => {
    Sp(s(e), t) && n(o);
  }, v4 = /* @__PURE__ */ U({
    name: "ElTooltipTrigger"
  }), h4 = /* @__PURE__ */ U({
    ...v4,
    props: vl,
    setup(e, { expose: t }) {
      const n = e, o = he("tooltip"), { controlled: l, id: a, open: r, onOpen: i, onClose: u, onToggle: c } = Ve($h, void 0), d = A(null), f = () => {
        if (s(l) || n.disabled)
          return !0;
      }, v = At(n, "trigger"), p = bn(f, $r(v, "hover", (y) => {
        i(y), n.focusOnTarget && y.target && Re(() => {
          au(y.target, { preventScroll: !0 });
        });
      })), m = bn(f, $r(v, "hover", u)), h = bn(f, $r(v, "click", (y) => {
        y.button === 0 && c(y);
      })), g = bn(f, $r(v, "focus", i)), b = bn(f, $r(v, "focus", u)), C = bn(f, $r(v, "contextmenu", (y) => {
        y.preventDefault(), c(y);
      })), w = bn(f, (y) => {
        const E = Ht(y);
        n.triggerKeys.includes(E) && (y.preventDefault(), c(y));
      });
      return t({
        triggerRef: d
      }), (y, E) => (_(), ae(s(OA), {
        id: s(a),
        "virtual-ref": y.virtualRef,
        open: s(r),
        "virtual-triggering": y.virtualTriggering,
        class: $(s(o).e("trigger")),
        onBlur: s(b),
        onClick: s(h),
        onContextmenu: s(C),
        onFocus: s(g),
        onMouseenter: s(p),
        onMouseleave: s(m),
        onKeydown: s(w)
      }, {
        default: Q(() => [
          ee(y.$slots, "default")
        ]),
        _: 3
      }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]));
    }
  });
  var m4 = /* @__PURE__ */ Ne(h4, [["__file", "trigger.vue"]]);
  const g4 = /* @__PURE__ */ U({
    __name: "teleport",
    props: Bd,
    setup(e) {
      return (t, n) => t.disabled ? ee(t.$slots, "default", { key: 0 }) : (_(), ae(tT, {
        key: 1,
        to: t.to
      }, [
        ee(t.$slots, "default")
      ], 8, ["to"]));
    }
  });
  var b4 = /* @__PURE__ */ Ne(g4, [["__file", "teleport.vue"]]);
  const uu = rt(b4), eS = () => {
    const e = Hv(), t = hh(), n = S(() => `${e.value}-popper-container-${t.prefix}`), o = S(() => `#${n.value}`);
    return {
      id: n,
      selector: o
    };
  }, y4 = (e) => {
    const t = document.createElement("div");
    return t.id = e, document.body.appendChild(t), t;
  }, w4 = () => {
    const { id: e, selector: t } = eS();
    return gd(() => {
      xt && (typeof process < "u" && process.env.NODE_ENV === "test" || !document.body.querySelector(t.value)) && y4(e.value);
    }), {
      id: e,
      selector: t
    };
  }, Yb = (e) => [...new Set(e)], Vs = (e) => ye(e) ? e[0] : e, Kn = (e) => !e && e !== 0 ? [] : ye(e) ? e : [e], C4 = /* @__PURE__ */ U({
    name: "ElTooltipContent",
    inheritAttrs: !1
  }), S4 = /* @__PURE__ */ U({
    ...C4,
    props: zt,
    setup(e, { expose: t }) {
      const n = e, { selector: o } = eS(), l = he("tooltip"), a = A(), r = Vc(() => {
        var D;
        return (D = a.value) == null ? void 0 : D.popperContentRef;
      });
      let i;
      const {
        controlled: u,
        id: c,
        open: d,
        trigger: f,
        onClose: v,
        onOpen: p,
        onShow: m,
        onHide: h,
        onBeforeShow: g,
        onBeforeHide: b
      } = Ve($h, void 0), C = S(() => n.transition || `${l.namespace.value}-fade-in-linear`), w = S(() => typeof process < "u" && process.env.NODE_ENV === "test" && !process.env.RUN_TEST_WITH_PERSISTENT ? !0 : n.persistent);
      Bt(() => {
        i == null || i();
      });
      const y = S(() => s(w) ? !0 : s(d)), E = S(() => n.disabled ? !1 : s(d)), k = S(() => n.appendTo || o.value), T = S(() => {
        var D;
        return (D = n.style) != null ? D : {};
      }), x = A(!0), I = () => {
        h(), R() && au(document.body, { preventScroll: !0 }), x.value = !0;
      }, P = () => {
        if (s(u))
          return !0;
      }, O = bn(P, () => {
        n.enterable && Sp(s(f), "hover") && p();
      }), N = bn(P, () => {
        Sp(s(f), "hover") && v();
      }), z = () => {
        var D, L;
        (L = (D = a.value) == null ? void 0 : D.updatePopper) == null || L.call(D), g == null || g();
      }, Y = () => {
        b == null || b();
      }, G = () => {
        m();
      }, M = () => {
        n.virtualTriggering || v();
      }, R = (D) => {
        var L;
        const V = (L = a.value) == null ? void 0 : L.popperContentRef, F = (D == null ? void 0 : D.relatedTarget) || document.activeElement;
        return V == null ? void 0 : V.contains(F);
      };
      return de(() => s(d), (D) => {
        D ? (x.value = !1, i = ah(r, () => {
          if (s(u))
            return;
          Kn(s(f)).every((V) => V !== "hover" && V !== "focus") && v();
        }, { detectIframe: !0 })) : i == null || i();
      }, {
        flush: "post"
      }), de(() => n.content, () => {
        var D, L;
        (L = (D = a.value) == null ? void 0 : D.updatePopper) == null || L.call(D);
      }), t({
        contentRef: a,
        isFocusInsideContent: R
      }), (D, L) => (_(), ae(s(uu), {
        disabled: !D.teleported,
        to: s(k)
      }, {
        default: Q(() => [
          s(y) || !x.value ? (_(), ae(Mn, {
            key: 0,
            name: s(C),
            appear: !s(w),
            onAfterLeave: I,
            onBeforeEnter: z,
            onAfterEnter: G,
            onBeforeLeave: Y,
            persisted: ""
          }, {
            default: Q(() => [
              it(q(s(a4), pt({
                id: s(c),
                ref_key: "contentRef",
                ref: a
              }, D.$attrs, {
                "aria-label": D.ariaLabel,
                "aria-hidden": x.value,
                "boundaries-padding": D.boundariesPadding,
                "fallback-placements": D.fallbackPlacements,
                "gpu-acceleration": D.gpuAcceleration,
                offset: D.offset,
                placement: D.placement,
                "popper-options": D.popperOptions,
                "arrow-offset": D.arrowOffset,
                strategy: D.strategy,
                effect: D.effect,
                enterable: D.enterable,
                pure: D.pure,
                "popper-class": D.popperClass,
                "popper-style": [D.popperStyle, s(T)],
                "reference-el": D.referenceEl,
                "trigger-target-el": D.triggerTargetEl,
                visible: s(E),
                "z-index": D.zIndex,
                loop: D.loop,
                onMouseenter: s(O),
                onMouseleave: s(N),
                onBlur: M,
                onClose: s(v)
              }), {
                default: Q(() => [
                  ee(D.$slots, "default")
                ]),
                _: 3
              }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "arrow-offset", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "loop", "onMouseenter", "onMouseleave", "onClose"]), [
                [Mt, s(E)]
              ])
            ]),
            _: 3
          }, 8, ["name", "appear"])) : oe("v-if", !0)
        ]),
        _: 3
      }, 8, ["disabled", "to"]));
    }
  });
  var E4 = /* @__PURE__ */ Ne(S4, [["__file", "content.vue"]]);
  const k4 = /* @__PURE__ */ U({
    name: "ElTooltip"
  }), _4 = /* @__PURE__ */ U({
    ...k4,
    props: f4,
    emits: p4,
    setup(e, { expose: t, emit: n }) {
      const o = e;
      w4();
      const l = he("tooltip"), a = xn(), r = A(), i = A(), u = () => {
        var w;
        const y = s(r);
        y && ((w = y.popperInstanceRef) == null || w.update());
      }, c = A(!1), d = A(), { show: f, hide: v, hasUpdateHandler: p } = d4({
        indicator: c,
        toggleReason: d
      }), { onOpen: m, onClose: h } = mC({
        showAfter: At(o, "showAfter"),
        hideAfter: At(o, "hideAfter"),
        autoClose: At(o, "autoClose"),
        open: f,
        close: v
      }), g = S(() => Vt(o.visible) && !p.value), b = S(() => [l.b(), o.popperClass]);
      yt($h, {
        controlled: g,
        id: a,
        open: ir(c),
        trigger: At(o, "trigger"),
        onOpen: m,
        onClose: h,
        onToggle: (w) => {
          s(c) ? h(w) : m(w);
        },
        onShow: () => {
          n("show", d.value);
        },
        onHide: () => {
          n("hide", d.value);
        },
        onBeforeShow: () => {
          n("before-show", d.value);
        },
        onBeforeHide: () => {
          n("before-hide", d.value);
        },
        updatePopper: u
      }), de(() => o.disabled, (w) => {
        w && c.value && (c.value = !1);
      });
      const C = (w) => {
        var y;
        return (y = i.value) == null ? void 0 : y.isFocusInsideContent(w);
      };
      return mw(() => c.value && v()), t({
        popperRef: r,
        contentRef: i,
        isFocusInsideContent: C,
        updatePopper: u,
        onOpen: m,
        onClose: h,
        hide: v
      }), (w, y) => (_(), ae(s(QC), {
        ref_key: "popperRef",
        ref: r,
        role: w.role
      }, {
        default: Q(() => [
          q(m4, {
            disabled: w.disabled,
            trigger: w.trigger,
            "trigger-keys": w.triggerKeys,
            "virtual-ref": w.virtualRef,
            "virtual-triggering": w.virtualTriggering,
            "focus-on-target": w.focusOnTarget
          }, {
            default: Q(() => [
              w.$slots.default ? ee(w.$slots, "default", { key: 0 }) : oe("v-if", !0)
            ]),
            _: 3
          }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering", "focus-on-target"]),
          q(E4, {
            ref_key: "contentRef",
            ref: i,
            "aria-label": w.ariaLabel,
            "boundaries-padding": w.boundariesPadding,
            content: w.content,
            disabled: w.disabled,
            effect: w.effect,
            enterable: w.enterable,
            "fallback-placements": w.fallbackPlacements,
            "hide-after": w.hideAfter,
            "gpu-acceleration": w.gpuAcceleration,
            offset: w.offset,
            persistent: w.persistent,
            "popper-class": s(b),
            "popper-style": w.popperStyle,
            placement: w.placement,
            "popper-options": w.popperOptions,
            "arrow-offset": w.arrowOffset,
            pure: w.pure,
            "raw-content": w.rawContent,
            "reference-el": w.referenceEl,
            "trigger-target-el": w.triggerTargetEl,
            "show-after": w.showAfter,
            strategy: w.strategy,
            teleported: w.teleported,
            transition: w.transition,
            "virtual-triggering": w.virtualTriggering,
            "z-index": w.zIndex,
            "append-to": w.appendTo,
            loop: w.loop
          }, {
            default: Q(() => [
              ee(w.$slots, "content", {}, () => [
                w.rawContent ? (_(), B("span", {
                  key: 0,
                  innerHTML: w.content
                }, null, 8, ["innerHTML"])) : (_(), B("span", { key: 1 }, ke(w.content), 1))
              ]),
              w.showArrow ? (_(), ae(s(kA), { key: 0 })) : oe("v-if", !0)
            ]),
            _: 3
          }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "arrow-offset", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to", "loop"])
        ]),
        _: 3
      }, 8, ["role"]));
    }
  });
  var T4 = /* @__PURE__ */ Ne(_4, [["__file", "tooltip.vue"]]);
  const Pn = rt(T4), N4 = Te({
    ...lu,
    valueKey: {
      type: String,
      default: "value"
    },
    modelValue: {
      type: [String, Number],
      default: ""
    },
    debounce: {
      type: Number,
      default: 300
    },
    placement: {
      type: X(String),
      values: [
        "top",
        "top-start",
        "top-end",
        "bottom",
        "bottom-start",
        "bottom-end"
      ],
      default: "bottom-start"
    },
    fetchSuggestions: {
      type: X([Function, Array]),
      default: It
    },
    popperClass: zt.popperClass,
    popperStyle: zt.popperStyle,
    triggerOnFocus: {
      type: Boolean,
      default: !0
    },
    selectWhenUnmatched: Boolean,
    hideLoading: Boolean,
    teleported: zt.teleported,
    appendTo: zt.appendTo,
    highlightFirstItem: Boolean,
    fitInputWidth: Boolean,
    loopNavigation: {
      type: Boolean,
      default: !0
    }
  }), $4 = {
    [et]: (e) => Ae(e) || je(e),
    [fn]: (e) => Ae(e) || je(e),
    [gt]: (e) => Ae(e) || je(e),
    focus: (e) => e instanceof FocusEvent,
    blur: (e) => e instanceof FocusEvent,
    clear: () => !0,
    select: (e) => ot(e)
  }, tS = "ElAutocomplete", O4 = /* @__PURE__ */ U({
    name: tS,
    inheritAttrs: !1
  }), I4 = /* @__PURE__ */ U({
    ...O4,
    props: N4,
    emits: $4,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = S(() => jl(o, Object.keys(lu))), a = ea(), r = Cn(), i = he("autocomplete"), u = A(), c = A(), d = A(), f = A();
      let v = !1, p = !1;
      const m = A([]), h = A(-1), g = A(""), b = A(!1), C = A(!1), w = A(!1), y = xn(), E = S(() => a.style), k = S(() => (m.value.length > 0 || w.value) && b.value), T = S(() => !o.hideLoading && w.value), x = S(() => u.value ? Array.from(u.value.$el.querySelectorAll("input")) : []), I = () => {
        k.value && (g.value = `${u.value.$el.offsetWidth}px`);
      }, P = () => {
        h.value = -1;
      }, O = async (ne) => {
        if (C.value)
          return;
        const le = (Ce) => {
          w.value = !1, !C.value && (ye(Ce) ? (m.value = Ce, h.value = o.highlightFirstItem ? 0 : -1) : Zt(tS, "autocomplete suggestions must be an array"));
        };
        if (w.value = !0, ye(o.fetchSuggestions))
          le(o.fetchSuggestions);
        else {
          const Ce = await o.fetchSuggestions(ne, le);
          ye(Ce) && le(Ce);
        }
      }, N = S(() => o.debounce), z = eu(O, N), Y = (ne) => {
        const le = !!ne;
        if (n(fn, ne), n(et, ne), C.value = !1, b.value || (b.value = le), !o.triggerOnFocus && !ne) {
          C.value = !0, m.value = [];
          return;
        }
        z(ne);
      }, G = (ne) => {
        var le;
        r.value || (((le = ne.target) == null ? void 0 : le.tagName) !== "INPUT" || x.value.includes(document.activeElement)) && (b.value = !0);
      }, M = (ne) => {
        n(gt, ne);
      }, R = (ne) => {
        var le;
        if (p)
          p = !1;
        else {
          b.value = !0, n("focus", ne);
          const Ce = (le = o.modelValue) != null ? le : "";
          o.triggerOnFocus && !v && z(String(Ce));
        }
      }, D = (ne) => {
        setTimeout(() => {
          var le;
          if ((le = d.value) != null && le.isFocusInsideContent()) {
            p = !0;
            return;
          }
          b.value && H(), n("blur", ne);
        });
      }, L = () => {
        b.value = !1, n(et, ""), n("clear");
      }, V = async () => {
        var ne;
        (ne = u.value) != null && ne.isComposing || (k.value && h.value >= 0 && h.value < m.value.length ? J(m.value[h.value]) : (o.selectWhenUnmatched && (n("select", { value: o.modelValue }), m.value = [], h.value = -1), b.value = !0, z(String(o.modelValue))));
      }, F = (ne) => {
        k.value && (ne.preventDefault(), ne.stopPropagation(), H());
      }, H = () => {
        b.value = !1;
      }, K = () => {
        var ne;
        (ne = u.value) == null || ne.focus();
      }, Z = () => {
        var ne;
        (ne = u.value) == null || ne.blur();
      }, J = async (ne) => {
        n(fn, ne[o.valueKey]), n(et, ne[o.valueKey]), n("select", ne), m.value = [], h.value = -1;
      }, ie = (ne) => {
        var le, Ce;
        if (!k.value || w.value)
          return;
        if (ne < 0) {
          if (!o.loopNavigation) {
            h.value = -1;
            return;
          }
          ne = m.value.length - 1;
        }
        ne >= m.value.length && (ne = o.loopNavigation ? 0 : m.value.length - 1);
        const [j, te] = ue(), ce = te[ne], ge = j.scrollTop, { offsetTop: be, scrollHeight: Ee } = ce;
        be + Ee > ge + j.clientHeight && (j.scrollTop = be + Ee - j.clientHeight), be < ge && (j.scrollTop = be), h.value = ne, (Ce = (le = u.value) == null ? void 0 : le.ref) == null || Ce.setAttribute("aria-activedescendant", `${y.value}-item-${h.value}`);
      }, ue = () => {
        const ne = c.value.querySelector(`.${i.be("suggestion", "wrap")}`), le = ne.querySelectorAll(`.${i.be("suggestion", "list")} li`);
        return [ne, le];
      }, re = ah(f, () => {
        var ne;
        (ne = d.value) != null && ne.isFocusInsideContent() || k.value && H();
      }), se = (ne) => {
        switch (Ht(ne)) {
          case _e.up:
            ne.preventDefault(), ie(h.value - 1);
            break;
          case _e.down:
            ne.preventDefault(), ie(h.value + 1);
            break;
          case _e.enter:
          case _e.numpadEnter:
            ne.preventDefault(), V();
            break;
          case _e.tab:
            H();
            break;
          case _e.esc:
            F(ne);
            break;
          case _e.home:
            ne.preventDefault(), ie(0);
            break;
          case _e.end:
            ne.preventDefault(), ie(m.value.length - 1);
            break;
          case _e.pageUp:
            ne.preventDefault(), ie(Math.max(0, h.value - 10));
            break;
          case _e.pageDown:
            ne.preventDefault(), ie(Math.min(m.value.length - 1, h.value + 10));
            break;
        }
      };
      return Bt(() => {
        re == null || re();
      }), ft(() => {
        var ne;
        const le = (ne = u.value) == null ? void 0 : ne.ref;
        le && ([
          { key: "role", value: "textbox" },
          { key: "aria-autocomplete", value: "list" },
          { key: "aria-controls", value: "id" },
          {
            key: "aria-activedescendant",
            value: `${y.value}-item-${h.value}`
          }
        ].forEach(({ key: Ce, value: j }) => le.setAttribute(Ce, j)), v = le.hasAttribute("readonly"));
      }), t({
        highlightedIndex: h,
        activated: b,
        loading: w,
        inputRef: u,
        popperRef: d,
        suggestions: m,
        handleSelect: J,
        handleKeyEnter: V,
        focus: K,
        blur: Z,
        close: H,
        highlight: ie,
        getData: O
      }), (ne, le) => (_(), ae(s(Pn), {
        ref_key: "popperRef",
        ref: d,
        visible: s(k),
        placement: ne.placement,
        "fallback-placements": ["bottom-start", "top-start"],
        "popper-class": [s(i).e("popper"), ne.popperClass],
        "popper-style": ne.popperStyle,
        teleported: ne.teleported,
        "append-to": ne.appendTo,
        "gpu-acceleration": !1,
        pure: "",
        "manual-mode": "",
        effect: "light",
        trigger: "click",
        transition: `${s(i).namespace.value}-zoom-in-top`,
        persistent: "",
        role: "listbox",
        onBeforeShow: I,
        onHide: P
      }, {
        content: Q(() => [
          W("div", {
            ref_key: "regionRef",
            ref: c,
            class: $([s(i).b("suggestion"), s(i).is("loading", s(T))]),
            style: Ue({
              [ne.fitInputWidth ? "width" : "minWidth"]: g.value,
              outline: "none"
            }),
            role: "region"
          }, [
            ne.$slots.header ? (_(), B("div", {
              key: 0,
              class: $(s(i).be("suggestion", "header")),
              onClick: Ze(() => {
              }, ["stop"])
            }, [
              ee(ne.$slots, "header")
            ], 10, ["onClick"])) : oe("v-if", !0),
            q(s(Go), {
              id: s(y),
              tag: "ul",
              "wrap-class": s(i).be("suggestion", "wrap"),
              "view-class": s(i).be("suggestion", "list"),
              role: "listbox"
            }, {
              default: Q(() => [
                s(T) ? (_(), B("li", { key: 0 }, [
                  ee(ne.$slots, "loading", {}, () => [
                    q(s(ze), {
                      class: $(s(i).is("loading"))
                    }, {
                      default: Q(() => [
                        q(s(Cl))
                      ]),
                      _: 1
                    }, 8, ["class"])
                  ])
                ])) : (_(!0), B(We, { key: 1 }, bt(m.value, (Ce, j) => (_(), B("li", {
                  id: `${s(y)}-item-${j}`,
                  key: j,
                  class: $({ highlighted: h.value === j }),
                  role: "option",
                  "aria-selected": h.value === j,
                  onClick: (te) => J(Ce)
                }, [
                  ee(ne.$slots, "default", { item: Ce }, () => [
                    Ct(ke(Ce[ne.valueKey]), 1)
                  ])
                ], 10, ["id", "aria-selected", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["id", "wrap-class", "view-class"]),
            ne.$slots.footer ? (_(), B("div", {
              key: 1,
              class: $(s(i).be("suggestion", "footer")),
              onClick: Ze(() => {
              }, ["stop"])
            }, [
              ee(ne.$slots, "footer")
            ], 10, ["onClick"])) : oe("v-if", !0)
          ], 6)
        ]),
        default: Q(() => [
          W("div", {
            ref_key: "listboxRef",
            ref: f,
            class: $([s(i).b(), ne.$attrs.class]),
            style: Ue(s(E)),
            role: "combobox",
            "aria-haspopup": "listbox",
            "aria-expanded": s(k),
            "aria-owns": s(y)
          }, [
            q(s(Wn), pt({
              ref_key: "inputRef",
              ref: u
            }, pt(s(l), ne.$attrs), {
              "model-value": ne.modelValue,
              disabled: s(r),
              onInput: Y,
              onChange: M,
              onFocus: R,
              onBlur: D,
              onClear: L,
              onKeydown: se,
              onMousedown: G
            }), io({
              _: 2
            }, [
              ne.$slots.prepend ? {
                name: "prepend",
                fn: Q(() => [
                  ee(ne.$slots, "prepend")
                ])
              } : void 0,
              ne.$slots.append ? {
                name: "append",
                fn: Q(() => [
                  ee(ne.$slots, "append")
                ])
              } : void 0,
              ne.$slots.prefix ? {
                name: "prefix",
                fn: Q(() => [
                  ee(ne.$slots, "prefix")
                ])
              } : void 0,
              ne.$slots.suffix ? {
                name: "suffix",
                fn: Q(() => [
                  ee(ne.$slots, "suffix")
                ])
              } : void 0
            ]), 1040, ["model-value", "disabled"])
          ], 14, ["aria-expanded", "aria-owns"])
        ]),
        _: 3
      }, 8, ["visible", "placement", "popper-class", "popper-style", "teleported", "append-to", "transition"]));
    }
  });
  var M4 = /* @__PURE__ */ Ne(I4, [["__file", "autocomplete.vue"]]);
  const x4 = rt(M4), P4 = Te({
    size: {
      type: [Number, String],
      values: Tl,
      default: "",
      validator: (e) => je(e)
    },
    shape: {
      type: String,
      values: ["circle", "square"],
      default: "circle"
    },
    icon: {
      type: Lt
    },
    src: {
      type: String,
      default: ""
    },
    alt: String,
    srcSet: String,
    fit: {
      type: X(String),
      default: "cover"
    }
  }), R4 = {
    error: (e) => e instanceof Event
  }, D4 = /* @__PURE__ */ U({
    name: "ElAvatar"
  }), A4 = /* @__PURE__ */ U({
    ...D4,
    props: P4,
    emits: R4,
    setup(e, { emit: t }) {
      const n = e, o = he("avatar"), l = A(!1), a = S(() => {
        const { size: c, icon: d, shape: f } = n, v = [o.b()];
        return Ae(c) && v.push(o.m(c)), d && v.push(o.m("icon")), f && v.push(o.m(f)), v;
      }), r = S(() => {
        const { size: c } = n;
        return je(c) ? o.cssVarBlock({
          size: tn(c) || ""
        }) : void 0;
      }), i = S(() => ({
        objectFit: n.fit
      }));
      de(() => n.src, () => l.value = !1);
      function u(c) {
        l.value = !0, t("error", c);
      }
      return (c, d) => (_(), B("span", {
        class: $(s(a)),
        style: Ue(s(r))
      }, [
        (c.src || c.srcSet) && !l.value ? (_(), B("img", {
          key: 0,
          src: c.src,
          alt: c.alt,
          srcset: c.srcSet,
          style: Ue(s(i)),
          onError: u
        }, null, 44, ["src", "alt", "srcset"])) : c.icon ? (_(), ae(s(ze), { key: 1 }, {
          default: Q(() => [
            (_(), ae(ct(c.icon)))
          ]),
          _: 1
        })) : ee(c.$slots, "default", { key: 2 })
      ], 6));
    }
  });
  var V4 = /* @__PURE__ */ Ne(A4, [["__file", "avatar.vue"]]);
  const L4 = rt(V4), B4 = {
    visibilityHeight: {
      type: Number,
      default: 200
    },
    target: {
      type: String,
      default: ""
    },
    right: {
      type: Number,
      default: 40
    },
    bottom: {
      type: Number,
      default: 40
    }
  }, F4 = {
    click: (e) => e instanceof MouseEvent
  }, z4 = (e, t, n) => {
    const o = Ut(), l = Ut(), a = A(!1), r = () => {
      o.value && (a.value = o.value.scrollTop >= e.visibilityHeight);
    }, i = (c) => {
      var d;
      (d = o.value) == null || d.scrollTo({ top: 0, behavior: "smooth" }), t("click", c);
    }, u = Z1(r, 300, !0);
    return Dt(l, "scroll", u), ft(() => {
      var c;
      l.value = document, o.value = document.documentElement, e.target && (o.value = (c = document.querySelector(e.target)) != null ? c : void 0, o.value || Zt(n, `target does not exist: ${e.target}`), l.value = o.value), r();
    }), {
      visible: a,
      handleClick: i
    };
  }, nS = "ElBacktop", H4 = /* @__PURE__ */ U({
    name: nS
  }), K4 = /* @__PURE__ */ U({
    ...H4,
    props: B4,
    emits: F4,
    setup(e, { emit: t }) {
      const n = e, o = he("backtop"), { handleClick: l, visible: a } = z4(n, t, nS), r = S(() => ({
        right: `${n.right}px`,
        bottom: `${n.bottom}px`
      }));
      return (i, u) => (_(), ae(Mn, {
        name: `${s(o).namespace.value}-fade-in`
      }, {
        default: Q(() => [
          s(a) ? (_(), B("div", {
            key: 0,
            style: Ue(s(r)),
            class: $(s(o).b()),
            onClick: Ze(s(l), ["stop"])
          }, [
            ee(i.$slots, "default", {}, () => [
              q(s(ze), {
                class: $(s(o).e("icon"))
              }, {
                default: Q(() => [
                  q(s(zR))
                ]),
                _: 1
              }, 8, ["class"])
            ])
          ], 14, ["onClick"])) : oe("v-if", !0)
        ]),
        _: 3
      }, 8, ["name"]));
    }
  });
  var W4 = /* @__PURE__ */ Ne(K4, [["__file", "backtop.vue"]]);
  const j4 = rt(W4), U4 = Te({
    value: {
      type: [String, Number],
      default: ""
    },
    max: {
      type: Number,
      default: 99
    },
    isDot: Boolean,
    hidden: Boolean,
    type: {
      type: String,
      values: ["primary", "success", "warning", "info", "danger"],
      default: "danger"
    },
    showZero: {
      type: Boolean,
      default: !0
    },
    color: String,
    badgeStyle: {
      type: X([String, Object, Array])
    },
    offset: {
      type: X(Array),
      default: [0, 0]
    },
    badgeClass: {
      type: String
    }
  }), Y4 = /* @__PURE__ */ U({
    name: "ElBadge"
  }), q4 = /* @__PURE__ */ U({
    ...Y4,
    props: U4,
    setup(e, { expose: t }) {
      const n = e, o = he("badge"), l = S(() => n.isDot ? "" : je(n.value) && je(n.max) ? n.max < n.value ? `${n.max}+` : `${n.value}` : `${n.value}`), a = S(() => {
        var r, i, u, c, d;
        return [
          {
            backgroundColor: n.color,
            marginRight: tn(-((i = (r = n.offset) == null ? void 0 : r[0]) != null ? i : 0)),
            marginTop: tn((c = (u = n.offset) == null ? void 0 : u[1]) != null ? c : 0)
          },
          (d = n.badgeStyle) != null ? d : {}
        ];
      });
      return t({
        content: l
      }), (r, i) => (_(), B("div", {
        class: $(s(o).b())
      }, [
        ee(r.$slots, "default"),
        q(Mn, {
          name: `${s(o).namespace.value}-zoom-in-center`,
          persisted: ""
        }, {
          default: Q(() => [
            it(W("sup", {
              class: $([
                s(o).e("content"),
                s(o).em("content", r.type),
                s(o).is("fixed", !!r.$slots.default),
                s(o).is("dot", r.isDot),
                s(o).is("hide-zero", !r.showZero && r.value === 0),
                r.badgeClass
              ]),
              style: Ue(s(a))
            }, [
              ee(r.$slots, "content", { value: s(l) }, () => [
                Ct(ke(s(l)), 1)
              ])
            ], 6), [
              [Mt, !r.hidden && (s(l) || r.isDot || r.$slots.content)]
            ])
          ]),
          _: 3
        }, 8, ["name"])
      ], 2));
    }
  });
  var G4 = /* @__PURE__ */ Ne(q4, [["__file", "badge.vue"]]);
  const oS = rt(G4), lS = Symbol("breadcrumbKey"), X4 = Te({
    separator: {
      type: String,
      default: "/"
    },
    separatorIcon: {
      type: Lt
    }
  }), J4 = /* @__PURE__ */ U({
    name: "ElBreadcrumb"
  }), Z4 = /* @__PURE__ */ U({
    ...J4,
    props: X4,
    setup(e) {
      const t = e, { t: n } = _t(), o = he("breadcrumb"), l = A();
      return yt(lS, t), ft(() => {
        const a = l.value.querySelectorAll(`.${o.e("item")}`);
        a.length && a[a.length - 1].setAttribute("aria-current", "page");
      }), (a, r) => (_(), B("div", {
        ref_key: "breadcrumb",
        ref: l,
        class: $(s(o).b()),
        "aria-label": s(n)("el.breadcrumb.label"),
        role: "navigation"
      }, [
        ee(a.$slots, "default")
      ], 10, ["aria-label"]));
    }
  });
  var Q4 = /* @__PURE__ */ Ne(Z4, [["__file", "breadcrumb.vue"]]);
  const e3 = Te({
    to: {
      type: X([String, Object]),
      default: ""
    },
    replace: Boolean
  }), t3 = /* @__PURE__ */ U({
    name: "ElBreadcrumbItem"
  }), n3 = /* @__PURE__ */ U({
    ...t3,
    props: e3,
    setup(e) {
      const t = e, n = dt(), o = Ve(lS, void 0), l = he("breadcrumb"), a = n.appContext.config.globalProperties.$router, r = A(), i = () => {
        !t.to || !a || (t.replace ? a.replace(t.to) : a.push(t.to));
      };
      return (u, c) => {
        var d, f;
        return _(), B("span", {
          class: $(s(l).e("item"))
        }, [
          W("span", {
            ref_key: "link",
            ref: r,
            class: $([s(l).e("inner"), s(l).is("link", !!u.to)]),
            role: "link",
            onClick: i
          }, [
            ee(u.$slots, "default")
          ], 2),
          (d = s(o)) != null && d.separatorIcon ? (_(), ae(s(ze), {
            key: 0,
            class: $(s(l).e("separator"))
          }, {
            default: Q(() => [
              (_(), ae(ct(s(o).separatorIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : (_(), B("span", {
            key: 1,
            class: $(s(l).e("separator")),
            role: "presentation"
          }, ke((f = s(o)) == null ? void 0 : f.separator), 3))
        ], 2);
      };
    }
  });
  var aS = /* @__PURE__ */ Ne(n3, [["__file", "breadcrumb-item.vue"]]);
  const o3 = rt(Q4, {
    BreadcrumbItem: aS
  }), l3 = nn(aS), rS = Symbol("buttonGroupContextKey"), hl = ({ from: e, replacement: t, scope: n, version: o, ref: l, type: a = "API" }, r) => {
    de(() => s(r), (i) => {
      i && vt(n, `[${a}] ${e} is about to be deprecated in version ${o}, please use ${t} instead.
For more detail, please visit: ${l}
`);
    }, {
      immediate: !0
    });
  }, a3 = (e, t) => {
    hl({
      from: "type.text",
      replacement: "link",
      version: "3.0.0",
      scope: "props",
      ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
    }, S(() => e.type === "text"));
    const n = Ve(rS, void 0), o = ks("button"), { form: l } = Nn(), a = vn(S(() => n == null ? void 0 : n.size)), r = Cn(), i = A(), u = hn(), c = S(() => {
      var b;
      return e.type || (n == null ? void 0 : n.type) || ((b = o.value) == null ? void 0 : b.type) || "";
    }), d = S(() => {
      var b, C, w;
      return (w = (C = e.autoInsertSpace) != null ? C : (b = o.value) == null ? void 0 : b.autoInsertSpace) != null ? w : !1;
    }), f = S(() => {
      var b, C, w;
      return (w = (C = e.plain) != null ? C : (b = o.value) == null ? void 0 : b.plain) != null ? w : !1;
    }), v = S(() => {
      var b, C, w;
      return (w = (C = e.round) != null ? C : (b = o.value) == null ? void 0 : b.round) != null ? w : !1;
    }), p = S(() => {
      var b, C, w;
      return (w = (C = e.text) != null ? C : (b = o.value) == null ? void 0 : b.text) != null ? w : !1;
    }), m = S(() => e.tag === "button" ? {
      ariaDisabled: r.value || e.loading,
      disabled: r.value || e.loading,
      autofocus: e.autofocus,
      type: e.nativeType
    } : {}), h = S(() => {
      var b;
      const C = (b = u.default) == null ? void 0 : b.call(u);
      if (d.value && (C == null ? void 0 : C.length) === 1) {
        const w = C[0];
        if ((w == null ? void 0 : w.type) === Pa) {
          const y = w.children;
          return new RegExp("^\\p{Unified_Ideograph}{2}$", "u").test(y.trim());
        }
      }
      return !1;
    });
    return {
      _disabled: r,
      _size: a,
      _type: c,
      _ref: i,
      _props: m,
      _plain: f,
      _round: v,
      _text: p,
      shouldAddSpace: h,
      handleClick: (b) => {
        if (r.value || e.loading) {
          b.stopPropagation();
          return;
        }
        e.nativeType === "reset" && (l == null || l.resetFields()), t("click", b);
      }
    };
  }, Ep = [
    "default",
    "primary",
    "success",
    "warning",
    "info",
    "danger",
    "text",
    ""
  ], r3 = ["button", "submit", "reset"], kp = Te({
    size: mn,
    disabled: Boolean,
    type: {
      type: String,
      values: Ep,
      default: ""
    },
    icon: {
      type: Lt
    },
    nativeType: {
      type: String,
      values: r3,
      default: "button"
    },
    loading: Boolean,
    loadingIcon: {
      type: Lt,
      default: () => Cl
    },
    plain: {
      type: Boolean,
      default: void 0
    },
    text: {
      type: Boolean,
      default: void 0
    },
    link: Boolean,
    bg: Boolean,
    autofocus: Boolean,
    round: {
      type: Boolean,
      default: void 0
    },
    circle: Boolean,
    color: String,
    dark: Boolean,
    autoInsertSpace: {
      type: Boolean,
      default: void 0
    },
    tag: {
      type: X([String, Object]),
      default: "button"
    }
  }), s3 = {
    click: (e) => e instanceof MouseEvent
  };
  function Vn(e, t) {
    i3(e) && (e = "100%");
    var n = u3(e);
    return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))), n && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)), e);
  }
  function Ru(e) {
    return Math.min(1, Math.max(0, e));
  }
  function i3(e) {
    return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1;
  }
  function u3(e) {
    return typeof e == "string" && e.indexOf("%") !== -1;
  }
  function sS(e) {
    return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
  }
  function Du(e) {
    return e <= 1 ? "".concat(Number(e) * 100, "%") : e;
  }
  function Ya(e) {
    return e.length === 1 ? "0" + e : String(e);
  }
  function c3(e, t, n) {
    return {
      r: Vn(e, 255) * 255,
      g: Vn(t, 255) * 255,
      b: Vn(n, 255) * 255
    };
  }
  function qb(e, t, n) {
    e = Vn(e, 255), t = Vn(t, 255), n = Vn(n, 255);
    var o = Math.max(e, t, n), l = Math.min(e, t, n), a = 0, r = 0, i = (o + l) / 2;
    if (o === l)
      r = 0, a = 0;
    else {
      var u = o - l;
      switch (r = i > 0.5 ? u / (2 - o - l) : u / (o + l), o) {
        case e:
          a = (t - n) / u + (t < n ? 6 : 0);
          break;
        case t:
          a = (n - e) / u + 2;
          break;
        case n:
          a = (e - t) / u + 4;
          break;
      }
      a /= 6;
    }
    return { h: a, s: r, l: i };
  }
  function Nf(e, t, n) {
    return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
  }
  function d3(e, t, n) {
    var o, l, a;
    if (e = Vn(e, 360), t = Vn(t, 100), n = Vn(n, 100), t === 0)
      l = n, a = n, o = n;
    else {
      var r = n < 0.5 ? n * (1 + t) : n + t - n * t, i = 2 * n - r;
      o = Nf(i, r, e + 1 / 3), l = Nf(i, r, e), a = Nf(i, r, e - 1 / 3);
    }
    return { r: o * 255, g: l * 255, b: a * 255 };
  }
  function Gb(e, t, n) {
    e = Vn(e, 255), t = Vn(t, 255), n = Vn(n, 255);
    var o = Math.max(e, t, n), l = Math.min(e, t, n), a = 0, r = o, i = o - l, u = o === 0 ? 0 : i / o;
    if (o === l)
      a = 0;
    else {
      switch (o) {
        case e:
          a = (t - n) / i + (t < n ? 6 : 0);
          break;
        case t:
          a = (n - e) / i + 2;
          break;
        case n:
          a = (e - t) / i + 4;
          break;
      }
      a /= 6;
    }
    return { h: a, s: u, v: r };
  }
  function f3(e, t, n) {
    e = Vn(e, 360) * 6, t = Vn(t, 100), n = Vn(n, 100);
    var o = Math.floor(e), l = e - o, a = n * (1 - t), r = n * (1 - l * t), i = n * (1 - (1 - l) * t), u = o % 6, c = [n, r, a, a, i, n][u], d = [i, n, n, r, a, a][u], f = [a, a, i, n, n, r][u];
    return { r: c * 255, g: d * 255, b: f * 255 };
  }
  function Xb(e, t, n, o) {
    var l = [
      Ya(Math.round(e).toString(16)),
      Ya(Math.round(t).toString(16)),
      Ya(Math.round(n).toString(16))
    ];
    return o && l[0].startsWith(l[0].charAt(1)) && l[1].startsWith(l[1].charAt(1)) && l[2].startsWith(l[2].charAt(1)) ? l[0].charAt(0) + l[1].charAt(0) + l[2].charAt(0) : l.join("");
  }
  function p3(e, t, n, o, l) {
    var a = [
      Ya(Math.round(e).toString(16)),
      Ya(Math.round(t).toString(16)),
      Ya(Math.round(n).toString(16)),
      Ya(v3(o))
    ];
    return l && a[0].startsWith(a[0].charAt(1)) && a[1].startsWith(a[1].charAt(1)) && a[2].startsWith(a[2].charAt(1)) && a[3].startsWith(a[3].charAt(1)) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0) : a.join("");
  }
  function v3(e) {
    return Math.round(parseFloat(e) * 255).toString(16);
  }
  function Jb(e) {
    return co(e) / 255;
  }
  function co(e) {
    return parseInt(e, 16);
  }
  function h3(e) {
    return {
      r: e >> 16,
      g: (e & 65280) >> 8,
      b: e & 255
    };
  }
  var _p = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
  function m3(e) {
    var t = { r: 0, g: 0, b: 0 }, n = 1, o = null, l = null, a = null, r = !1, i = !1;
    return typeof e == "string" && (e = y3(e)), typeof e == "object" && (xl(e.r) && xl(e.g) && xl(e.b) ? (t = c3(e.r, e.g, e.b), r = !0, i = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : xl(e.h) && xl(e.s) && xl(e.v) ? (o = Du(e.s), l = Du(e.v), t = f3(e.h, o, l), r = !0, i = "hsv") : xl(e.h) && xl(e.s) && xl(e.l) && (o = Du(e.s), a = Du(e.l), t = d3(e.h, o, a), r = !0, i = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (n = e.a)), n = sS(n), {
      ok: r,
      format: e.format || i,
      r: Math.min(255, Math.max(t.r, 0)),
      g: Math.min(255, Math.max(t.g, 0)),
      b: Math.min(255, Math.max(t.b, 0)),
      a: n
    };
  }
  var g3 = "[-\\+]?\\d+%?", b3 = "[-\\+]?\\d*\\.\\d+%?", ya = "(?:".concat(b3, ")|(?:").concat(g3, ")"), $f = "[\\s|\\(]+(".concat(ya, ")[,|\\s]+(").concat(ya, ")[,|\\s]+(").concat(ya, ")\\s*\\)?"), Of = "[\\s|\\(]+(".concat(ya, ")[,|\\s]+(").concat(ya, ")[,|\\s]+(").concat(ya, ")[,|\\s]+(").concat(ya, ")\\s*\\)?"), Po = {
    CSS_UNIT: new RegExp(ya),
    rgb: new RegExp("rgb" + $f),
    rgba: new RegExp("rgba" + Of),
    hsl: new RegExp("hsl" + $f),
    hsla: new RegExp("hsla" + Of),
    hsv: new RegExp("hsv" + $f),
    hsva: new RegExp("hsva" + Of),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
  function y3(e) {
    if (e = e.trim().toLowerCase(), e.length === 0)
      return !1;
    var t = !1;
    if (_p[e])
      e = _p[e], t = !0;
    else if (e === "transparent")
      return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    var n = Po.rgb.exec(e);
    return n ? { r: n[1], g: n[2], b: n[3] } : (n = Po.rgba.exec(e), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = Po.hsl.exec(e), n ? { h: n[1], s: n[2], l: n[3] } : (n = Po.hsla.exec(e), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = Po.hsv.exec(e), n ? { h: n[1], s: n[2], v: n[3] } : (n = Po.hsva.exec(e), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = Po.hex8.exec(e), n ? {
      r: co(n[1]),
      g: co(n[2]),
      b: co(n[3]),
      a: Jb(n[4]),
      format: t ? "name" : "hex8"
    } : (n = Po.hex6.exec(e), n ? {
      r: co(n[1]),
      g: co(n[2]),
      b: co(n[3]),
      format: t ? "name" : "hex"
    } : (n = Po.hex4.exec(e), n ? {
      r: co(n[1] + n[1]),
      g: co(n[2] + n[2]),
      b: co(n[3] + n[3]),
      a: Jb(n[4] + n[4]),
      format: t ? "name" : "hex8"
    } : (n = Po.hex3.exec(e), n ? {
      r: co(n[1] + n[1]),
      g: co(n[2] + n[2]),
      b: co(n[3] + n[3]),
      format: t ? "name" : "hex"
    } : !1)))))))));
  }
  function xl(e) {
    return !!Po.CSS_UNIT.exec(String(e));
  }
  var Lr = (
    /** @class */
    function() {
      function e(t, n) {
        t === void 0 && (t = ""), n === void 0 && (n = {});
        var o;
        if (t instanceof e)
          return t;
        typeof t == "number" && (t = h3(t)), this.originalInput = t;
        var l = m3(t);
        this.originalInput = t, this.r = l.r, this.g = l.g, this.b = l.b, this.a = l.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (o = n.format) !== null && o !== void 0 ? o : l.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = l.ok;
      }
      return e.prototype.isDark = function() {
        return this.getBrightness() < 128;
      }, e.prototype.isLight = function() {
        return !this.isDark();
      }, e.prototype.getBrightness = function() {
        var t = this.toRgb();
        return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
      }, e.prototype.getLuminance = function() {
        var t = this.toRgb(), n, o, l, a = t.r / 255, r = t.g / 255, i = t.b / 255;
        return a <= 0.03928 ? n = a / 12.92 : n = Math.pow((a + 0.055) / 1.055, 2.4), r <= 0.03928 ? o = r / 12.92 : o = Math.pow((r + 0.055) / 1.055, 2.4), i <= 0.03928 ? l = i / 12.92 : l = Math.pow((i + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * o + 0.0722 * l;
      }, e.prototype.getAlpha = function() {
        return this.a;
      }, e.prototype.setAlpha = function(t) {
        return this.a = sS(t), this.roundA = Math.round(100 * this.a) / 100, this;
      }, e.prototype.isMonochrome = function() {
        var t = this.toHsl().s;
        return t === 0;
      }, e.prototype.toHsv = function() {
        var t = Gb(this.r, this.g, this.b);
        return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
      }, e.prototype.toHsvString = function() {
        var t = Gb(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), l = Math.round(t.v * 100);
        return this.a === 1 ? "hsv(".concat(n, ", ").concat(o, "%, ").concat(l, "%)") : "hsva(".concat(n, ", ").concat(o, "%, ").concat(l, "%, ").concat(this.roundA, ")");
      }, e.prototype.toHsl = function() {
        var t = qb(this.r, this.g, this.b);
        return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
      }, e.prototype.toHslString = function() {
        var t = qb(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), l = Math.round(t.l * 100);
        return this.a === 1 ? "hsl(".concat(n, ", ").concat(o, "%, ").concat(l, "%)") : "hsla(".concat(n, ", ").concat(o, "%, ").concat(l, "%, ").concat(this.roundA, ")");
      }, e.prototype.toHex = function(t) {
        return t === void 0 && (t = !1), Xb(this.r, this.g, this.b, t);
      }, e.prototype.toHexString = function(t) {
        return t === void 0 && (t = !1), "#" + this.toHex(t);
      }, e.prototype.toHex8 = function(t) {
        return t === void 0 && (t = !1), p3(this.r, this.g, this.b, this.a, t);
      }, e.prototype.toHex8String = function(t) {
        return t === void 0 && (t = !1), "#" + this.toHex8(t);
      }, e.prototype.toHexShortString = function(t) {
        return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
      }, e.prototype.toRgb = function() {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a
        };
      }, e.prototype.toRgbString = function() {
        var t = Math.round(this.r), n = Math.round(this.g), o = Math.round(this.b);
        return this.a === 1 ? "rgb(".concat(t, ", ").concat(n, ", ").concat(o, ")") : "rgba(".concat(t, ", ").concat(n, ", ").concat(o, ", ").concat(this.roundA, ")");
      }, e.prototype.toPercentageRgb = function() {
        var t = function(n) {
          return "".concat(Math.round(Vn(n, 255) * 100), "%");
        };
        return {
          r: t(this.r),
          g: t(this.g),
          b: t(this.b),
          a: this.a
        };
      }, e.prototype.toPercentageRgbString = function() {
        var t = function(n) {
          return Math.round(Vn(n, 255) * 100);
        };
        return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
      }, e.prototype.toName = function() {
        if (this.a === 0)
          return "transparent";
        if (this.a < 1)
          return !1;
        for (var t = "#" + Xb(this.r, this.g, this.b, !1), n = 0, o = Object.entries(_p); n < o.length; n++) {
          var l = o[n], a = l[0], r = l[1];
          if (t === r)
            return a;
        }
        return !1;
      }, e.prototype.toString = function(t) {
        var n = !!t;
        t = t ?? this.format;
        var o = !1, l = this.a < 1 && this.a >= 0, a = !n && l && (t.startsWith("hex") || t === "name");
        return a ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (o = this.toRgbString()), t === "prgb" && (o = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (o = this.toHexString()), t === "hex3" && (o = this.toHexString(!0)), t === "hex4" && (o = this.toHex8String(!0)), t === "hex8" && (o = this.toHex8String()), t === "name" && (o = this.toName()), t === "hsl" && (o = this.toHslString()), t === "hsv" && (o = this.toHsvString()), o || this.toHexString());
      }, e.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
      }, e.prototype.clone = function() {
        return new e(this.toString());
      }, e.prototype.lighten = function(t) {
        t === void 0 && (t = 10);
        var n = this.toHsl();
        return n.l += t / 100, n.l = Ru(n.l), new e(n);
      }, e.prototype.brighten = function(t) {
        t === void 0 && (t = 10);
        var n = this.toRgb();
        return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100)))), new e(n);
      }, e.prototype.darken = function(t) {
        t === void 0 && (t = 10);
        var n = this.toHsl();
        return n.l -= t / 100, n.l = Ru(n.l), new e(n);
      }, e.prototype.tint = function(t) {
        return t === void 0 && (t = 10), this.mix("white", t);
      }, e.prototype.shade = function(t) {
        return t === void 0 && (t = 10), this.mix("black", t);
      }, e.prototype.desaturate = function(t) {
        t === void 0 && (t = 10);
        var n = this.toHsl();
        return n.s -= t / 100, n.s = Ru(n.s), new e(n);
      }, e.prototype.saturate = function(t) {
        t === void 0 && (t = 10);
        var n = this.toHsl();
        return n.s += t / 100, n.s = Ru(n.s), new e(n);
      }, e.prototype.greyscale = function() {
        return this.desaturate(100);
      }, e.prototype.spin = function(t) {
        var n = this.toHsl(), o = (n.h + t) % 360;
        return n.h = o < 0 ? 360 + o : o, new e(n);
      }, e.prototype.mix = function(t, n) {
        n === void 0 && (n = 50);
        var o = this.toRgb(), l = new e(t).toRgb(), a = n / 100, r = {
          r: (l.r - o.r) * a + o.r,
          g: (l.g - o.g) * a + o.g,
          b: (l.b - o.b) * a + o.b,
          a: (l.a - o.a) * a + o.a
        };
        return new e(r);
      }, e.prototype.analogous = function(t, n) {
        t === void 0 && (t = 6), n === void 0 && (n = 30);
        var o = this.toHsl(), l = 360 / n, a = [this];
        for (o.h = (o.h - (l * t >> 1) + 720) % 360; --t; )
          o.h = (o.h + l) % 360, a.push(new e(o));
        return a;
      }, e.prototype.complement = function() {
        var t = this.toHsl();
        return t.h = (t.h + 180) % 360, new e(t);
      }, e.prototype.monochromatic = function(t) {
        t === void 0 && (t = 6);
        for (var n = this.toHsv(), o = n.h, l = n.s, a = n.v, r = [], i = 1 / t; t--; )
          r.push(new e({ h: o, s: l, v: a })), a = (a + i) % 1;
        return r;
      }, e.prototype.splitcomplement = function() {
        var t = this.toHsl(), n = t.h;
        return [
          this,
          new e({ h: (n + 72) % 360, s: t.s, l: t.l }),
          new e({ h: (n + 216) % 360, s: t.s, l: t.l })
        ];
      }, e.prototype.onBackground = function(t) {
        var n = this.toRgb(), o = new e(t).toRgb(), l = n.a + o.a * (1 - n.a);
        return new e({
          r: (n.r * n.a + o.r * o.a * (1 - n.a)) / l,
          g: (n.g * n.a + o.g * o.a * (1 - n.a)) / l,
          b: (n.b * n.a + o.b * o.a * (1 - n.a)) / l,
          a: l
        });
      }, e.prototype.triad = function() {
        return this.polyad(3);
      }, e.prototype.tetrad = function() {
        return this.polyad(4);
      }, e.prototype.polyad = function(t) {
        for (var n = this.toHsl(), o = n.h, l = [this], a = 360 / t, r = 1; r < t; r++)
          l.push(new e({ h: (o + r * a) % 360, s: n.s, l: n.l }));
        return l;
      }, e.prototype.equals = function(t) {
        return this.toRgbString() === new e(t).toRgbString();
      }, e;
    }()
  );
  function ua(e, t = 20) {
    return e.mix("#141414", t).toString();
  }
  function w3(e) {
    const t = Cn(), n = he("button");
    return S(() => {
      let o = {}, l = e.color;
      if (l) {
        const a = l.match(/var\((.*?)\)/);
        a && (l = window.getComputedStyle(window.document.documentElement).getPropertyValue(a[1]));
        const r = new Lr(l), i = e.dark ? r.tint(20).toString() : ua(r, 20);
        if (e.plain)
          o = n.cssVarBlock({
            "bg-color": e.dark ? ua(r, 90) : r.tint(90).toString(),
            "text-color": l,
            "border-color": e.dark ? ua(r, 50) : r.tint(50).toString(),
            "hover-text-color": `var(${n.cssVarName("color-white")})`,
            "hover-bg-color": l,
            "hover-border-color": l,
            "active-bg-color": i,
            "active-text-color": `var(${n.cssVarName("color-white")})`,
            "active-border-color": i
          }), t.value && (o[n.cssVarBlockName("disabled-bg-color")] = e.dark ? ua(r, 90) : r.tint(90).toString(), o[n.cssVarBlockName("disabled-text-color")] = e.dark ? ua(r, 50) : r.tint(50).toString(), o[n.cssVarBlockName("disabled-border-color")] = e.dark ? ua(r, 80) : r.tint(80).toString());
        else {
          const u = e.dark ? ua(r, 30) : r.tint(30).toString(), c = r.isDark() ? `var(${n.cssVarName("color-white")})` : `var(${n.cssVarName("color-black")})`;
          if (o = n.cssVarBlock({
            "bg-color": l,
            "text-color": c,
            "border-color": l,
            "hover-bg-color": u,
            "hover-text-color": c,
            "hover-border-color": u,
            "active-bg-color": i,
            "active-border-color": i
          }), t.value) {
            const d = e.dark ? ua(r, 50) : r.tint(50).toString();
            o[n.cssVarBlockName("disabled-bg-color")] = d, o[n.cssVarBlockName("disabled-text-color")] = e.dark ? "rgba(255, 255, 255, 0.5)" : `var(${n.cssVarName("color-white")})`, o[n.cssVarBlockName("disabled-border-color")] = d;
          }
        }
      }
      return o;
    });
  }
  const C3 = /* @__PURE__ */ U({
    name: "ElButton"
  }), S3 = /* @__PURE__ */ U({
    ...C3,
    props: kp,
    emits: s3,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = w3(o), a = he("button"), {
        _ref: r,
        _size: i,
        _type: u,
        _disabled: c,
        _props: d,
        _plain: f,
        _round: v,
        _text: p,
        shouldAddSpace: m,
        handleClick: h
      } = a3(o, n), g = S(() => [
        a.b(),
        a.m(u.value),
        a.m(i.value),
        a.is("disabled", c.value),
        a.is("loading", o.loading),
        a.is("plain", f.value),
        a.is("round", v.value),
        a.is("circle", o.circle),
        a.is("text", p.value),
        a.is("link", o.link),
        a.is("has-bg", o.bg)
      ]);
      return t({
        ref: r,
        size: i,
        type: u,
        disabled: c,
        shouldAddSpace: m
      }), (b, C) => (_(), ae(ct(b.tag), pt({
        ref_key: "_ref",
        ref: r
      }, s(d), {
        class: s(g),
        style: s(l),
        onClick: s(h)
      }), {
        default: Q(() => [
          b.loading ? (_(), B(We, { key: 0 }, [
            b.$slots.loading ? ee(b.$slots, "loading", { key: 0 }) : (_(), ae(s(ze), {
              key: 1,
              class: $(s(a).is("loading"))
            }, {
              default: Q(() => [
                (_(), ae(ct(b.loadingIcon)))
              ]),
              _: 1
            }, 8, ["class"]))
          ], 64)) : b.icon || b.$slots.icon ? (_(), ae(s(ze), { key: 1 }, {
            default: Q(() => [
              b.icon ? (_(), ae(ct(b.icon), { key: 0 })) : ee(b.$slots, "icon", { key: 1 })
            ]),
            _: 3
          })) : oe("v-if", !0),
          b.$slots.default ? (_(), B("span", {
            key: 2,
            class: $({ [s(a).em("text", "expand")]: s(m) })
          }, [
            ee(b.$slots, "default")
          ], 2)) : oe("v-if", !0)
        ]),
        _: 3
      }, 16, ["class", "style", "onClick"]));
    }
  });
  var E3 = /* @__PURE__ */ Ne(S3, [["__file", "button.vue"]]);
  const k3 = {
    size: kp.size,
    type: kp.type
  }, _3 = /* @__PURE__ */ U({
    name: "ElButtonGroup"
  }), T3 = /* @__PURE__ */ U({
    ..._3,
    props: k3,
    setup(e) {
      const t = e;
      yt(rS, Rt({
        size: At(t, "size"),
        type: At(t, "type")
      }));
      const n = he("button");
      return (o, l) => (_(), B("div", {
        class: $(s(n).b("group"))
      }, [
        ee(o.$slots, "default")
      ], 2));
    }
  });
  var iS = /* @__PURE__ */ Ne(T3, [["__file", "button-group.vue"]]);
  const _n = rt(E3, {
    ButtonGroup: iS
  }), uS = nn(iS);
  var ra = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
  function sa(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  }
  var cS = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(ra, function() {
      var n = 1e3, o = 6e4, l = 36e5, a = "millisecond", r = "second", i = "minute", u = "hour", c = "day", d = "week", f = "month", v = "quarter", p = "year", m = "date", h = "Invalid Date", g = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, b = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, C = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(Y) {
        var G = ["th", "st", "nd", "rd"], M = Y % 100;
        return "[" + Y + (G[(M - 20) % 10] || G[M] || G[0]) + "]";
      } }, w = function(Y, G, M) {
        var R = String(Y);
        return !R || R.length >= G ? Y : "" + Array(G + 1 - R.length).join(M) + Y;
      }, y = { s: w, z: function(Y) {
        var G = -Y.utcOffset(), M = Math.abs(G), R = Math.floor(M / 60), D = M % 60;
        return (G <= 0 ? "+" : "-") + w(R, 2, "0") + ":" + w(D, 2, "0");
      }, m: function Y(G, M) {
        if (G.date() < M.date()) return -Y(M, G);
        var R = 12 * (M.year() - G.year()) + (M.month() - G.month()), D = G.clone().add(R, f), L = M - D < 0, V = G.clone().add(R + (L ? -1 : 1), f);
        return +(-(R + (M - D) / (L ? D - V : V - D)) || 0);
      }, a: function(Y) {
        return Y < 0 ? Math.ceil(Y) || 0 : Math.floor(Y);
      }, p: function(Y) {
        return { M: f, y: p, w: d, d: c, D: m, h: u, m: i, s: r, ms: a, Q: v }[Y] || String(Y || "").toLowerCase().replace(/s$/, "");
      }, u: function(Y) {
        return Y === void 0;
      } }, E = "en", k = {};
      k[E] = C;
      var T = "$isDayjsObject", x = function(Y) {
        return Y instanceof N || !(!Y || !Y[T]);
      }, I = function Y(G, M, R) {
        var D;
        if (!G) return E;
        if (typeof G == "string") {
          var L = G.toLowerCase();
          k[L] && (D = L), M && (k[L] = M, D = L);
          var V = G.split("-");
          if (!D && V.length > 1) return Y(V[0]);
        } else {
          var F = G.name;
          k[F] = G, D = F;
        }
        return !R && D && (E = D), D || !R && E;
      }, P = function(Y, G) {
        if (x(Y)) return Y.clone();
        var M = typeof G == "object" ? G : {};
        return M.date = Y, M.args = arguments, new N(M);
      }, O = y;
      O.l = I, O.i = x, O.w = function(Y, G) {
        return P(Y, { locale: G.$L, utc: G.$u, x: G.$x, $offset: G.$offset });
      };
      var N = function() {
        function Y(M) {
          this.$L = I(M.locale, null, !0), this.parse(M), this.$x = this.$x || M.x || {}, this[T] = !0;
        }
        var G = Y.prototype;
        return G.parse = function(M) {
          this.$d = function(R) {
            var D = R.date, L = R.utc;
            if (D === null) return /* @__PURE__ */ new Date(NaN);
            if (O.u(D)) return /* @__PURE__ */ new Date();
            if (D instanceof Date) return new Date(D);
            if (typeof D == "string" && !/Z$/i.test(D)) {
              var V = D.match(g);
              if (V) {
                var F = V[2] - 1 || 0, H = (V[7] || "0").substring(0, 3);
                return L ? new Date(Date.UTC(V[1], F, V[3] || 1, V[4] || 0, V[5] || 0, V[6] || 0, H)) : new Date(V[1], F, V[3] || 1, V[4] || 0, V[5] || 0, V[6] || 0, H);
              }
            }
            return new Date(D);
          }(M), this.init();
        }, G.init = function() {
          var M = this.$d;
          this.$y = M.getFullYear(), this.$M = M.getMonth(), this.$D = M.getDate(), this.$W = M.getDay(), this.$H = M.getHours(), this.$m = M.getMinutes(), this.$s = M.getSeconds(), this.$ms = M.getMilliseconds();
        }, G.$utils = function() {
          return O;
        }, G.isValid = function() {
          return this.$d.toString() !== h;
        }, G.isSame = function(M, R) {
          var D = P(M);
          return this.startOf(R) <= D && D <= this.endOf(R);
        }, G.isAfter = function(M, R) {
          return P(M) < this.startOf(R);
        }, G.isBefore = function(M, R) {
          return this.endOf(R) < P(M);
        }, G.$g = function(M, R, D) {
          return O.u(M) ? this[R] : this.set(D, M);
        }, G.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, G.valueOf = function() {
          return this.$d.getTime();
        }, G.startOf = function(M, R) {
          var D = this, L = !!O.u(R) || R, V = O.p(M), F = function(se, ne) {
            var le = O.w(D.$u ? Date.UTC(D.$y, ne, se) : new Date(D.$y, ne, se), D);
            return L ? le : le.endOf(c);
          }, H = function(se, ne) {
            return O.w(D.toDate()[se].apply(D.toDate("s"), (L ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ne)), D);
          }, K = this.$W, Z = this.$M, J = this.$D, ie = "set" + (this.$u ? "UTC" : "");
          switch (V) {
            case p:
              return L ? F(1, 0) : F(31, 11);
            case f:
              return L ? F(1, Z) : F(0, Z + 1);
            case d:
              var ue = this.$locale().weekStart || 0, re = (K < ue ? K + 7 : K) - ue;
              return F(L ? J - re : J + (6 - re), Z);
            case c:
            case m:
              return H(ie + "Hours", 0);
            case u:
              return H(ie + "Minutes", 1);
            case i:
              return H(ie + "Seconds", 2);
            case r:
              return H(ie + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, G.endOf = function(M) {
          return this.startOf(M, !1);
        }, G.$set = function(M, R) {
          var D, L = O.p(M), V = "set" + (this.$u ? "UTC" : ""), F = (D = {}, D[c] = V + "Date", D[m] = V + "Date", D[f] = V + "Month", D[p] = V + "FullYear", D[u] = V + "Hours", D[i] = V + "Minutes", D[r] = V + "Seconds", D[a] = V + "Milliseconds", D)[L], H = L === c ? this.$D + (R - this.$W) : R;
          if (L === f || L === p) {
            var K = this.clone().set(m, 1);
            K.$d[F](H), K.init(), this.$d = K.set(m, Math.min(this.$D, K.daysInMonth())).$d;
          } else F && this.$d[F](H);
          return this.init(), this;
        }, G.set = function(M, R) {
          return this.clone().$set(M, R);
        }, G.get = function(M) {
          return this[O.p(M)]();
        }, G.add = function(M, R) {
          var D, L = this;
          M = Number(M);
          var V = O.p(R), F = function(Z) {
            var J = P(L);
            return O.w(J.date(J.date() + Math.round(Z * M)), L);
          };
          if (V === f) return this.set(f, this.$M + M);
          if (V === p) return this.set(p, this.$y + M);
          if (V === c) return F(1);
          if (V === d) return F(7);
          var H = (D = {}, D[i] = o, D[u] = l, D[r] = n, D)[V] || 1, K = this.$d.getTime() + M * H;
          return O.w(K, this);
        }, G.subtract = function(M, R) {
          return this.add(-1 * M, R);
        }, G.format = function(M) {
          var R = this, D = this.$locale();
          if (!this.isValid()) return D.invalidDate || h;
          var L = M || "YYYY-MM-DDTHH:mm:ssZ", V = O.z(this), F = this.$H, H = this.$m, K = this.$M, Z = D.weekdays, J = D.months, ie = D.meridiem, ue = function(ne, le, Ce, j) {
            return ne && (ne[le] || ne(R, L)) || Ce[le].slice(0, j);
          }, re = function(ne) {
            return O.s(F % 12 || 12, ne, "0");
          }, se = ie || function(ne, le, Ce) {
            var j = ne < 12 ? "AM" : "PM";
            return Ce ? j.toLowerCase() : j;
          };
          return L.replace(b, function(ne, le) {
            return le || function(Ce) {
              switch (Ce) {
                case "YY":
                  return String(R.$y).slice(-2);
                case "YYYY":
                  return O.s(R.$y, 4, "0");
                case "M":
                  return K + 1;
                case "MM":
                  return O.s(K + 1, 2, "0");
                case "MMM":
                  return ue(D.monthsShort, K, J, 3);
                case "MMMM":
                  return ue(J, K);
                case "D":
                  return R.$D;
                case "DD":
                  return O.s(R.$D, 2, "0");
                case "d":
                  return String(R.$W);
                case "dd":
                  return ue(D.weekdaysMin, R.$W, Z, 2);
                case "ddd":
                  return ue(D.weekdaysShort, R.$W, Z, 3);
                case "dddd":
                  return Z[R.$W];
                case "H":
                  return String(F);
                case "HH":
                  return O.s(F, 2, "0");
                case "h":
                  return re(1);
                case "hh":
                  return re(2);
                case "a":
                  return se(F, H, !0);
                case "A":
                  return se(F, H, !1);
                case "m":
                  return String(H);
                case "mm":
                  return O.s(H, 2, "0");
                case "s":
                  return String(R.$s);
                case "ss":
                  return O.s(R.$s, 2, "0");
                case "SSS":
                  return O.s(R.$ms, 3, "0");
                case "Z":
                  return V;
              }
              return null;
            }(ne) || V.replace(":", "");
          });
        }, G.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, G.diff = function(M, R, D) {
          var L, V = this, F = O.p(R), H = P(M), K = (H.utcOffset() - this.utcOffset()) * o, Z = this - H, J = function() {
            return O.m(V, H);
          };
          switch (F) {
            case p:
              L = J() / 12;
              break;
            case f:
              L = J();
              break;
            case v:
              L = J() / 3;
              break;
            case d:
              L = (Z - K) / 6048e5;
              break;
            case c:
              L = (Z - K) / 864e5;
              break;
            case u:
              L = Z / l;
              break;
            case i:
              L = Z / o;
              break;
            case r:
              L = Z / n;
              break;
            default:
              L = Z;
          }
          return D ? L : O.a(L);
        }, G.daysInMonth = function() {
          return this.endOf(f).$D;
        }, G.$locale = function() {
          return k[this.$L];
        }, G.locale = function(M, R) {
          if (!M) return this.$L;
          var D = this.clone(), L = I(M, R, !0);
          return L && (D.$L = L), D;
        }, G.clone = function() {
          return O.w(this.$d, this);
        }, G.toDate = function() {
          return new Date(this.valueOf());
        }, G.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, G.toISOString = function() {
          return this.$d.toISOString();
        }, G.toString = function() {
          return this.$d.toUTCString();
        }, Y;
      }(), z = N.prototype;
      return P.prototype = z, [["$ms", a], ["$s", r], ["$m", i], ["$H", u], ["$W", c], ["$M", f], ["$y", p], ["$D", m]].forEach(function(Y) {
        z[Y[1]] = function(G) {
          return this.$g(G, Y[0], Y[1]);
        };
      }), P.extend = function(Y, G) {
        return Y.$i || (Y(G, N, P), Y.$i = !0), P;
      }, P.locale = I, P.isDayjs = x, P.unix = function(Y) {
        return P(1e3 * Y);
      }, P.en = k[E], P.Ls = k, P.p = {}, P;
    });
  })(cS);
  var N3 = cS.exports;
  const st = /* @__PURE__ */ sa(N3), If = (e, t) => [
    e > 0 ? e - 1 : void 0,
    e,
    e < t ? e + 1 : void 0
  ], Ea = (e) => Array.from(Array.from({ length: e }).keys()), dS = (e) => e.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim(), fS = (e) => e.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim(), Zb = function(e, t) {
    const n = ka(e), o = ka(t);
    return n && o ? e.getTime() === t.getTime() : !n && !o ? e === t : !1;
  }, pS = function(e, t) {
    const n = ye(e), o = ye(t);
    return n && o ? e.length !== t.length ? !1 : e.every((l, a) => Zb(l, t[a])) : !n && !o ? Zb(e, t) : !1;
  }, Qb = function(e, t, n) {
    const o = Zn(t) || t === "x" ? st(e).locale(n) : st(e, t).locale(n);
    return o.isValid() ? o : void 0;
  }, ey = function(e, t, n) {
    return Zn(t) ? e : t === "x" ? +e : st(e).locale(n).format(t);
  }, Mf = (e, t) => {
    var n;
    const o = [], l = t == null ? void 0 : t();
    for (let a = 0; a < e; a++)
      o.push((n = l == null ? void 0 : l.includes(a)) != null ? n : !1);
    return o;
  }, nc = (e) => ye(e) ? e.map((t) => t.toDate()) : e.toDate(), $3 = (e, t) => {
    const n = e.subtract(1, "month").endOf("month").date();
    return Ea(t).map((o, l) => n - (t - l - 1));
  }, O3 = (e) => {
    const t = e.daysInMonth();
    return Ea(t).map((n, o) => o + 1);
  }, I3 = (e) => Ea(e.length / 7).map((t) => {
    const n = t * 7;
    return e.slice(n, n + 7);
  }), M3 = Te({
    selectedDay: {
      type: X(Object)
    },
    range: {
      type: X(Array)
    },
    date: {
      type: X(Object),
      required: !0
    },
    hideHeader: {
      type: Boolean
    }
  }), x3 = {
    pick: (e) => ot(e)
  };
  var vS = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(ra, function() {
      return function(n, o, l) {
        var a = o.prototype, r = function(f) {
          return f && (f.indexOf ? f : f.s);
        }, i = function(f, v, p, m, h) {
          var g = f.name ? f : f.$locale(), b = r(g[v]), C = r(g[p]), w = b || C.map(function(E) {
            return E.slice(0, m);
          });
          if (!h) return w;
          var y = g.weekStart;
          return w.map(function(E, k) {
            return w[(k + (y || 0)) % 7];
          });
        }, u = function() {
          return l.Ls[l.locale()];
        }, c = function(f, v) {
          return f.formats[v] || function(p) {
            return p.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(m, h, g) {
              return h || g.slice(1);
            });
          }(f.formats[v.toUpperCase()]);
        }, d = function() {
          var f = this;
          return { months: function(v) {
            return v ? v.format("MMMM") : i(f, "months");
          }, monthsShort: function(v) {
            return v ? v.format("MMM") : i(f, "monthsShort", "months", 3);
          }, firstDayOfWeek: function() {
            return f.$locale().weekStart || 0;
          }, weekdays: function(v) {
            return v ? v.format("dddd") : i(f, "weekdays");
          }, weekdaysMin: function(v) {
            return v ? v.format("dd") : i(f, "weekdaysMin", "weekdays", 2);
          }, weekdaysShort: function(v) {
            return v ? v.format("ddd") : i(f, "weekdaysShort", "weekdays", 3);
          }, longDateFormat: function(v) {
            return c(f.$locale(), v);
          }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
        };
        a.localeData = function() {
          return d.bind(this)();
        }, l.localeData = function() {
          var f = u();
          return { firstDayOfWeek: function() {
            return f.weekStart || 0;
          }, weekdays: function() {
            return l.weekdays();
          }, weekdaysShort: function() {
            return l.weekdaysShort();
          }, weekdaysMin: function() {
            return l.weekdaysMin();
          }, months: function() {
            return l.months();
          }, monthsShort: function() {
            return l.monthsShort();
          }, longDateFormat: function(v) {
            return c(f, v);
          }, meridiem: f.meridiem, ordinal: f.ordinal };
        }, l.months = function() {
          return i(u(), "months");
        }, l.monthsShort = function() {
          return i(u(), "monthsShort", "months", 3);
        }, l.weekdays = function(f) {
          return i(u(), "weekdays", null, null, f);
        }, l.weekdaysShort = function(f) {
          return i(u(), "weekdaysShort", "weekdays", 3, f);
        }, l.weekdaysMin = function(f) {
          return i(u(), "weekdaysMin", "weekdays", 2, f);
        };
      };
    });
  })(vS);
  var P3 = vS.exports;
  const hS = /* @__PURE__ */ sa(P3), R3 = [
    "year",
    "years",
    "month",
    "months",
    "date",
    "dates",
    "week",
    "datetime",
    "datetimerange",
    "daterange",
    "monthrange",
    "yearrange"
  ], xf = [
    "sun",
    "mon",
    "tue",
    "wed",
    "thu",
    "fri",
    "sat"
  ], D3 = (e, t) => {
    st.extend(hS);
    const n = st.localeData().firstDayOfWeek(), { t: o, lang: l } = _t(), a = st().locale(l.value), r = S(() => !!e.range && !!e.range.length), i = S(() => {
      let v = [];
      if (r.value) {
        const [p, m] = e.range, h = Ea(m.date() - p.date() + 1).map((C) => ({
          text: p.date() + C,
          type: "current"
        }));
        let g = h.length % 7;
        g = g === 0 ? 0 : 7 - g;
        const b = Ea(g).map((C, w) => ({
          text: w + 1,
          type: "next"
        }));
        v = h.concat(b);
      } else {
        const p = e.date.startOf("month").day(), m = $3(e.date, (p - n + 7) % 7).map((C) => ({
          text: C,
          type: "prev"
        })), h = O3(e.date).map((C) => ({
          text: C,
          type: "current"
        }));
        v = [...m, ...h];
        const g = 7 - (v.length % 7 || 7), b = Ea(g).map((C, w) => ({
          text: w + 1,
          type: "next"
        }));
        v = v.concat(b);
      }
      return I3(v);
    }), u = S(() => {
      const v = n;
      return v === 0 ? xf.map((p) => o(`el.datepicker.weeks.${p}`)) : xf.slice(v).concat(xf.slice(0, v)).map((p) => o(`el.datepicker.weeks.${p}`));
    }), c = (v, p) => {
      switch (p) {
        case "prev":
          return e.date.startOf("month").subtract(1, "month").date(v);
        case "next":
          return e.date.startOf("month").add(1, "month").date(v);
        case "current":
          return e.date.date(v);
      }
    };
    return {
      now: a,
      isInRange: r,
      rows: i,
      weekDays: u,
      getFormattedDate: c,
      handlePickDay: ({ text: v, type: p }) => {
        const m = c(v, p);
        t("pick", m);
      },
      getSlotData: ({ text: v, type: p }) => {
        const m = c(v, p);
        return {
          isSelected: m.isSame(e.selectedDay),
          type: `${p}-month`,
          day: m.format("YYYY-MM-DD"),
          date: m.toDate()
        };
      }
    };
  }, A3 = /* @__PURE__ */ U({
    name: "DateTable"
  }), V3 = /* @__PURE__ */ U({
    ...A3,
    props: M3,
    emits: x3,
    setup(e, { expose: t, emit: n }) {
      const o = e, {
        isInRange: l,
        now: a,
        rows: r,
        weekDays: i,
        getFormattedDate: u,
        handlePickDay: c,
        getSlotData: d
      } = D3(o, n), f = he("calendar-table"), v = he("calendar-day"), p = ({ text: m, type: h }) => {
        const g = [h];
        if (h === "current") {
          const b = u(m, h);
          b.isSame(o.selectedDay, "day") && g.push(v.is("selected")), b.isSame(a, "day") && g.push(v.is("today"));
        }
        return g;
      };
      return t({
        getFormattedDate: u
      }), (m, h) => (_(), B("table", {
        class: $([s(f).b(), s(f).is("range", s(l))]),
        cellspacing: "0",
        cellpadding: "0"
      }, [
        m.hideHeader ? oe("v-if", !0) : (_(), B("thead", { key: 0 }, [
          W("tr", null, [
            (_(!0), B(We, null, bt(s(i), (g) => (_(), B("th", {
              key: g,
              scope: "col"
            }, ke(g), 1))), 128))
          ])
        ])),
        W("tbody", null, [
          (_(!0), B(We, null, bt(s(r), (g, b) => (_(), B("tr", {
            key: b,
            class: $({
              [s(f).e("row")]: !0,
              [s(f).em("row", "hide-border")]: b === 0 && m.hideHeader
            })
          }, [
            (_(!0), B(We, null, bt(g, (C, w) => (_(), B("td", {
              key: w,
              class: $(p(C)),
              onClick: (y) => s(c)(C)
            }, [
              W("div", {
                class: $(s(v).b())
              }, [
                ee(m.$slots, "date-cell", {
                  data: s(d)(C)
                }, () => [
                  W("span", null, ke(C.text), 1)
                ])
              ], 2)
            ], 10, ["onClick"]))), 128))
          ], 2))), 128))
        ])
      ], 2));
    }
  });
  var ty = /* @__PURE__ */ Ne(V3, [["__file", "date-table.vue"]]);
  const L3 = (e, t) => {
    const n = e.endOf("month"), o = t.startOf("month"), a = n.isSame(o, "week") ? o.add(1, "week") : o;
    return [
      [e, n],
      [a.startOf("week"), t]
    ];
  }, B3 = (e, t) => {
    const n = e.endOf("month"), o = e.add(1, "month").startOf("month"), l = n.isSame(o, "week") ? o.add(1, "week") : o, a = l.endOf("month"), r = t.startOf("month"), i = a.isSame(r, "week") ? r.add(1, "week") : r;
    return [
      [e, n],
      [l.startOf("week"), a],
      [i.startOf("week"), t]
    ];
  }, F3 = (e, t, n) => {
    const { lang: o } = _t(), l = A(), a = st().locale(o.value), r = S({
      get() {
        return e.modelValue ? u.value : l.value;
      },
      set(g) {
        if (!g)
          return;
        l.value = g;
        const b = g.toDate();
        t(fn, b), t(et, b);
      }
    }), i = S(() => {
      if (!e.range || !ye(e.range) || e.range.length !== 2 || e.range.some((w) => !ka(w)))
        return [];
      const g = e.range.map((w) => st(w).locale(o.value)), [b, C] = g;
      return b.isAfter(C) ? (vt(n, "end time should be greater than start time"), []) : b.isSame(C, "month") ? p(b, C) : b.add(1, "month").month() !== C.month() ? (vt(n, "start time and end time interval must not exceed two months"), []) : p(b, C);
    }), u = S(() => e.modelValue ? st(e.modelValue).locale(o.value) : r.value || (i.value.length ? i.value[0][0] : a)), c = S(() => u.value.subtract(1, "month").date(1)), d = S(() => u.value.add(1, "month").date(1)), f = S(() => u.value.subtract(1, "year").date(1)), v = S(() => u.value.add(1, "year").date(1)), p = (g, b) => {
      const C = g.startOf("week"), w = b.endOf("week"), y = C.get("month"), E = w.get("month");
      return y === E ? [[C, w]] : (y + 1) % 12 === E ? L3(C, w) : y + 2 === E || (y + 1) % 11 === E ? B3(C, w) : (vt(n, "start time and end time interval must not exceed two months"), []);
    }, m = (g) => {
      r.value = g;
    };
    return {
      calculateValidatedDateRange: p,
      date: u,
      realSelectedDay: r,
      pickDay: m,
      selectDate: (g) => {
        const C = {
          "prev-month": c.value,
          "next-month": d.value,
          "prev-year": f.value,
          "next-year": v.value,
          today: a
        }[g];
        C.isSame(u.value, "day") || m(C);
      },
      validatedRange: i
    };
  }, z3 = (e) => ye(e) && e.length === 2 && e.every((t) => ka(t)), H3 = Te({
    modelValue: {
      type: Date
    },
    range: {
      type: X(Array),
      validator: z3
    }
  }), K3 = {
    [et]: (e) => ka(e),
    [fn]: (e) => ka(e)
  }, mS = "ElCalendar", W3 = /* @__PURE__ */ U({
    name: mS
  }), j3 = /* @__PURE__ */ U({
    ...W3,
    props: H3,
    emits: K3,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = he("calendar"), {
        calculateValidatedDateRange: a,
        date: r,
        pickDay: i,
        realSelectedDay: u,
        selectDate: c,
        validatedRange: d
      } = F3(o, n, mS), { t: f } = _t(), v = S(() => {
        const p = `el.datepicker.month${r.value.format("M")}`;
        return `${r.value.year()} ${f("el.datepicker.year")} ${f(p)}`;
      });
      return t({
        selectedDay: u,
        pickDay: i,
        selectDate: c,
        calculateValidatedDateRange: a
      }), (p, m) => (_(), B("div", {
        class: $(s(l).b())
      }, [
        W("div", {
          class: $(s(l).e("header"))
        }, [
          ee(p.$slots, "header", { date: s(v) }, () => [
            W("div", {
              class: $(s(l).e("title"))
            }, ke(s(v)), 3),
            s(d).length === 0 ? (_(), B("div", {
              key: 0,
              class: $(s(l).e("button-group"))
            }, [
              q(s(uS), null, {
                default: Q(() => [
                  q(s(_n), {
                    size: "small",
                    onClick: (h) => s(c)("prev-month")
                  }, {
                    default: Q(() => [
                      Ct(ke(s(f)("el.datepicker.prevMonth")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  q(s(_n), {
                    size: "small",
                    onClick: (h) => s(c)("today")
                  }, {
                    default: Q(() => [
                      Ct(ke(s(f)("el.datepicker.today")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  q(s(_n), {
                    size: "small",
                    onClick: (h) => s(c)("next-month")
                  }, {
                    default: Q(() => [
                      Ct(ke(s(f)("el.datepicker.nextMonth")), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ]),
                _: 1
              })
            ], 2)) : oe("v-if", !0)
          ])
        ], 2),
        s(d).length === 0 ? (_(), B("div", {
          key: 0,
          class: $(s(l).e("body"))
        }, [
          q(ty, {
            date: s(r),
            "selected-day": s(u),
            onPick: s(i)
          }, io({
            _: 2
          }, [
            p.$slots["date-cell"] ? {
              name: "date-cell",
              fn: Q((h) => [
                ee(p.$slots, "date-cell", Bo(fl(h)))
              ])
            } : void 0
          ]), 1032, ["date", "selected-day", "onPick"])
        ], 2)) : (_(), B("div", {
          key: 1,
          class: $(s(l).e("body"))
        }, [
          (_(!0), B(We, null, bt(s(d), (h, g) => (_(), ae(ty, {
            key: g,
            date: h[0],
            "selected-day": s(u),
            range: h,
            "hide-header": g !== 0,
            onPick: s(i)
          }, io({
            _: 2
          }, [
            p.$slots["date-cell"] ? {
              name: "date-cell",
              fn: Q((b) => [
                ee(p.$slots, "date-cell", Bo(fl(b)))
              ])
            } : void 0
          ]), 1032, ["date", "selected-day", "range", "hide-header", "onPick"]))), 128))
        ], 2))
      ], 2));
    }
  });
  var U3 = /* @__PURE__ */ Ne(j3, [["__file", "calendar.vue"]]);
  const Y3 = rt(U3), q3 = Te({
    header: {
      type: String,
      default: ""
    },
    footer: {
      type: String,
      default: ""
    },
    bodyStyle: {
      type: X([String, Object, Array]),
      default: ""
    },
    headerClass: String,
    bodyClass: String,
    footerClass: String,
    shadow: {
      type: String,
      values: ["always", "hover", "never"],
      default: void 0
    }
  }), G3 = /* @__PURE__ */ U({
    name: "ElCard"
  }), X3 = /* @__PURE__ */ U({
    ...G3,
    props: q3,
    setup(e) {
      const t = ks("card"), n = he("card");
      return (o, l) => {
        var a;
        return _(), B("div", {
          class: $([
            s(n).b(),
            s(n).is(`${o.shadow || ((a = s(t)) == null ? void 0 : a.shadow) || "always"}-shadow`)
          ])
        }, [
          o.$slots.header || o.header ? (_(), B("div", {
            key: 0,
            class: $([s(n).e("header"), o.headerClass])
          }, [
            ee(o.$slots, "header", {}, () => [
              Ct(ke(o.header), 1)
            ])
          ], 2)) : oe("v-if", !0),
          W("div", {
            class: $([s(n).e("body"), o.bodyClass]),
            style: Ue(o.bodyStyle)
          }, [
            ee(o.$slots, "default")
          ], 6),
          o.$slots.footer || o.footer ? (_(), B("div", {
            key: 1,
            class: $([s(n).e("footer"), o.footerClass])
          }, [
            ee(o.$slots, "footer", {}, () => [
              Ct(ke(o.footer), 1)
            ])
          ], 2)) : oe("v-if", !0)
        ], 2);
      };
    }
  });
  var J3 = /* @__PURE__ */ Ne(X3, [["__file", "card.vue"]]);
  const Z3 = rt(J3), Q3 = Te({
    initialIndex: {
      type: Number,
      default: 0
    },
    height: {
      type: String,
      default: ""
    },
    trigger: {
      type: String,
      values: ["hover", "click"],
      default: "hover"
    },
    autoplay: {
      type: Boolean,
      default: !0
    },
    interval: {
      type: Number,
      default: 3e3
    },
    indicatorPosition: {
      type: String,
      values: ["", "none", "outside"],
      default: ""
    },
    arrow: {
      type: String,
      values: ["always", "hover", "never"],
      default: "hover"
    },
    type: {
      type: String,
      values: ["", "card"],
      default: ""
    },
    cardScale: {
      type: Number,
      default: 0.83
    },
    loop: {
      type: Boolean,
      default: !0
    },
    direction: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "horizontal"
    },
    pauseOnHover: {
      type: Boolean,
      default: !0
    },
    motionBlur: Boolean
  }), eL = {
    change: (e, t) => [e, t].every(je)
  }, gS = Symbol("carouselContextKey"), Ti = "ElCarouselItem", tL = "utils/vue/vnode";
  var ko = /* @__PURE__ */ ((e) => (e[e.TEXT = 1] = "TEXT", e[e.CLASS = 2] = "CLASS", e[e.STYLE = 4] = "STYLE", e[e.PROPS = 8] = "PROPS", e[e.FULL_PROPS = 16] = "FULL_PROPS", e[e.HYDRATE_EVENTS = 32] = "HYDRATE_EVENTS", e[e.STABLE_FRAGMENT = 64] = "STABLE_FRAGMENT", e[e.KEYED_FRAGMENT = 128] = "KEYED_FRAGMENT", e[e.UNKEYED_FRAGMENT = 256] = "UNKEYED_FRAGMENT", e[e.NEED_PATCH = 512] = "NEED_PATCH", e[e.DYNAMIC_SLOTS = 1024] = "DYNAMIC_SLOTS", e[e.HOISTED = -1] = "HOISTED", e[e.BAIL = -2] = "BAIL", e))(ko || {});
  function Tp(e) {
    return Wt(e) && e.type === We;
  }
  function nL(e) {
    return Wt(e) && e.type === Qt;
  }
  function oL(e) {
    return Wt(e) && !Tp(e) && !nL(e);
  }
  const lL = (e) => {
    if (!Wt(e))
      return vt(tL, "[getNormalizedProps] must be a VNode"), {};
    const t = e.props || {}, n = (Wt(e.type) ? e.type.props : void 0) || {}, o = {};
    return Object.keys(n).forEach((l) => {
      Ot(n[l], "default") && (o[l] = n[l].default);
    }), Object.keys(t).forEach((l) => {
      o[In(l)] = t[l];
    }), o;
  }, cl = (e) => {
    const t = ye(e) ? e : [e], n = [];
    return t.forEach((o) => {
      var l;
      ye(o) ? n.push(...cl(o)) : Wt(o) && ((l = o.component) != null && l.subTree) ? n.push(o, ...cl(o.component.subTree)) : Wt(o) && ye(o.children) ? n.push(...cl(o.children)) : Wt(o) && o.shapeFlag === 2 ? n.push(...cl(o.type())) : n.push(o);
    }), n;
  }, aL = (e, t, n) => cl(e.subTree).filter((a) => {
    var r;
    return Wt(a) && ((r = a.type) == null ? void 0 : r.name) === t && !!a.component;
  }).map((a) => a.component.uid).map((a) => n[a]).filter((a) => !!a), Fd = (e, t) => {
    const n = Ut({}), o = Ut([]), l = /* @__PURE__ */ new WeakMap(), a = (d) => {
      n.value[d.uid] = d, ju(n), ft(() => {
        const f = d.getVnode().el, v = f.parentNode;
        if (!l.has(v)) {
          l.set(v, []);
          const p = v.insertBefore.bind(v);
          v.insertBefore = (m, h) => (l.get(v).some((b) => m === b || h === b) && ju(n), p(m, h));
        }
        l.get(v).push(f);
      });
    }, r = (d) => {
      delete n.value[d.uid], ju(n);
      const f = d.getVnode().el, v = f.parentNode, p = l.get(v), m = p.indexOf(f);
      p.splice(m, 1);
    }, i = () => {
      o.value = aL(e, t, n.value);
    }, u = (d) => d.render();
    return {
      children: o,
      addChild: a,
      removeChild: r,
      ChildrenSorter: /* @__PURE__ */ U({
        setup(d, { slots: f }) {
          return () => (i(), f.default ? qe(u, {
            render: f.default
          }) : null);
        }
      })
    };
  }, ny = 300, rL = (e, t, n) => {
    const {
      children: o,
      addChild: l,
      removeChild: a,
      ChildrenSorter: r
    } = Fd(dt(), Ti), i = hn(), u = A(-1), c = A(null), d = A(!1), f = A(), v = A(0), p = A(!0), m = S(() => e.arrow !== "never" && !s(b)), h = S(() => o.value.some((J) => J.props.label.toString().length > 0)), g = S(() => e.type === "card"), b = S(() => e.direction === "vertical"), C = S(() => e.height !== "auto" ? {
      height: e.height
    } : {
      height: `${v.value}px`,
      overflow: "hidden"
    }), w = lr((J) => {
      I(J);
    }, ny, { trailing: !0 }), y = lr((J) => {
      R(J);
    }, ny), E = (J) => p.value ? u.value <= 1 ? J <= 1 : J > 1 : !0;
    function k() {
      c.value && (clearInterval(c.value), c.value = null);
    }
    function T() {
      e.interval <= 0 || !e.autoplay || c.value || (c.value = setInterval(() => x(), e.interval));
    }
    const x = () => {
      u.value < o.value.length - 1 ? u.value = u.value + 1 : e.loop && (u.value = 0);
    };
    function I(J) {
      if (Ae(J)) {
        const re = o.value.filter((se) => se.props.name === J);
        re.length > 0 && (J = o.value.indexOf(re[0]));
      }
      if (J = Number(J), Number.isNaN(J) || J !== Math.floor(J)) {
        vt(n, "index must be integer.");
        return;
      }
      const ie = o.value.length, ue = u.value;
      J < 0 ? u.value = e.loop ? ie - 1 : 0 : J >= ie ? u.value = e.loop ? 0 : ie - 1 : u.value = J, ue === u.value && P(ue), V();
    }
    function P(J) {
      o.value.forEach((ie, ue) => {
        ie.translateItem(ue, u.value, J);
      });
    }
    function O(J, ie) {
      var ue, re, se, ne;
      const le = s(o), Ce = le.length;
      if (Ce === 0 || !J.states.inStage)
        return !1;
      const j = ie + 1, te = ie - 1, ce = Ce - 1, ge = le[ce].states.active, be = le[0].states.active, Ee = (re = (ue = le[j]) == null ? void 0 : ue.states) == null ? void 0 : re.active, Oe = (ne = (se = le[te]) == null ? void 0 : se.states) == null ? void 0 : ne.active;
      return ie === ce && be || Ee ? "left" : ie === 0 && ge || Oe ? "right" : !1;
    }
    function N() {
      d.value = !0, e.pauseOnHover && k();
    }
    function z() {
      d.value = !1, T();
    }
    function Y(J) {
      s(b) || o.value.forEach((ie, ue) => {
        J === O(ie, ue) && (ie.states.hover = !0);
      });
    }
    function G() {
      s(b) || o.value.forEach((J) => {
        J.states.hover = !1;
      });
    }
    function M(J) {
      u.value = J;
    }
    function R(J) {
      e.trigger === "hover" && J !== u.value && (u.value = J);
    }
    function D() {
      I(u.value - 1);
    }
    function L() {
      I(u.value + 1);
    }
    function V() {
      k(), e.pauseOnHover || T();
    }
    function F(J) {
      e.height === "auto" && (v.value = J);
    }
    function H() {
      var J;
      const ie = (J = i.default) == null ? void 0 : J.call(i);
      if (!ie)
        return null;
      const re = cl(ie).filter((se) => Wt(se) && se.type.name === Ti);
      return (re == null ? void 0 : re.length) === 2 && e.loop && !g.value ? (p.value = !0, re) : (p.value = !1, null);
    }
    de(() => u.value, (J, ie) => {
      P(ie), p.value && (J = J % 2, ie = ie % 2), ie > -1 && t(gt, J, ie);
    });
    const K = S({
      get: () => p.value ? u.value % 2 : u.value,
      set: (J) => u.value = J
    });
    de(() => e.autoplay, (J) => {
      J ? T() : k();
    }), de(() => e.loop, () => {
      I(u.value);
    }), de(() => e.interval, () => {
      V();
    });
    const Z = Ut();
    return ft(() => {
      de(() => o.value, () => {
        o.value.length > 0 && I(e.initialIndex);
      }, {
        immediate: !0
      }), Z.value = qt(f.value, () => {
        P();
      }), T();
    }), Bt(() => {
      k(), f.value && Z.value && Z.value.stop();
    }), yt(gS, {
      root: f,
      isCardType: g,
      isVertical: b,
      items: o,
      loop: e.loop,
      cardScale: e.cardScale,
      addItem: l,
      removeItem: a,
      setActiveItem: I,
      setContainerHeight: F
    }), {
      root: f,
      activeIndex: u,
      exposeActiveIndex: K,
      arrowDisplay: m,
      hasLabel: h,
      hover: d,
      isCardType: g,
      items: o,
      isVertical: b,
      containerStyle: C,
      isItemsTwoLength: p,
      handleButtonEnter: Y,
      handleButtonLeave: G,
      handleIndicatorClick: M,
      handleMouseEnter: N,
      handleMouseLeave: z,
      setActiveItem: I,
      prev: D,
      next: L,
      PlaceholderItem: H,
      isTwoLengthShow: E,
      ItemsSorter: r,
      throttledArrowClick: w,
      throttledIndicatorHover: y
    };
  }, bS = "ElCarousel", sL = /* @__PURE__ */ U({
    name: bS
  }), iL = /* @__PURE__ */ U({
    ...sL,
    props: Q3,
    emits: eL,
    setup(e, { expose: t, emit: n }) {
      const o = e, {
        root: l,
        activeIndex: a,
        exposeActiveIndex: r,
        arrowDisplay: i,
        hasLabel: u,
        hover: c,
        isCardType: d,
        items: f,
        isVertical: v,
        containerStyle: p,
        handleButtonEnter: m,
        handleButtonLeave: h,
        handleIndicatorClick: g,
        handleMouseEnter: b,
        handleMouseLeave: C,
        setActiveItem: w,
        prev: y,
        next: E,
        PlaceholderItem: k,
        isTwoLengthShow: T,
        ItemsSorter: x,
        throttledArrowClick: I,
        throttledIndicatorHover: P
      } = rL(o, n, bS), O = he("carousel"), { t: N } = _t(), z = S(() => {
        const R = [O.b(), O.m(o.direction)];
        return s(d) && R.push(O.m("card")), R;
      }), Y = S(() => {
        const R = [O.e("indicators"), O.em("indicators", o.direction)];
        return s(u) && R.push(O.em("indicators", "labels")), o.indicatorPosition === "outside" && R.push(O.em("indicators", "outside")), s(v) && R.push(O.em("indicators", "right")), R;
      });
      function G(R) {
        if (!o.motionBlur)
          return;
        const D = s(v) ? `${O.namespace.value}-transitioning-vertical` : `${O.namespace.value}-transitioning`;
        R.currentTarget.classList.add(D);
      }
      function M(R) {
        if (!o.motionBlur)
          return;
        const D = s(v) ? `${O.namespace.value}-transitioning-vertical` : `${O.namespace.value}-transitioning`;
        R.currentTarget.classList.remove(D);
      }
      return t({
        activeIndex: r,
        setActiveItem: w,
        prev: y,
        next: E
      }), (R, D) => (_(), B("div", {
        ref_key: "root",
        ref: l,
        class: $(s(z)),
        onMouseenter: Ze(s(b), ["stop"]),
        onMouseleave: Ze(s(C), ["stop"])
      }, [
        s(i) ? (_(), ae(Mn, {
          key: 0,
          name: "carousel-arrow-left",
          persisted: ""
        }, {
          default: Q(() => [
            it(W("button", {
              type: "button",
              class: $([s(O).e("arrow"), s(O).em("arrow", "left")]),
              "aria-label": s(N)("el.carousel.leftArrow"),
              onMouseenter: (L) => s(m)("left"),
              onMouseleave: s(h),
              onClick: Ze((L) => s(I)(s(a) - 1), ["stop"])
            }, [
              q(s(ze), null, {
                default: Q(() => [
                  q(s(ql))
                ]),
                _: 1
              })
            ], 42, ["aria-label", "onMouseenter", "onMouseleave", "onClick"]), [
              [Mt, (R.arrow === "always" || s(c)) && (R.loop || s(a) > 0)]
            ])
          ]),
          _: 1
        })) : oe("v-if", !0),
        s(i) ? (_(), ae(Mn, {
          key: 1,
          name: "carousel-arrow-right",
          persisted: ""
        }, {
          default: Q(() => [
            it(W("button", {
              type: "button",
              class: $([s(O).e("arrow"), s(O).em("arrow", "right")]),
              "aria-label": s(N)("el.carousel.rightArrow"),
              onMouseenter: (L) => s(m)("right"),
              onMouseleave: s(h),
              onClick: Ze((L) => s(I)(s(a) + 1), ["stop"])
            }, [
              q(s(ze), null, {
                default: Q(() => [
                  q(s(Un))
                ]),
                _: 1
              })
            ], 42, ["aria-label", "onMouseenter", "onMouseleave", "onClick"]), [
              [
                Mt,
                (R.arrow === "always" || s(c)) && (R.loop || s(a) < s(f).length - 1)
              ]
            ])
          ]),
          _: 1
        })) : oe("v-if", !0),
        W("div", {
          class: $(s(O).e("container")),
          style: Ue(s(p)),
          onTransitionstart: G,
          onTransitionend: M
        }, [
          q(s(k)),
          ee(R.$slots, "default")
        ], 38),
        q(s(x), null, {
          default: Q(() => [
            R.indicatorPosition !== "none" ? (_(), B("ul", {
              key: 0,
              class: $(s(Y))
            }, [
              (_(!0), B(We, null, bt(s(f), (L, V) => it((_(), B("li", {
                key: V,
                class: $([
                  s(O).e("indicator"),
                  s(O).em("indicator", R.direction),
                  s(O).is("active", V === s(a))
                ]),
                onMouseenter: (F) => s(P)(V),
                onClick: Ze((F) => s(g)(V), ["stop"])
              }, [
                W("button", {
                  class: $(s(O).e("button")),
                  "aria-label": s(N)("el.carousel.indicator", { index: V + 1 })
                }, [
                  s(u) ? (_(), B("span", { key: 0 }, ke(L.props.label), 1)) : oe("v-if", !0)
                ], 10, ["aria-label"])
              ], 42, ["onMouseenter", "onClick"])), [
                [Mt, s(T)(V)]
              ])), 128))
            ], 2)) : oe("v-if", !0)
          ]),
          _: 1
        }),
        R.motionBlur ? (_(), B("svg", {
          key: 2,
          xmlns: "http://www.w3.org/2000/svg",
          version: "1.1",
          style: { display: "none" }
        }, [
          W("defs", null, [
            W("filter", { id: "elCarouselHorizontal" }, [
              W("feGaussianBlur", {
                in: "SourceGraphic",
                stdDeviation: "12,0"
              })
            ]),
            W("filter", { id: "elCarouselVertical" }, [
              W("feGaussianBlur", {
                in: "SourceGraphic",
                stdDeviation: "0,10"
              })
            ])
          ])
        ])) : oe("v-if", !0)
      ], 42, ["onMouseenter", "onMouseleave"]));
    }
  });
  var uL = /* @__PURE__ */ Ne(iL, [["__file", "carousel.vue"]]);
  const cL = Te({
    name: { type: String, default: "" },
    label: {
      type: [String, Number],
      default: ""
    }
  }), dL = (e) => {
    const t = Ve(gS), n = dt();
    t || vt(Ti, "usage: <el-carousel></el-carousel-item></el-carousel>"), n || vt(Ti, "compositional hook can only be invoked inside setups");
    const o = A(), l = A(!1), a = A(0), r = A(1), i = A(!1), u = A(!1), c = A(!1), d = A(!1), { isCardType: f, isVertical: v, cardScale: p } = t;
    function m(y, E, k) {
      const T = k - 1, x = E - 1, I = E + 1, P = k / 2;
      return E === 0 && y === T ? -1 : E === T && y === 0 ? k : y < x && E - y >= P ? k + 1 : y > I && y - E >= P ? -2 : y;
    }
    function h(y, E) {
      var k, T;
      const x = s(v) ? ((k = t.root.value) == null ? void 0 : k.offsetHeight) || 0 : ((T = t.root.value) == null ? void 0 : T.offsetWidth) || 0;
      return c.value ? x * ((2 - p) * (y - E) + 1) / 4 : y < E ? -(1 + p) * x / 4 : (3 + p) * x / 4;
    }
    function g(y, E, k) {
      const T = t.root.value;
      return T ? ((k ? T.offsetHeight : T.offsetWidth) || 0) * (y - E) : 0;
    }
    const b = (y, E, k) => {
      var T;
      const x = s(f), I = (T = t.items.value.length) != null ? T : Number.NaN, P = y === E;
      !x && !kt(k) && (d.value = P || y === k), !P && I > 2 && t.loop && (y = m(y, E, I));
      const O = s(v);
      i.value = P, x ? (c.value = Math.round(Math.abs(y - E)) <= 1, a.value = h(y, E), r.value = s(i) ? 1 : p) : a.value = g(y, E, O), u.value = !0, P && o.value && t.setContainerHeight(o.value.offsetHeight);
    };
    function C() {
      if (t && s(f)) {
        const y = t.items.value.findIndex(({ uid: E }) => E === n.uid);
        t.setActiveItem(y);
      }
    }
    const w = {
      props: e,
      states: Rt({
        hover: l,
        translate: a,
        scale: r,
        active: i,
        ready: u,
        inStage: c,
        animating: d
      }),
      uid: n.uid,
      getVnode: () => n.vnode,
      translateItem: b
    };
    return t.addItem(w), Bt(() => {
      t.removeItem(w);
    }), {
      carouselItemRef: o,
      active: i,
      animating: d,
      hover: l,
      inStage: c,
      isVertical: v,
      translate: a,
      isCardType: f,
      scale: r,
      ready: u,
      handleItemClick: C
    };
  }, fL = /* @__PURE__ */ U({
    name: Ti
  }), pL = /* @__PURE__ */ U({
    ...fL,
    props: cL,
    setup(e) {
      const t = e, n = he("carousel"), {
        carouselItemRef: o,
        active: l,
        animating: a,
        hover: r,
        inStage: i,
        isVertical: u,
        translate: c,
        isCardType: d,
        scale: f,
        ready: v,
        handleItemClick: p
      } = dL(t), m = S(() => [
        n.e("item"),
        n.is("active", l.value),
        n.is("in-stage", i.value),
        n.is("hover", r.value),
        n.is("animating", a.value),
        {
          [n.em("item", "card")]: d.value,
          [n.em("item", "card-vertical")]: d.value && u.value
        }
      ]), h = S(() => {
        const b = `${`translate${s(u) ? "Y" : "X"}`}(${s(c)}px)`, C = `scale(${s(f)})`;
        return {
          transform: [b, C].join(" ")
        };
      });
      return (g, b) => it((_(), B("div", {
        ref_key: "carouselItemRef",
        ref: o,
        class: $(s(m)),
        style: Ue(s(h)),
        onClick: s(p)
      }, [
        s(d) ? it((_(), B("div", {
          key: 0,
          class: $(s(n).e("mask"))
        }, null, 2)), [
          [Mt, !s(l)]
        ]) : oe("v-if", !0),
        ee(g.$slots, "default")
      ], 14, ["onClick"])), [
        [Mt, s(v)]
      ]);
    }
  });
  var yS = /* @__PURE__ */ Ne(pL, [["__file", "carousel-item.vue"]]);
  const vL = rt(uL, {
    CarouselItem: yS
  }), hL = nn(yS), wS = {
    modelValue: {
      type: [Number, String, Boolean],
      default: void 0
    },
    label: {
      type: [String, Boolean, Number, Object],
      default: void 0
    },
    value: {
      type: [String, Boolean, Number, Object],
      default: void 0
    },
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: {
      type: String,
      default: void 0
    },
    trueValue: {
      type: [String, Number],
      default: void 0
    },
    falseValue: {
      type: [String, Number],
      default: void 0
    },
    trueLabel: {
      type: [String, Number],
      default: void 0
    },
    falseLabel: {
      type: [String, Number],
      default: void 0
    },
    id: {
      type: String,
      default: void 0
    },
    border: Boolean,
    size: mn,
    tabindex: [String, Number],
    validateEvent: {
      type: Boolean,
      default: !0
    },
    ...Yn(["ariaControls"])
  }, CS = {
    [et]: (e) => Ae(e) || je(e) || Vt(e),
    change: (e) => Ae(e) || je(e) || Vt(e)
  }, Ts = Symbol("checkboxGroupContextKey"), mL = ({
    model: e,
    isChecked: t
  }) => {
    const n = Ve(Ts, void 0), o = S(() => {
      var a, r;
      const i = (a = n == null ? void 0 : n.max) == null ? void 0 : a.value, u = (r = n == null ? void 0 : n.min) == null ? void 0 : r.value;
      return !kt(i) && e.value.length >= i && !t.value || !kt(u) && e.value.length <= u && t.value;
    });
    return {
      isDisabled: Cn(S(() => (n == null ? void 0 : n.disabled.value) || o.value)),
      isLimitDisabled: o
    };
  }, gL = (e, {
    model: t,
    isLimitExceeded: n,
    hasOwnLabel: o,
    isDisabled: l,
    isLabeledByFormItem: a
  }) => {
    const r = Ve(Ts, void 0), { formItem: i } = Nn(), { emit: u } = dt();
    function c(m) {
      var h, g, b, C;
      return [!0, e.trueValue, e.trueLabel].includes(m) ? (g = (h = e.trueValue) != null ? h : e.trueLabel) != null ? g : !0 : (C = (b = e.falseValue) != null ? b : e.falseLabel) != null ? C : !1;
    }
    function d(m, h) {
      u(gt, c(m), h);
    }
    function f(m) {
      if (n.value)
        return;
      const h = m.target;
      u(gt, c(h.checked), m);
    }
    async function v(m) {
      n.value || !o.value && !l.value && a.value && (m.composedPath().some((b) => b.tagName === "LABEL") || (t.value = c([!1, e.falseValue, e.falseLabel].includes(t.value)), await Re(), d(t.value, m)));
    }
    const p = S(() => (r == null ? void 0 : r.validateEvent) || e.validateEvent);
    return de(() => e.modelValue, () => {
      p.value && (i == null || i.validate("change").catch((m) => vt(m)));
    }), {
      handleChange: f,
      onClickRoot: v
    };
  }, bL = (e) => {
    const t = A(!1), { emit: n } = dt(), o = Ve(Ts, void 0), l = S(() => kt(o) === !1), a = A(!1), r = S({
      get() {
        var i, u;
        return l.value ? (i = o == null ? void 0 : o.modelValue) == null ? void 0 : i.value : (u = e.modelValue) != null ? u : t.value;
      },
      set(i) {
        var u, c;
        l.value && ye(i) ? (a.value = ((u = o == null ? void 0 : o.max) == null ? void 0 : u.value) !== void 0 && i.length > (o == null ? void 0 : o.max.value) && i.length > r.value.length, a.value === !1 && ((c = o == null ? void 0 : o.changeEvent) == null || c.call(o, i))) : (n(et, i), t.value = i);
      }
    });
    return {
      model: r,
      isGroup: l,
      isLimitExceeded: a
    };
  }, yL = (e, t, { model: n }) => {
    const o = Ve(Ts, void 0), l = A(!1), a = S(() => go(e.value) ? e.label : e.value), r = S(() => {
      const d = n.value;
      return Vt(d) ? d : ye(d) ? ot(a.value) ? d.map(Pt).some((f) => ln(f, a.value)) : d.map(Pt).includes(a.value) : d != null ? d === e.trueValue || d === e.trueLabel : !!d;
    }), i = vn(S(() => {
      var d;
      return (d = o == null ? void 0 : o.size) == null ? void 0 : d.value;
    }), {
      prop: !0
    }), u = vn(S(() => {
      var d;
      return (d = o == null ? void 0 : o.size) == null ? void 0 : d.value;
    })), c = S(() => !!t.default || !go(a.value));
    return {
      checkboxButtonSize: i,
      isChecked: r,
      isFocused: l,
      checkboxSize: u,
      hasOwnLabel: c,
      actualValue: a
    };
  }, SS = (e, t) => {
    const { formItem: n } = Nn(), { model: o, isGroup: l, isLimitExceeded: a } = bL(e), {
      isFocused: r,
      isChecked: i,
      checkboxButtonSize: u,
      checkboxSize: c,
      hasOwnLabel: d,
      actualValue: f
    } = yL(e, t, { model: o }), { isDisabled: v } = mL({ model: o, isChecked: i }), { inputId: p, isLabeledByFormItem: m } = wo(e, {
      formItemContext: n,
      disableIdGeneration: d,
      disableIdManagement: l
    }), { handleChange: h, onClickRoot: g } = gL(e, {
      model: o,
      isLimitExceeded: a,
      hasOwnLabel: d,
      isDisabled: v,
      isLabeledByFormItem: m
    });
    return (() => {
      function C() {
        var w, y;
        ye(o.value) && !o.value.includes(f.value) ? o.value.push(f.value) : o.value = (y = (w = e.trueValue) != null ? w : e.trueLabel) != null ? y : !0;
      }
      e.checked && C();
    })(), hl({
      from: "label act as value",
      replacement: "value",
      version: "3.0.0",
      scope: "el-checkbox",
      ref: "https://element-plus.org/en-US/component/checkbox.html"
    }, S(() => l.value && go(e.value))), hl({
      from: "true-label",
      replacement: "true-value",
      version: "3.0.0",
      scope: "el-checkbox",
      ref: "https://element-plus.org/en-US/component/checkbox.html"
    }, S(() => !!e.trueLabel)), hl({
      from: "false-label",
      replacement: "false-value",
      version: "3.0.0",
      scope: "el-checkbox",
      ref: "https://element-plus.org/en-US/component/checkbox.html"
    }, S(() => !!e.falseLabel)), {
      inputId: p,
      isLabeledByFormItem: m,
      isChecked: i,
      isDisabled: v,
      isFocused: r,
      checkboxButtonSize: u,
      checkboxSize: c,
      hasOwnLabel: d,
      model: o,
      actualValue: f,
      handleChange: h,
      onClickRoot: g
    };
  }, wL = /* @__PURE__ */ U({
    name: "ElCheckbox"
  }), CL = /* @__PURE__ */ U({
    ...wL,
    props: wS,
    emits: CS,
    setup(e) {
      const t = e, n = hn(), {
        inputId: o,
        isLabeledByFormItem: l,
        isChecked: a,
        isDisabled: r,
        isFocused: i,
        checkboxSize: u,
        hasOwnLabel: c,
        model: d,
        actualValue: f,
        handleChange: v,
        onClickRoot: p
      } = SS(t, n), m = S(() => {
        var C, w, y, E;
        return t.trueValue || t.falseValue || t.trueLabel || t.falseLabel ? {
          "true-value": (w = (C = t.trueValue) != null ? C : t.trueLabel) != null ? w : !0,
          "false-value": (E = (y = t.falseValue) != null ? y : t.falseLabel) != null ? E : !1
        } : {
          value: f.value
        };
      }), h = he("checkbox"), g = S(() => [
        h.b(),
        h.m(u.value),
        h.is("disabled", r.value),
        h.is("bordered", t.border),
        h.is("checked", a.value)
      ]), b = S(() => [
        h.e("input"),
        h.is("disabled", r.value),
        h.is("checked", a.value),
        h.is("indeterminate", t.indeterminate),
        h.is("focus", i.value)
      ]);
      return (C, w) => (_(), ae(ct(!s(c) && s(l) ? "span" : "label"), {
        class: $(s(g)),
        "aria-controls": C.indeterminate ? C.ariaControls : null,
        onClick: s(p)
      }, {
        default: Q(() => [
          W("span", {
            class: $(s(b))
          }, [
            it(W("input", pt({
              id: s(o),
              "onUpdate:modelValue": (y) => Kt(d) ? d.value = y : null,
              class: s(h).e("original"),
              type: "checkbox",
              indeterminate: C.indeterminate,
              name: C.name,
              tabindex: C.tabindex,
              disabled: s(r)
            }, s(m), {
              onChange: s(v),
              onFocus: (y) => i.value = !0,
              onBlur: (y) => i.value = !1,
              onClick: Ze(() => {
              }, ["stop"])
            }), null, 16, ["id", "onUpdate:modelValue", "indeterminate", "name", "tabindex", "disabled", "onChange", "onFocus", "onBlur", "onClick"]), [
              [t1, s(d)]
            ]),
            W("span", {
              class: $(s(h).e("inner"))
            }, null, 2)
          ], 2),
          s(c) ? (_(), B("span", {
            key: 0,
            class: $(s(h).e("label"))
          }, [
            ee(C.$slots, "default"),
            C.$slots.default ? oe("v-if", !0) : (_(), B(We, { key: 0 }, [
              Ct(ke(C.label), 1)
            ], 64))
          ], 2)) : oe("v-if", !0)
        ]),
        _: 3
      }, 8, ["class", "aria-controls", "onClick"]));
    }
  });
  var ES = /* @__PURE__ */ Ne(CL, [["__file", "checkbox.vue"]]);
  const SL = /* @__PURE__ */ U({
    name: "ElCheckboxButton"
  }), EL = /* @__PURE__ */ U({
    ...SL,
    props: wS,
    emits: CS,
    setup(e) {
      const t = e, n = hn(), {
        isFocused: o,
        isChecked: l,
        isDisabled: a,
        checkboxButtonSize: r,
        model: i,
        actualValue: u,
        handleChange: c
      } = SS(t, n), d = S(() => {
        var h, g, b, C;
        return t.trueValue || t.falseValue || t.trueLabel || t.falseLabel ? {
          "true-value": (g = (h = t.trueValue) != null ? h : t.trueLabel) != null ? g : !0,
          "false-value": (C = (b = t.falseValue) != null ? b : t.falseLabel) != null ? C : !1
        } : {
          value: u.value
        };
      }), f = Ve(Ts, void 0), v = he("checkbox"), p = S(() => {
        var h, g, b, C;
        const w = (g = (h = f == null ? void 0 : f.fill) == null ? void 0 : h.value) != null ? g : "";
        return {
          backgroundColor: w,
          borderColor: w,
          color: (C = (b = f == null ? void 0 : f.textColor) == null ? void 0 : b.value) != null ? C : "",
          boxShadow: w ? `-1px 0 0 0 ${w}` : void 0
        };
      }), m = S(() => [
        v.b("button"),
        v.bm("button", r.value),
        v.is("disabled", a.value),
        v.is("checked", l.value),
        v.is("focus", o.value)
      ]);
      return (h, g) => (_(), B("label", {
        class: $(s(m))
      }, [
        it(W("input", pt({
          "onUpdate:modelValue": (b) => Kt(i) ? i.value = b : null,
          class: s(v).be("button", "original"),
          type: "checkbox",
          name: h.name,
          tabindex: h.tabindex,
          disabled: s(a)
        }, s(d), {
          onChange: s(c),
          onFocus: (b) => o.value = !0,
          onBlur: (b) => o.value = !1,
          onClick: Ze(() => {
          }, ["stop"])
        }), null, 16, ["onUpdate:modelValue", "name", "tabindex", "disabled", "onChange", "onFocus", "onBlur", "onClick"]), [
          [t1, s(i)]
        ]),
        h.$slots.default || h.label ? (_(), B("span", {
          key: 0,
          class: $(s(v).be("button", "inner")),
          style: Ue(s(l) ? s(p) : void 0)
        }, [
          ee(h.$slots, "default", {}, () => [
            Ct(ke(h.label), 1)
          ])
        ], 6)) : oe("v-if", !0)
      ], 2));
    }
  });
  var Oh = /* @__PURE__ */ Ne(EL, [["__file", "checkbox-button.vue"]]);
  const kL = Te({
    modelValue: {
      type: X(Array),
      default: () => []
    },
    disabled: Boolean,
    min: Number,
    max: Number,
    size: mn,
    fill: String,
    textColor: String,
    tag: {
      type: String,
      default: "div"
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    options: {
      type: X(Array)
    },
    props: {
      type: X(Object),
      default: () => kS
    },
    type: {
      type: String,
      values: ["checkbox", "button"],
      default: "checkbox"
    },
    ...Yn(["ariaLabel"])
  }), _L = {
    [et]: (e) => ye(e),
    change: (e) => ye(e)
  }, kS = {
    label: "label",
    value: "value",
    disabled: "disabled"
  }, TL = /* @__PURE__ */ U({
    name: "ElCheckboxGroup"
  }), NL = /* @__PURE__ */ U({
    ...TL,
    props: kL,
    emits: _L,
    setup(e, { emit: t }) {
      const n = e, o = he("checkbox"), { formItem: l } = Nn(), { inputId: a, isLabeledByFormItem: r } = wo(n, {
        formItemContext: l
      }), i = async (v) => {
        t(et, v), await Re(), t(gt, v);
      }, u = S({
        get() {
          return n.modelValue;
        },
        set(v) {
          i(v);
        }
      }), c = S(() => ({
        ...kS,
        ...n.props
      })), d = (v) => {
        const { label: p, value: m, disabled: h } = c.value, g = {
          label: v[p],
          value: v[m],
          disabled: v[h]
        };
        return { ...Md(v, [p, m, h]), ...g };
      }, f = S(() => n.type === "button" ? Oh : ES);
      return yt(Ts, {
        ...jl(wn(n), [
          "size",
          "min",
          "max",
          "disabled",
          "validateEvent",
          "fill",
          "textColor"
        ]),
        modelValue: u,
        changeEvent: i
      }), de(() => n.modelValue, (v, p) => {
        n.validateEvent && !ln(v, p) && (l == null || l.validate("change").catch((m) => vt(m)));
      }), (v, p) => {
        var m;
        return _(), ae(ct(v.tag), {
          id: s(a),
          class: $(s(o).b("group")),
          role: "group",
          "aria-label": s(r) ? void 0 : v.ariaLabel || "checkbox-group",
          "aria-labelledby": s(r) ? (m = s(l)) == null ? void 0 : m.labelId : void 0
        }, {
          default: Q(() => [
            ee(v.$slots, "default", {}, () => [
              (_(!0), B(We, null, bt(v.options, (h, g) => (_(), ae(ct(s(f)), pt({ key: g }, d(h)), null, 16))), 128))
            ])
          ]),
          _: 3
        }, 8, ["id", "class", "aria-label", "aria-labelledby"]);
      };
    }
  });
  var _S = /* @__PURE__ */ Ne(NL, [["__file", "checkbox-group.vue"]]);
  const xo = rt(ES, {
    CheckboxButton: Oh,
    CheckboxGroup: _S
  }), $L = nn(Oh), TS = nn(_S), NS = Te({
    modelValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    size: mn,
    disabled: Boolean,
    label: {
      type: [String, Number, Boolean],
      default: void 0
    },
    value: {
      type: [String, Number, Boolean],
      default: void 0
    },
    name: {
      type: String,
      default: void 0
    }
  }), OL = Te({
    ...NS,
    border: Boolean
  }), $S = {
    [et]: (e) => Ae(e) || je(e) || Vt(e),
    [gt]: (e) => Ae(e) || je(e) || Vt(e)
  }, OS = Symbol("radioGroupKey"), IS = (e, t) => {
    const n = A(), o = Ve(OS, void 0), l = S(() => !!o), a = S(() => go(e.value) ? e.label : e.value), r = S({
      get() {
        return l.value ? o.modelValue : e.modelValue;
      },
      set(f) {
        l.value ? o.changeEvent(f) : t && t(et, f), n.value.checked = e.modelValue === a.value;
      }
    }), i = vn(S(() => o == null ? void 0 : o.size)), u = Cn(S(() => o == null ? void 0 : o.disabled)), c = A(!1), d = S(() => u.value || l.value && r.value !== a.value ? -1 : 0);
    return hl({
      from: "label act as value",
      replacement: "value",
      version: "3.0.0",
      scope: "el-radio",
      ref: "https://element-plus.org/en-US/component/radio.html"
    }, S(() => l.value && go(e.value))), {
      radioRef: n,
      isGroup: l,
      radioGroup: o,
      focus: c,
      size: i,
      disabled: u,
      tabIndex: d,
      modelValue: r,
      actualValue: a
    };
  }, IL = /* @__PURE__ */ U({
    name: "ElRadio"
  }), ML = /* @__PURE__ */ U({
    ...IL,
    props: OL,
    emits: $S,
    setup(e, { emit: t }) {
      const n = e, o = he("radio"), { radioRef: l, radioGroup: a, focus: r, size: i, disabled: u, modelValue: c, actualValue: d } = IS(n, t);
      function f() {
        Re(() => t(gt, c.value));
      }
      return (v, p) => {
        var m;
        return _(), B("label", {
          class: $([
            s(o).b(),
            s(o).is("disabled", s(u)),
            s(o).is("focus", s(r)),
            s(o).is("bordered", v.border),
            s(o).is("checked", s(c) === s(d)),
            s(o).m(s(i))
          ])
        }, [
          W("span", {
            class: $([
              s(o).e("input"),
              s(o).is("disabled", s(u)),
              s(o).is("checked", s(c) === s(d))
            ])
          }, [
            it(W("input", {
              ref_key: "radioRef",
              ref: l,
              "onUpdate:modelValue": (h) => Kt(c) ? c.value = h : null,
              class: $(s(o).e("original")),
              value: s(d),
              name: v.name || ((m = s(a)) == null ? void 0 : m.name),
              disabled: s(u),
              checked: s(c) === s(d),
              type: "radio",
              onFocus: (h) => r.value = !0,
              onBlur: (h) => r.value = !1,
              onChange: f,
              onClick: Ze(() => {
              }, ["stop"])
            }, null, 42, ["onUpdate:modelValue", "value", "name", "disabled", "checked", "onFocus", "onBlur", "onClick"]), [
              [n1, s(c)]
            ]),
            W("span", {
              class: $(s(o).e("inner"))
            }, null, 2)
          ], 2),
          W("span", {
            class: $(s(o).e("label")),
            onKeydown: Ze(() => {
            }, ["stop"])
          }, [
            ee(v.$slots, "default", {}, () => [
              Ct(ke(v.label), 1)
            ])
          ], 42, ["onKeydown"])
        ], 2);
      };
    }
  });
  var MS = /* @__PURE__ */ Ne(ML, [["__file", "radio.vue"]]);
  const xL = Te({
    ...NS
  }), PL = /* @__PURE__ */ U({
    name: "ElRadioButton"
  }), RL = /* @__PURE__ */ U({
    ...PL,
    props: xL,
    setup(e) {
      const t = e, n = he("radio"), { radioRef: o, focus: l, size: a, disabled: r, modelValue: i, radioGroup: u, actualValue: c } = IS(t), d = S(() => ({
        backgroundColor: (u == null ? void 0 : u.fill) || "",
        borderColor: (u == null ? void 0 : u.fill) || "",
        boxShadow: u != null && u.fill ? `-1px 0 0 0 ${u.fill}` : "",
        color: (u == null ? void 0 : u.textColor) || ""
      }));
      return (f, v) => {
        var p;
        return _(), B("label", {
          class: $([
            s(n).b("button"),
            s(n).is("active", s(i) === s(c)),
            s(n).is("disabled", s(r)),
            s(n).is("focus", s(l)),
            s(n).bm("button", s(a))
          ])
        }, [
          it(W("input", {
            ref_key: "radioRef",
            ref: o,
            "onUpdate:modelValue": (m) => Kt(i) ? i.value = m : null,
            class: $(s(n).be("button", "original-radio")),
            value: s(c),
            type: "radio",
            name: f.name || ((p = s(u)) == null ? void 0 : p.name),
            disabled: s(r),
            onFocus: (m) => l.value = !0,
            onBlur: (m) => l.value = !1,
            onClick: Ze(() => {
            }, ["stop"])
          }, null, 42, ["onUpdate:modelValue", "value", "name", "disabled", "onFocus", "onBlur", "onClick"]), [
            [n1, s(i)]
          ]),
          W("span", {
            class: $(s(n).be("button", "inner")),
            style: Ue(s(i) === s(c) ? s(d) : {}),
            onKeydown: Ze(() => {
            }, ["stop"])
          }, [
            ee(f.$slots, "default", {}, () => [
              Ct(ke(f.label), 1)
            ])
          ], 46, ["onKeydown"])
        ], 2);
      };
    }
  });
  var Ih = /* @__PURE__ */ Ne(RL, [["__file", "radio-button.vue"]]);
  const DL = Te({
    id: {
      type: String,
      default: void 0
    },
    size: mn,
    disabled: Boolean,
    modelValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    fill: {
      type: String,
      default: ""
    },
    textColor: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: void 0
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    options: {
      type: X(Array)
    },
    props: {
      type: X(Object),
      default: () => xS
    },
    type: {
      type: String,
      values: ["radio", "button"],
      default: "radio"
    },
    ...Yn(["ariaLabel"])
  }), AL = $S, xS = {
    label: "label",
    value: "value",
    disabled: "disabled"
  }, VL = /* @__PURE__ */ U({
    name: "ElRadioGroup"
  }), LL = /* @__PURE__ */ U({
    ...VL,
    props: DL,
    emits: AL,
    setup(e, { emit: t }) {
      const n = e, o = he("radio"), l = xn(), a = A(), { formItem: r } = Nn(), { inputId: i, isLabeledByFormItem: u } = wo(n, {
        formItemContext: r
      }), c = (m) => {
        t(et, m), Re(() => t(gt, m));
      };
      ft(() => {
        const m = a.value.querySelectorAll("[type=radio]"), h = m[0];
        !Array.from(m).some((g) => g.checked) && h && (h.tabIndex = 0);
      });
      const d = S(() => n.name || l.value), f = S(() => ({
        ...xS,
        ...n.props
      })), v = (m) => {
        const { label: h, value: g, disabled: b } = f.value, C = {
          label: m[h],
          value: m[g],
          disabled: m[b]
        };
        return { ...Md(m, [h, g, b]), ...C };
      }, p = S(() => n.type === "button" ? Ih : MS);
      return yt(OS, Rt({
        ...wn(n),
        changeEvent: c,
        name: d
      })), de(() => n.modelValue, (m, h) => {
        n.validateEvent && !ln(m, h) && (r == null || r.validate("change").catch((g) => vt(g)));
      }), (m, h) => (_(), B("div", {
        id: s(i),
        ref_key: "radioGroupRef",
        ref: a,
        class: $(s(o).b("group")),
        role: "radiogroup",
        "aria-label": s(u) ? void 0 : m.ariaLabel || "radio-group",
        "aria-labelledby": s(u) ? s(r).labelId : void 0
      }, [
        ee(m.$slots, "default", {}, () => [
          (_(!0), B(We, null, bt(m.options, (g, b) => (_(), ae(ct(s(p)), pt({ key: b }, v(g)), null, 16))), 128))
        ])
      ], 10, ["id", "aria-label", "aria-labelledby"]));
    }
  });
  var PS = /* @__PURE__ */ Ne(LL, [["__file", "radio-group.vue"]]);
  const RS = rt(MS, {
    RadioButton: Ih,
    RadioGroup: PS
  }), BL = nn(PS), FL = nn(Ih), zd = Symbol();
  function zL(e) {
    return !!(ye(e) ? e.every(({
      type: t
    }) => t === Qt) : (e == null ? void 0 : e.type) === Qt);
  }
  var HL = /* @__PURE__ */ U({
    name: "NodeContent",
    props: {
      node: {
        type: Object,
        required: !0
      }
    },
    setup(e) {
      const t = he("cascader-node"), {
        renderLabelFn: n
      } = Ve(zd), {
        node: o
      } = e, {
        data: l,
        label: a
      } = o, r = () => {
        const i = n == null ? void 0 : n({
          node: o,
          data: l
        });
        return zL(i) ? a : i ?? a;
      };
      return () => q("span", {
        class: t.e("label")
      }, [r()]);
    }
  });
  const KL = /* @__PURE__ */ U({
    name: "ElCascaderNode"
  }), WL = /* @__PURE__ */ U({
    ...KL,
    props: {
      node: {
        type: Object,
        required: !0
      },
      menuId: String
    },
    emits: ["expand"],
    setup(e, { emit: t }) {
      const n = e, o = Ve(zd), l = he("cascader-node"), a = S(() => o.isHoverMenu), r = S(() => o.config.multiple), i = S(() => o.config.checkStrictly), u = S(() => o.config.showPrefix), c = S(() => {
        var x;
        return (x = o.checkedNodes[0]) == null ? void 0 : x.uid;
      }), d = S(() => n.node.isDisabled), f = S(() => n.node.isLeaf), v = S(() => i.value && !f.value || !d.value), p = S(() => h(o.expandingNode)), m = S(() => i.value && o.checkedNodes.some(h)), h = (x) => {
        var I;
        const { level: P, uid: O } = n.node;
        return ((I = x == null ? void 0 : x.pathNodes[P - 1]) == null ? void 0 : I.uid) === O;
      }, g = () => {
        p.value || o.expandNode(n.node);
      }, b = (x) => {
        const { node: I } = n;
        x !== I.checked && o.handleCheckChange(I, x);
      }, C = () => {
        o.lazyLoad(n.node, () => {
          f.value || g();
        });
      }, w = (x) => {
        a.value && (y(), !f.value && t("expand", x));
      }, y = () => {
        const { node: x } = n;
        !v.value || x.loading || (x.loaded ? g() : C());
      }, E = () => {
        f.value && !d.value && !i.value && !r.value ? T(!0) : (o.config.checkOnClickNode && (r.value || i.value) || f.value && o.config.checkOnClickLeaf) && !d.value ? k(!n.node.checked) : a.value || y();
      }, k = (x) => {
        i.value ? (b(x), n.node.loaded && g()) : T(x);
      }, T = (x) => {
        n.node.loaded ? (b(x), !i.value && g()) : C();
      };
      return (x, I) => (_(), B("li", {
        id: `${e.menuId}-${e.node.uid}`,
        role: "menuitem",
        "aria-haspopup": !s(f),
        "aria-owns": s(f) ? void 0 : e.menuId,
        "aria-expanded": s(p),
        tabindex: s(v) ? -1 : void 0,
        class: $([
          s(l).b(),
          s(l).is("selectable", s(i)),
          s(l).is("active", e.node.checked),
          s(l).is("disabled", !s(v)),
          s(p) && "in-active-path",
          s(m) && "in-checked-path"
        ]),
        onMouseenter: w,
        onFocus: w,
        onClick: E
      }, [
        oe(" prefix "),
        s(r) && s(u) ? (_(), ae(s(xo), {
          key: 0,
          "model-value": e.node.checked,
          indeterminate: e.node.indeterminate,
          disabled: s(d),
          onClick: Ze(() => {
          }, ["stop"]),
          "onUpdate:modelValue": k
        }, null, 8, ["model-value", "indeterminate", "disabled", "onClick"])) : s(i) && s(u) ? (_(), ae(s(RS), {
          key: 1,
          "model-value": s(c),
          label: e.node.uid,
          disabled: s(d),
          "onUpdate:modelValue": k,
          onClick: Ze(() => {
          }, ["stop"])
        }, {
          default: Q(() => [
            oe(`
        Add an empty element to avoid render label,
        do not use empty fragment here for https://github.com/vuejs/vue-next/pull/2485
      `),
            W("span")
          ]),
          _: 1
        }, 8, ["model-value", "label", "disabled", "onClick"])) : s(f) && e.node.checked ? (_(), ae(s(ze), {
          key: 2,
          class: $(s(l).e("prefix"))
        }, {
          default: Q(() => [
            q(s(ou))
          ]),
          _: 1
        }, 8, ["class"])) : oe("v-if", !0),
        oe(" content "),
        q(s(HL), { node: e.node }, null, 8, ["node"]),
        oe(" postfix "),
        s(f) ? oe("v-if", !0) : (_(), B(We, { key: 3 }, [
          e.node.loading ? (_(), ae(s(ze), {
            key: 0,
            class: $([s(l).is("loading"), s(l).e("postfix")])
          }, {
            default: Q(() => [
              q(s(Cl))
            ]),
            _: 1
          }, 8, ["class"])) : (_(), ae(s(ze), {
            key: 1,
            class: $(["arrow-right", s(l).e("postfix")])
          }, {
            default: Q(() => [
              q(s(Un))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64))
      ], 42, ["id", "aria-haspopup", "aria-owns", "aria-expanded", "tabindex"]));
    }
  });
  var jL = /* @__PURE__ */ Ne(WL, [["__file", "node.vue"]]);
  const UL = /* @__PURE__ */ U({
    name: "ElCascaderMenu"
  }), YL = /* @__PURE__ */ U({
    ...UL,
    props: {
      nodes: {
        type: Array,
        required: !0
      },
      index: {
        type: Number,
        required: !0
      }
    },
    setup(e) {
      const t = e, n = dt(), o = he("cascader-menu"), { t: l } = _t(), a = xn();
      let r, i;
      const u = Ve(zd), c = A(), d = S(() => !t.nodes.length), f = S(() => !u.initialLoaded), v = S(() => `${a.value}-${t.index}`), p = (b) => {
        r = b.target;
      }, m = (b) => {
        if (!(!u.isHoverMenu || !r || !c.value))
          if (r.contains(b.target)) {
            h();
            const C = n.vnode.el, { left: w } = C.getBoundingClientRect(), { offsetWidth: y, offsetHeight: E } = C, k = b.clientX - w, T = r.offsetTop, x = T + r.offsetHeight;
            c.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${k} ${T} L${y} 0 V${T} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${k} ${x} L${y} ${E} V${x} Z" />
        `;
          } else i || (i = window.setTimeout(g, u.config.hoverThreshold));
      }, h = () => {
        i && (clearTimeout(i), i = void 0);
      }, g = () => {
        c.value && (c.value.innerHTML = "", h());
      };
      return (b, C) => (_(), ae(s(Go), {
        key: s(v),
        tag: "ul",
        role: "menu",
        class: $(s(o).b()),
        "wrap-class": s(o).e("wrap"),
        "view-class": [s(o).e("list"), s(o).is("empty", s(d))],
        onMousemove: m,
        onMouseleave: g
      }, {
        default: Q(() => {
          var w;
          return [
            (_(!0), B(We, null, bt(e.nodes, (y) => (_(), ae(jL, {
              key: y.uid,
              node: y,
              "menu-id": s(v),
              onExpand: p
            }, null, 8, ["node", "menu-id"]))), 128)),
            s(f) ? (_(), B("div", {
              key: 0,
              class: $(s(o).e("empty-text"))
            }, [
              q(s(ze), {
                size: "14",
                class: $(s(o).is("loading"))
              }, {
                default: Q(() => [
                  q(s(Cl))
                ]),
                _: 1
              }, 8, ["class"]),
              Ct(" " + ke(s(l)("el.cascader.loading")), 1)
            ], 2)) : s(d) ? (_(), B("div", {
              key: 1,
              class: $(s(o).e("empty-text"))
            }, [
              ee(b.$slots, "empty", {}, () => [
                Ct(ke(s(l)("el.cascader.noData")), 1)
              ])
            ], 2)) : (w = s(u)) != null && w.isHoverMenu ? (_(), B(We, { key: 2 }, [
              oe(" eslint-disable-next-line vue/html-self-closing "),
              (_(), B("svg", {
                ref_key: "hoverZone",
                ref: c,
                class: $(s(o).e("hover-zone"))
              }, null, 2))
            ], 2112)) : oe("v-if", !0)
          ];
        }),
        _: 3
      }, 8, ["class", "wrap-class", "view-class"]));
    }
  });
  var qL = /* @__PURE__ */ Ne(YL, [["__file", "menu.vue"]]);
  let GL = 0;
  const XL = (e) => {
    const t = [e];
    let { parent: n } = e;
    for (; n; )
      t.unshift(n), n = n.parent;
    return t;
  };
  let Np = class $p {
    constructor(t, n, o, l = !1) {
      this.data = t, this.config = n, this.parent = o, this.root = l, this.uid = GL++, this.checked = !1, this.indeterminate = !1, this.loading = !1;
      const { value: a, label: r, children: i } = n, u = t[i], c = XL(this);
      this.level = l ? 0 : o ? o.level + 1 : 1, this.value = t[a], this.label = t[r], this.pathNodes = c, this.pathValues = c.map((d) => d.value), this.pathLabels = c.map((d) => d.label), this.childrenData = u, this.children = (u || []).map((d) => new $p(d, n, this)), this.loaded = !n.lazy || this.isLeaf || !Zn(u), this.text = "";
    }
    get isDisabled() {
      const { data: t, parent: n, config: o } = this, { disabled: l, checkStrictly: a } = o;
      return (Fe(l) ? l(t, this) : !!t[l]) || !a && !!(n != null && n.isDisabled);
    }
    get isLeaf() {
      const { data: t, config: n, childrenData: o, loaded: l } = this, { lazy: a, leaf: r } = n, i = Fe(r) ? r(t, this) : t[r];
      return kt(i) ? a && !l ? !1 : !(ye(o) && o.length) : !!i;
    }
    get valueByOption() {
      return this.config.emitPath ? this.pathValues : this.value;
    }
    appendChild(t) {
      const { childrenData: n, children: o } = this, l = new $p(t, this.config, this);
      return ye(n) ? n.push(t) : this.childrenData = [t], o.push(l), l;
    }
    calcText(t, n) {
      const o = t ? this.pathLabels.join(n) : this.label;
      return this.text = o, o;
    }
    broadcast(t) {
      this.children.forEach((n) => {
        var o;
        n && (n.broadcast(t), (o = n.onParentCheck) == null || o.call(n, t));
      });
    }
    emit() {
      var t;
      const { parent: n } = this;
      n && ((t = n.onChildCheck) == null || t.call(n), n.emit());
    }
    onParentCheck(t) {
      this.isDisabled || this.setCheckState(t);
    }
    onChildCheck() {
      const { children: t } = this, n = t.filter((l) => !l.isDisabled), o = n.length ? n.every((l) => l.checked) : !1;
      this.setCheckState(o);
    }
    setCheckState(t) {
      const n = this.children.length, o = this.children.reduce((l, a) => {
        const r = a.checked ? 1 : a.indeterminate ? 0.5 : 0;
        return l + r;
      }, 0);
      this.checked = this.loaded && this.children.filter((l) => !l.isDisabled).every((l) => l.loaded && l.checked) && t, this.indeterminate = this.loaded && o !== n && o > 0;
    }
    doCheck(t) {
      if (this.checked === t)
        return;
      const { checkStrictly: n, multiple: o } = this.config;
      n || !o ? this.checked = t : (this.broadcast(t), this.setCheckState(t), this.emit());
    }
  };
  const Op = (e, t) => e.reduce((n, o) => (o.isLeaf ? n.push(o) : (!t && n.push(o), n = n.concat(Op(o.children, t))), n), []);
  class oy {
    constructor(t, n) {
      this.config = n;
      const o = (t || []).map((l) => new Np(l, this.config));
      this.nodes = o, this.allNodes = Op(o, !1), this.leafNodes = Op(o, !0);
    }
    getNodes() {
      return this.nodes;
    }
    getFlattedNodes(t) {
      return t ? this.leafNodes : this.allNodes;
    }
    appendNode(t, n) {
      const o = n ? n.appendChild(t) : new Np(t, this.config);
      n || this.nodes.push(o), this.appendAllNodesAndLeafNodes(o);
    }
    appendNodes(t, n) {
      t.length > 0 ? t.forEach((o) => this.appendNode(o, n)) : n && n.isLeaf && this.leafNodes.push(n);
    }
    appendAllNodesAndLeafNodes(t) {
      this.allNodes.push(t), t.isLeaf && this.leafNodes.push(t), t.children && t.children.forEach((n) => {
        this.appendAllNodesAndLeafNodes(n);
      });
    }
    getNodeByValue(t, n = !1) {
      return go(t) ? null : this.getFlattedNodes(n).find((l) => ln(l.value, t) || ln(l.pathValues, t)) || null;
    }
    getSameNode(t) {
      return t && this.getFlattedNodes(!1).find(({ value: o, level: l }) => ln(t.value, o) && t.level === l) || null;
    }
  }
  const DS = Te({
    modelValue: {
      type: X([Number, String, Array, Object])
    },
    options: {
      type: X(Array),
      default: () => []
    },
    props: {
      type: X(Object),
      default: () => ({})
    }
  }), JL = {
    expandTrigger: "click",
    multiple: !1,
    checkStrictly: !1,
    emitPath: !0,
    lazy: !1,
    lazyLoad: It,
    value: "value",
    label: "label",
    children: "children",
    leaf: "leaf",
    disabled: "disabled",
    hoverThreshold: 500,
    checkOnClickNode: !1,
    checkOnClickLeaf: !0,
    showPrefix: !0
  }, ZL = Te({
    ...DS,
    border: {
      type: Boolean,
      default: !0
    },
    renderLabel: {
      type: Function
    }
  }), ly = (e) => !0, QL = {
    [et]: ly,
    [gt]: ly,
    close: () => !0,
    "expand-change": (e) => e
  }, e8 = (e) => S(() => ({
    ...JL,
    ...e.props
  })), ay = (e) => {
    if (!e)
      return 0;
    const t = e.id.split("-");
    return Number(t[t.length - 2]);
  }, t8 = (e) => {
    if (!e)
      return;
    const t = e.querySelector("input");
    t ? t.click() : _C(e) && e.click();
  }, n8 = (e, t) => {
    const n = t.slice(0), o = n.map((a) => a.uid), l = e.reduce((a, r) => {
      const i = o.indexOf(r.uid);
      return i > -1 && (a.push(r), n.splice(i, 1), o.splice(i, 1)), a;
    }, []);
    return l.push(...n), l;
  }, o8 = /* @__PURE__ */ U({
    name: "ElCascaderPanel"
  }), l8 = /* @__PURE__ */ U({
    ...o8,
    props: ZL,
    emits: QL,
    setup(e, { expose: t, emit: n }) {
      const o = e;
      let l = !1;
      const a = he("cascader"), r = e8(o), i = hn();
      let u;
      const c = A(!0), d = A(!1), f = A([]), v = A(), p = A([]), m = A(), h = A([]), g = S(() => r.value.expandTrigger === "hover"), b = S(() => o.renderLabel || i.default), C = () => {
        const { options: M } = o, R = r.value;
        l = !1, u = new oy(M, R), p.value = [u.getNodes()], R.lazy && Zn(o.options) ? (c.value = !1, w(void 0, (D) => {
          D && (u = new oy(D, R), p.value = [u.getNodes()]), c.value = !0, O(!1, !0);
        })) : O(!1, !0);
      }, w = (M, R) => {
        const D = r.value;
        M = M || new Np({}, D, void 0, !0), M.loading = !0;
        const L = (F) => {
          const H = M, K = H.root ? null : H;
          H.loading = !1, H.loaded = !0, H.childrenData = H.childrenData || [], F && (u == null || u.appendNodes(F, K)), F && (R == null || R(F)), M.level === 0 && (d.value = !0);
        }, V = () => {
          M.loading = !1, M.loaded = !1, M.level === 0 && (c.value = !0);
        };
        D.lazyLoad(M, L, V);
      }, y = (M, R) => {
        var D;
        const { level: L } = M, V = p.value.slice(0, L);
        let F;
        M.isLeaf ? F = M.pathNodes[L - 2] : (F = M, V.push(M.children)), ((D = m.value) == null ? void 0 : D.uid) !== (F == null ? void 0 : F.uid) && (m.value = M, p.value = V, !R && n("expand-change", (M == null ? void 0 : M.pathValues) || []));
      }, E = (M, R, D = !0) => {
        const { checkStrictly: L, multiple: V } = r.value, F = h.value[0];
        l = !0, !V && (F == null || F.doCheck(!1)), M.doCheck(R), P(), D && !V && !L && n("close"), !D && !V && k(M);
      }, k = (M) => {
        M && (M = M.parent, k(M), M && y(M));
      }, T = (M) => u == null ? void 0 : u.getFlattedNodes(M), x = (M) => {
        var R;
        return (R = T(M)) == null ? void 0 : R.filter(({ checked: D }) => D !== !1);
      }, I = () => {
        h.value.forEach((M) => M.doCheck(!1)), P(), p.value = p.value.slice(0, 1), m.value = void 0, n("expand-change", []);
      }, P = () => {
        var M;
        const { checkStrictly: R, multiple: D } = r.value, L = h.value, V = x(!R), F = n8(L, V), H = F.map((K) => K.valueByOption);
        h.value = F, v.value = D ? H : (M = H[0]) != null ? M : null;
      }, O = (M = !1, R = !1) => {
        const { modelValue: D } = o, { lazy: L, multiple: V, checkStrictly: F } = r.value, H = !F;
        if (!(!c.value || l || !R && ln(D, v.value)))
          if (L && !M) {
            const Z = Yb(uP(Kn(D))).map((J) => u == null ? void 0 : u.getNodeByValue(J)).filter((J) => !!J && !J.loaded && !J.loading);
            Z.length ? Z.forEach((J) => {
              w(J, () => O(!1, R));
            }) : O(!0, R);
          } else {
            const K = V ? Kn(D) : [D], Z = Yb(K.map((J) => u == null ? void 0 : u.getNodeByValue(J, H)));
            N(Z, R), v.value = Ac(D ?? void 0);
          }
      }, N = (M, R = !0) => {
        const { checkStrictly: D } = r.value, L = h.value, V = M.filter((K) => !!K && (D || K.isLeaf)), F = u == null ? void 0 : u.getSameNode(m.value), H = R && F || V[0];
        H ? H.pathNodes.forEach((K) => y(K, !0)) : m.value = void 0, L.forEach((K) => K.doCheck(!1)), Rt(V).forEach((K) => K.doCheck(!0)), h.value = V, Re(z);
      }, z = () => {
        xt && f.value.forEach((M) => {
          const R = M == null ? void 0 : M.$el;
          if (R) {
            const D = R.querySelector(`.${a.namespace.value}-scrollbar__wrap`), L = R.querySelector(`.${a.b("node")}.${a.is("active")}:last-child`) || R.querySelector(`.${a.b("node")}.in-active-path`);
            ch(D, L);
          }
        });
      }, Y = (M) => {
        const R = M.target, D = Ht(M);
        switch (D) {
          case _e.up:
          case _e.down: {
            M.preventDefault();
            const L = D === _e.up ? -1 : 1;
            ec(TC(R, L, `.${a.b("node")}[tabindex="-1"]`));
            break;
          }
          case _e.left: {
            M.preventDefault();
            const L = f.value[ay(R) - 1], V = L == null ? void 0 : L.$el.querySelector(`.${a.b("node")}[aria-expanded="true"]`);
            ec(V);
            break;
          }
          case _e.right: {
            M.preventDefault();
            const L = f.value[ay(R) + 1], V = L == null ? void 0 : L.$el.querySelector(`.${a.b("node")}[tabindex="-1"]`);
            ec(V);
            break;
          }
          case _e.enter:
          case _e.numpadEnter:
            t8(R);
            break;
        }
      };
      yt(zd, Rt({
        config: r,
        expandingNode: m,
        checkedNodes: h,
        isHoverMenu: g,
        initialLoaded: c,
        renderLabelFn: b,
        lazyLoad: w,
        expandNode: y,
        handleCheckChange: E
      })), de(r, (M, R) => {
        ln(M, R) || C();
      }, {
        immediate: !0
      }), de(() => o.options, C, {
        deep: !0
      }), de(() => o.modelValue, () => {
        l = !1, O();
      }, {
        deep: !0
      }), de(() => v.value, (M) => {
        ln(M, o.modelValue) || (n(et, M), n(gt, M));
      });
      const G = () => {
        d.value || C();
      };
      return Pv(() => f.value = []), ft(() => !Zn(o.modelValue) && O()), t({
        menuList: f,
        menus: p,
        checkedNodes: h,
        handleKeyDown: Y,
        handleCheckChange: E,
        getFlattedNodes: T,
        getCheckedNodes: x,
        clearCheckedNodes: I,
        calculateCheckedValue: P,
        scrollToExpandingNode: z,
        loadLazyRootNodes: G
      }), (M, R) => (_(), B("div", {
        class: $([s(a).b("panel"), s(a).is("bordered", M.border)]),
        onKeydown: Y
      }, [
        (_(!0), B(We, null, bt(p.value, (D, L) => (_(), ae(qL, {
          key: L,
          ref_for: !0,
          ref: (V) => f.value[L] = V,
          index: L,
          nodes: [...D]
        }, {
          empty: Q(() => [
            ee(M.$slots, "empty")
          ]),
          _: 2
        }, 1032, ["index", "nodes"]))), 128))
      ], 34));
    }
  });
  var a8 = /* @__PURE__ */ Ne(l8, [["__file", "index.vue"]]);
  const AS = rt(a8), Xl = Te({
    type: {
      type: String,
      values: ["primary", "success", "info", "warning", "danger"],
      default: "primary"
    },
    closable: Boolean,
    disableTransitions: Boolean,
    hit: Boolean,
    color: String,
    size: {
      type: String,
      values: Tl
    },
    effect: {
      type: String,
      values: ["dark", "light", "plain"],
      default: "light"
    },
    round: Boolean
  }), r8 = {
    close: (e) => e instanceof MouseEvent,
    click: (e) => e instanceof MouseEvent
  }, s8 = /* @__PURE__ */ U({
    name: "ElTag"
  }), i8 = /* @__PURE__ */ U({
    ...s8,
    props: Xl,
    emits: r8,
    setup(e, { emit: t }) {
      const n = e, o = vn(), l = he("tag"), a = S(() => {
        const { type: c, hit: d, effect: f, closable: v, round: p } = n;
        return [
          l.b(),
          l.is("closable", v),
          l.m(c || "primary"),
          l.m(o.value),
          l.m(f),
          l.is("hit", d),
          l.is("round", p)
        ];
      }), r = (c) => {
        t("close", c);
      }, i = (c) => {
        t("click", c);
      }, u = (c) => {
        var d, f, v;
        (v = (f = (d = c == null ? void 0 : c.component) == null ? void 0 : d.subTree) == null ? void 0 : f.component) != null && v.bum && (c.component.subTree.component.bum = null);
      };
      return (c, d) => c.disableTransitions ? (_(), B("span", {
        key: 0,
        class: $(s(a)),
        style: Ue({ backgroundColor: c.color }),
        onClick: i
      }, [
        W("span", {
          class: $(s(l).e("content"))
        }, [
          ee(c.$slots, "default")
        ], 2),
        c.closable ? (_(), ae(s(ze), {
          key: 0,
          class: $(s(l).e("close")),
          onClick: Ze(r, ["stop"])
        }, {
          default: Q(() => [
            q(s(Oo))
          ]),
          _: 1
        }, 8, ["class", "onClick"])) : oe("v-if", !0)
      ], 6)) : (_(), ae(Mn, {
        key: 1,
        name: `${s(l).namespace.value}-zoom-in-center`,
        appear: "",
        onVnodeMounted: u
      }, {
        default: Q(() => [
          W("span", {
            class: $(s(a)),
            style: Ue({ backgroundColor: c.color }),
            onClick: i
          }, [
            W("span", {
              class: $(s(l).e("content"))
            }, [
              ee(c.$slots, "default")
            ], 2),
            c.closable ? (_(), ae(s(ze), {
              key: 0,
              class: $(s(l).e("close")),
              onClick: Ze(r, ["stop"])
            }, {
              default: Q(() => [
                q(s(Oo))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : oe("v-if", !0)
          ], 6)
        ]),
        _: 3
      }, 8, ["name"]));
    }
  });
  var u8 = /* @__PURE__ */ Ne(i8, [["__file", "tag.vue"]]);
  const Wl = rt(u8), c8 = Te({
    ...DS,
    size: mn,
    placeholder: String,
    disabled: Boolean,
    clearable: Boolean,
    clearIcon: {
      type: Lt,
      default: oa
    },
    filterable: Boolean,
    filterMethod: {
      type: X(Function),
      default: (e, t) => e.text.includes(t)
    },
    separator: {
      type: String,
      default: " / "
    },
    showAllLevels: {
      type: Boolean,
      default: !0
    },
    collapseTags: Boolean,
    maxCollapseTags: {
      type: Number,
      default: 1
    },
    collapseTagsTooltip: Boolean,
    maxCollapseTagsTooltipHeight: {
      type: [String, Number]
    },
    debounce: {
      type: Number,
      default: 300
    },
    beforeFilter: {
      type: X(Function),
      default: () => !0
    },
    placement: {
      type: X(String),
      values: aa,
      default: "bottom-start"
    },
    fallbackPlacements: {
      type: X(Array),
      default: ["bottom-start", "bottom", "top-start", "top", "right", "left"]
    },
    popperClass: zt.popperClass,
    popperStyle: zt.popperStyle,
    teleported: zt.teleported,
    effect: {
      type: X(String),
      default: "light"
    },
    tagType: { ...Xl.type, default: "info" },
    tagEffect: { ...Xl.effect, default: "light" },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    persistent: {
      type: Boolean,
      default: !0
    },
    showCheckedStrategy: {
      type: String,
      values: ["parent", "child"],
      default: "child"
    },
    checkOnClickNode: Boolean,
    showPrefix: {
      type: Boolean,
      default: !0
    },
    ...Cr
  }), ry = (e) => !0, d8 = {
    [et]: ry,
    [gt]: ry,
    focus: (e) => e instanceof FocusEvent,
    blur: (e) => e instanceof FocusEvent,
    clear: () => !0,
    visibleChange: (e) => Vt(e),
    expandChange: (e) => !!e,
    removeTag: (e) => !!e
  }, fa = /* @__PURE__ */ new Map();
  if (xt) {
    let e;
    document.addEventListener("mousedown", (t) => e = t), document.addEventListener("mouseup", (t) => {
      if (e) {
        for (const n of fa.values())
          for (const { documentHandler: o } of n)
            o(t, e);
        e = void 0;
      }
    });
  }
  function sy(e, t) {
    let n = [];
    return ye(t.arg) ? n = t.arg : Qn(t.arg) && n.push(t.arg), function(o, l) {
      const a = t.instance.popperRef, r = o.target, i = l == null ? void 0 : l.target, u = !t || !t.instance, c = !r || !i, d = e.contains(r) || e.contains(i), f = e === r, v = n.length && n.some((m) => m == null ? void 0 : m.contains(r)) || n.length && n.includes(i), p = a && (a.contains(r) || a.contains(i));
      u || c || d || f || v || p || t.value(o, l);
    };
  }
  const Jl = {
    beforeMount(e, t) {
      fa.has(e) || fa.set(e, []), fa.get(e).push({
        documentHandler: sy(e, t),
        bindingFn: t.value
      });
    },
    updated(e, t) {
      fa.has(e) || fa.set(e, []);
      const n = fa.get(e), o = n.findIndex((a) => a.bindingFn === t.oldValue), l = {
        documentHandler: sy(e, t),
        bindingFn: t.value
      };
      o >= 0 ? n.splice(o, 1, l) : n.push(l);
    },
    unmounted(e) {
      fa.delete(e);
    }
  }, f8 = /* @__PURE__ */ U({
    name: "ElCascader"
  }), p8 = /* @__PURE__ */ U({
    ...f8,
    props: c8,
    emits: d8,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = {
        modifiers: [
          {
            name: "arrowPosition",
            enabled: !0,
            phase: "main",
            fn: ({ state: Se }) => {
              const { modifiersData: Je, placement: lt } = Se;
              ["right", "left", "bottom", "top"].includes(lt) || Je.arrow && (Je.arrow.x = 35);
            },
            requires: ["arrow"]
          }
        ]
      }, a = ea();
      let r = 0, i = 0;
      const u = he("cascader"), c = he("input"), { t: d } = _t(), { formItem: f } = Nn(), v = Cn(), { valueOnClear: p } = nu(o), { isComposing: m, handleComposition: h } = ru({
        afterComposition(Se) {
          var Je;
          const lt = (Je = Se.target) == null ? void 0 : Je.value;
          ve(lt);
        }
      }), g = A(), b = A(), C = A(), w = A(), y = A(), E = A(), k = A(!1), T = A(!1), x = A(!1), I = A(""), P = A(""), O = A([]), N = A([]), z = S(() => o.props.multiple ? o.collapseTags ? O.value.slice(0, o.maxCollapseTags) : O.value : []), Y = S(() => o.props.multiple ? o.collapseTags ? O.value.slice(o.maxCollapseTags) : [] : []), G = S(() => a.style), M = S(() => {
        var Se;
        return (Se = o.placeholder) != null ? Se : d("el.cascader.placeholder");
      }), R = S(() => P.value || O.value.length > 0 || m.value ? "" : M.value), D = vn(), L = S(() => D.value === "small" ? "small" : "default"), V = S(() => !!o.props.multiple), F = S(() => !o.filterable || V.value), H = S(() => V.value ? P.value : I.value), K = S(() => {
        var Se;
        return ((Se = y.value) == null ? void 0 : Se.checkedNodes) || [];
      }), { wrapperRef: Z, isFocused: J, handleBlur: ie } = la(C, {
        disabled: v,
        beforeBlur(Se) {
          var Je, lt;
          return ((Je = g.value) == null ? void 0 : Je.isFocusInsideContent(Se)) || ((lt = b.value) == null ? void 0 : lt.isFocusInsideContent(Se));
        },
        afterBlur() {
          var Se;
          o.validateEvent && ((Se = f == null ? void 0 : f.validate) == null || Se.call(f, "blur").catch((Je) => vt(Je)));
        }
      }), ue = S(() => !o.clearable || v.value || x.value || !T.value && !J.value ? !1 : !!K.value.length), re = S(() => {
        const { showAllLevels: Se, separator: Je } = o, lt = K.value;
        return lt.length ? V.value ? "" : lt[0].calcText(Se, Je) : "";
      }), se = S(() => (f == null ? void 0 : f.validateState) || ""), ne = S({
        get() {
          return Ac(o.modelValue);
        },
        set(Se) {
          const Je = Se ?? p.value;
          n(et, Je), n(gt, Je), o.validateEvent && (f == null || f.validate("change").catch((lt) => vt(lt)));
        }
      }), le = S(() => [
        u.b(),
        u.m(D.value),
        u.is("disabled", v.value),
        a.class
      ]), Ce = S(() => [
        c.e("icon"),
        "icon-arrow-down",
        u.is("reverse", k.value)
      ]), j = S(() => u.is("focus", J.value)), te = S(() => {
        var Se, Je;
        return (Je = (Se = g.value) == null ? void 0 : Se.popperRef) == null ? void 0 : Je.contentRef;
      }), ce = (Se) => {
        if (J.value) {
          const Je = new FocusEvent("blur", Se);
          ie(Je);
        }
        ge(!1);
      }, ge = (Se) => {
        var Je, lt, Yt;
        v.value || (Se = Se ?? !k.value, Se !== k.value && (k.value = Se, (lt = (Je = C.value) == null ? void 0 : Je.input) == null || lt.setAttribute("aria-expanded", `${Se}`), Se ? (be(), Re((Yt = y.value) == null ? void 0 : Yt.scrollToExpandingNode)) : o.filterable && Nt(), n("visibleChange", Se)));
      }, be = () => {
        Re(() => {
          var Se;
          (Se = g.value) == null || Se.updatePopper();
        });
      }, Ee = () => {
        x.value = !1;
      }, Oe = (Se) => {
        const { showAllLevels: Je, separator: lt } = o;
        return {
          node: Se,
          key: Se.uid,
          text: Se.calcText(Je, lt),
          hitState: !1,
          closable: !v.value && !Se.isDisabled
        };
      }, De = (Se) => {
        var Je;
        const lt = Se.node;
        lt.doCheck(!1), (Je = y.value) == null || Je.calculateCheckedValue(), n("removeTag", lt.valueByOption);
      }, we = () => {
        switch (o.showCheckedStrategy) {
          case "child":
            return K.value;
          case "parent": {
            const Se = pe(!1), Je = Se.map((Yt) => Yt.value);
            return Se.filter((Yt) => !Yt.parent || !Je.includes(Yt.parent.value));
          }
          default:
            return [];
        }
      }, me = () => {
        if (!V.value)
          return;
        const Se = we(), Je = [];
        Se.forEach((lt) => Je.push(Oe(lt))), O.value = Je;
      }, Pe = () => {
        var Se, Je;
        const { filterMethod: lt, showAllLevels: Yt, separator: $n } = o, xe = (Je = (Se = y.value) == null ? void 0 : Se.getFlattedNodes(!o.props.checkStrictly)) == null ? void 0 : Je.filter((wt) => wt.isDisabled ? !1 : (wt.calcText(Yt, $n), lt(wt, H.value)));
        V.value && O.value.forEach((wt) => {
          wt.hitState = !1;
        }), x.value = !0, N.value = xe, be();
      }, Me = () => {
        var Se;
        let Je;
        x.value && E.value ? Je = E.value.$el.querySelector(`.${u.e("suggestion-item")}`) : Je = (Se = y.value) == null ? void 0 : Se.$el.querySelector(`.${u.b("node")}[tabindex="-1"]`), Je && (Je.focus(), !x.value && Je.click());
      }, Be = () => {
        var Se, Je;
        const lt = (Se = C.value) == null ? void 0 : Se.input, Yt = w.value, $n = (Je = E.value) == null ? void 0 : Je.$el;
        if (!(!xt || !lt)) {
          if ($n) {
            const xe = $n.querySelector(`.${u.e("suggestion-list")}`);
            xe.style.minWidth = `${lt.offsetWidth}px`;
          }
          if (Yt) {
            const { offsetHeight: xe } = Yt, wt = O.value.length > 0 ? `${Math.max(xe, r) - 2}px` : `${r}px`;
            lt.style.height = wt, be();
          }
        }
      }, pe = (Se) => {
        var Je;
        return (Je = y.value) == null ? void 0 : Je.getCheckedNodes(Se);
      }, Le = (Se) => {
        be(), n("expandChange", Se);
      }, Xe = (Se) => {
        if (m.value)
          return;
        switch (Ht(Se)) {
          case _e.enter:
          case _e.numpadEnter:
            ge();
            break;
          case _e.down:
            ge(!0), Re(Me), Se.preventDefault();
            break;
          case _e.esc:
            k.value === !0 && (Se.preventDefault(), Se.stopPropagation(), ge(!1));
            break;
          case _e.tab:
            ge(!1);
            break;
        }
      }, ut = () => {
        var Se;
        (Se = y.value) == null || Se.clearCheckedNodes(), !k.value && o.filterable && Nt(), ge(!1), n("clear");
      }, Nt = () => {
        const { value: Se } = re;
        I.value = Se, P.value = Se;
      }, Ye = (Se) => {
        var Je, lt;
        const { checked: Yt } = Se;
        V.value ? (Je = y.value) == null || Je.handleCheckChange(Se, !Yt, !1) : (!Yt && ((lt = y.value) == null || lt.handleCheckChange(Se, !0, !1)), ge(!1));
      }, tt = (Se) => {
        const Je = Se.target, lt = Ht(Se);
        switch (lt) {
          case _e.up:
          case _e.down: {
            Se.preventDefault();
            const Yt = lt === _e.up ? -1 : 1;
            ec(TC(Je, Yt, `.${u.e("suggestion-item")}[tabindex="-1"]`));
            break;
          }
          case _e.enter:
          case _e.numpadEnter:
            Je.click();
            break;
        }
      }, fe = () => {
        const Se = O.value[O.value.length - 1];
        i = P.value ? 0 : i + 1, !(!Se || !i || o.collapseTags && O.value.length > 1) && (Se.hitState ? De(Se) : Se.hitState = !0);
      }, He = S(() => o.debounce), Qe = eu(() => {
        const { value: Se } = H;
        if (!Se)
          return;
        const Je = o.beforeFilter(Se);
        _a(Je) ? Je.then(Pe).catch(() => {
        }) : Je !== !1 ? Pe() : Ee();
      }, He), ve = (Se, Je) => {
        !k.value && ge(!0), !(Je != null && Je.isComposing) && (Se ? Qe() : Ee());
      }, Ke = (Se) => Number.parseFloat(jP(c.cssVarName("input-height"), Se).value) - 2, St = () => {
        var Se;
        (Se = C.value) == null || Se.focus();
      }, Ft = () => {
        var Se;
        (Se = C.value) == null || Se.blur();
      };
      return de(x, be), de([
        K,
        v,
        () => o.collapseTags,
        () => o.maxCollapseTags
      ], me), de(O, () => {
        Re(() => Be());
      }), de(D, async () => {
        await Re();
        const Se = C.value.input;
        r = Ke(Se) || r, Be();
      }), de(re, Nt, { immediate: !0 }), de(() => k.value, (Se) => {
        var Je;
        Se && o.props.lazy && o.props.lazyLoad && ((Je = y.value) == null || Je.loadLazyRootNodes());
      }), ft(() => {
        const Se = C.value.input, Je = Ke(Se);
        r = Se.offsetHeight || Je, qt(Se, Be);
      }), t({
        getCheckedNodes: pe,
        cascaderPanelRef: y,
        togglePopperVisible: ge,
        contentRef: te,
        presentText: re,
        focus: St,
        blur: Ft
      }), (Se, Je) => (_(), ae(s(Pn), {
        ref_key: "tooltipRef",
        ref: g,
        visible: k.value,
        teleported: Se.teleported,
        "popper-class": [s(u).e("dropdown"), Se.popperClass],
        "popper-style": Se.popperStyle,
        "popper-options": l,
        "fallback-placements": Se.fallbackPlacements,
        "stop-popper-mouse-event": !1,
        "gpu-acceleration": !1,
        placement: Se.placement,
        transition: `${s(u).namespace.value}-zoom-in-top`,
        effect: Se.effect,
        pure: "",
        persistent: Se.persistent,
        onHide: Ee
      }, {
        default: Q(() => [
          it((_(), B("div", {
            ref_key: "wrapperRef",
            ref: Z,
            class: $(s(le)),
            style: Ue(s(G)),
            onClick: () => ge(s(F) ? void 0 : !0),
            onKeydown: Xe,
            onMouseenter: (lt) => T.value = !0,
            onMouseleave: (lt) => T.value = !1
          }, [
            q(s(Wn), {
              ref_key: "inputRef",
              ref: C,
              modelValue: I.value,
              "onUpdate:modelValue": (lt) => I.value = lt,
              placeholder: s(R),
              readonly: s(F),
              disabled: s(v),
              "validate-event": !1,
              size: s(D),
              class: $(s(j)),
              tabindex: s(V) && Se.filterable && !s(v) ? -1 : void 0,
              onCompositionstart: s(h),
              onCompositionupdate: s(h),
              onCompositionend: s(h),
              onInput: ve
            }, io({
              suffix: Q(() => [
                s(ue) ? (_(), ae(s(ze), {
                  key: "clear",
                  class: $([s(c).e("icon"), "icon-circle-close"]),
                  onClick: Ze(ut, ["stop"])
                }, {
                  default: Q(() => [
                    (_(), ae(ct(Se.clearIcon)))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : (_(), ae(s(ze), {
                  key: "arrow-down",
                  class: $(s(Ce)),
                  onClick: Ze((lt) => ge(), ["stop"])
                }, {
                  default: Q(() => [
                    q(s(Nl))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"]))
              ]),
              _: 2
            }, [
              Se.$slots.prefix ? {
                name: "prefix",
                fn: Q(() => [
                  ee(Se.$slots, "prefix")
                ])
              } : void 0
            ]), 1032, ["modelValue", "onUpdate:modelValue", "placeholder", "readonly", "disabled", "size", "class", "tabindex", "onCompositionstart", "onCompositionupdate", "onCompositionend"]),
            s(V) ? (_(), B("div", {
              key: 0,
              ref_key: "tagWrapper",
              ref: w,
              class: $([
                s(u).e("tags"),
                s(u).is("validate", !!s(se))
              ])
            }, [
              ee(Se.$slots, "tag", {
                data: O.value,
                deleteTag: De
              }, () => [
                (_(!0), B(We, null, bt(s(z), (lt) => (_(), ae(s(Wl), {
                  key: lt.key,
                  type: Se.tagType,
                  size: s(L),
                  effect: Se.tagEffect,
                  hit: lt.hitState,
                  closable: lt.closable,
                  "disable-transitions": "",
                  onClose: (Yt) => De(lt)
                }, {
                  default: Q(() => [
                    W("span", null, ke(lt.text), 1)
                  ]),
                  _: 2
                }, 1032, ["type", "size", "effect", "hit", "closable", "onClose"]))), 128))
              ]),
              Se.collapseTags && O.value.length > Se.maxCollapseTags ? (_(), ae(s(Pn), {
                key: 0,
                ref_key: "tagTooltipRef",
                ref: b,
                disabled: k.value || !Se.collapseTagsTooltip,
                "fallback-placements": ["bottom", "top", "right", "left"],
                placement: "bottom",
                "popper-class": Se.popperClass,
                "popper-style": Se.popperStyle,
                effect: Se.effect,
                persistent: Se.persistent
              }, {
                default: Q(() => [
                  q(s(Wl), {
                    closable: !1,
                    size: s(L),
                    type: Se.tagType,
                    effect: Se.tagEffect,
                    "disable-transitions": ""
                  }, {
                    default: Q(() => [
                      W("span", {
                        class: $(s(u).e("tags-text"))
                      }, " + " + ke(O.value.length - Se.maxCollapseTags), 3)
                    ]),
                    _: 1
                  }, 8, ["size", "type", "effect"])
                ]),
                content: Q(() => [
                  q(s(Go), { "max-height": Se.maxCollapseTagsTooltipHeight }, {
                    default: Q(() => [
                      W("div", {
                        class: $(s(u).e("collapse-tags"))
                      }, [
                        (_(!0), B(We, null, bt(s(Y), (lt, Yt) => (_(), B("div", {
                          key: Yt,
                          class: $(s(u).e("collapse-tag"))
                        }, [
                          (_(), ae(s(Wl), {
                            key: lt.key,
                            class: "in-tooltip",
                            type: Se.tagType,
                            size: s(L),
                            effect: Se.tagEffect,
                            hit: lt.hitState,
                            closable: lt.closable,
                            "disable-transitions": "",
                            onClose: ($n) => De(lt)
                          }, {
                            default: Q(() => [
                              W("span", null, ke(lt.text), 1)
                            ]),
                            _: 2
                          }, 1032, ["type", "size", "effect", "hit", "closable", "onClose"]))
                        ], 2))), 128))
                      ], 2)
                    ]),
                    _: 1
                  }, 8, ["max-height"])
                ]),
                _: 1
              }, 8, ["disabled", "popper-class", "popper-style", "effect", "persistent"])) : oe("v-if", !0),
              Se.filterable && !s(v) ? it((_(), B("input", {
                key: 1,
                "onUpdate:modelValue": (lt) => P.value = lt,
                type: "text",
                class: $(s(u).e("search-input")),
                placeholder: s(re) ? "" : s(M),
                onInput: (lt) => ve(P.value, lt),
                onClick: Ze((lt) => ge(!0), ["stop"]),
                onKeydown: on(fe, ["delete"]),
                onCompositionstart: s(h),
                onCompositionupdate: s(h),
                onCompositionend: s(h)
              }, null, 42, ["onUpdate:modelValue", "placeholder", "onInput", "onClick", "onKeydown", "onCompositionstart", "onCompositionupdate", "onCompositionend"])), [
                [Sd, P.value]
              ]) : oe("v-if", !0)
            ], 2)) : oe("v-if", !0)
          ], 46, ["onClick", "onMouseenter", "onMouseleave"])), [
            [s(Jl), ce, s(te)]
          ])
        ]),
        content: Q(() => [
          Se.$slots.header ? (_(), B("div", {
            key: 0,
            class: $(s(u).e("header")),
            onClick: Ze(() => {
            }, ["stop"])
          }, [
            ee(Se.$slots, "header")
          ], 10, ["onClick"])) : oe("v-if", !0),
          it(q(s(AS), {
            ref_key: "cascaderPanelRef",
            ref: y,
            modelValue: s(ne),
            "onUpdate:modelValue": (lt) => Kt(ne) ? ne.value = lt : null,
            options: Se.options,
            props: o.props,
            border: !1,
            "render-label": Se.$slots.default,
            onExpandChange: Le,
            onClose: (lt) => Se.$nextTick(() => ge(!1))
          }, {
            empty: Q(() => [
              ee(Se.$slots, "empty")
            ]),
            _: 3
          }, 8, ["modelValue", "onUpdate:modelValue", "options", "props", "render-label", "onClose"]), [
            [Mt, !x.value]
          ]),
          Se.filterable ? it((_(), ae(s(Go), {
            key: 1,
            ref_key: "suggestionPanel",
            ref: E,
            tag: "ul",
            class: $(s(u).e("suggestion-panel")),
            "view-class": s(u).e("suggestion-list"),
            onKeydown: tt
          }, {
            default: Q(() => [
              N.value.length ? (_(!0), B(We, { key: 0 }, bt(N.value, (lt) => (_(), B("li", {
                key: lt.uid,
                class: $([
                  s(u).e("suggestion-item"),
                  s(u).is("checked", lt.checked)
                ]),
                tabindex: -1,
                onClick: (Yt) => Ye(lt)
              }, [
                ee(Se.$slots, "suggestion-item", { item: lt }, () => [
                  W("span", null, ke(lt.text), 1),
                  lt.checked ? (_(), ae(s(ze), { key: 0 }, {
                    default: Q(() => [
                      q(s(ou))
                    ]),
                    _: 1
                  })) : oe("v-if", !0)
                ])
              ], 10, ["onClick"]))), 128)) : ee(Se.$slots, "empty", { key: 1 }, () => [
                W("li", {
                  class: $(s(u).e("empty-text"))
                }, ke(s(d)("el.cascader.noMatch")), 3)
              ])
            ]),
            _: 3
          }, 8, ["class", "view-class"])), [
            [Mt, x.value]
          ]) : oe("v-if", !0),
          Se.$slots.footer ? (_(), B("div", {
            key: 2,
            class: $(s(u).e("footer")),
            onClick: Ze(() => {
            }, ["stop"])
          }, [
            ee(Se.$slots, "footer")
          ], 10, ["onClick"])) : oe("v-if", !0)
        ]),
        _: 3
      }, 8, ["visible", "teleported", "popper-class", "popper-style", "fallback-placements", "placement", "transition", "effect", "persistent"]));
    }
  });
  var v8 = /* @__PURE__ */ Ne(p8, [["__file", "cascader.vue"]]);
  const h8 = rt(v8), m8 = Te({
    checked: Boolean,
    disabled: Boolean,
    type: {
      type: String,
      values: ["primary", "success", "info", "warning", "danger"],
      default: "primary"
    }
  }), g8 = {
    "update:checked": (e) => Vt(e),
    [gt]: (e) => Vt(e)
  }, b8 = /* @__PURE__ */ U({
    name: "ElCheckTag"
  }), y8 = /* @__PURE__ */ U({
    ...b8,
    props: m8,
    emits: g8,
    setup(e, { emit: t }) {
      const n = e, o = he("check-tag"), l = S(() => [
        o.b(),
        o.is("checked", n.checked),
        o.is("disabled", n.disabled),
        o.m(n.type || "primary")
      ]), a = () => {
        if (n.disabled)
          return;
        const r = !n.checked;
        t(gt, r), t("update:checked", r);
      };
      return (r, i) => (_(), B("span", {
        class: $(s(l)),
        onClick: a
      }, [
        ee(r.$slots, "default")
      ], 2));
    }
  });
  var w8 = /* @__PURE__ */ Ne(y8, [["__file", "check-tag.vue"]]);
  const C8 = rt(w8), S8 = Te({
    tag: {
      type: String,
      default: "div"
    },
    span: {
      type: Number,
      default: 24
    },
    offset: {
      type: Number,
      default: 0
    },
    pull: {
      type: Number,
      default: 0
    },
    push: {
      type: Number,
      default: 0
    },
    xs: {
      type: X([Number, Object]),
      default: () => en({})
    },
    sm: {
      type: X([Number, Object]),
      default: () => en({})
    },
    md: {
      type: X([Number, Object]),
      default: () => en({})
    },
    lg: {
      type: X([Number, Object]),
      default: () => en({})
    },
    xl: {
      type: X([Number, Object]),
      default: () => en({})
    }
  }), VS = Symbol("rowContextKey"), E8 = /* @__PURE__ */ U({
    name: "ElCol"
  }), k8 = /* @__PURE__ */ U({
    ...E8,
    props: S8,
    setup(e) {
      const t = e, { gutter: n } = Ve(VS, { gutter: S(() => 0) }), o = he("col"), l = S(() => {
        const r = {};
        return n.value && (r.paddingLeft = r.paddingRight = `${n.value / 2}px`), r;
      }), a = S(() => {
        const r = [];
        return ["span", "offset", "pull", "push"].forEach((c) => {
          const d = t[c];
          je(d) && (c === "span" ? r.push(o.b(`${t[c]}`)) : d > 0 && r.push(o.b(`${c}-${t[c]}`)));
        }), ["xs", "sm", "md", "lg", "xl"].forEach((c) => {
          je(t[c]) ? r.push(o.b(`${c}-${t[c]}`)) : ot(t[c]) && Object.entries(t[c]).forEach(([d, f]) => {
            r.push(d !== "span" ? o.b(`${c}-${d}-${f}`) : o.b(`${c}-${f}`));
          });
        }), n.value && r.push(o.is("guttered")), [o.b(), r];
      });
      return (r, i) => (_(), ae(ct(r.tag), {
        class: $(s(a)),
        style: Ue(s(l))
      }, {
        default: Q(() => [
          ee(r.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style"]));
    }
  });
  var _8 = /* @__PURE__ */ Ne(k8, [["__file", "col.vue"]]);
  const T8 = rt(_8), iy = (e) => je(e) || Ae(e) || ye(e), N8 = Te({
    accordion: Boolean,
    modelValue: {
      type: X([Array, String, Number]),
      default: () => en([])
    },
    expandIconPosition: {
      type: X([String]),
      default: "right"
    },
    beforeCollapse: {
      type: X(Function)
    }
  }), $8 = {
    [et]: iy,
    [gt]: iy
  }, LS = Symbol("collapseContextKey"), uy = "ElCollapse", O8 = (e, t) => {
    const n = A(En(e.modelValue)), o = (r) => {
      n.value = r;
      const i = e.accordion ? n.value[0] : n.value;
      t(et, i), t(gt, i);
    }, l = (r) => {
      if (e.accordion)
        o([n.value[0] === r ? "" : r]);
      else {
        const i = [...n.value], u = i.indexOf(r);
        u > -1 ? i.splice(u, 1) : i.push(r), o(i);
      }
    }, a = async (r) => {
      const { beforeCollapse: i } = e;
      if (!i) {
        l(r);
        return;
      }
      const u = i(r);
      [
        _a(u),
        Vt(u)
      ].includes(!0) || Zt(uy, "beforeCollapse must return type `Promise<boolean>` or `boolean`"), _a(u) ? u.then((d) => {
        d !== !1 && l(r);
      }).catch((d) => {
        vt(uy, `some error occurred: ${d}`);
      }) : u && l(r);
    };
    return de(() => e.modelValue, () => n.value = En(e.modelValue), { deep: !0 }), yt(LS, {
      activeNames: n,
      handleItemClick: a
    }), {
      activeNames: n,
      setActiveNames: o
    };
  }, I8 = (e) => {
    const t = he("collapse");
    return {
      rootKls: S(() => [
        t.b(),
        t.b(`icon-position-${e.expandIconPosition}`)
      ])
    };
  }, M8 = /* @__PURE__ */ U({
    name: "ElCollapse"
  }), x8 = /* @__PURE__ */ U({
    ...M8,
    props: N8,
    emits: $8,
    setup(e, { expose: t, emit: n }) {
      const o = e, { activeNames: l, setActiveNames: a } = O8(o, n), { rootKls: r } = I8(o);
      return t({
        activeNames: l,
        setActiveNames: a
      }), (i, u) => (_(), B("div", {
        class: $(s(r))
      }, [
        ee(i.$slots, "default")
      ], 2));
    }
  });
  var P8 = /* @__PURE__ */ Ne(x8, [["__file", "collapse.vue"]]);
  const R8 = /* @__PURE__ */ U({
    name: "ElCollapseTransition"
  }), D8 = /* @__PURE__ */ U({
    ...R8,
    setup(e) {
      const t = he("collapse-transition"), n = (l) => {
        l.style.maxHeight = "", l.style.overflow = l.dataset.oldOverflow, l.style.paddingTop = l.dataset.oldPaddingTop, l.style.paddingBottom = l.dataset.oldPaddingBottom;
      }, o = {
        beforeEnter(l) {
          l.dataset || (l.dataset = {}), l.dataset.oldPaddingTop = l.style.paddingTop, l.dataset.oldPaddingBottom = l.style.paddingBottom, l.style.height && (l.dataset.elExistsHeight = l.style.height), l.style.maxHeight = 0, l.style.paddingTop = 0, l.style.paddingBottom = 0;
        },
        enter(l) {
          requestAnimationFrame(() => {
            l.dataset.oldOverflow = l.style.overflow, l.dataset.elExistsHeight ? l.style.maxHeight = l.dataset.elExistsHeight : l.scrollHeight !== 0 ? l.style.maxHeight = `${l.scrollHeight}px` : l.style.maxHeight = 0, l.style.paddingTop = l.dataset.oldPaddingTop, l.style.paddingBottom = l.dataset.oldPaddingBottom, l.style.overflow = "hidden";
          });
        },
        afterEnter(l) {
          l.style.maxHeight = "", l.style.overflow = l.dataset.oldOverflow;
        },
        enterCancelled(l) {
          n(l);
        },
        beforeLeave(l) {
          l.dataset || (l.dataset = {}), l.dataset.oldPaddingTop = l.style.paddingTop, l.dataset.oldPaddingBottom = l.style.paddingBottom, l.dataset.oldOverflow = l.style.overflow, l.style.maxHeight = `${l.scrollHeight}px`, l.style.overflow = "hidden";
        },
        leave(l) {
          l.scrollHeight !== 0 && (l.style.maxHeight = 0, l.style.paddingTop = 0, l.style.paddingBottom = 0);
        },
        afterLeave(l) {
          n(l);
        },
        leaveCancelled(l) {
          n(l);
        }
      };
      return (l, a) => (_(), ae(Mn, pt({
        name: s(t).b()
      }, cT(o)), {
        default: Q(() => [
          ee(l.$slots, "default")
        ]),
        _: 3
      }, 16, ["name"]));
    }
  });
  var A8 = /* @__PURE__ */ Ne(D8, [["__file", "collapse-transition.vue"]]);
  const Hd = rt(A8), V8 = Te({
    title: {
      type: String,
      default: ""
    },
    name: {
      type: X([String, Number]),
      default: void 0
    },
    icon: {
      type: Lt,
      default: Un
    },
    disabled: Boolean
  }), L8 = (e) => {
    const t = Ve(LS), { namespace: n } = he("collapse"), o = A(!1), l = A(!1), a = hh(), r = S(() => a.current++), i = S(() => {
      var v;
      return (v = e.name) != null ? v : `${n.value}-id-${a.prefix}-${s(r)}`;
    }), u = S(() => t == null ? void 0 : t.activeNames.value.includes(s(i)));
    return {
      focusing: o,
      id: r,
      isActive: u,
      handleFocus: () => {
        setTimeout(() => {
          l.value ? l.value = !1 : o.value = !0;
        }, 50);
      },
      handleHeaderClick: (v) => {
        if (e.disabled)
          return;
        const p = v.target;
        p != null && p.closest("input, textarea, select") || (t == null || t.handleItemClick(s(i)), o.value = !1, l.value = !0);
      },
      handleEnterClick: (v) => {
        const p = v.target;
        p != null && p.closest("input, textarea, select") || (v.preventDefault(), t == null || t.handleItemClick(s(i)));
      }
    };
  }, B8 = (e, { focusing: t, isActive: n, id: o }) => {
    const l = he("collapse"), a = S(() => [
      l.b("item"),
      l.is("active", s(n)),
      l.is("disabled", e.disabled)
    ]), r = S(() => [
      l.be("item", "header"),
      l.is("active", s(n)),
      { focusing: s(t) && !e.disabled }
    ]), i = S(() => [
      l.be("item", "arrow"),
      l.is("active", s(n))
    ]), u = S(() => [l.be("item", "title")]), c = S(() => l.be("item", "wrap")), d = S(() => l.be("item", "content")), f = S(() => l.b(`content-${s(o)}`)), v = S(() => l.b(`head-${s(o)}`));
    return {
      itemTitleKls: u,
      arrowKls: i,
      headKls: r,
      rootKls: a,
      itemWrapperKls: c,
      itemContentKls: d,
      scopedContentId: f,
      scopedHeadId: v
    };
  }, F8 = /* @__PURE__ */ U({
    name: "ElCollapseItem"
  }), z8 = /* @__PURE__ */ U({
    ...F8,
    props: V8,
    setup(e, { expose: t }) {
      const n = e, {
        focusing: o,
        id: l,
        isActive: a,
        handleFocus: r,
        handleHeaderClick: i,
        handleEnterClick: u
      } = L8(n), {
        arrowKls: c,
        headKls: d,
        rootKls: f,
        itemTitleKls: v,
        itemWrapperKls: p,
        itemContentKls: m,
        scopedContentId: h,
        scopedHeadId: g
      } = B8(n, { focusing: o, isActive: a, id: l });
      return t({
        isActive: a
      }), (b, C) => (_(), B("div", {
        class: $(s(f))
      }, [
        W("div", {
          id: s(g),
          class: $(s(d)),
          "aria-expanded": s(a),
          "aria-controls": s(h),
          "aria-describedby": s(h),
          tabindex: b.disabled ? void 0 : 0,
          "aria-disabled": b.disabled,
          role: "button",
          onClick: s(i),
          onKeydown: on(Ze(s(u), ["stop"]), ["space", "enter"]),
          onFocus: s(r),
          onBlur: (w) => o.value = !1
        }, [
          W("span", {
            class: $(s(v))
          }, [
            ee(b.$slots, "title", { isActive: s(a) }, () => [
              Ct(ke(b.title), 1)
            ])
          ], 2),
          ee(b.$slots, "icon", { isActive: s(a) }, () => [
            q(s(ze), {
              class: $(s(c))
            }, {
              default: Q(() => [
                (_(), ae(ct(b.icon)))
              ]),
              _: 1
            }, 8, ["class"])
          ])
        ], 42, ["id", "aria-expanded", "aria-controls", "aria-describedby", "tabindex", "aria-disabled", "onClick", "onKeydown", "onFocus", "onBlur"]),
        q(s(Hd), null, {
          default: Q(() => [
            it(W("div", {
              id: s(h),
              role: "region",
              class: $(s(p)),
              "aria-hidden": !s(a),
              "aria-labelledby": s(g)
            }, [
              W("div", {
                class: $(s(m))
              }, [
                ee(b.$slots, "default")
              ], 2)
            ], 10, ["id", "aria-hidden", "aria-labelledby"]), [
              [Mt, s(a)]
            ])
          ]),
          _: 3
        })
      ], 2));
    }
  });
  var BS = /* @__PURE__ */ Ne(z8, [["__file", "collapse-item.vue"]]);
  const H8 = rt(P8, {
    CollapseItem: BS
  }), K8 = nn(BS), FS = Te({
    color: {
      type: X(Object),
      required: !0
    },
    vertical: Boolean,
    disabled: Boolean
  }), W8 = FS;
  let Pf = !1;
  function Ip(e, t) {
    if (!xt)
      return;
    const n = function(a) {
      var r;
      (r = t.drag) == null || r.call(t, a);
    }, o = function(a) {
      var r;
      document.removeEventListener("mousemove", n), document.removeEventListener("mouseup", o), document.removeEventListener("touchmove", n), document.removeEventListener("touchend", o), document.onselectstart = null, document.ondragstart = null, Pf = !1, (r = t.end) == null || r.call(t, a);
    }, l = function(a) {
      var r;
      Pf || (document.onselectstart = () => !1, document.ondragstart = () => !1, document.addEventListener("mousemove", n), document.addEventListener("mouseup", o), document.addEventListener("touchmove", n), document.addEventListener("touchend", o), Pf = !0, (r = t.start) == null || r.call(t, a));
    };
    e.addEventListener("mousedown", l), e.addEventListener("touchstart", l, { passive: !1 });
  }
  const cy = (e) => {
    let t = 0, n = e;
    for (; n; )
      t += n.offsetTop, n = n.offsetParent;
    return t;
  }, Mp = (e, t) => Math.abs(cy(e) - cy(t)), zS = (e) => {
    let t, n;
    return e.type === "touchend" ? (n = e.changedTouches[0].clientY, t = e.changedTouches[0].clientX) : e.type.startsWith("touch") ? (n = e.touches[0].clientY, t = e.touches[0].clientX) : (n = e.clientY, t = e.clientX), {
      clientX: t,
      clientY: n
    };
  }, HS = (e, { key: t, minValue: n, maxValue: o }) => {
    const l = dt(), a = Ut(), r = Ut(), i = S(() => e.color.get(t));
    function u(v) {
      var p;
      if (e.disabled)
        return;
      v.target !== a.value && c(v), (p = a.value) == null || p.focus();
    }
    function c(v) {
      if (!r.value || !a.value || e.disabled)
        return;
      const m = l.vnode.el.getBoundingClientRect(), { clientX: h, clientY: g } = zS(v);
      let b;
      if (e.vertical) {
        let C = g - m.top;
        C = Math.max(a.value.offsetHeight / 2, C), C = Math.min(C, m.height - a.value.offsetHeight / 2), b = Math.round((C - a.value.offsetHeight / 2) / (m.height - a.value.offsetHeight) * o);
      } else {
        let C = h - m.left;
        C = Math.max(a.value.offsetWidth / 2, C), C = Math.min(C, m.width - a.value.offsetWidth / 2), b = Math.round((C - a.value.offsetWidth / 2) / (m.width - a.value.offsetWidth) * o);
      }
      e.color.set(t, b);
    }
    function d(v) {
      if (e.disabled)
        return;
      const { shiftKey: p } = v, m = Ht(v), h = p ? 10 : 1, g = t === "hue" ? -1 : 1;
      let b = !0;
      switch (m) {
        case _e.left:
        case _e.down:
          f(-h * g);
          break;
        case _e.right:
        case _e.up:
          f(h * g);
          break;
        case _e.home:
          e.color.set(t, t === "hue" ? o : n);
          break;
        case _e.end:
          e.color.set(t, t === "hue" ? n : o);
          break;
        case _e.pageDown:
          f(-4 * g);
          break;
        case _e.pageUp:
          f(4 * g);
          break;
        default:
          b = !1;
          break;
      }
      b && v.preventDefault();
    }
    function f(v) {
      let p = i.value + v;
      p = p < n ? n : p > o ? o : p, e.color.set(t, p);
    }
    return {
      thumb: a,
      bar: r,
      currentValue: i,
      handleDrag: c,
      handleClick: u,
      handleKeydown: d
    };
  }, KS = (e, {
    namespace: t,
    maxValue: n,
    bar: o,
    thumb: l,
    currentValue: a,
    handleDrag: r,
    getBackground: i
  }) => {
    const u = dt(), c = he(t), d = A(0), f = A(0), v = A();
    function p() {
      if (!l.value || e.vertical)
        return 0;
      const E = u.vnode.el, k = a.value;
      return E ? Math.round(k * (E.offsetWidth - l.value.offsetWidth / 2) / n) : 0;
    }
    function m() {
      if (!l.value)
        return 0;
      const E = u.vnode.el;
      if (!e.vertical)
        return 0;
      const k = a.value;
      return E ? Math.round(k * (E.offsetHeight - l.value.offsetHeight / 2) / n) : 0;
    }
    function h() {
      d.value = p(), f.value = m(), v.value = i == null ? void 0 : i();
    }
    ft(() => {
      if (!o.value || !l.value)
        return;
      const E = {
        drag: (k) => {
          r(k);
        },
        end: (k) => {
          r(k);
        }
      };
      Ip(o.value, E), Ip(l.value, E), h();
    }), de(a, () => h()), de(() => e.color.value, () => h());
    const g = S(() => [
      c.b(),
      c.is("vertical", e.vertical),
      c.is("disabled", e.disabled)
    ]), b = S(() => c.e("bar")), C = S(() => c.e("thumb")), w = S(() => ({ background: v.value })), y = S(() => ({
      left: tn(d.value),
      top: tn(f.value)
    }));
    return {
      rootKls: g,
      barKls: b,
      barStyle: w,
      thumbKls: C,
      thumbStyle: y,
      thumbLeft: d,
      thumbTop: f,
      update: h
    };
  }, dy = 0, Rf = 100, j8 = /* @__PURE__ */ U({
    name: "ElColorAlphaSlider"
  }), U8 = /* @__PURE__ */ U({
    ...j8,
    props: FS,
    setup(e, { expose: t }) {
      const n = e, { currentValue: o, bar: l, thumb: a, handleDrag: r, handleClick: i, handleKeydown: u } = HS(n, { key: "alpha", minValue: dy, maxValue: Rf }), { rootKls: c, barKls: d, barStyle: f, thumbKls: v, thumbStyle: p, update: m } = KS(n, {
        namespace: "color-alpha-slider",
        maxValue: Rf,
        currentValue: o,
        bar: l,
        thumb: a,
        handleDrag: r,
        getBackground: C
      }), { t: h } = _t(), g = S(() => h("el.colorpicker.alphaLabel")), b = S(() => h("el.colorpicker.alphaDescription", {
        alpha: o.value,
        color: n.color.value
      }));
      function C() {
        if (n.color && n.color.value) {
          const { r: w, g: y, b: E } = n.color.toRgb();
          return `linear-gradient(to right, rgba(${w}, ${y}, ${E}, 0) 0%, rgba(${w}, ${y}, ${E}, 1) 100%)`;
        }
        return "";
      }
      return t({
        update: m,
        bar: l,
        thumb: a
      }), (w, y) => (_(), B("div", {
        class: $(s(c))
      }, [
        W("div", {
          ref_key: "bar",
          ref: l,
          class: $(s(d)),
          style: Ue(s(f)),
          onClick: s(i)
        }, null, 14, ["onClick"]),
        W("div", {
          ref_key: "thumb",
          ref: a,
          class: $(s(v)),
          style: Ue(s(p)),
          "aria-label": s(g),
          "aria-valuenow": s(o),
          "aria-valuetext": s(b),
          "aria-orientation": w.vertical ? "vertical" : "horizontal",
          "aria-valuemin": dy,
          "aria-valuemax": Rf,
          role: "slider",
          tabindex: "0",
          onKeydown: s(u)
        }, null, 46, ["aria-label", "aria-valuenow", "aria-valuetext", "aria-orientation", "onKeydown"])
      ], 2));
    }
  });
  var Y8 = /* @__PURE__ */ Ne(U8, [["__file", "alpha-slider.vue"]]);
  const fy = 0, Df = 360, q8 = /* @__PURE__ */ U({
    name: "ElColorHueSlider"
  }), G8 = /* @__PURE__ */ U({
    ...q8,
    props: W8,
    setup(e, { expose: t }) {
      const n = e, { currentValue: o, bar: l, thumb: a, handleDrag: r, handleClick: i, handleKeydown: u } = HS(n, { key: "hue", minValue: fy, maxValue: Df }), { rootKls: c, barKls: d, thumbKls: f, thumbStyle: v, thumbTop: p, update: m } = KS(n, {
        namespace: "color-hue-slider",
        maxValue: Df,
        currentValue: o,
        bar: l,
        thumb: a,
        handleDrag: r
      }), { t: h } = _t(), g = S(() => h("el.colorpicker.hueLabel")), b = S(() => h("el.colorpicker.hueDescription", {
        hue: o.value,
        color: n.color.value
      }));
      return t({
        bar: l,
        thumb: a,
        thumbTop: p,
        update: m
      }), (C, w) => (_(), B("div", {
        class: $(s(c))
      }, [
        W("div", {
          ref_key: "bar",
          ref: l,
          class: $(s(d)),
          onClick: s(i)
        }, null, 10, ["onClick"]),
        W("div", {
          ref_key: "thumb",
          ref: a,
          class: $(s(f)),
          style: Ue(s(v)),
          "aria-label": s(g),
          "aria-valuenow": s(o),
          "aria-valuetext": s(b),
          "aria-orientation": C.vertical ? "vertical" : "horizontal",
          "aria-valuemin": fy,
          "aria-valuemax": Df,
          role: "slider",
          tabindex: "0",
          onKeydown: s(u)
        }, null, 46, ["aria-label", "aria-valuenow", "aria-valuetext", "aria-orientation", "onKeydown"])
      ], 2));
    }
  });
  var X8 = /* @__PURE__ */ Ne(G8, [["__file", "hue-slider.vue"]]);
  const J8 = Te({
    colors: {
      type: X(Array),
      required: !0
    },
    color: {
      type: X(Object),
      required: !0
    },
    enableAlpha: {
      type: Boolean,
      required: !0
    },
    disabled: Boolean
  }), WS = Te({
    modelValue: {
      type: X(String),
      default: void 0
    },
    border: {
      type: Boolean,
      default: !0
    },
    showAlpha: Boolean,
    colorFormat: String,
    disabled: Boolean,
    predefine: {
      type: X(Array)
    },
    validateEvent: {
      type: Boolean,
      default: !0
    }
  }), Z8 = {
    [et]: (e) => Ae(e) || cn(e)
  }, jS = Symbol("colorCommonPickerKey"), US = Symbol("colorPickerPanelContextKey");
  class zc {
    constructor(t = {}) {
      this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100, this._tiny = new Lr(), this._isValid = !1, this.enableAlpha = !1, this.format = "", this.value = "";
      for (const n in t)
        Ot(t, n) && (this[n] = t[n]);
      t.value ? this.fromString(t.value) : this.doOnChange();
    }
    set(t, n) {
      if (arguments.length === 1 && typeof t == "object") {
        for (const o in t)
          Ot(t, o) && this.set(o, t[o]);
        return;
      }
      this[`_${t}`] = n, this._isValid = !0, this.doOnChange();
    }
    get(t) {
      return ["hue", "saturation", "value", "alpha"].includes(t) ? Math.round(this[`_${t}`]) : this[`_${t}`];
    }
    toRgb() {
      return this._isValid ? this._tiny.toRgb() : { r: 255, g: 255, b: 255, a: 0 };
    }
    fromString(t) {
      const n = new Lr(t);
      if (this._isValid = n.isValid, n.isValid) {
        const { h: o, s: l, v: a, a: r } = n.toHsv();
        this._hue = o, this._saturation = l * 100, this._value = a * 100, this._alpha = r * 100;
      } else
        this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100;
      this.doOnChange();
    }
    clear() {
      this._isValid = !1, this.value = "", this._hue = 0, this._saturation = 100, this._value = 100, this._alpha = 100;
    }
    compare(t) {
      const n = new Lr({
        h: t._hue,
        s: t._saturation / 100,
        v: t._value / 100,
        a: t._alpha / 100
      });
      return this._tiny.equals(n);
    }
    doOnChange() {
      const { _hue: t, _saturation: n, _value: o, _alpha: l, format: a, enableAlpha: r } = this;
      let i = a || (r ? "rgb" : "hex");
      a === "hex" && r && (i = "hex8"), this._tiny = new Lr({
        h: t,
        s: n / 100,
        v: o / 100,
        a: l / 100
      }), this.value = this._isValid ? this._tiny.toString(i) : "";
    }
  }
  const Q8 = (e) => {
    const { currentColor: t } = Ve(US), n = A(l(e.colors, e.color));
    de(() => t.value, (a) => {
      const r = new zc({
        value: a,
        enableAlpha: e.enableAlpha
      });
      n.value.forEach((i) => {
        i.selected = r.compare(i);
      });
    }), to(() => {
      n.value = l(e.colors, e.color);
    });
    function o(a) {
      e.color.fromString(e.colors[a]);
    }
    function l(a, r) {
      return a.map((i) => {
        const u = new zc({
          value: i,
          enableAlpha: e.enableAlpha
        });
        return u.selected = u.compare(r), u;
      });
    }
    return {
      rgbaColors: n,
      handleSelect: o
    };
  }, eB = (e) => {
    const t = he("color-predefine"), n = S(() => [t.b(), t.is("disabled", e.disabled)]), o = S(() => t.e("colors"));
    function l(a) {
      return [
        t.e("color-selector"),
        t.is("alpha", a.get("alpha") < 100),
        { selected: a.selected }
      ];
    }
    return {
      rootKls: n,
      colorsKls: o,
      colorSelectorKls: l
    };
  }, tB = /* @__PURE__ */ U({
    name: "ElColorPredefine"
  }), nB = /* @__PURE__ */ U({
    ...tB,
    props: J8,
    setup(e) {
      const t = e, { rgbaColors: n, handleSelect: o } = Q8(t), { rootKls: l, colorsKls: a, colorSelectorKls: r } = eB(t), { t: i } = _t(), u = (c) => i("el.colorpicker.predefineDescription", { value: c });
      return (c, d) => (_(), B("div", {
        class: $(s(l))
      }, [
        W("div", {
          class: $(s(a))
        }, [
          (_(!0), B(We, null, bt(s(n), (f, v) => (_(), B("button", {
            key: c.colors[v],
            type: "button",
            disabled: c.disabled,
            "aria-label": u(f.value),
            class: $(s(r)(f)),
            onClick: (p) => s(o)(v)
          }, [
            W("div", {
              style: Ue({ backgroundColor: f.value })
            }, null, 4)
          ], 10, ["disabled", "aria-label", "onClick"]))), 128))
        ], 2)
      ], 2));
    }
  });
  var oB = /* @__PURE__ */ Ne(nB, [["__file", "predefine.vue"]]);
  const lB = Te({
    color: {
      type: X(Object),
      required: !0
    },
    disabled: Boolean
  }), aB = (e) => {
    const t = dt(), n = A(), o = A(0), l = A(0), a = A("hsl(0, 100%, 50%)"), r = S(() => e.color.get("saturation")), i = S(() => e.color.get("value")), u = S(() => e.color.get("hue"));
    function c(m) {
      var h;
      if (e.disabled)
        return;
      m.target !== n.value && d(m), (h = n.value) == null || h.focus({ preventScroll: !0 });
    }
    function d(m) {
      if (e.disabled)
        return;
      const g = t.vnode.el.getBoundingClientRect(), { clientX: b, clientY: C } = zS(m);
      let w = b - g.left, y = C - g.top;
      w = Math.max(0, w), w = Math.min(w, g.width), y = Math.max(0, y), y = Math.min(y, g.height), l.value = w, o.value = y, e.color.set({
        saturation: w / g.width * 100,
        value: 100 - y / g.height * 100
      });
    }
    function f(m) {
      if (e.disabled)
        return;
      const { shiftKey: h } = m, g = Ht(m), b = h ? 10 : 1;
      let C = !0;
      switch (g) {
        case _e.left:
          v(-b);
          break;
        case _e.right:
          v(b);
          break;
        case _e.up:
          p(b);
          break;
        case _e.down:
          p(-b);
          break;
        default:
          C = !1;
          break;
      }
      C && m.preventDefault();
    }
    function v(m) {
      let h = r.value + m;
      h = h < 0 ? 0 : h > 100 ? 100 : h, e.color.set("saturation", h);
    }
    function p(m) {
      let h = i.value + m;
      h = h < 0 ? 0 : h > 100 ? 100 : h, e.color.set("value", h);
    }
    return {
      cursorRef: n,
      cursorTop: o,
      cursorLeft: l,
      background: a,
      saturation: r,
      brightness: i,
      hue: u,
      handleClick: c,
      handleDrag: d,
      handleKeydown: f
    };
  }, rB = (e, {
    cursorTop: t,
    cursorLeft: n,
    background: o,
    handleDrag: l
  }) => {
    const a = dt(), r = he("color-svpanel");
    function i() {
      const v = e.color.get("saturation"), p = e.color.get("value"), m = a.vnode.el, { clientWidth: h, clientHeight: g } = m;
      n.value = v * h / 100, t.value = (100 - p) * g / 100, o.value = `hsl(${e.color.get("hue")}, 100%, 50%)`;
    }
    ft(() => {
      Ip(a.vnode.el, {
        drag: (v) => {
          l(v);
        },
        end: (v) => {
          l(v);
        }
      }), i();
    }), de([
      () => e.color.get("hue"),
      () => e.color.get("value"),
      () => e.color.value
    ], () => i());
    const u = S(() => r.b()), c = S(() => r.e("cursor")), d = S(() => ({
      backgroundColor: o.value
    })), f = S(() => ({
      top: tn(t.value),
      left: tn(n.value)
    }));
    return {
      rootKls: u,
      cursorKls: c,
      rootStyle: d,
      cursorStyle: f,
      update: i
    };
  }, sB = /* @__PURE__ */ U({
    name: "ElSvPanel"
  }), iB = /* @__PURE__ */ U({
    ...sB,
    props: lB,
    setup(e, { expose: t }) {
      const n = e, {
        cursorRef: o,
        cursorTop: l,
        cursorLeft: a,
        background: r,
        saturation: i,
        brightness: u,
        handleClick: c,
        handleDrag: d,
        handleKeydown: f
      } = aB(n), { rootKls: v, cursorKls: p, rootStyle: m, cursorStyle: h, update: g } = rB(n, {
        cursorTop: l,
        cursorLeft: a,
        background: r,
        handleDrag: d
      }), { t: b } = _t(), C = S(() => b("el.colorpicker.svLabel")), w = S(() => b("el.colorpicker.svDescription", {
        saturation: i.value,
        brightness: u.value,
        color: n.color.value
      }));
      return t({
        update: g
      }), (y, E) => (_(), B("div", {
        class: $(s(v)),
        style: Ue(s(m)),
        onClick: s(c)
      }, [
        W("div", {
          ref_key: "cursorRef",
          ref: o,
          class: $(s(p)),
          style: Ue(s(h)),
          tabindex: "0",
          role: "slider",
          "aria-valuemin": "0,0",
          "aria-valuemax": "100,100",
          "aria-label": s(C),
          "aria-valuenow": `${s(i)},${s(u)}`,
          "aria-valuetext": s(w),
          onKeydown: s(f)
        }, null, 46, ["aria-label", "aria-valuenow", "aria-valuetext", "onKeydown"])
      ], 14, ["onClick"]));
    }
  });
  var uB = /* @__PURE__ */ Ne(iB, [["__file", "sv-panel.vue"]]);
  const YS = (e, t) => {
    const n = Rt(new zc({
      enableAlpha: e.showAlpha,
      format: e.colorFormat || "",
      value: e.modelValue
    }));
    return de(() => [e.colorFormat, e.showAlpha], () => {
      n.enableAlpha = e.showAlpha, n.format = e.colorFormat || n.format, n.doOnChange(), t(et, n.value);
    }), {
      color: n
    };
  }, cB = /* @__PURE__ */ U({
    name: "ElColorPickerPanel"
  }), dB = /* @__PURE__ */ U({
    ...cB,
    props: WS,
    emits: Z8,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = he("color-picker-panel"), { formItem: a } = Nn(), r = Cn(), i = A(), u = A(), c = A(), d = A(), f = A(""), { color: v } = Ve(jS, () => YS(o, n), !0);
      function p() {
        v.fromString(f.value), v.value !== f.value && (f.value = v.value);
      }
      function m() {
        var g;
        o.validateEvent && ((g = a == null ? void 0 : a.validate) == null || g.call(a, "blur").catch((b) => vt(b)));
      }
      function h() {
        var g, b, C;
        (g = i.value) == null || g.update(), (b = u.value) == null || b.update(), (C = c.value) == null || C.update();
      }
      return ft(() => {
        o.modelValue && (f.value = v.value), Re(h);
      }), de(() => o.modelValue, (g) => {
        g !== v.value && (g ? v.fromString(g) : v.clear());
      }), de(() => v.value, (g) => {
        n(et, g), f.value = g, o.validateEvent && (a == null || a.validate("change").catch((b) => vt(b)));
      }), yt(US, {
        currentColor: S(() => v.value)
      }), t({
        color: v,
        inputRef: d,
        update: h
      }), (g, b) => (_(), B("div", {
        class: $([s(l).b(), s(l).is("disabled", s(r)), s(l).is("border", g.border)]),
        onFocusout: m
      }, [
        W("div", {
          class: $(s(l).e("wrapper"))
        }, [
          q(X8, {
            ref_key: "hueRef",
            ref: i,
            class: "hue-slider",
            color: s(v),
            vertical: "",
            disabled: s(r)
          }, null, 8, ["color", "disabled"]),
          q(uB, {
            ref_key: "svRef",
            ref: u,
            color: s(v),
            disabled: s(r)
          }, null, 8, ["color", "disabled"])
        ], 2),
        g.showAlpha ? (_(), ae(Y8, {
          key: 0,
          ref_key: "alphaRef",
          ref: c,
          color: s(v),
          disabled: s(r)
        }, null, 8, ["color", "disabled"])) : oe("v-if", !0),
        g.predefine ? (_(), ae(oB, {
          key: 1,
          ref: "predefine",
          "enable-alpha": g.showAlpha,
          color: s(v),
          colors: g.predefine,
          disabled: s(r)
        }, null, 8, ["enable-alpha", "color", "colors", "disabled"])) : oe("v-if", !0),
        W("div", {
          class: $(s(l).e("footer"))
        }, [
          q(s(Wn), {
            ref_key: "inputRef",
            ref: d,
            modelValue: f.value,
            "onUpdate:modelValue": (C) => f.value = C,
            "validate-event": !1,
            size: "small",
            disabled: s(r),
            onChange: p
          }, null, 8, ["modelValue", "onUpdate:modelValue", "disabled"]),
          ee(g.$slots, "footer")
        ], 2)
      ], 34));
    }
  });
  var fB = /* @__PURE__ */ Ne(dB, [["__file", "color-picker-panel.vue"]]);
  const qS = rt(fB), pB = Te({
    persistent: {
      type: Boolean,
      default: !0
    },
    modelValue: {
      type: X(String),
      default: void 0
    },
    id: String,
    showAlpha: Boolean,
    colorFormat: String,
    disabled: Boolean,
    size: mn,
    popperClass: zt.popperClass,
    popperStyle: zt.popperStyle,
    tabindex: {
      type: [String, Number],
      default: 0
    },
    teleported: zt.teleported,
    appendTo: zt.appendTo,
    predefine: {
      type: X(Array)
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    ...Cr,
    ...Yn(["ariaLabel"])
  }), vB = {
    [et]: (e) => Ae(e) || cn(e),
    [gt]: (e) => Ae(e) || cn(e),
    activeChange: (e) => Ae(e) || cn(e),
    focus: (e) => e instanceof FocusEvent,
    blur: (e) => e instanceof FocusEvent
  }, hB = /* @__PURE__ */ U({
    name: "ElColorPicker"
  }), mB = /* @__PURE__ */ U({
    ...hB,
    props: pB,
    emits: vB,
    setup(e, { expose: t, emit: n }) {
      const o = e, { t: l } = _t(), a = he("color"), { formItem: r } = Nn(), i = vn(), u = Cn(), { valueOnClear: c, isEmptyValue: d } = nu(o, null), f = YS(o, n), { inputId: v, isLabeledByFormItem: p } = wo(o, {
        formItemContext: r
      }), m = A(), h = A(), g = A(), b = A(!1), C = A(!1);
      let w = !0;
      const { isFocused: y, handleFocus: E, handleBlur: k } = la(h, {
        disabled: u,
        beforeBlur(se) {
          var ne;
          return (ne = m.value) == null ? void 0 : ne.isFocusInsideContent(se);
        },
        afterBlur() {
          var se;
          G(!1), L(), o.validateEvent && ((se = r == null ? void 0 : r.validate) == null || se.call(r, "blur").catch((ne) => vt(ne)));
        }
      }), T = FP(() => {
        var se, ne;
        return (ne = (se = g.value) == null ? void 0 : se.color) != null ? ne : f.color;
      }), x = S(() => jl(o, Object.keys(WS))), I = S(() => !o.modelValue && !C.value ? "transparent" : Y(T, o.showAlpha)), P = S(() => !o.modelValue && !C.value ? "" : T.value), O = S(() => p.value ? void 0 : o.ariaLabel || l("el.colorpicker.defaultLabel")), N = S(() => p.value ? r == null ? void 0 : r.labelId : void 0), z = S(() => [
        a.b("picker"),
        a.is("disabled", u.value),
        a.bm("picker", i.value),
        a.is("focused", y.value)
      ]);
      function Y(se, ne) {
        const { r: le, g: Ce, b: j, a: te } = se.toRgb();
        return ne ? `rgba(${le}, ${Ce}, ${j}, ${te})` : `rgb(${le}, ${Ce}, ${j})`;
      }
      function G(se) {
        b.value = se;
      }
      const M = wl(G, 100, { leading: !0 });
      function R() {
        u.value || G(!0);
      }
      function D() {
        M(!1), L();
      }
      function L() {
        Re(() => {
          o.modelValue ? T.fromString(o.modelValue) : (T.value = "", Re(() => {
            C.value = !1;
          }));
        });
      }
      function V() {
        u.value || (b.value && L(), M(!b.value));
      }
      function F() {
        const se = d(T.value) ? c.value : T.value;
        n(et, se), n(gt, se), o.validateEvent && (r == null || r.validate("change").catch((ne) => vt(ne))), M(!1), Re(() => {
          const ne = new zc({
            enableAlpha: o.showAlpha,
            format: o.colorFormat || "",
            value: o.modelValue
          });
          T.compare(ne) || L();
        });
      }
      function H() {
        M(!1), n(et, c.value), n(gt, c.value), o.modelValue !== c.value && o.validateEvent && (r == null || r.validate("change").catch((se) => vt(se))), L();
      }
      function K() {
        var se, ne;
        (ne = (se = g == null ? void 0 : g.value) == null ? void 0 : se.inputRef) == null || ne.focus();
      }
      function Z() {
        b.value && (D(), y.value && ue());
      }
      function J(se) {
        se.preventDefault(), se.stopPropagation(), G(!1), L();
      }
      function ie(se) {
        switch (Ht(se)) {
          case _e.enter:
          case _e.numpadEnter:
          case _e.space:
            se.preventDefault(), se.stopPropagation(), R();
            break;
          case _e.esc:
            J(se);
            break;
        }
      }
      function ue() {
        h.value.focus();
      }
      function re() {
        h.value.blur();
      }
      return de(() => P.value, (se) => {
        w && n("activeChange", se), w = !0;
      }), de(() => T.value, () => {
        !o.modelValue && !C.value && (C.value = !0);
      }), de(() => o.modelValue, (se) => {
        se ? se && se !== T.value && (w = !1, T.fromString(se)) : C.value = !1;
      }), de(() => b.value, () => {
        var se;
        Re((se = g.value) == null ? void 0 : se.update);
      }), yt(jS, f), t({
        color: T,
        show: R,
        hide: D,
        focus: ue,
        blur: re
      }), (se, ne) => (_(), ae(s(Pn), {
        ref_key: "popper",
        ref: m,
        visible: b.value,
        "show-arrow": !1,
        "fallback-placements": ["bottom", "top", "right", "left"],
        offset: 0,
        "gpu-acceleration": !1,
        "popper-class": [s(a).be("picker", "panel"), se.popperClass],
        "popper-style": se.popperStyle,
        "stop-popper-mouse-event": !1,
        pure: "",
        loop: "",
        role: "dialog",
        effect: "light",
        trigger: "click",
        teleported: se.teleported,
        transition: `${s(a).namespace.value}-zoom-in-top`,
        persistent: se.persistent,
        "append-to": se.appendTo,
        onShow: K,
        onHide: (le) => G(!1)
      }, {
        content: Q(() => [
          it((_(), ae(s(qS), pt({
            ref_key: "pickerPanelRef",
            ref: g
          }, s(x), {
            border: !1,
            "validate-event": !1,
            onKeydown: on(J, ["esc"])
          }), {
            footer: Q(() => [
              W("div", null, [
                q(s(_n), {
                  class: $(s(a).be("footer", "link-btn")),
                  text: "",
                  size: "small",
                  onClick: H
                }, {
                  default: Q(() => [
                    Ct(ke(s(l)("el.colorpicker.clear")), 1)
                  ]),
                  _: 1
                }, 8, ["class"]),
                q(s(_n), {
                  plain: "",
                  size: "small",
                  class: $(s(a).be("footer", "btn")),
                  onClick: F
                }, {
                  default: Q(() => [
                    Ct(ke(s(l)("el.colorpicker.confirm")), 1)
                  ]),
                  _: 1
                }, 8, ["class"])
              ])
            ]),
            _: 1
          }, 16, ["onKeydown"])), [
            [s(Jl), Z, h.value]
          ])
        ]),
        default: Q(() => [
          W("div", pt({
            id: s(v),
            ref_key: "triggerRef",
            ref: h
          }, se.$attrs, {
            class: s(z),
            role: "button",
            "aria-label": s(O),
            "aria-labelledby": s(N),
            "aria-description": s(l)("el.colorpicker.description", { color: se.modelValue || "" }),
            "aria-disabled": s(u),
            tabindex: s(u) ? void 0 : se.tabindex,
            onKeydown: ie,
            onFocus: s(E),
            onBlur: s(k)
          }), [
            W("div", {
              class: $(s(a).be("picker", "trigger")),
              onClick: V
            }, [
              W("span", {
                class: $([s(a).be("picker", "color"), s(a).is("alpha", se.showAlpha)])
              }, [
                W("span", {
                  class: $(s(a).be("picker", "color-inner")),
                  style: Ue({
                    backgroundColor: s(I)
                  })
                }, [
                  it(q(s(ze), {
                    class: $([s(a).be("picker", "icon"), s(a).is("icon-arrow-down")])
                  }, {
                    default: Q(() => [
                      q(s(Nl))
                    ]),
                    _: 1
                  }, 8, ["class"]), [
                    [Mt, se.modelValue || C.value]
                  ]),
                  it(q(s(ze), {
                    class: $([s(a).be("picker", "empty"), s(a).is("icon-close")])
                  }, {
                    default: Q(() => [
                      q(s(Oo))
                    ]),
                    _: 1
                  }, 8, ["class"]), [
                    [Mt, !se.modelValue && !C.value]
                  ])
                ], 6)
              ], 2)
            ], 2)
          ], 16, ["id", "aria-label", "aria-labelledby", "aria-description", "aria-disabled", "tabindex", "onFocus", "onBlur"])
        ]),
        _: 1
      }, 8, ["visible", "popper-class", "popper-style", "teleported", "transition", "persistent", "append-to", "onHide"]));
    }
  });
  var gB = /* @__PURE__ */ Ne(mB, [["__file", "color-picker.vue"]]);
  const bB = rt(gB), yB = Te({
    a11y: {
      type: Boolean,
      default: !0
    },
    locale: {
      type: X(Object)
    },
    size: mn,
    button: {
      type: X(Object)
    },
    card: {
      type: X(Object)
    },
    dialog: {
      type: X(Object)
    },
    link: {
      type: X(Object)
    },
    experimentalFeatures: {
      type: X(Object)
    },
    keyboardNavigation: {
      type: Boolean,
      default: !0
    },
    message: {
      type: X(Object)
    },
    zIndex: Number,
    namespace: {
      type: String,
      default: "el"
    },
    ...Cr
  }), Hn = {
    placement: "top"
  }, wB = /* @__PURE__ */ U({
    name: "ElConfigProvider",
    props: yB,
    setup(e, { slots: t }) {
      const n = ih(e);
      return de(() => e.message, (o) => {
        var l, a;
        Object.assign(Hn, (a = (l = n == null ? void 0 : n.value) == null ? void 0 : l.message) != null ? a : {}, o ?? {});
      }, { immediate: !0, deep: !0 }), () => ee(t, "default", { config: n == null ? void 0 : n.value });
    }
  }), CB = rt(wB), SB = /* @__PURE__ */ U({
    name: "ElContainer"
  }), EB = /* @__PURE__ */ U({
    ...SB,
    props: Te({
      direction: {
        type: String,
        values: ["horizontal", "vertical"]
      }
    }),
    setup(e) {
      const t = e, n = hn(), o = he("container"), l = S(() => t.direction === "vertical" ? !0 : t.direction === "horizontal" ? !1 : n && n.default ? n.default().some((r) => {
        const i = r.type.name;
        return i === "ElHeader" || i === "ElFooter";
      }) : !1);
      return (a, r) => (_(), B("section", {
        class: $([s(o).b(), s(o).is("vertical", s(l))])
      }, [
        ee(a.$slots, "default")
      ], 2));
    }
  });
  var kB = /* @__PURE__ */ Ne(EB, [["__file", "container.vue"]]);
  const _B = /* @__PURE__ */ U({
    name: "ElAside"
  }), TB = /* @__PURE__ */ U({
    ..._B,
    props: {
      width: {
        type: String,
        default: null
      }
    },
    setup(e) {
      const t = e, n = he("aside"), o = S(() => t.width ? n.cssVarBlock({ width: t.width }) : {});
      return (l, a) => (_(), B("aside", {
        class: $(s(n).b()),
        style: Ue(s(o))
      }, [
        ee(l.$slots, "default")
      ], 6));
    }
  });
  var GS = /* @__PURE__ */ Ne(TB, [["__file", "aside.vue"]]);
  const NB = /* @__PURE__ */ U({
    name: "ElFooter"
  }), $B = /* @__PURE__ */ U({
    ...NB,
    props: {
      height: {
        type: String,
        default: null
      }
    },
    setup(e) {
      const t = e, n = he("footer"), o = S(() => t.height ? n.cssVarBlock({ height: t.height }) : {});
      return (l, a) => (_(), B("footer", {
        class: $(s(n).b()),
        style: Ue(s(o))
      }, [
        ee(l.$slots, "default")
      ], 6));
    }
  });
  var XS = /* @__PURE__ */ Ne($B, [["__file", "footer.vue"]]);
  const OB = /* @__PURE__ */ U({
    name: "ElHeader"
  }), IB = /* @__PURE__ */ U({
    ...OB,
    props: {
      height: {
        type: String,
        default: null
      }
    },
    setup(e) {
      const t = e, n = he("header"), o = S(() => t.height ? n.cssVarBlock({
        height: t.height
      }) : {});
      return (l, a) => (_(), B("header", {
        class: $(s(n).b()),
        style: Ue(s(o))
      }, [
        ee(l.$slots, "default")
      ], 6));
    }
  });
  var JS = /* @__PURE__ */ Ne(IB, [["__file", "header.vue"]]);
  const MB = /* @__PURE__ */ U({
    name: "ElMain"
  }), xB = /* @__PURE__ */ U({
    ...MB,
    setup(e) {
      const t = he("main");
      return (n, o) => (_(), B("main", {
        class: $(s(t).b())
      }, [
        ee(n.$slots, "default")
      ], 2));
    }
  });
  var ZS = /* @__PURE__ */ Ne(xB, [["__file", "main.vue"]]);
  const PB = rt(kB, {
    Aside: GS,
    Footer: XS,
    Header: JS,
    Main: ZS
  }), RB = nn(GS), DB = nn(XS), AB = nn(JS), VB = nn(ZS);
  var QS = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(ra, function() {
      var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, o = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, l = /\d/, a = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, u = {}, c = function(g) {
        return (g = +g) + (g > 68 ? 1900 : 2e3);
      }, d = function(g) {
        return function(b) {
          this[g] = +b;
        };
      }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(g) {
        (this.zone || (this.zone = {})).offset = function(b) {
          if (!b || b === "Z") return 0;
          var C = b.match(/([+-]|\d\d)/g), w = 60 * C[1] + (+C[2] || 0);
          return w === 0 ? 0 : C[0] === "+" ? -w : w;
        }(g);
      }], v = function(g) {
        var b = u[g];
        return b && (b.indexOf ? b : b.s.concat(b.f));
      }, p = function(g, b) {
        var C, w = u.meridiem;
        if (w) {
          for (var y = 1; y <= 24; y += 1) if (g.indexOf(w(y, 0, b)) > -1) {
            C = y > 12;
            break;
          }
        } else C = g === (b ? "pm" : "PM");
        return C;
      }, m = { A: [i, function(g) {
        this.afternoon = p(g, !1);
      }], a: [i, function(g) {
        this.afternoon = p(g, !0);
      }], Q: [l, function(g) {
        this.month = 3 * (g - 1) + 1;
      }], S: [l, function(g) {
        this.milliseconds = 100 * +g;
      }], SS: [a, function(g) {
        this.milliseconds = 10 * +g;
      }], SSS: [/\d{3}/, function(g) {
        this.milliseconds = +g;
      }], s: [r, d("seconds")], ss: [r, d("seconds")], m: [r, d("minutes")], mm: [r, d("minutes")], H: [r, d("hours")], h: [r, d("hours")], HH: [r, d("hours")], hh: [r, d("hours")], D: [r, d("day")], DD: [a, d("day")], Do: [i, function(g) {
        var b = u.ordinal, C = g.match(/\d+/);
        if (this.day = C[0], b) for (var w = 1; w <= 31; w += 1) b(w).replace(/\[|\]/g, "") === g && (this.day = w);
      }], w: [r, d("week")], ww: [a, d("week")], M: [r, d("month")], MM: [a, d("month")], MMM: [i, function(g) {
        var b = v("months"), C = (v("monthsShort") || b.map(function(w) {
          return w.slice(0, 3);
        })).indexOf(g) + 1;
        if (C < 1) throw new Error();
        this.month = C % 12 || C;
      }], MMMM: [i, function(g) {
        var b = v("months").indexOf(g) + 1;
        if (b < 1) throw new Error();
        this.month = b % 12 || b;
      }], Y: [/[+-]?\d+/, d("year")], YY: [a, function(g) {
        this.year = c(g);
      }], YYYY: [/\d{4}/, d("year")], Z: f, ZZ: f };
      function h(g) {
        var b, C;
        b = g, C = u && u.formats;
        for (var w = (g = b.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(P, O, N) {
          var z = N && N.toUpperCase();
          return O || C[N] || n[N] || C[z].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(Y, G, M) {
            return G || M.slice(1);
          });
        })).match(o), y = w.length, E = 0; E < y; E += 1) {
          var k = w[E], T = m[k], x = T && T[0], I = T && T[1];
          w[E] = I ? { regex: x, parser: I } : k.replace(/^\[|\]$/g, "");
        }
        return function(P) {
          for (var O = {}, N = 0, z = 0; N < y; N += 1) {
            var Y = w[N];
            if (typeof Y == "string") z += Y.length;
            else {
              var G = Y.regex, M = Y.parser, R = P.slice(z), D = G.exec(R)[0];
              M.call(O, D), P = P.replace(D, "");
            }
          }
          return function(L) {
            var V = L.afternoon;
            if (V !== void 0) {
              var F = L.hours;
              V ? F < 12 && (L.hours += 12) : F === 12 && (L.hours = 0), delete L.afternoon;
            }
          }(O), O;
        };
      }
      return function(g, b, C) {
        C.p.customParseFormat = !0, g && g.parseTwoDigitYear && (c = g.parseTwoDigitYear);
        var w = b.prototype, y = w.parse;
        w.parse = function(E) {
          var k = E.date, T = E.utc, x = E.args;
          this.$u = T;
          var I = x[1];
          if (typeof I == "string") {
            var P = x[2] === !0, O = x[3] === !0, N = P || O, z = x[2];
            O && (z = x[2]), u = this.$locale(), !P && z && (u = C.Ls[z]), this.$d = function(R, D, L, V) {
              try {
                if (["x", "X"].indexOf(D) > -1) return new Date((D === "X" ? 1e3 : 1) * R);
                var F = h(D)(R), H = F.year, K = F.month, Z = F.day, J = F.hours, ie = F.minutes, ue = F.seconds, re = F.milliseconds, se = F.zone, ne = F.week, le = /* @__PURE__ */ new Date(), Ce = Z || (H || K ? 1 : le.getDate()), j = H || le.getFullYear(), te = 0;
                H && !K || (te = K > 0 ? K - 1 : le.getMonth());
                var ce, ge = J || 0, be = ie || 0, Ee = ue || 0, Oe = re || 0;
                return se ? new Date(Date.UTC(j, te, Ce, ge, be, Ee, Oe + 60 * se.offset * 1e3)) : L ? new Date(Date.UTC(j, te, Ce, ge, be, Ee, Oe)) : (ce = new Date(j, te, Ce, ge, be, Ee, Oe), ne && (ce = V(ce).week(ne).toDate()), ce);
              } catch {
                return /* @__PURE__ */ new Date("");
              }
            }(k, I, T, C), this.init(), z && z !== !0 && (this.$L = this.locale(z).$L), N && k != this.format(I) && (this.$d = /* @__PURE__ */ new Date("")), u = {};
          } else if (I instanceof Array) for (var Y = I.length, G = 1; G <= Y; G += 1) {
            x[1] = I[G - 1];
            var M = C.apply(this, x);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            G === Y && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else y.call(this, E);
        };
      };
    });
  })(QS);
  var LB = QS.exports;
  const Mh = /* @__PURE__ */ sa(LB), py = ["hours", "minutes", "seconds"], Xo = "EP_PICKER_BASE", xh = "ElPopperOptions", eE = Symbol("commonPickerContextKey"), us = "HH:mm:ss", ga = "YYYY-MM-DD", BB = {
    date: ga,
    dates: ga,
    week: "gggg[w]ww",
    year: "YYYY",
    years: "YYYY",
    month: "YYYY-MM",
    months: "YYYY-MM",
    datetime: `${ga} ${us}`,
    monthrange: "YYYY-MM",
    yearrange: "YYYY",
    daterange: ga,
    datetimerange: `${ga} ${us}`
  }, tE = (e, t) => {
    const { lang: n } = _t(), o = A(!1), l = A(!1), a = A(null), r = S(() => {
      const { modelValue: m } = e;
      return !m || ye(m) && !m.filter(Boolean).length;
    }), i = (m) => {
      if (!pS(e.modelValue, m)) {
        let h;
        ye(m) ? h = m.map((b) => ey(b, e.valueFormat, n.value)) : m && (h = ey(m, e.valueFormat, n.value)), t(et, m && h, n.value);
      }
    }, u = S(() => {
      var m;
      let h;
      if (r.value ? c.value.getDefaultValue && (h = c.value.getDefaultValue()) : ye(e.modelValue) ? h = e.modelValue.map((g) => Qb(g, e.valueFormat, n.value)) : h = Qb((m = e.modelValue) != null ? m : "", e.valueFormat, n.value), c.value.getRangeAvailableTime) {
        const g = c.value.getRangeAvailableTime(h);
        ln(g, h) || (h = g, r.value || i(nc(h)));
      }
      return ye(h) && h.some((g) => !g) && (h = []), h;
    }), c = A({});
    return {
      parsedValue: u,
      pickerActualVisible: l,
      pickerOptions: c,
      pickerVisible: o,
      userInput: a,
      valueIsEmpty: r,
      emitInput: i,
      onCalendarChange: (m) => {
        t("calendar-change", m);
      },
      onPanelChange: (m, h, g) => {
        t("panel-change", m, h, g);
      },
      onPick: (m = "", h = !1) => {
        o.value = h;
        let g;
        ye(m) ? g = m.map((b) => b.toDate()) : g = m && m.toDate(), a.value = null, i(g);
      },
      onSetPickerOption: (m) => {
        c.value[m[0]] = m[1], c.value.panelReady = !0;
      }
    };
  }, Ph = Te({
    disabledHours: {
      type: X(Function)
    },
    disabledMinutes: {
      type: X(Function)
    },
    disabledSeconds: {
      type: X(Function)
    }
  }), nE = Te({
    visible: Boolean,
    actualVisible: {
      type: Boolean,
      default: void 0
    },
    format: {
      type: String,
      default: ""
    }
  }), Rh = Te({
    automaticDropdown: {
      type: Boolean,
      default: !0
    },
    id: {
      type: X([Array, String])
    },
    name: {
      type: X([Array, String])
    },
    popperClass: zt.popperClass,
    popperStyle: zt.popperStyle,
    format: String,
    valueFormat: String,
    dateFormat: String,
    timeFormat: String,
    type: {
      type: String,
      default: ""
    },
    clearable: {
      type: Boolean,
      default: !0
    },
    clearIcon: {
      type: X([String, Object]),
      default: oa
    },
    editable: {
      type: Boolean,
      default: !0
    },
    prefixIcon: {
      type: X([String, Object]),
      default: ""
    },
    size: mn,
    readonly: Boolean,
    disabled: Boolean,
    placeholder: {
      type: String,
      default: ""
    },
    popperOptions: {
      type: X(Object),
      default: () => ({})
    },
    modelValue: {
      type: X([Date, Array, String, Number]),
      default: ""
    },
    rangeSeparator: {
      type: String,
      default: "-"
    },
    startPlaceholder: String,
    endPlaceholder: String,
    defaultValue: {
      type: X([Date, Array])
    },
    defaultTime: {
      type: X([Date, Array])
    },
    isRange: Boolean,
    ...Ph,
    disabledDate: {
      type: Function
    },
    cellClassName: {
      type: Function
    },
    shortcuts: {
      type: Array,
      default: () => []
    },
    arrowControl: Boolean,
    tabindex: {
      type: X([String, Number]),
      default: 0
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    unlinkPanels: Boolean,
    placement: {
      type: X(String),
      values: aa,
      default: "bottom"
    },
    fallbackPlacements: {
      type: X(Array),
      default: ["bottom", "top", "right", "left"]
    },
    ...Cr,
    ...Yn(["ariaLabel"]),
    showNow: {
      type: Boolean,
      default: !0
    },
    showConfirm: {
      type: Boolean,
      default: !0
    },
    showFooter: {
      type: Boolean,
      default: !0
    },
    showWeekNumber: Boolean
  }), FB = Te({
    id: {
      type: X(Array)
    },
    name: {
      type: X(Array)
    },
    modelValue: {
      type: X([Array, String])
    },
    startPlaceholder: String,
    endPlaceholder: String,
    disabled: Boolean
  }), zB = /* @__PURE__ */ U({
    name: "PickerRangeTrigger",
    inheritAttrs: !1
  }), HB = /* @__PURE__ */ U({
    ...zB,
    props: FB,
    emits: [
      "mouseenter",
      "mouseleave",
      "click",
      "touchstart",
      "focus",
      "blur",
      "startInput",
      "endInput",
      "startChange",
      "endChange"
    ],
    setup(e, { expose: t, emit: n }) {
      const o = e, { formItem: l } = Nn(), { inputId: a } = wo(Rt({ id: S(() => {
        var T;
        return (T = o.id) == null ? void 0 : T[0];
      }) }), {
        formItemContext: l
      }), r = Ad(), i = he("date"), u = he("range"), c = A(), d = A(), { wrapperRef: f, isFocused: v } = la(c, {
        disabled: S(() => o.disabled)
      }), p = (T) => {
        n("click", T);
      }, m = (T) => {
        n("mouseenter", T);
      }, h = (T) => {
        n("mouseleave", T);
      }, g = (T) => {
        n("touchstart", T);
      }, b = (T) => {
        n("startInput", T);
      }, C = (T) => {
        n("endInput", T);
      }, w = (T) => {
        n("startChange", T);
      }, y = (T) => {
        n("endChange", T);
      };
      return t({
        focus: () => {
          var T;
          (T = c.value) == null || T.focus();
        },
        blur: () => {
          var T, x;
          (T = c.value) == null || T.blur(), (x = d.value) == null || x.blur();
        }
      }), (T, x) => (_(), B("div", {
        ref_key: "wrapperRef",
        ref: f,
        class: $([s(i).is("active", s(v)), T.$attrs.class]),
        style: Ue(T.$attrs.style),
        onClick: p,
        onMouseenter: m,
        onMouseleave: h,
        onTouchstartPassive: g
      }, [
        ee(T.$slots, "prefix"),
        W("input", pt(s(r), {
          id: s(a),
          ref_key: "inputRef",
          ref: c,
          name: T.name && T.name[0],
          placeholder: T.startPlaceholder,
          value: T.modelValue && T.modelValue[0],
          class: s(u).b("input"),
          disabled: T.disabled,
          onInput: b,
          onChange: w
        }), null, 16, ["id", "name", "placeholder", "value", "disabled"]),
        ee(T.$slots, "range-separator"),
        W("input", pt(s(r), {
          id: T.id && T.id[1],
          ref_key: "endInputRef",
          ref: d,
          name: T.name && T.name[1],
          placeholder: T.endPlaceholder,
          value: T.modelValue && T.modelValue[1],
          class: s(u).b("input"),
          disabled: T.disabled,
          onInput: C,
          onChange: y
        }), null, 16, ["id", "name", "placeholder", "value", "disabled"]),
        ee(T.$slots, "suffix")
      ], 38));
    }
  });
  var KB = /* @__PURE__ */ Ne(HB, [["__file", "picker-range-trigger.vue"]]);
  const WB = /* @__PURE__ */ U({
    name: "Picker"
  }), jB = /* @__PURE__ */ U({
    ...WB,
    props: Rh,
    emits: [
      et,
      gt,
      "focus",
      "blur",
      "clear",
      "calendar-change",
      "panel-change",
      "visible-change",
      "keydown"
    ],
    setup(e, { expose: t, emit: n }) {
      const o = e, l = ea(), a = he("date"), r = he("input"), i = he("range"), { formItem: u } = Nn(), c = Ve(xh, {}), d = nu(o, null), f = A(), v = A(), p = A(null);
      let m = !1;
      const h = Cn(), g = tE(o, n), {
        parsedValue: b,
        pickerActualVisible: C,
        userInput: w,
        pickerVisible: y,
        pickerOptions: E,
        valueIsEmpty: k,
        emitInput: T,
        onPick: x,
        onSetPickerOption: I,
        onCalendarChange: P,
        onPanelChange: O
      } = g, { isFocused: N, handleFocus: z, handleBlur: Y } = la(v, {
        disabled: h,
        beforeFocus() {
          return o.readonly;
        },
        afterFocus() {
          o.automaticDropdown && (y.value = !0);
        },
        beforeBlur(ve) {
          var Ke;
          return !m && ((Ke = f.value) == null ? void 0 : Ke.isFocusInsideContent(ve));
        },
        afterBlur() {
          Me(), y.value = !1, m = !1, o.validateEvent && (u == null || u.validate("blur").catch((ve) => vt(ve)));
        }
      }), G = A(!1), M = S(() => [
        a.b("editor"),
        a.bm("editor", o.type),
        r.e("wrapper"),
        a.is("disabled", h.value),
        a.is("active", y.value),
        i.b("editor"),
        we ? i.bm("editor", we.value) : "",
        l.class
      ]), R = S(() => [
        r.e("icon"),
        i.e("close-icon"),
        te.value ? "" : i.em("close-icon", "hidden")
      ]);
      de(y, (ve) => {
        ve ? Re(() => {
          ve && (p.value = o.modelValue);
        }) : (w.value = null, Re(() => {
          D(o.modelValue);
        }));
      });
      const D = (ve, Ke) => {
        (Ke || !pS(ve, p.value)) && (n(gt, ve), Ke && (p.value = ve), o.validateEvent && (u == null || u.validate("change").catch((St) => vt(St))));
      }, L = (ve) => {
        n("keydown", ve);
      }, V = S(() => v.value ? Array.from(v.value.$el.querySelectorAll("input")) : []), F = (ve, Ke, St) => {
        const Ft = V.value;
        Ft.length && (!St || St === "min" ? (Ft[0].setSelectionRange(ve, Ke), Ft[0].focus()) : St === "max" && (Ft[1].setSelectionRange(ve, Ke), Ft[1].focus()));
      }, H = () => {
        C.value = !0;
      }, K = () => {
        n("visible-change", !0);
      }, Z = () => {
        C.value = !1, y.value = !1, n("visible-change", !1);
      }, J = () => {
        y.value = !0;
      }, ie = () => {
        y.value = !1;
      }, ue = S(() => {
        const ve = pe(b.value);
        return ye(w.value) ? [
          w.value[0] || ve && ve[0] || "",
          w.value[1] || ve && ve[1] || ""
        ] : w.value !== null ? w.value : !se.value && k.value || !y.value && k.value ? "" : ve ? ne.value || le.value || Ce.value ? ve.join(", ") : ve : "";
      }), re = S(() => o.type.includes("time")), se = S(() => o.type.startsWith("time")), ne = S(() => o.type === "dates"), le = S(() => o.type === "months"), Ce = S(() => o.type === "years"), j = S(() => o.prefixIcon || (re.value ? bC : LR)), te = S(() => o.clearable && !h.value && !o.readonly && !k.value && (G.value || N.value)), ce = (ve) => {
        o.readonly || h.value || (te.value && (ve.stopPropagation(), E.value.handleClear ? E.value.handleClear() : T(d.valueOnClear.value), D(d.valueOnClear.value, !0), Z()), n("clear"));
      }, ge = async (ve) => {
        var Ke;
        o.readonly || h.value || (((Ke = ve.target) == null ? void 0 : Ke.tagName) !== "INPUT" || N.value || !o.automaticDropdown) && (y.value = !0);
      }, be = () => {
        o.readonly || h.value || !k.value && o.clearable && (G.value = !0);
      }, Ee = () => {
        G.value = !1;
      }, Oe = (ve) => {
        var Ke;
        o.readonly || h.value || (((Ke = ve.touches[0].target) == null ? void 0 : Ke.tagName) !== "INPUT" || N.value || !o.automaticDropdown) && (y.value = !0);
      }, De = S(() => o.type.includes("range")), we = vn(), me = S(() => {
        var ve, Ke;
        return (Ke = (ve = s(f)) == null ? void 0 : ve.popperRef) == null ? void 0 : Ke.contentRef;
      }), Pe = ah(v, (ve) => {
        const Ke = s(me), St = kn(v);
        Ke && (ve.target === Ke || ve.composedPath().includes(Ke)) || ve.target === St || St && ve.composedPath().includes(St) || (y.value = !1);
      });
      Bt(() => {
        Pe == null || Pe();
      });
      const Me = () => {
        if (w.value) {
          const ve = Be(ue.value);
          ve && Le(ve) && (T(nc(ve)), w.value = null);
        }
        w.value === "" && (T(d.valueOnClear.value), D(d.valueOnClear.value, !0), w.value = null);
      }, Be = (ve) => ve ? E.value.parseUserInput(ve) : null, pe = (ve) => ve ? ye(ve) ? ve.map((St) => St.format(o.format)) : ve.format(o.format) : null, Le = (ve) => E.value.isValidValue(ve), Xe = async (ve) => {
        if (o.readonly || h.value)
          return;
        const Ke = Ht(ve);
        if (L(ve), Ke === _e.esc) {
          y.value === !0 && (y.value = !1, ve.preventDefault(), ve.stopPropagation());
          return;
        }
        if (Ke === _e.down && (E.value.handleFocusPicker && (ve.preventDefault(), ve.stopPropagation()), y.value === !1 && (y.value = !0, await Re()), E.value.handleFocusPicker)) {
          E.value.handleFocusPicker();
          return;
        }
        if (Ke === _e.tab) {
          m = !0;
          return;
        }
        if (Ke === _e.enter || Ke === _e.numpadEnter) {
          y.value ? (w.value === null || w.value === "" || Le(Be(ue.value))) && (Me(), y.value = !1) : y.value = !0, ve.preventDefault(), ve.stopPropagation();
          return;
        }
        if (w.value) {
          ve.stopPropagation();
          return;
        }
        E.value.handleKeydownInput && E.value.handleKeydownInput(ve);
      }, ut = (ve) => {
        w.value = ve, y.value || (y.value = !0);
      }, Nt = (ve) => {
        const Ke = ve.target;
        w.value ? w.value = [Ke.value, w.value[1]] : w.value = [Ke.value, null];
      }, Ye = (ve) => {
        const Ke = ve.target;
        w.value ? w.value = [w.value[0], Ke.value] : w.value = [null, Ke.value];
      }, tt = () => {
        var ve;
        const Ke = w.value, St = Be(Ke && Ke[0]), Ft = s(b);
        if (St && St.isValid()) {
          w.value = [
            pe(St),
            ((ve = ue.value) == null ? void 0 : ve[1]) || null
          ];
          const Se = [St, Ft && (Ft[1] || null)];
          Le(Se) && (T(nc(Se)), w.value = null);
        }
      }, fe = () => {
        var ve;
        const Ke = s(w), St = Be(Ke && Ke[1]), Ft = s(b);
        if (St && St.isValid()) {
          w.value = [
            ((ve = s(ue)) == null ? void 0 : ve[0]) || null,
            pe(St)
          ];
          const Se = [Ft && Ft[0], St];
          Le(Se) && (T(nc(Se)), w.value = null);
        }
      }, He = () => {
        var ve;
        (ve = v.value) == null || ve.focus();
      }, Qe = () => {
        var ve;
        (ve = v.value) == null || ve.blur();
      };
      return yt(Xo, {
        props: o,
        emptyValues: d
      }), yt(eE, g), t({
        focus: He,
        blur: Qe,
        handleOpen: J,
        handleClose: ie,
        onPick: x
      }), (ve, Ke) => (_(), ae(s(Pn), pt({
        ref_key: "refPopper",
        ref: f,
        visible: s(y),
        effect: "light",
        pure: "",
        trigger: "click"
      }, ve.$attrs, {
        role: "dialog",
        teleported: "",
        transition: `${s(a).namespace.value}-zoom-in-top`,
        "popper-class": [`${s(a).namespace.value}-picker__popper`, ve.popperClass],
        "popper-style": ve.popperStyle,
        "popper-options": s(c),
        "fallback-placements": ve.fallbackPlacements,
        "gpu-acceleration": !1,
        placement: ve.placement,
        "stop-popper-mouse-event": !1,
        "hide-after": 0,
        persistent: "",
        onBeforeShow: H,
        onShow: K,
        onHide: Z
      }), {
        default: Q(() => [
          s(De) ? (_(), ae(KB, {
            key: 1,
            id: ve.id,
            ref_key: "inputRef",
            ref: v,
            "model-value": s(ue),
            name: ve.name,
            disabled: s(h),
            readonly: !ve.editable || ve.readonly,
            "start-placeholder": ve.startPlaceholder,
            "end-placeholder": ve.endPlaceholder,
            class: $(s(M)),
            style: Ue(ve.$attrs.style),
            "aria-label": ve.ariaLabel,
            tabindex: ve.tabindex,
            autocomplete: "off",
            role: "combobox",
            onClick: ge,
            onFocus: s(z),
            onBlur: s(Y),
            onStartInput: Nt,
            onStartChange: tt,
            onEndInput: Ye,
            onEndChange: fe,
            onMousedown: ge,
            onMouseenter: be,
            onMouseleave: Ee,
            onTouchstartPassive: Oe,
            onKeydown: Xe
          }, {
            prefix: Q(() => [
              s(j) ? (_(), ae(s(ze), {
                key: 0,
                class: $([s(r).e("icon"), s(i).e("icon")])
              }, {
                default: Q(() => [
                  (_(), ae(ct(s(j))))
                ]),
                _: 1
              }, 8, ["class"])) : oe("v-if", !0)
            ]),
            "range-separator": Q(() => [
              ee(ve.$slots, "range-separator", {}, () => [
                W("span", {
                  class: $(s(i).b("separator"))
                }, ke(ve.rangeSeparator), 3)
              ])
            ]),
            suffix: Q(() => [
              ve.clearIcon ? (_(), ae(s(ze), {
                key: 0,
                class: $(s(R)),
                onMousedown: Ze(s(It), ["prevent"]),
                onClick: ce
              }, {
                default: Q(() => [
                  (_(), ae(ct(ve.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : oe("v-if", !0)
            ]),
            _: 3
          }, 8, ["id", "model-value", "name", "disabled", "readonly", "start-placeholder", "end-placeholder", "class", "style", "aria-label", "tabindex", "onFocus", "onBlur"])) : (_(), ae(s(Wn), {
            key: 0,
            id: ve.id,
            ref_key: "inputRef",
            ref: v,
            "container-role": "combobox",
            "model-value": s(ue),
            name: ve.name,
            size: s(we),
            disabled: s(h),
            placeholder: ve.placeholder,
            class: $([
              s(a).b("editor"),
              s(a).bm("editor", ve.type),
              s(a).is("focus", s(y)),
              ve.$attrs.class
            ]),
            style: Ue(ve.$attrs.style),
            readonly: !ve.editable || ve.readonly || s(ne) || s(le) || s(Ce) || ve.type === "week",
            "aria-label": ve.ariaLabel,
            tabindex: ve.tabindex,
            "validate-event": !1,
            onInput: ut,
            onFocus: s(z),
            onBlur: s(Y),
            onKeydown: Xe,
            onChange: Me,
            onMousedown: ge,
            onMouseenter: be,
            onMouseleave: Ee,
            onTouchstartPassive: Oe,
            onClick: Ze(() => {
            }, ["stop"])
          }, {
            prefix: Q(() => [
              s(j) ? (_(), ae(s(ze), {
                key: 0,
                class: $(s(r).e("icon")),
                onMousedown: Ze(ge, ["prevent"]),
                onTouchstartPassive: Oe
              }, {
                default: Q(() => [
                  (_(), ae(ct(s(j))))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : oe("v-if", !0)
            ]),
            suffix: Q(() => [
              s(te) && ve.clearIcon ? (_(), ae(s(ze), {
                key: 0,
                class: $(`${s(r).e("icon")} clear-icon`),
                onMousedown: Ze(s(It), ["prevent"]),
                onClick: ce
              }, {
                default: Q(() => [
                  (_(), ae(ct(ve.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onMousedown"])) : oe("v-if", !0)
            ]),
            _: 1
          }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "aria-label", "tabindex", "onFocus", "onBlur", "onClick"]))
        ]),
        content: Q(() => [
          ee(ve.$slots, "default", {
            visible: s(y),
            actualVisible: s(C),
            parsedValue: s(b),
            format: ve.format,
            dateFormat: ve.dateFormat,
            timeFormat: ve.timeFormat,
            unlinkPanels: ve.unlinkPanels,
            type: ve.type,
            defaultValue: ve.defaultValue,
            showNow: ve.showNow,
            showConfirm: ve.showConfirm,
            showFooter: ve.showFooter,
            showWeekNumber: ve.showWeekNumber,
            onPick: s(x),
            onSelectRange: F,
            onSetPickerOption: s(I),
            onCalendarChange: s(P),
            onPanelChange: s(O),
            onMousedown: Ze(() => {
            }, ["stop"])
          })
        ]),
        _: 3
      }, 16, ["visible", "transition", "popper-class", "popper-style", "popper-options", "fallback-placements", "placement"]));
    }
  });
  var oE = /* @__PURE__ */ Ne(jB, [["__file", "picker.vue"]]);
  const UB = Te({
    ...nE,
    datetimeRole: String,
    parsedValue: {
      type: X(Object)
    }
  }), lE = ({
    getAvailableHours: e,
    getAvailableMinutes: t,
    getAvailableSeconds: n
  }) => {
    const o = (r, i, u, c) => {
      const d = {
        hour: e,
        minute: t,
        second: n
      };
      let f = r;
      return ["hour", "minute", "second"].forEach((v) => {
        if (d[v]) {
          let p;
          const m = d[v];
          switch (v) {
            case "minute": {
              p = m(f.hour(), i, c);
              break;
            }
            case "second": {
              p = m(f.hour(), f.minute(), i, c);
              break;
            }
            default: {
              p = m(i, c);
              break;
            }
          }
          if (p != null && p.length && !p.includes(f[v]())) {
            const h = u ? 0 : p.length - 1;
            f = f[v](p[h]);
          }
        }
      }), f;
    }, l = {};
    return {
      timePickerOptions: l,
      getAvailableTime: o,
      onSetOption: ([r, i]) => {
        l[r] = i;
      }
    };
  }, Af = (e) => {
    const t = (o, l) => o || l, n = (o) => o !== !0;
    return e.map(t).filter(n);
  }, aE = (e, t, n) => ({
    getHoursList: (r, i) => Mf(24, e && (() => e == null ? void 0 : e(r, i))),
    getMinutesList: (r, i, u) => Mf(60, t && (() => t == null ? void 0 : t(r, i, u))),
    getSecondsList: (r, i, u, c) => Mf(60, n && (() => n == null ? void 0 : n(r, i, u, c)))
  }), rE = (e, t, n) => {
    const { getHoursList: o, getMinutesList: l, getSecondsList: a } = aE(e, t, n);
    return {
      getAvailableHours: (c, d) => Af(o(c, d)),
      getAvailableMinutes: (c, d, f) => Af(l(c, d, f)),
      getAvailableSeconds: (c, d, f, v) => Af(a(c, d, f, v))
    };
  }, sE = (e) => {
    const t = A(e.parsedValue);
    return de(() => e.visible, (n) => {
      n || (t.value = e.parsedValue);
    }), t;
  }, YB = Te({
    role: {
      type: String,
      required: !0
    },
    spinnerDate: {
      type: X(Object),
      required: !0
    },
    showSeconds: {
      type: Boolean,
      default: !0
    },
    arrowControl: Boolean,
    amPmMode: {
      type: X(String),
      default: ""
    },
    ...Ph
  }), qB = 100, GB = 600, Au = "_RepeatClick", Hc = {
    beforeMount(e, t) {
      const n = t.value, { interval: o = qB, delay: l = GB } = Fe(n) ? {} : n;
      let a, r;
      const i = () => Fe(n) ? n() : n.handler(), u = () => {
        r && (clearTimeout(r), r = void 0), a && (clearInterval(a), a = void 0);
      }, c = (d) => {
        d.button === 0 && (u(), i(), document.addEventListener("mouseup", u, { once: !0 }), r = setTimeout(() => {
          a = setInterval(() => {
            i();
          }, o);
        }, l));
      };
      e[Au] = { start: c, clear: u }, e.addEventListener("mousedown", c);
    },
    unmounted(e) {
      if (!e[Au])
        return;
      const { start: t, clear: n } = e[Au];
      t && e.removeEventListener("mousedown", t), n && (n(), document.removeEventListener("mouseup", n)), e[Au] = null;
    }
  }, XB = /* @__PURE__ */ U({
    __name: "basic-time-spinner",
    props: YB,
    emits: [gt, "select-range", "set-option"],
    setup(e, { emit: t }) {
      const n = e, o = Ve(Xo), { isRange: l, format: a } = o.props, r = he("time"), { getHoursList: i, getMinutesList: u, getSecondsList: c } = aE(n.disabledHours, n.disabledMinutes, n.disabledSeconds);
      let d = !1;
      const f = A(), v = A(), p = A(), m = A(), h = {
        hours: v,
        minutes: p,
        seconds: m
      }, g = S(() => n.showSeconds ? py : py.slice(0, 2)), b = S(() => {
        const { spinnerDate: H } = n, K = H.hour(), Z = H.minute(), J = H.second();
        return { hours: K, minutes: Z, seconds: J };
      }), C = S(() => {
        const { hours: H, minutes: K } = s(b), { role: Z, spinnerDate: J } = n, ie = l ? void 0 : J;
        return {
          hours: i(Z, ie),
          minutes: u(H, Z, ie),
          seconds: c(H, K, Z, ie)
        };
      }), w = S(() => {
        const { hours: H, minutes: K, seconds: Z } = s(b);
        return {
          hours: If(H, 23),
          minutes: If(K, 59),
          seconds: If(Z, 59)
        };
      }), y = wl((H) => {
        d = !1, T(H);
      }, 200), E = (H) => {
        if (!!!n.amPmMode)
          return "";
        const Z = n.amPmMode === "A";
        let J = H < 12 ? " am" : " pm";
        return Z && (J = J.toUpperCase()), J;
      }, k = (H) => {
        let K = [0, 0];
        const Z = a || us, J = Z.indexOf("HH"), ie = Z.indexOf("mm"), ue = Z.indexOf("ss");
        switch (H) {
          case "hours":
            J !== -1 && (K = [J, J + 2]);
            break;
          case "minutes":
            ie !== -1 && (K = [ie, ie + 2]);
            break;
          case "seconds":
            ue !== -1 && (K = [ue, ue + 2]);
            break;
        }
        const [re, se] = K;
        t("select-range", re, se), f.value = H;
      }, T = (H) => {
        P(H, s(b)[H]);
      }, x = () => {
        T("hours"), T("minutes"), T("seconds");
      }, I = (H) => H.querySelector(`.${r.namespace.value}-scrollbar__wrap`), P = (H, K) => {
        if (n.arrowControl)
          return;
        const Z = s(h[H]);
        Z && Z.$el && (I(Z.$el).scrollTop = Math.max(0, K * O(H)));
      }, O = (H) => {
        const K = s(h[H]), Z = K == null ? void 0 : K.$el.querySelector("li");
        return Z && Number.parseFloat(Bl(Z, "height")) || 0;
      }, N = () => {
        Y(1);
      }, z = () => {
        Y(-1);
      }, Y = (H) => {
        f.value || k("hours");
        const K = f.value, Z = s(b)[K], J = f.value === "hours" ? 24 : 60, ie = G(K, Z, H, J);
        M(K, ie), P(K, ie), Re(() => k(K));
      }, G = (H, K, Z, J) => {
        let ie = (K + Z + J) % J;
        const ue = s(C)[H];
        for (; ue[ie] && ie !== K; )
          ie = (ie + Z + J) % J;
        return ie;
      }, M = (H, K) => {
        if (s(C)[H][K])
          return;
        const { hours: ie, minutes: ue, seconds: re } = s(b);
        let se;
        switch (H) {
          case "hours":
            se = n.spinnerDate.hour(K).minute(ue).second(re);
            break;
          case "minutes":
            se = n.spinnerDate.hour(ie).minute(K).second(re);
            break;
          case "seconds":
            se = n.spinnerDate.hour(ie).minute(ue).second(K);
            break;
        }
        t(gt, se);
      }, R = (H, { value: K, disabled: Z }) => {
        Z || (M(H, K), k(H), P(H, K));
      }, D = (H) => {
        const K = s(h[H]);
        if (!K)
          return;
        d = !0, y(H);
        const Z = Math.min(Math.round((I(K.$el).scrollTop - (L(H) * 0.5 - 10) / O(H) + 3) / O(H)), H === "hours" ? 23 : 59);
        M(H, Z);
      }, L = (H) => s(h[H]).$el.offsetHeight, V = () => {
        const H = (K) => {
          const Z = s(h[K]);
          Z && Z.$el && (I(Z.$el).onscroll = () => {
            D(K);
          });
        };
        H("hours"), H("minutes"), H("seconds");
      };
      ft(() => {
        Re(() => {
          !n.arrowControl && V(), x(), n.role === "start" && k("hours");
        });
      });
      const F = (H, K) => {
        h[K].value = H ?? void 0;
      };
      return t("set-option", [`${n.role}_scrollDown`, Y]), t("set-option", [`${n.role}_emitSelectRange`, k]), de(() => n.spinnerDate, () => {
        d || x();
      }), (H, K) => (_(), B("div", {
        class: $([s(r).b("spinner"), { "has-seconds": H.showSeconds }])
      }, [
        H.arrowControl ? oe("v-if", !0) : (_(!0), B(We, { key: 0 }, bt(s(g), (Z) => (_(), ae(s(Go), {
          key: Z,
          ref_for: !0,
          ref: (J) => F(J, Z),
          class: $(s(r).be("spinner", "wrapper")),
          "wrap-style": "max-height: inherit;",
          "view-class": s(r).be("spinner", "list"),
          noresize: "",
          tag: "ul",
          onMouseenter: (J) => k(Z),
          onMousemove: (J) => T(Z)
        }, {
          default: Q(() => [
            (_(!0), B(We, null, bt(s(C)[Z], (J, ie) => (_(), B("li", {
              key: ie,
              class: $([
                s(r).be("spinner", "item"),
                s(r).is("active", ie === s(b)[Z]),
                s(r).is("disabled", J)
              ]),
              onClick: (ue) => R(Z, { value: ie, disabled: J })
            }, [
              Z === "hours" ? (_(), B(We, { key: 0 }, [
                Ct(ke(("0" + (H.amPmMode ? ie % 12 || 12 : ie)).slice(-2)) + ke(E(ie)), 1)
              ], 64)) : (_(), B(We, { key: 1 }, [
                Ct(ke(("0" + ie).slice(-2)), 1)
              ], 64))
            ], 10, ["onClick"]))), 128))
          ]),
          _: 2
        }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]))), 128)),
        H.arrowControl ? (_(!0), B(We, { key: 1 }, bt(s(g), (Z) => (_(), B("div", {
          key: Z,
          class: $([s(r).be("spinner", "wrapper"), s(r).is("arrow")]),
          onMouseenter: (J) => k(Z)
        }, [
          it((_(), ae(s(ze), {
            class: $(["arrow-up", s(r).be("spinner", "arrow")])
          }, {
            default: Q(() => [
              q(s(Pd))
            ]),
            _: 1
          }, 8, ["class"])), [
            [s(Hc), z]
          ]),
          it((_(), ae(s(ze), {
            class: $(["arrow-down", s(r).be("spinner", "arrow")])
          }, {
            default: Q(() => [
              q(s(Nl))
            ]),
            _: 1
          }, 8, ["class"])), [
            [s(Hc), N]
          ]),
          W("ul", {
            class: $(s(r).be("spinner", "list"))
          }, [
            (_(!0), B(We, null, bt(s(w)[Z], (J, ie) => (_(), B("li", {
              key: ie,
              class: $([
                s(r).be("spinner", "item"),
                s(r).is("active", J === s(b)[Z]),
                s(r).is("disabled", s(C)[Z][J])
              ])
            }, [
              s(je)(J) ? (_(), B(We, { key: 0 }, [
                Z === "hours" ? (_(), B(We, { key: 0 }, [
                  Ct(ke(("0" + (H.amPmMode ? J % 12 || 12 : J)).slice(-2)) + ke(E(J)), 1)
                ], 64)) : (_(), B(We, { key: 1 }, [
                  Ct(ke(("0" + J).slice(-2)), 1)
                ], 64))
              ], 64)) : oe("v-if", !0)
            ], 2))), 128))
          ], 2)
        ], 42, ["onMouseenter"]))), 128)) : oe("v-if", !0)
      ], 2));
    }
  });
  var xp = /* @__PURE__ */ Ne(XB, [["__file", "basic-time-spinner.vue"]]);
  const JB = /* @__PURE__ */ U({
    __name: "panel-time-pick",
    props: UB,
    emits: ["pick", "select-range", "set-picker-option"],
    setup(e, { emit: t }) {
      const n = e, o = Ve(Xo), {
        arrowControl: l,
        disabledHours: a,
        disabledMinutes: r,
        disabledSeconds: i,
        defaultValue: u
      } = o.props, { getAvailableHours: c, getAvailableMinutes: d, getAvailableSeconds: f } = rE(a, r, i), v = he("time"), { t: p, lang: m } = _t(), h = A([0, 2]), g = sE(n), b = S(() => kt(n.actualVisible) ? `${v.namespace.value}-zoom-in-top` : ""), C = S(() => n.format.includes("ss")), w = S(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), y = (R) => {
        const D = st(R).locale(m.value), L = Y(D);
        return D.isSame(L);
      }, E = () => {
        const R = g.value;
        t("pick", R, !1), Re(() => {
          g.value = R;
        });
      }, k = (R = !1, D = !1) => {
        D || t("pick", n.parsedValue, R);
      }, T = (R) => {
        if (!n.visible)
          return;
        const D = Y(R).millisecond(0);
        t("pick", D, !0);
      }, x = (R, D) => {
        t("select-range", R, D), h.value = [R, D];
      }, I = (R) => {
        const D = n.format, L = D.indexOf("HH"), V = D.indexOf("mm"), F = D.indexOf("ss"), H = [], K = [];
        L !== -1 && (H.push(L), K.push("hours")), V !== -1 && (H.push(V), K.push("minutes")), F !== -1 && C.value && (H.push(F), K.push("seconds"));
        const J = (H.indexOf(h.value[0]) + R + H.length) % H.length;
        O.start_emitSelectRange(K[J]);
      }, P = (R) => {
        const D = Ht(R), { left: L, right: V, up: F, down: H } = _e;
        if ([L, V].includes(D)) {
          I(D === L ? -1 : 1), R.preventDefault();
          return;
        }
        if ([F, H].includes(D)) {
          const K = D === F ? -1 : 1;
          O.start_scrollDown(K), R.preventDefault();
          return;
        }
      }, { timePickerOptions: O, onSetOption: N, getAvailableTime: z } = lE({
        getAvailableHours: c,
        getAvailableMinutes: d,
        getAvailableSeconds: f
      }), Y = (R) => z(R, n.datetimeRole || "", !0), G = (R) => R ? st(R, n.format).locale(m.value) : null, M = () => st(u).locale(m.value);
      return t("set-picker-option", ["isValidValue", y]), t("set-picker-option", ["parseUserInput", G]), t("set-picker-option", ["handleKeydownInput", P]), t("set-picker-option", ["getRangeAvailableTime", Y]), t("set-picker-option", ["getDefaultValue", M]), (R, D) => (_(), ae(Mn, { name: s(b) }, {
        default: Q(() => [
          R.actualVisible || R.visible ? (_(), B("div", {
            key: 0,
            class: $(s(v).b("panel"))
          }, [
            W("div", {
              class: $([s(v).be("panel", "content"), { "has-seconds": s(C) }])
            }, [
              q(xp, {
                ref: "spinner",
                role: R.datetimeRole || "start",
                "arrow-control": s(l),
                "show-seconds": s(C),
                "am-pm-mode": s(w),
                "spinner-date": R.parsedValue,
                "disabled-hours": s(a),
                "disabled-minutes": s(r),
                "disabled-seconds": s(i),
                onChange: T,
                onSetOption: s(N),
                onSelectRange: x
              }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])
            ], 2),
            W("div", {
              class: $(s(v).be("panel", "footer"))
            }, [
              W("button", {
                type: "button",
                class: $([s(v).be("panel", "btn"), "cancel"]),
                onClick: E
              }, ke(s(p)("el.datepicker.cancel")), 3),
              W("button", {
                type: "button",
                class: $([s(v).be("panel", "btn"), "confirm"]),
                onClick: (L) => k()
              }, ke(s(p)("el.datepicker.confirm")), 11, ["onClick"])
            ], 2)
          ], 2)) : oe("v-if", !0)
        ]),
        _: 1
      }, 8, ["name"]));
    }
  });
  var Kc = /* @__PURE__ */ Ne(JB, [["__file", "panel-time-pick.vue"]]);
  const ZB = Te({
    ...nE,
    parsedValue: {
      type: X(Array)
    }
  }), QB = /* @__PURE__ */ U({
    __name: "panel-time-range",
    props: ZB,
    emits: ["pick", "select-range", "set-picker-option"],
    setup(e, { emit: t }) {
      const n = e, o = (ne, le) => {
        const Ce = [];
        for (let j = ne; j <= le; j++)
          Ce.push(j);
        return Ce;
      }, { t: l, lang: a } = _t(), r = he("time"), i = he("picker"), u = Ve(Xo), {
        arrowControl: c,
        disabledHours: d,
        disabledMinutes: f,
        disabledSeconds: v,
        defaultValue: p
      } = u.props, m = S(() => [
        r.be("range-picker", "body"),
        r.be("panel", "content"),
        r.is("arrow", c),
        y.value ? "has-seconds" : ""
      ]), h = S(() => [
        r.be("range-picker", "body"),
        r.be("panel", "content"),
        r.is("arrow", c),
        y.value ? "has-seconds" : ""
      ]), g = S(() => n.parsedValue[0]), b = S(() => n.parsedValue[1]), C = sE(n), w = () => {
        const ne = C.value;
        t("pick", ne, !1), Re(() => {
          C.value = ne;
        });
      }, y = S(() => n.format.includes("ss")), E = S(() => n.format.includes("A") ? "A" : n.format.includes("a") ? "a" : ""), k = (ne = !1) => {
        t("pick", [g.value, b.value], ne);
      }, T = (ne) => {
        P(ne.millisecond(0), b.value);
      }, x = (ne) => {
        P(g.value, ne.millisecond(0));
      }, I = (ne) => {
        const le = ne.map((j) => st(j).locale(a.value)), Ce = F(le);
        return le[0].isSame(Ce[0]) && le[1].isSame(Ce[1]);
      }, P = (ne, le) => {
        n.visible && t("pick", [ne, le], !0);
      }, O = S(() => g.value > b.value), N = A([0, 2]), z = (ne, le) => {
        t("select-range", ne, le, "min"), N.value = [ne, le];
      }, Y = S(() => y.value ? 11 : 8), G = (ne, le) => {
        t("select-range", ne, le, "max");
        const Ce = s(Y);
        N.value = [ne + Ce, le + Ce];
      }, M = (ne) => {
        const le = y.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11], Ce = ["hours", "minutes"].concat(y.value ? ["seconds"] : []), te = (le.indexOf(N.value[0]) + ne + le.length) % le.length, ce = le.length / 2;
        te < ce ? J.start_emitSelectRange(Ce[te]) : J.end_emitSelectRange(Ce[te - ce]);
      }, R = (ne) => {
        const le = Ht(ne), { left: Ce, right: j, up: te, down: ce } = _e;
        if ([Ce, j].includes(le)) {
          M(le === Ce ? -1 : 1), ne.preventDefault();
          return;
        }
        if ([te, ce].includes(le)) {
          const ge = le === te ? -1 : 1, be = N.value[0] < Y.value ? "start" : "end";
          J[`${be}_scrollDown`](ge), ne.preventDefault();
          return;
        }
      }, D = (ne, le) => {
        const Ce = d ? d(ne) : [], j = ne === "start", ce = (le || (j ? b.value : g.value)).hour(), ge = j ? o(ce + 1, 23) : o(0, ce - 1);
        return Ef(Ce, ge);
      }, L = (ne, le, Ce) => {
        const j = f ? f(ne, le) : [], te = le === "start", ce = Ce || (te ? b.value : g.value), ge = ce.hour();
        if (ne !== ge)
          return j;
        const be = ce.minute(), Ee = te ? o(be + 1, 59) : o(0, be - 1);
        return Ef(j, Ee);
      }, V = (ne, le, Ce, j) => {
        const te = v ? v(ne, le, Ce) : [], ce = Ce === "start", ge = j || (ce ? b.value : g.value), be = ge.hour(), Ee = ge.minute();
        if (ne !== be || le !== Ee)
          return te;
        const Oe = ge.second(), De = ce ? o(Oe + 1, 59) : o(0, Oe - 1);
        return Ef(te, De);
      }, F = ([ne, le]) => [
        ie(ne, "start", !0, le),
        ie(le, "end", !1, ne)
      ], { getAvailableHours: H, getAvailableMinutes: K, getAvailableSeconds: Z } = rE(D, L, V), {
        timePickerOptions: J,
        getAvailableTime: ie,
        onSetOption: ue
      } = lE({
        getAvailableHours: H,
        getAvailableMinutes: K,
        getAvailableSeconds: Z
      }), re = (ne) => ne ? ye(ne) ? ne.map((le) => st(le, n.format).locale(a.value)) : st(ne, n.format).locale(a.value) : null, se = () => {
        if (ye(p))
          return p.map((le) => st(le).locale(a.value));
        const ne = st(p).locale(a.value);
        return [ne, ne.add(60, "m")];
      };
      return t("set-picker-option", ["parseUserInput", re]), t("set-picker-option", ["isValidValue", I]), t("set-picker-option", ["handleKeydownInput", R]), t("set-picker-option", ["getDefaultValue", se]), t("set-picker-option", ["getRangeAvailableTime", F]), (ne, le) => ne.actualVisible ? (_(), B("div", {
        key: 0,
        class: $([s(r).b("range-picker"), s(i).b("panel")])
      }, [
        W("div", {
          class: $(s(r).be("range-picker", "content"))
        }, [
          W("div", {
            class: $(s(r).be("range-picker", "cell"))
          }, [
            W("div", {
              class: $(s(r).be("range-picker", "header"))
            }, ke(s(l)("el.datepicker.startTime")), 3),
            W("div", {
              class: $(s(m))
            }, [
              q(xp, {
                ref: "minSpinner",
                role: "start",
                "show-seconds": s(y),
                "am-pm-mode": s(E),
                "arrow-control": s(c),
                "spinner-date": s(g),
                "disabled-hours": D,
                "disabled-minutes": L,
                "disabled-seconds": V,
                onChange: T,
                onSetOption: s(ue),
                onSelectRange: z
              }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
            ], 2)
          ], 2),
          W("div", {
            class: $(s(r).be("range-picker", "cell"))
          }, [
            W("div", {
              class: $(s(r).be("range-picker", "header"))
            }, ke(s(l)("el.datepicker.endTime")), 3),
            W("div", {
              class: $(s(h))
            }, [
              q(xp, {
                ref: "maxSpinner",
                role: "end",
                "show-seconds": s(y),
                "am-pm-mode": s(E),
                "arrow-control": s(c),
                "spinner-date": s(b),
                "disabled-hours": D,
                "disabled-minutes": L,
                "disabled-seconds": V,
                onChange: x,
                onSetOption: s(ue),
                onSelectRange: G
              }, null, 8, ["show-seconds", "am-pm-mode", "arrow-control", "spinner-date", "onSetOption"])
            ], 2)
          ], 2)
        ], 2),
        W("div", {
          class: $(s(r).be("panel", "footer"))
        }, [
          W("button", {
            type: "button",
            class: $([s(r).be("panel", "btn"), "cancel"]),
            onClick: (Ce) => w()
          }, ke(s(l)("el.datepicker.cancel")), 11, ["onClick"]),
          W("button", {
            type: "button",
            class: $([s(r).be("panel", "btn"), "confirm"]),
            disabled: s(O),
            onClick: (Ce) => k()
          }, ke(s(l)("el.datepicker.confirm")), 11, ["disabled", "onClick"])
        ], 2)
      ], 2)) : oe("v-if", !0);
    }
  });
  var e6 = /* @__PURE__ */ Ne(QB, [["__file", "panel-time-range.vue"]]);
  st.extend(Mh);
  var t6 = /* @__PURE__ */ U({
    name: "ElTimePicker",
    install: null,
    props: {
      ...Rh,
      isRange: Boolean
    },
    emits: [et],
    setup(e, t) {
      const n = A(), [o, l] = e.isRange ? ["timerange", e6] : ["time", Kc], a = (r) => t.emit(et, r);
      return yt(xh, e.popperOptions), t.expose({
        focus: () => {
          var r;
          (r = n.value) == null || r.focus();
        },
        blur: () => {
          var r;
          (r = n.value) == null || r.blur();
        },
        handleOpen: () => {
          var r;
          (r = n.value) == null || r.handleOpen();
        },
        handleClose: () => {
          var r;
          (r = n.value) == null || r.handleClose();
        }
      }), () => {
        var r;
        const i = (r = e.format) != null ? r : us;
        return q(oE, pt(e, {
          ref: n,
          type: o,
          format: i,
          "onUpdate:modelValue": a
        }), {
          default: (u) => q(l, u, null)
        });
      };
    }
  });
  const n6 = rt(t6);
  var iE = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(ra, function() {
      return function(n, o) {
        var l = o.prototype, a = l.format;
        l.format = function(r) {
          var i = this, u = this.$locale();
          if (!this.isValid()) return a.bind(this)(r);
          var c = this.$utils(), d = (r || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(f) {
            switch (f) {
              case "Q":
                return Math.ceil((i.$M + 1) / 3);
              case "Do":
                return u.ordinal(i.$D);
              case "gggg":
                return i.weekYear();
              case "GGGG":
                return i.isoWeekYear();
              case "wo":
                return u.ordinal(i.week(), "W");
              case "w":
              case "ww":
                return c.s(i.week(), f === "w" ? 1 : 2, "0");
              case "W":
              case "WW":
                return c.s(i.isoWeek(), f === "W" ? 1 : 2, "0");
              case "k":
              case "kk":
                return c.s(String(i.$H === 0 ? 24 : i.$H), f === "k" ? 1 : 2, "0");
              case "X":
                return Math.floor(i.$d.getTime() / 1e3);
              case "x":
                return i.$d.getTime();
              case "z":
                return "[" + i.offsetName() + "]";
              case "zzz":
                return "[" + i.offsetName("long") + "]";
              default:
                return f;
            }
          });
          return a.bind(this)(d);
        };
      };
    });
  })(iE);
  var o6 = iE.exports;
  const l6 = /* @__PURE__ */ sa(o6);
  var uE = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(ra, function() {
      var n = "week", o = "year";
      return function(l, a, r) {
        var i = a.prototype;
        i.week = function(u) {
          if (u === void 0 && (u = null), u !== null) return this.add(7 * (u - this.week()), "day");
          var c = this.$locale().yearStart || 1;
          if (this.month() === 11 && this.date() > 25) {
            var d = r(this).startOf(o).add(1, o).date(c), f = r(this).endOf(n);
            if (d.isBefore(f)) return 1;
          }
          var v = r(this).startOf(o).date(c).startOf(n).subtract(1, "millisecond"), p = this.diff(v, n, !0);
          return p < 0 ? r(this).startOf("week").week() : Math.ceil(p);
        }, i.weeks = function(u) {
          return u === void 0 && (u = null), this.week(u);
        };
      };
    });
  })(uE);
  var a6 = uE.exports;
  const r6 = /* @__PURE__ */ sa(a6);
  var cE = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(ra, function() {
      return function(n, o) {
        o.prototype.weekYear = function() {
          var l = this.month(), a = this.week(), r = this.year();
          return a === 1 && l === 11 ? r + 1 : l === 0 && a >= 52 ? r - 1 : r;
        };
      };
    });
  })(cE);
  var s6 = cE.exports;
  const i6 = /* @__PURE__ */ sa(s6);
  var dE = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(ra, function() {
      return function(n, o, l) {
        o.prototype.dayOfYear = function(a) {
          var r = Math.round((l(this).startOf("day") - l(this).startOf("year")) / 864e5) + 1;
          return a == null ? r : this.add(a - r, "day");
        };
      };
    });
  })(dE);
  var u6 = dE.exports;
  const c6 = /* @__PURE__ */ sa(u6);
  var fE = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(ra, function() {
      return function(n, o) {
        o.prototype.isSameOrAfter = function(l, a) {
          return this.isSame(l, a) || this.isAfter(l, a);
        };
      };
    });
  })(fE);
  var d6 = fE.exports;
  const f6 = /* @__PURE__ */ sa(d6);
  var pE = { exports: {} };
  (function(e, t) {
    (function(n, o) {
      e.exports = o();
    })(ra, function() {
      return function(n, o) {
        o.prototype.isSameOrBefore = function(l, a) {
          return this.isSame(l, a) || this.isBefore(l, a);
        };
      };
    });
  })(pE);
  var p6 = pE.exports;
  const v6 = /* @__PURE__ */ sa(p6), h6 = Te({
    valueFormat: String,
    dateFormat: String,
    timeFormat: String,
    disabled: Boolean,
    modelValue: {
      type: X([Date, Array, String, Number]),
      default: ""
    },
    defaultValue: {
      type: X([Date, Array])
    },
    defaultTime: {
      type: X([Date, Array])
    },
    isRange: Boolean,
    ...Ph,
    disabledDate: {
      type: Function
    },
    cellClassName: {
      type: Function
    },
    shortcuts: {
      type: Array,
      default: () => []
    },
    arrowControl: Boolean,
    unlinkPanels: Boolean,
    showNow: {
      type: Boolean,
      default: !0
    },
    showConfirm: Boolean,
    showFooter: Boolean,
    showWeekNumber: Boolean,
    type: {
      type: X(String),
      default: "date"
    },
    clearable: {
      type: Boolean,
      default: !0
    },
    border: {
      type: Boolean,
      default: !0
    }
  }), Dh = Symbol("rootPickerContextKey"), cu = "ElIsDefaultFormat", m6 = [
    "date",
    "dates",
    "year",
    "years",
    "month",
    "months",
    "week",
    "range"
  ], Ah = Te({
    cellClassName: {
      type: X(Function)
    },
    disabledDate: {
      type: X(Function)
    },
    date: {
      type: X(Object),
      required: !0
    },
    minDate: {
      type: X(Object)
    },
    maxDate: {
      type: X(Object)
    },
    parsedValue: {
      type: X([Object, Array])
    },
    rangeState: {
      type: X(Object),
      default: () => ({
        endDate: null,
        selecting: !1
      })
    },
    disabled: Boolean
  }), vE = Te({
    type: {
      type: X(String),
      required: !0,
      values: R3
    },
    dateFormat: String,
    timeFormat: String,
    showNow: {
      type: Boolean,
      default: !0
    },
    showConfirm: Boolean,
    showFooter: {
      type: Boolean,
      default: !0
    },
    showWeekNumber: Boolean,
    border: Boolean,
    disabled: Boolean
  }), Vh = Te({
    unlinkPanels: Boolean,
    visible: {
      type: Boolean,
      default: !0
    },
    showConfirm: Boolean,
    showFooter: {
      type: Boolean,
      default: !0
    },
    border: Boolean,
    disabled: Boolean,
    parsedValue: {
      type: X(Array)
    }
  }), Lh = (e) => ({
    type: String,
    values: m6,
    default: e
  }), g6 = Te({
    ...vE,
    parsedValue: {
      type: X([Object, Array])
    },
    visible: {
      type: Boolean,
      default: !0
    },
    format: {
      type: String,
      default: ""
    }
  }), Ni = (e) => {
    if (!ye(e))
      return !1;
    const [t, n] = e;
    return st.isDayjs(t) && st.isDayjs(n) && st(t).isValid() && st(n).isValid() && t.isSameOrBefore(n);
  }, Kd = (e, { lang: t, step: n = 1, unit: o, unlinkPanels: l }) => {
    let a;
    if (ye(e)) {
      let [r, i] = e.map((u) => st(u).locale(t));
      return l || (i = r.add(n, o)), [r, i];
    } else e ? a = st(e) : a = st();
    return a = a.locale(t), [a, a.add(n, o)];
  }, b6 = (e, t, {
    columnIndexOffset: n,
    startDate: o,
    nextEndDate: l,
    now: a,
    unit: r,
    relativeDateGetter: i,
    setCellMetadata: u,
    setRowMetadata: c
  }) => {
    for (let d = 0; d < e.row; d++) {
      const f = t[d];
      for (let v = 0; v < e.column; v++) {
        let p = f[v + n];
        p || (p = {
          row: d,
          column: v,
          type: "normal",
          inRange: !1,
          start: !1,
          end: !1
        });
        const m = d * e.column + v, h = i(m);
        p.dayjs = h, p.date = h.toDate(), p.timestamp = h.valueOf(), p.type = "normal", p.inRange = !!(o && h.isSameOrAfter(o, r) && l && h.isSameOrBefore(l, r)) || !!(o && h.isSameOrBefore(o, r) && l && h.isSameOrAfter(l, r)), o != null && o.isSameOrAfter(l) ? (p.start = !!l && h.isSame(l, r), p.end = o && h.isSame(o, r)) : (p.start = !!o && h.isSame(o, r), p.end = !!l && h.isSame(l, r)), h.isSame(a, r) && (p.type = "today"), u == null || u(p, { rowIndex: d, columnIndex: v }), f[v + n] = p;
      }
      c == null || c(f);
    }
  }, Wc = (e, t, n, o) => {
    const l = st().locale(o).startOf("month").month(n).year(t).hour(e.hour()).minute(e.minute()).second(e.second()), a = l.daysInMonth();
    return Ea(a).map((r) => l.add(r, "day").toDate());
  }, cs = (e, t, n, o, l) => {
    const a = st().year(t).month(n).startOf("month").hour(e.hour()).minute(e.minute()).second(e.second()), r = Wc(e, t, n, o).find((i) => !(l != null && l(i)));
    return r ? st(r).locale(o) : a.locale(o);
  }, jc = (e, t, n) => {
    const o = e.year();
    if (!(n != null && n(e.toDate())))
      return e.locale(t);
    const l = e.month();
    if (!Wc(e, o, l, t).every(n))
      return cs(e, o, l, t, n);
    for (let a = 0; a < 12; a++)
      if (!Wc(e, o, a, t).every(n))
        return cs(e, o, a, t, n);
    return e;
  }, ds = (e, t, n, o) => {
    if (ye(e))
      return e.map((l) => ds(l, t, n, o));
    if (Ae(e)) {
      const l = o != null && o.value ? st(e) : st(e, t);
      if (!l.isValid())
        return l;
    }
    return st(e, t).locale(n);
  }, y6 = Te({
    ...Ah,
    showWeekNumber: Boolean,
    selectionMode: Lh("date")
  }), w6 = ["changerange", "pick", "select"], Uc = (e = "") => ["normal", "today"].includes(e), C6 = (e, t) => {
    const { lang: n } = _t(), o = A(), l = A(), a = A(), r = A(), i = A([[], [], [], [], [], []]);
    let u = !1;
    const c = e.date.$locale().weekStart || 7, d = e.date.locale("en").localeData().weekdaysShort().map((L) => L.toLowerCase()), f = S(() => c > 3 ? 7 - c : -c), v = S(() => {
      const L = e.date.startOf("month");
      return L.subtract(L.day() || 7, "day");
    }), p = S(() => d.concat(d).slice(c, c + 7)), m = S(() => S1(s(y)).some((L) => L.isCurrent)), h = S(() => {
      const L = e.date.startOf("month"), V = L.day() || 7, F = L.daysInMonth(), H = L.subtract(1, "month").daysInMonth();
      return {
        startOfMonthDay: V,
        dateCountOfMonth: F,
        dateCountOfLastMonth: H
      };
    }), g = S(() => e.selectionMode === "dates" ? Kn(e.parsedValue) : []), b = (L, { count: V, rowIndex: F, columnIndex: H }) => {
      const { startOfMonthDay: K, dateCountOfMonth: Z, dateCountOfLastMonth: J } = s(h), ie = s(f);
      if (F >= 0 && F <= 1) {
        const ue = K + ie < 0 ? 7 + K + ie : K + ie;
        if (H + F * 7 >= ue)
          return L.text = V, !0;
        L.text = J - (ue - H % 7) + 1 + F * 7, L.type = "prev-month";
      } else
        return V <= Z ? L.text = V : (L.text = V - Z, L.type = "next-month"), !0;
      return !1;
    }, C = (L, { columnIndex: V, rowIndex: F }, H) => {
      const { disabledDate: K, cellClassName: Z } = e, J = s(g), ie = b(L, { count: H, rowIndex: F, columnIndex: V }), ue = L.dayjs.toDate();
      return L.selected = J.find((re) => re.isSame(L.dayjs, "day")), L.isSelected = !!L.selected, L.isCurrent = k(L), L.disabled = K == null ? void 0 : K(ue), L.customClass = Z == null ? void 0 : Z(ue), ie;
    }, w = (L) => {
      if (e.selectionMode === "week") {
        const [V, F] = e.showWeekNumber ? [1, 7] : [0, 6], H = D(L[V + 1]);
        L[V].inRange = H, L[V].start = H, L[F].inRange = H, L[F].end = H;
      }
    }, y = S(() => {
      const { minDate: L, maxDate: V, rangeState: F, showWeekNumber: H } = e, K = s(f), Z = s(i), J = "day";
      let ie = 1;
      if (b6({ row: 6, column: 7 }, Z, {
        startDate: L,
        columnIndexOffset: H ? 1 : 0,
        nextEndDate: F.endDate || V || F.selecting && L || null,
        now: st().locale(s(n)).startOf(J),
        unit: J,
        relativeDateGetter: (ue) => s(v).add(ue - K, J),
        setCellMetadata: (...ue) => {
          C(...ue, ie) && (ie += 1);
        },
        setRowMetadata: w
      }), H)
        for (let ue = 0; ue < 6; ue++)
          Z[ue][1].dayjs && (Z[ue][0] = {
            type: "week",
            text: Z[ue][1].dayjs.week()
          });
      return Z;
    });
    de(() => e.date, async () => {
      var L;
      (L = s(o)) != null && L.contains(document.activeElement) && (await Re(), await E());
    });
    const E = async () => {
      var L;
      return (L = s(l)) == null ? void 0 : L.focus();
    }, k = (L) => e.selectionMode === "date" && Uc(L.type) && T(L, e.parsedValue), T = (L, V) => V ? st(V).locale(s(n)).isSame(e.date.date(Number(L.text)), "day") : !1, x = (L, V) => {
      const F = L * 7 + (V - (e.showWeekNumber ? 1 : 0)) - s(f);
      return s(v).add(F, "day");
    }, I = (L) => {
      var V;
      if (!e.rangeState.selecting)
        return;
      let F = L.target;
      if (F.tagName === "SPAN" && (F = (V = F.parentNode) == null ? void 0 : V.parentNode), F.tagName === "DIV" && (F = F.parentNode), F.tagName !== "TD")
        return;
      const H = F.parentNode.rowIndex - 1, K = F.cellIndex;
      s(y)[H][K].disabled || (H !== s(a) || K !== s(r)) && (a.value = H, r.value = K, t("changerange", {
        selecting: !0,
        endDate: x(H, K)
      }));
    }, P = (L) => !s(m) && (L == null ? void 0 : L.text) === 1 && Uc(L.type) || L.isCurrent, O = (L) => {
      u || s(m) || e.selectionMode !== "date" || R(L, !0);
    }, N = (L) => {
      L.target.closest("td") && (u = !0);
    }, z = (L) => {
      L.target.closest("td") && (u = !1);
    }, Y = (L) => {
      !e.rangeState.selecting || !e.minDate ? (t("pick", { minDate: L, maxDate: null }), t("select", !0)) : (L >= e.minDate ? t("pick", { minDate: e.minDate, maxDate: L }) : t("pick", { minDate: L, maxDate: e.minDate }), t("select", !1));
    }, G = (L) => {
      const V = L.week(), F = `${L.year()}w${V}`;
      t("pick", {
        year: L.year(),
        week: V,
        value: F,
        date: L.startOf("week")
      });
    }, M = (L, V) => {
      const F = V ? Kn(e.parsedValue).filter((H) => (H == null ? void 0 : H.valueOf()) !== L.valueOf()) : Kn(e.parsedValue).concat([L]);
      t("pick", F);
    }, R = (L, V = !1) => {
      if (e.disabled)
        return;
      const F = L.target.closest("td");
      if (!F)
        return;
      const H = F.parentNode.rowIndex - 1, K = F.cellIndex, Z = s(y)[H][K];
      if (Z.disabled || Z.type === "week")
        return;
      const J = x(H, K);
      switch (e.selectionMode) {
        case "range": {
          Y(J);
          break;
        }
        case "date": {
          t("pick", J, V);
          break;
        }
        case "week": {
          G(J);
          break;
        }
        case "dates": {
          M(J, !!Z.selected);
          break;
        }
      }
    }, D = (L) => {
      if (e.selectionMode !== "week")
        return !1;
      let V = e.date.startOf("day");
      if (L.type === "prev-month" && (V = V.subtract(1, "month")), L.type === "next-month" && (V = V.add(1, "month")), V = V.date(Number.parseInt(L.text, 10)), e.parsedValue && !ye(e.parsedValue)) {
        const F = (e.parsedValue.day() - c + 7) % 7 - 1;
        return e.parsedValue.subtract(F, "day").isSame(V, "day");
      }
      return !1;
    };
    return {
      WEEKS: p,
      rows: y,
      tbodyRef: o,
      currentCellRef: l,
      focus: E,
      isCurrent: k,
      isWeekActive: D,
      isSelectedCell: P,
      handlePickDate: R,
      handleMouseUp: z,
      handleMouseDown: N,
      handleMouseMove: I,
      handleFocus: O
    };
  }, S6 = (e, {
    isCurrent: t,
    isWeekActive: n
  }) => {
    const o = he("date-table"), { t: l } = _t(), a = S(() => [
      o.b(),
      o.is("week-mode", e.selectionMode === "week" && !e.disabled)
    ]), r = S(() => l("el.datepicker.dateTablePrompt")), i = (c) => {
      const d = [];
      return Uc(c.type) && !c.disabled ? (d.push("available"), c.type === "today" && d.push("today")) : d.push(c.type), t(c) && d.push("current"), c.inRange && (Uc(c.type) || e.selectionMode === "week") && (d.push("in-range"), c.start && d.push("start-date"), c.end && d.push("end-date")), (c.disabled || e.disabled) && d.push("disabled"), c.selected && d.push("selected"), c.customClass && d.push(c.customClass), d.join(" ");
    }, u = (c) => [
      o.e("row"),
      { current: n(c) }
    ];
    return {
      tableKls: a,
      tableLabel: r,
      weekHeaderClass: o.e("week-header"),
      getCellClasses: i,
      getRowKls: u,
      t: l
    };
  }, E6 = Te({
    cell: {
      type: X(Object)
    }
  });
  var Bh = /* @__PURE__ */ U({
    name: "ElDatePickerCell",
    props: E6,
    setup(e) {
      const t = he("date-table-cell"), {
        slots: n
      } = Ve(Dh);
      return () => {
        const {
          cell: o
        } = e;
        return ee(n, "default", {
          ...o
        }, () => {
          var l;
          return [q("div", {
            class: t.b()
          }, [q("span", {
            class: t.e("text")
          }, [(l = o == null ? void 0 : o.renderText) != null ? l : o == null ? void 0 : o.text])])];
        });
      };
    }
  });
  const k6 = /* @__PURE__ */ U({
    __name: "basic-date-table",
    props: y6,
    emits: w6,
    setup(e, { expose: t, emit: n }) {
      const o = e, {
        WEEKS: l,
        rows: a,
        tbodyRef: r,
        currentCellRef: i,
        focus: u,
        isCurrent: c,
        isWeekActive: d,
        isSelectedCell: f,
        handlePickDate: v,
        handleMouseUp: p,
        handleMouseDown: m,
        handleMouseMove: h,
        handleFocus: g
      } = C6(o, n), { tableLabel: b, tableKls: C, getCellClasses: w, getRowKls: y, weekHeaderClass: E, t: k } = S6(o, {
        isCurrent: c,
        isWeekActive: d
      });
      let T = !1;
      return Bt(() => {
        T = !0;
      }), t({
        focus: u
      }), (x, I) => (_(), B("table", {
        "aria-label": s(b),
        class: $(s(C)),
        cellspacing: "0",
        cellpadding: "0",
        role: "grid",
        onClick: s(v),
        onMousemove: s(h),
        onMousedown: s(m),
        onMouseup: s(p)
      }, [
        W("tbody", {
          ref_key: "tbodyRef",
          ref: r
        }, [
          W("tr", null, [
            x.showWeekNumber ? (_(), B("th", {
              key: 0,
              scope: "col",
              class: $(s(E))
            }, null, 2)) : oe("v-if", !0),
            (_(!0), B(We, null, bt(s(l), (P, O) => (_(), B("th", {
              key: O,
              "aria-label": s(k)("el.datepicker.weeksFull." + P),
              scope: "col"
            }, ke(s(k)("el.datepicker.weeks." + P)), 9, ["aria-label"]))), 128))
          ]),
          (_(!0), B(We, null, bt(s(a), (P, O) => (_(), B("tr", {
            key: O,
            class: $(s(y)(x.showWeekNumber ? P[2] : P[1]))
          }, [
            (_(!0), B(We, null, bt(P, (N, z) => (_(), B("td", {
              key: `${O}.${z}`,
              ref_for: !0,
              ref: (Y) => !s(T) && s(f)(N) && (i.value = Y),
              class: $(s(w)(N)),
              "aria-current": N.isCurrent ? "date" : void 0,
              "aria-selected": N.isCurrent,
              tabindex: s(f)(N) ? 0 : -1,
              onFocus: s(g)
            }, [
              q(s(Bh), { cell: N }, null, 8, ["cell"])
            ], 42, ["aria-current", "aria-selected", "tabindex", "onFocus"]))), 128))
          ], 2))), 128))
        ], 512)
      ], 42, ["aria-label", "onClick", "onMousemove", "onMousedown", "onMouseup"]));
    }
  });
  var Pp = /* @__PURE__ */ Ne(k6, [["__file", "basic-date-table.vue"]]);
  const _6 = Te({
    ...Ah,
    selectionMode: Lh("month")
  }), T6 = /* @__PURE__ */ U({
    __name: "basic-month-table",
    props: _6,
    emits: ["changerange", "pick", "select"],
    setup(e, { expose: t, emit: n }) {
      const o = e, l = he("month-table"), { t: a, lang: r } = _t(), i = A(), u = A(), c = A(o.date.locale("en").localeData().monthsShort().map((w) => w.toLowerCase())), d = A([[], [], []]), f = A(), v = A(), p = S(() => {
        var w, y, E;
        const k = d.value, T = st().locale(r.value).startOf("month");
        for (let x = 0; x < 3; x++) {
          const I = k[x];
          for (let P = 0; P < 4; P++) {
            const O = I[P] || (I[P] = {
              row: x,
              column: P,
              type: "normal",
              inRange: !1,
              start: !1,
              end: !1,
              text: -1,
              disabled: !1,
              isSelected: !1,
              customClass: void 0,
              date: void 0,
              dayjs: void 0,
              isCurrent: void 0,
              selected: void 0,
              renderText: void 0,
              timestamp: void 0
            });
            O.type = "normal";
            const N = x * 4 + P, z = o.date.startOf("year").month(N), Y = o.rangeState.endDate || o.maxDate || o.rangeState.selecting && o.minDate || null;
            O.inRange = !!(o.minDate && z.isSameOrAfter(o.minDate, "month") && Y && z.isSameOrBefore(Y, "month")) || !!(o.minDate && z.isSameOrBefore(o.minDate, "month") && Y && z.isSameOrAfter(Y, "month")), (w = o.minDate) != null && w.isSameOrAfter(Y) ? (O.start = !!(Y && z.isSame(Y, "month")), O.end = o.minDate && z.isSame(o.minDate, "month")) : (O.start = !!(o.minDate && z.isSame(o.minDate, "month")), O.end = !!(Y && z.isSame(Y, "month"))), T.isSame(z) && (O.type = "today");
            const M = z.toDate();
            O.text = N, O.disabled = ((y = o.disabledDate) == null ? void 0 : y.call(o, M)) || !1, O.date = M, O.customClass = (E = o.cellClassName) == null ? void 0 : E.call(o, M), O.dayjs = z, O.timestamp = z.valueOf(), O.isSelected = g(O);
          }
        }
        return k;
      }), m = () => {
        var w;
        (w = u.value) == null || w.focus();
      }, h = (w) => {
        const y = {}, E = o.date.year(), k = /* @__PURE__ */ new Date(), T = w.text;
        return y.disabled = o.disabled || (o.disabledDate ? Wc(o.date, E, T, r.value).every(o.disabledDate) : !1), y.current = Kn(o.parsedValue).some((x) => st.isDayjs(x) && x.year() === E && x.month() === T), y.today = k.getFullYear() === E && k.getMonth() === T, w.customClass && (y[w.customClass] = !0), w.inRange && (y["in-range"] = !0, w.start && (y["start-date"] = !0), w.end && (y["end-date"] = !0)), y;
      }, g = (w) => {
        const y = o.date.year(), E = w.text;
        return Kn(o.date).some((k) => k.year() === y && k.month() === E);
      }, b = (w) => {
        var y;
        if (!o.rangeState.selecting)
          return;
        let E = w.target;
        if (E.tagName === "SPAN" && (E = (y = E.parentNode) == null ? void 0 : y.parentNode), E.tagName === "DIV" && (E = E.parentNode), E.tagName !== "TD")
          return;
        const k = E.parentNode.rowIndex, T = E.cellIndex;
        p.value[k][T].disabled || (k !== f.value || T !== v.value) && (f.value = k, v.value = T, n("changerange", {
          selecting: !0,
          endDate: o.date.startOf("year").month(k * 4 + T)
        }));
      }, C = (w) => {
        var y;
        if (o.disabled)
          return;
        const E = (y = w.target) == null ? void 0 : y.closest("td");
        if ((E == null ? void 0 : E.tagName) !== "TD" || Lo(E, "disabled"))
          return;
        const k = E.cellIndex, x = E.parentNode.rowIndex * 4 + k, I = o.date.startOf("year").month(x);
        if (o.selectionMode === "months") {
          if (w.type === "keydown") {
            n("pick", Kn(o.parsedValue), !1);
            return;
          }
          const P = cs(o.date, o.date.year(), x, r.value, o.disabledDate), O = Lo(E, "current") ? Kn(o.parsedValue).filter((N) => (N == null ? void 0 : N.year()) !== P.year() || (N == null ? void 0 : N.month()) !== P.month()) : Kn(o.parsedValue).concat([st(P)]);
          n("pick", O);
        } else o.selectionMode === "range" ? o.rangeState.selecting ? (o.minDate && I >= o.minDate ? n("pick", { minDate: o.minDate, maxDate: I }) : n("pick", { minDate: I, maxDate: o.minDate }), n("select", !1)) : (n("pick", { minDate: I, maxDate: null }), n("select", !0)) : n("pick", x);
      };
      return de(() => o.date, async () => {
        var w, y;
        (w = i.value) != null && w.contains(document.activeElement) && (await Re(), (y = u.value) == null || y.focus());
      }), t({
        focus: m
      }), (w, y) => (_(), B("table", {
        role: "grid",
        "aria-label": s(a)("el.datepicker.monthTablePrompt"),
        class: $(s(l).b()),
        onClick: C,
        onMousemove: b
      }, [
        W("tbody", {
          ref_key: "tbodyRef",
          ref: i
        }, [
          (_(!0), B(We, null, bt(s(p), (E, k) => (_(), B("tr", { key: k }, [
            (_(!0), B(We, null, bt(E, (T, x) => (_(), B("td", {
              key: x,
              ref_for: !0,
              ref: (I) => T.isSelected && (u.value = I),
              class: $(h(T)),
              "aria-selected": !!T.isSelected,
              "aria-label": s(a)(`el.datepicker.month${+T.text + 1}`),
              tabindex: T.isSelected ? 0 : -1,
              onKeydown: [
                on(Ze(C, ["prevent", "stop"]), ["space"]),
                on(Ze(C, ["prevent", "stop"]), ["enter"])
              ]
            }, [
              q(s(Bh), {
                cell: {
                  ...T,
                  renderText: s(a)("el.datepicker.months." + c.value[T.text])
                }
              }, null, 8, ["cell"])
            ], 42, ["aria-selected", "aria-label", "tabindex", "onKeydown"]))), 128))
          ]))), 128))
        ], 512)
      ], 42, ["aria-label"]));
    }
  });
  var $i = /* @__PURE__ */ Ne(T6, [["__file", "basic-month-table.vue"]]);
  const N6 = Te({
    ...Ah,
    selectionMode: Lh("year")
  }), $6 = /* @__PURE__ */ U({
    __name: "basic-year-table",
    props: N6,
    emits: ["changerange", "pick", "select"],
    setup(e, { expose: t, emit: n }) {
      const o = e, l = (y, E) => {
        const k = st(String(y)).locale(E).startOf("year"), x = k.endOf("year").dayOfYear();
        return Ea(x).map((I) => k.add(I, "day").toDate());
      }, a = he("year-table"), { t: r, lang: i } = _t(), u = A(), c = A(), d = S(() => Math.floor(o.date.year() / 10) * 10), f = A([[], [], []]), v = A(), p = A(), m = S(() => {
        var y, E, k;
        const T = f.value, x = st().locale(i.value).startOf("year");
        for (let I = 0; I < 3; I++) {
          const P = T[I];
          for (let O = 0; O < 4 && !(I * 4 + O >= 10); O++) {
            let N = P[O];
            N || (N = {
              row: I,
              column: O,
              type: "normal",
              inRange: !1,
              start: !1,
              end: !1,
              text: -1,
              disabled: !1,
              isSelected: !1,
              customClass: void 0,
              date: void 0,
              dayjs: void 0,
              isCurrent: void 0,
              selected: void 0,
              renderText: void 0,
              timestamp: void 0
            }), N.type = "normal";
            const z = I * 4 + O + d.value, Y = st().year(z), G = o.rangeState.endDate || o.maxDate || o.rangeState.selecting && o.minDate || null;
            N.inRange = !!(o.minDate && Y.isSameOrAfter(o.minDate, "year") && G && Y.isSameOrBefore(G, "year")) || !!(o.minDate && Y.isSameOrBefore(o.minDate, "year") && G && Y.isSameOrAfter(G, "year")), (y = o.minDate) != null && y.isSameOrAfter(G) ? (N.start = !!(G && Y.isSame(G, "year")), N.end = !!(o.minDate && Y.isSame(o.minDate, "year"))) : (N.start = !!(o.minDate && Y.isSame(o.minDate, "year")), N.end = !!(G && Y.isSame(G, "year"))), x.isSame(Y) && (N.type = "today"), N.text = z;
            const R = Y.toDate();
            N.disabled = ((E = o.disabledDate) == null ? void 0 : E.call(o, R)) || !1, N.date = R, N.customClass = (k = o.cellClassName) == null ? void 0 : k.call(o, R), N.dayjs = Y, N.timestamp = Y.valueOf(), N.isSelected = b(N), P[O] = N;
          }
        }
        return T;
      }), h = () => {
        var y;
        (y = c.value) == null || y.focus();
      }, g = (y) => {
        const E = {}, k = st().locale(i.value), T = y.text;
        return E.disabled = o.disabled || (o.disabledDate ? l(T, i.value).every(o.disabledDate) : !1), E.today = k.year() === T, E.current = Kn(o.parsedValue).some((x) => x.year() === T), y.customClass && (E[y.customClass] = !0), y.inRange && (E["in-range"] = !0, y.start && (E["start-date"] = !0), y.end && (E["end-date"] = !0)), E;
      }, b = (y) => {
        const E = y.text;
        return Kn(o.date).some((k) => k.year() === E);
      }, C = (y) => {
        var E;
        if (o.disabled)
          return;
        const k = (E = y.target) == null ? void 0 : E.closest("td");
        if (!k || !k.textContent || Lo(k, "disabled"))
          return;
        const T = k.cellIndex, I = k.parentNode.rowIndex * 4 + T + d.value, P = st().year(I);
        if (o.selectionMode === "range")
          o.rangeState.selecting ? (o.minDate && P >= o.minDate ? n("pick", { minDate: o.minDate, maxDate: P }) : n("pick", { minDate: P, maxDate: o.minDate }), n("select", !1)) : (n("pick", { minDate: P, maxDate: null }), n("select", !0));
        else if (o.selectionMode === "years") {
          if (y.type === "keydown") {
            n("pick", Kn(o.parsedValue), !1);
            return;
          }
          const O = jc(P.startOf("year"), i.value, o.disabledDate), N = Lo(k, "current") ? Kn(o.parsedValue).filter((z) => (z == null ? void 0 : z.year()) !== I) : Kn(o.parsedValue).concat([O]);
          n("pick", N);
        } else
          n("pick", I);
      }, w = (y) => {
        var E;
        if (!o.rangeState.selecting)
          return;
        const k = (E = y.target) == null ? void 0 : E.closest("td");
        if (!k)
          return;
        const T = k.parentNode.rowIndex, x = k.cellIndex;
        m.value[T][x].disabled || (T !== v.value || x !== p.value) && (v.value = T, p.value = x, n("changerange", {
          selecting: !0,
          endDate: st().year(d.value).add(T * 4 + x, "year")
        }));
      };
      return de(() => o.date, async () => {
        var y, E;
        (y = u.value) != null && y.contains(document.activeElement) && (await Re(), (E = c.value) == null || E.focus());
      }), t({
        focus: h
      }), (y, E) => (_(), B("table", {
        role: "grid",
        "aria-label": s(r)("el.datepicker.yearTablePrompt"),
        class: $(s(a).b()),
        onClick: C,
        onMousemove: w
      }, [
        W("tbody", {
          ref_key: "tbodyRef",
          ref: u
        }, [
          (_(!0), B(We, null, bt(s(m), (k, T) => (_(), B("tr", { key: T }, [
            (_(!0), B(We, null, bt(k, (x, I) => (_(), B("td", {
              key: `${T}_${I}`,
              ref_for: !0,
              ref: (P) => x.isSelected && (c.value = P),
              class: $(["available", g(x)]),
              "aria-selected": x.isSelected,
              "aria-label": String(x.text),
              tabindex: x.isSelected ? 0 : -1,
              onKeydown: [
                on(Ze(C, ["prevent", "stop"]), ["space"]),
                on(Ze(C, ["prevent", "stop"]), ["enter"])
              ]
            }, [
              q(s(Bh), { cell: x }, null, 8, ["cell"])
            ], 42, ["aria-selected", "aria-label", "tabindex", "onKeydown"]))), 128))
          ]))), 128))
        ], 512)
      ], 42, ["aria-label"]));
    }
  });
  var Oi = /* @__PURE__ */ Ne($6, [["__file", "basic-year-table.vue"]]);
  const O6 = /* @__PURE__ */ U({
    __name: "panel-date-pick",
    props: g6,
    emits: ["pick", "set-picker-option", "panel-change"],
    setup(e, { emit: t }) {
      const n = e, o = (fe, He, Qe) => !0, l = he("picker-panel"), a = he("date-picker"), r = ea(), i = hn(), { t: u, lang: c } = _t(), d = Ve(Xo), f = Ve(cu, void 0), { shortcuts: v, disabledDate: p, cellClassName: m, defaultTime: h } = d.props, g = At(d.props, "defaultValue"), b = A(), C = A(st().locale(c.value)), w = A(!1);
      let y = !1;
      const E = S(() => st(h).locale(c.value)), k = S(() => C.value.month()), T = S(() => C.value.year()), x = A([]), I = A(null), P = A(null), O = (fe) => x.value.length > 0 ? o(fe, x.value, n.format || "HH:mm:ss") : !0, N = (fe) => h && !ge.value && !w.value && !y ? E.value.year(fe.year()).month(fe.month()).date(fe.date()) : ue.value ? fe.millisecond(0) : fe.startOf("day"), z = (fe, ...He) => {
        if (!fe)
          t("pick", fe, ...He);
        else if (ye(fe)) {
          const Qe = fe.map(N);
          t("pick", Qe, ...He);
        } else
          t("pick", N(fe), ...He);
        I.value = null, P.value = null, w.value = !1, y = !1;
      }, Y = async (fe, He) => {
        if (V.value === "date" && st.isDayjs(fe)) {
          const Qe = Vs(n.parsedValue);
          let ve = Qe ? Qe.year(fe.year()).month(fe.month()).date(fe.date()) : fe;
          O(ve), C.value = ve, z(ve, ue.value || He);
        } else V.value === "week" ? z(fe.date) : V.value === "dates" && z(fe, !0);
      }, G = (fe) => {
        const He = fe ? "add" : "subtract";
        C.value = C.value[He](1, "month"), tt("month");
      }, M = (fe) => {
        const He = C.value, Qe = fe ? "add" : "subtract";
        C.value = R.value === "year" ? He[Qe](10, "year") : He[Qe](1, "year"), tt("year");
      }, R = A("date"), D = S(() => {
        const fe = u("el.datepicker.year");
        if (R.value === "year") {
          const He = Math.floor(T.value / 10) * 10;
          return fe ? `${He} ${fe} - ${He + 9} ${fe}` : `${He} - ${He + 9}`;
        }
        return `${T.value} ${fe}`;
      }), L = (fe) => {
        const He = Fe(fe.value) ? fe.value() : fe.value;
        if (He) {
          y = !0, z(st(He).locale(c.value));
          return;
        }
        fe.onClick && fe.onClick({
          attrs: r,
          slots: i,
          emit: t
        });
      }, V = S(() => {
        const { type: fe } = n;
        return ["week", "month", "months", "year", "years", "dates"].includes(fe) ? fe : "date";
      }), F = S(() => V.value === "dates" || V.value === "months" || V.value === "years"), H = S(() => V.value === "date" ? R.value : V.value), K = S(() => !!v.length), Z = async (fe, He) => {
        V.value === "month" ? (C.value = cs(C.value, C.value.year(), fe, c.value, p), z(C.value, !1)) : V.value === "months" ? z(fe, He ?? !0) : (C.value = cs(C.value, C.value.year(), fe, c.value, p), R.value = "date", ["month", "year", "date", "week"].includes(V.value) && (z(C.value, !0), await Re(), Xe())), tt("month");
      }, J = async (fe, He) => {
        if (V.value === "year") {
          const Qe = C.value.startOf("year").year(fe);
          C.value = jc(Qe, c.value, p), z(C.value, !1);
        } else if (V.value === "years")
          z(fe, He ?? !0);
        else {
          const Qe = C.value.year(fe);
          C.value = jc(Qe, c.value, p), R.value = "month", ["month", "year", "date", "week"].includes(V.value) && (z(C.value, !0), await Re(), Xe());
        }
        tt("year");
      }, ie = async (fe) => {
        n.disabled || (R.value = fe, await Re(), Xe());
      }, ue = S(() => n.type === "datetime" || n.type === "datetimerange"), re = S(() => {
        const fe = ue.value || V.value === "dates", He = V.value === "years", Qe = V.value === "months", ve = R.value === "date", Ke = R.value === "year", St = R.value === "month";
        return fe && ve || He && Ke || Qe && St;
      }), se = S(() => !F.value && n.showNow || n.showConfirm), ne = S(() => p ? n.parsedValue ? ye(n.parsedValue) ? p(n.parsedValue[0].toDate()) : p(n.parsedValue.toDate()) : !0 : !1), le = () => {
        if (F.value)
          z(n.parsedValue);
        else {
          let fe = Vs(n.parsedValue);
          if (!fe) {
            const He = st(h).locale(c.value), Qe = Le();
            fe = He.year(Qe.year()).month(Qe.month()).date(Qe.date());
          }
          C.value = fe, z(fe);
        }
      }, Ce = S(() => p ? p(st().locale(c.value).toDate()) : !1), j = () => {
        const He = st().locale(c.value).toDate();
        w.value = !0, (!p || !p(He)) && O(He) && (C.value = st().locale(c.value), z(C.value));
      }, te = S(() => n.timeFormat || fS(n.format) || us), ce = S(() => n.dateFormat || dS(n.format) || ga), ge = S(() => P.value ? P.value : !n.parsedValue && !g.value ? void 0 : (Vs(n.parsedValue) || C.value).format(te.value)), be = S(() => I.value ? I.value : !n.parsedValue && !g.value ? void 0 : (Vs(n.parsedValue) || C.value).format(ce.value)), Ee = A(!1), Oe = () => {
        Ee.value = !0;
      }, De = () => {
        Ee.value = !1;
      }, we = (fe) => ({
        hour: fe.hour(),
        minute: fe.minute(),
        second: fe.second(),
        year: fe.year(),
        month: fe.month(),
        date: fe.date()
      }), me = (fe, He, Qe) => {
        const { hour: ve, minute: Ke, second: St } = we(fe), Ft = Vs(n.parsedValue), Se = Ft ? Ft.hour(ve).minute(Ke).second(St) : fe;
        C.value = Se, z(C.value, !0), Qe || (Ee.value = He);
      }, Pe = (fe) => {
        const He = st(fe, te.value).locale(c.value);
        if (He.isValid() && O(He)) {
          const { year: Qe, month: ve, date: Ke } = we(C.value);
          C.value = He.year(Qe).month(ve).date(Ke), P.value = null, Ee.value = !1, z(C.value, !0);
        }
      }, Me = (fe) => {
        const He = ds(fe, ce.value, c.value, f);
        if (He.isValid()) {
          if (p && p(He.toDate()))
            return;
          const { hour: Qe, minute: ve, second: Ke } = we(C.value);
          C.value = He.hour(Qe).minute(ve).second(Ke), I.value = null, z(C.value, !0);
        }
      }, Be = (fe) => st.isDayjs(fe) && fe.isValid() && (p ? !p(fe.toDate()) : !0), pe = (fe) => ds(fe, n.format, c.value, f), Le = () => {
        const fe = st(g.value).locale(c.value);
        if (!g.value) {
          const He = E.value;
          return st().hour(He.hour()).minute(He.minute()).second(He.second()).locale(c.value);
        }
        return fe;
      }, Xe = () => {
        var fe;
        ["week", "month", "year", "date"].includes(V.value) && ((fe = b.value) == null || fe.focus());
      }, ut = () => {
        Xe(), V.value === "week" && Ye(_e.down);
      }, Nt = (fe) => {
        const He = Ht(fe);
        [
          _e.up,
          _e.down,
          _e.left,
          _e.right,
          _e.home,
          _e.end,
          _e.pageUp,
          _e.pageDown
        ].includes(He) && (Ye(He), fe.stopPropagation(), fe.preventDefault()), [_e.enter, _e.space, _e.numpadEnter].includes(He) && I.value === null && P.value === null && (fe.preventDefault(), z(C.value, !1));
      }, Ye = (fe) => {
        var He;
        const { up: Qe, down: ve, left: Ke, right: St, home: Ft, end: Se, pageUp: Je, pageDown: lt } = _e, Yt = {
          year: {
            [Qe]: -4,
            [ve]: 4,
            [Ke]: -1,
            [St]: 1,
            offset: (xe, wt) => xe.setFullYear(xe.getFullYear() + wt)
          },
          month: {
            [Qe]: -4,
            [ve]: 4,
            [Ke]: -1,
            [St]: 1,
            offset: (xe, wt) => xe.setMonth(xe.getMonth() + wt)
          },
          week: {
            [Qe]: -1,
            [ve]: 1,
            [Ke]: -1,
            [St]: 1,
            offset: (xe, wt) => xe.setDate(xe.getDate() + wt * 7)
          },
          date: {
            [Qe]: -7,
            [ve]: 7,
            [Ke]: -1,
            [St]: 1,
            [Ft]: (xe) => -xe.getDay(),
            [Se]: (xe) => -xe.getDay() + 6,
            [Je]: (xe) => -new Date(xe.getFullYear(), xe.getMonth(), 0).getDate(),
            [lt]: (xe) => new Date(xe.getFullYear(), xe.getMonth() + 1, 0).getDate(),
            offset: (xe, wt) => xe.setDate(xe.getDate() + wt)
          }
        }, $n = C.value.toDate();
        for (; Math.abs(C.value.diff($n, "year", !0)) < 1; ) {
          const xe = Yt[H.value];
          if (!xe)
            return;
          if (xe.offset($n, Fe(xe[fe]) ? xe[fe]($n) : (He = xe[fe]) != null ? He : 0), p && p($n))
            break;
          const wt = st($n).locale(c.value);
          C.value = wt, t("pick", wt, !0);
          break;
        }
      }, tt = (fe) => {
        t("panel-change", C.value.toDate(), fe, R.value);
      };
      return de(() => V.value, (fe) => {
        if (["month", "year"].includes(fe)) {
          R.value = fe;
          return;
        } else if (fe === "years") {
          R.value = "year";
          return;
        } else if (fe === "months") {
          R.value = "month";
          return;
        }
        R.value = "date";
      }, { immediate: !0 }), de(() => g.value, (fe) => {
        fe && (C.value = Le());
      }, { immediate: !0 }), de(() => n.parsedValue, (fe) => {
        if (fe) {
          if (F.value || ye(fe))
            return;
          C.value = fe;
        } else
          C.value = Le();
      }, { immediate: !0 }), t("set-picker-option", ["isValidValue", Be]), t("set-picker-option", ["parseUserInput", pe]), t("set-picker-option", ["handleFocusPicker", ut]), (fe, He) => (_(), B("div", {
        class: $([
          s(l).b(),
          s(a).b(),
          s(l).is("border", fe.border),
          s(l).is("disabled", fe.disabled),
          {
            "has-sidebar": fe.$slots.sidebar || s(K),
            "has-time": s(ue)
          }
        ])
      }, [
        W("div", {
          class: $(s(l).e("body-wrapper"))
        }, [
          ee(fe.$slots, "sidebar", {
            class: $(s(l).e("sidebar"))
          }),
          s(K) ? (_(), B("div", {
            key: 0,
            class: $(s(l).e("sidebar"))
          }, [
            (_(!0), B(We, null, bt(s(v), (Qe, ve) => (_(), B("button", {
              key: ve,
              type: "button",
              disabled: fe.disabled,
              class: $(s(l).e("shortcut")),
              onClick: (Ke) => L(Qe)
            }, ke(Qe.text), 11, ["disabled", "onClick"]))), 128))
          ], 2)) : oe("v-if", !0),
          W("div", {
            class: $(s(l).e("body"))
          }, [
            s(ue) ? (_(), B("div", {
              key: 0,
              class: $(s(a).e("time-header"))
            }, [
              W("span", {
                class: $(s(a).e("editor-wrap"))
              }, [
                q(s(Wn), {
                  placeholder: s(u)("el.datepicker.selectDate"),
                  "model-value": s(be),
                  size: "small",
                  "validate-event": !1,
                  disabled: fe.disabled,
                  onInput: (Qe) => I.value = Qe,
                  onChange: Me
                }, null, 8, ["placeholder", "model-value", "disabled", "onInput"])
              ], 2),
              it((_(), B("span", {
                class: $(s(a).e("editor-wrap"))
              }, [
                q(s(Wn), {
                  placeholder: s(u)("el.datepicker.selectTime"),
                  "model-value": s(ge),
                  size: "small",
                  "validate-event": !1,
                  disabled: fe.disabled,
                  onFocus: Oe,
                  onInput: (Qe) => P.value = Qe,
                  onChange: Pe
                }, null, 8, ["placeholder", "model-value", "disabled", "onInput"]),
                q(s(Kc), {
                  visible: Ee.value,
                  format: s(te),
                  "parsed-value": C.value,
                  onPick: me
                }, null, 8, ["visible", "format", "parsed-value"])
              ], 2)), [
                [s(Jl), De]
              ])
            ], 2)) : oe("v-if", !0),
            it(W("div", {
              class: $([
                s(a).e("header"),
                (R.value === "year" || R.value === "month") && s(a).em("header", "bordered")
              ])
            }, [
              W("span", {
                class: $(s(a).e("prev-btn"))
              }, [
                W("button", {
                  type: "button",
                  "aria-label": s(u)("el.datepicker.prevYear"),
                  class: $(["d-arrow-left", s(l).e("icon-btn")]),
                  disabled: fe.disabled,
                  onClick: (Qe) => M(!1)
                }, [
                  ee(fe.$slots, "prev-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Oa))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["aria-label", "disabled", "onClick"]),
                it(W("button", {
                  type: "button",
                  "aria-label": s(u)("el.datepicker.prevMonth"),
                  class: $([s(l).e("icon-btn"), "arrow-left"]),
                  disabled: fe.disabled,
                  onClick: (Qe) => G(!1)
                }, [
                  ee(fe.$slots, "prev-month", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(ql))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["aria-label", "disabled", "onClick"]), [
                  [Mt, R.value === "date"]
                ])
              ], 2),
              W("span", {
                role: "button",
                class: $(s(a).e("header-label")),
                "aria-live": "polite",
                tabindex: "0",
                onKeydown: on((Qe) => ie("year"), ["enter"]),
                onClick: (Qe) => ie("year")
              }, ke(s(D)), 43, ["onKeydown", "onClick"]),
              it(W("span", {
                role: "button",
                "aria-live": "polite",
                tabindex: "0",
                class: $([
                  s(a).e("header-label"),
                  { active: R.value === "month" }
                ]),
                onKeydown: on((Qe) => ie("month"), ["enter"]),
                onClick: (Qe) => ie("month")
              }, ke(s(u)(`el.datepicker.month${s(k) + 1}`)), 43, ["onKeydown", "onClick"]), [
                [Mt, R.value === "date"]
              ]),
              W("span", {
                class: $(s(a).e("next-btn"))
              }, [
                it(W("button", {
                  type: "button",
                  "aria-label": s(u)("el.datepicker.nextMonth"),
                  class: $([s(l).e("icon-btn"), "arrow-right"]),
                  disabled: fe.disabled,
                  onClick: (Qe) => G(!0)
                }, [
                  ee(fe.$slots, "next-month", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Un))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["aria-label", "disabled", "onClick"]), [
                  [Mt, R.value === "date"]
                ]),
                W("button", {
                  type: "button",
                  "aria-label": s(u)("el.datepicker.nextYear"),
                  class: $([s(l).e("icon-btn"), "d-arrow-right"]),
                  disabled: fe.disabled,
                  onClick: (Qe) => M(!0)
                }, [
                  ee(fe.$slots, "next-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Ia))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["aria-label", "disabled", "onClick"])
              ], 2)
            ], 2), [
              [Mt, R.value !== "time"]
            ]),
            W("div", {
              class: $(s(l).e("content")),
              onKeydown: Nt
            }, [
              R.value === "date" ? (_(), ae(Pp, {
                key: 0,
                ref_key: "currentViewRef",
                ref: b,
                "selection-mode": s(V),
                date: C.value,
                "parsed-value": fe.parsedValue,
                "disabled-date": s(p),
                disabled: fe.disabled,
                "cell-class-name": s(m),
                "show-week-number": fe.showWeekNumber,
                onPick: Y
              }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "disabled", "cell-class-name", "show-week-number"])) : oe("v-if", !0),
              R.value === "year" ? (_(), ae(Oi, {
                key: 1,
                ref_key: "currentViewRef",
                ref: b,
                "selection-mode": s(V),
                date: C.value,
                "disabled-date": s(p),
                disabled: fe.disabled,
                "parsed-value": fe.parsedValue,
                "cell-class-name": s(m),
                onPick: J
              }, null, 8, ["selection-mode", "date", "disabled-date", "disabled", "parsed-value", "cell-class-name"])) : oe("v-if", !0),
              R.value === "month" ? (_(), ae($i, {
                key: 2,
                ref_key: "currentViewRef",
                ref: b,
                "selection-mode": s(V),
                date: C.value,
                "parsed-value": fe.parsedValue,
                "disabled-date": s(p),
                disabled: fe.disabled,
                "cell-class-name": s(m),
                onPick: Z
              }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "disabled", "cell-class-name"])) : oe("v-if", !0)
            ], 34)
          ], 2)
        ], 2),
        fe.showFooter && s(re) && s(se) ? (_(), B("div", {
          key: 0,
          class: $(s(l).e("footer"))
        }, [
          it(q(s(_n), {
            text: "",
            size: "small",
            class: $(s(l).e("link-btn")),
            disabled: s(Ce),
            onClick: j
          }, {
            default: Q(() => [
              Ct(ke(s(u)("el.datepicker.now")), 1)
            ]),
            _: 1
          }, 8, ["class", "disabled"]), [
            [Mt, !s(F) && fe.showNow]
          ]),
          fe.showConfirm ? (_(), ae(s(_n), {
            key: 0,
            plain: "",
            size: "small",
            class: $(s(l).e("link-btn")),
            disabled: s(ne),
            onClick: le
          }, {
            default: Q(() => [
              Ct(ke(s(u)("el.datepicker.confirm")), 1)
            ]),
            _: 1
          }, 8, ["class", "disabled"])) : oe("v-if", !0)
        ], 2)) : oe("v-if", !0)
      ], 2));
    }
  });
  var I6 = /* @__PURE__ */ Ne(O6, [["__file", "panel-date-pick.vue"]]);
  const M6 = Te({
    ...vE,
    ...Vh
  }), x6 = (e) => {
    const { emit: t } = dt(), n = ea(), o = hn();
    return (a) => {
      const r = Fe(a.value) ? a.value() : a.value;
      if (r) {
        t("pick", [
          st(r[0]).locale(e.value),
          st(r[1]).locale(e.value)
        ]);
        return;
      }
      a.onClick && a.onClick({
        attrs: n,
        slots: o,
        emit: t
      });
    };
  }, Fh = (e, {
    defaultValue: t,
    defaultTime: n,
    leftDate: o,
    rightDate: l,
    step: a,
    unit: r,
    sortDates: i
  }) => {
    const { emit: u } = dt(), { pickerNs: c } = Ve(Dh), d = he("date-range-picker"), { t: f, lang: v } = _t(), p = x6(v), m = A(), h = A(), g = A({
      endDate: null,
      selecting: !1
    }), b = (k) => {
      g.value = k;
    }, C = (k = !1) => {
      const T = s(m), x = s(h);
      Ni([T, x]) && u("pick", [T, x], k);
    }, w = (k) => {
      g.value.selecting = k, k || (g.value.endDate = null);
    }, y = (k) => {
      if (ye(k) && k.length === 2) {
        const [T, x] = k;
        m.value = T, o.value = T, h.value = x, i(s(m), s(h));
      } else
        E();
    }, E = () => {
      let [k, T] = Kd(s(t), {
        lang: s(v),
        step: a,
        unit: r,
        unlinkPanels: e.unlinkPanels
      });
      const x = (P) => P.diff(P.startOf("d"), "ms"), I = s(n);
      if (I) {
        let P = 0, O = 0;
        if (ye(I)) {
          const [N, z] = I.map(st);
          P = x(N), O = x(z);
        } else {
          const N = x(st(I));
          P = N, O = N;
        }
        k = k.startOf("d").add(P, "ms"), T = T.startOf("d").add(O, "ms");
      }
      m.value = void 0, h.value = void 0, o.value = k, l.value = T;
    };
    return de(t, (k) => {
      k && E();
    }, { immediate: !0 }), de(() => e.parsedValue, (k) => {
      (!(k != null && k.length) || !ln(k, [m.value, h.value])) && y(k);
    }, {
      immediate: !0
    }), de(() => e.visible, () => {
      e.visible && y(e.parsedValue);
    }, { immediate: !0 }), {
      minDate: m,
      maxDate: h,
      rangeState: g,
      lang: v,
      ppNs: c,
      drpNs: d,
      handleChangeRange: b,
      handleRangeConfirm: C,
      handleShortcutClick: p,
      onSelect: w,
      parseValue: y,
      t: f
    };
  }, P6 = (e, t, n, o) => {
    const l = A("date"), a = A(), r = A("date"), i = A(), u = Ve(Xo), { disabledDate: c } = u.props, { t: d, lang: f } = _t(), v = S(() => n.value.year()), p = S(() => n.value.month()), m = S(() => o.value.year()), h = S(() => o.value.month());
    function g(k, T) {
      const x = d("el.datepicker.year");
      if (k.value === "year") {
        const I = Math.floor(T.value / 10) * 10;
        return x ? `${I} ${x} - ${I + 9} ${x}` : `${I} - ${I + 9}`;
      }
      return `${T.value} ${x}`;
    }
    function b(k) {
      k == null || k.focus();
    }
    async function C(k, T) {
      if (e.disabled)
        return;
      const x = k === "left" ? l : r, I = k === "left" ? a : i;
      x.value = T, await Re(), b(I.value);
    }
    async function w(k, T, x) {
      if (e.disabled)
        return;
      const I = T === "left", P = I ? n : o, O = I ? o : n, N = I ? l : r, z = I ? a : i;
      if (k === "year") {
        const Y = P.value.year(x);
        P.value = jc(Y, f.value, c);
      }
      k === "month" && (P.value = cs(P.value, P.value.year(), x, f.value, c)), e.unlinkPanels || (O.value = T === "left" ? P.value.add(1, "month") : P.value.subtract(1, "month")), N.value = k === "year" ? "month" : "date", await Re(), b(z.value), y(k);
    }
    function y(k) {
      t("panel-change", [n.value.toDate(), o.value.toDate()], k);
    }
    function E(k, T, x) {
      const I = x ? "add" : "subtract";
      return k === "year" ? T[I](10, "year") : T[I](1, "year");
    }
    return {
      leftCurrentView: l,
      rightCurrentView: r,
      leftCurrentViewRef: a,
      rightCurrentViewRef: i,
      leftYear: v,
      rightYear: m,
      leftMonth: p,
      rightMonth: h,
      leftYearLabel: S(() => g(l, v)),
      rightYearLabel: S(() => g(r, m)),
      showLeftPicker: (k) => C("left", k),
      showRightPicker: (k) => C("right", k),
      handleLeftYearPick: (k) => w("year", "left", k),
      handleRightYearPick: (k) => w("year", "right", k),
      handleLeftMonthPick: (k) => w("month", "left", k),
      handleRightMonthPick: (k) => w("month", "right", k),
      handlePanelChange: y,
      adjustDateByView: E
    };
  }, Vu = "month", R6 = /* @__PURE__ */ U({
    __name: "panel-date-range",
    props: M6,
    emits: [
      "pick",
      "set-picker-option",
      "calendar-change",
      "panel-change"
    ],
    setup(e, { emit: t }) {
      const n = e, o = Ve(Xo), l = Ve(cu, void 0), { disabledDate: a, cellClassName: r, defaultTime: i, clearable: u } = o.props, c = At(o.props, "format"), d = At(o.props, "shortcuts"), f = At(o.props, "defaultValue"), { lang: v } = _t(), p = A(st().locale(v.value)), m = A(st().locale(v.value).add(1, Vu)), {
        minDate: h,
        maxDate: g,
        rangeState: b,
        ppNs: C,
        drpNs: w,
        handleChangeRange: y,
        handleRangeConfirm: E,
        handleShortcutClick: k,
        onSelect: T,
        parseValue: x,
        t: I
      } = Fh(n, {
        defaultValue: f,
        defaultTime: i,
        leftDate: p,
        rightDate: m,
        unit: Vu,
        sortDates: $n
      });
      de(() => n.visible, (xe) => {
        !xe && b.value.selecting && (x(n.parsedValue), T(!1));
      });
      const P = A({
        min: null,
        max: null
      }), O = A({
        min: null,
        max: null
      }), {
        leftCurrentView: N,
        rightCurrentView: z,
        leftCurrentViewRef: Y,
        rightCurrentViewRef: G,
        leftYear: M,
        rightYear: R,
        leftMonth: D,
        rightMonth: L,
        leftYearLabel: V,
        rightYearLabel: F,
        showLeftPicker: H,
        showRightPicker: K,
        handleLeftYearPick: Z,
        handleRightYearPick: J,
        handleLeftMonthPick: ie,
        handleRightMonthPick: ue,
        handlePanelChange: re,
        adjustDateByView: se
      } = P6(n, t, p, m), ne = S(() => !!d.value.length), le = S(() => P.value.min !== null ? P.value.min : h.value ? h.value.format(ge.value) : ""), Ce = S(() => P.value.max !== null ? P.value.max : g.value || h.value ? (g.value || h.value).format(ge.value) : ""), j = S(() => O.value.min !== null ? O.value.min : h.value ? h.value.format(ce.value) : ""), te = S(() => O.value.max !== null ? O.value.max : g.value || h.value ? (g.value || h.value).format(ce.value) : ""), ce = S(() => n.timeFormat || fS(c.value || "") || us), ge = S(() => n.dateFormat || dS(c.value || "") || ga), be = (xe) => Ni(xe) && (a ? !a(xe[0].toDate()) && !a(xe[1].toDate()) : !0), Ee = () => {
        p.value = se(N.value, p.value, !1), n.unlinkPanels || (m.value = p.value.add(1, "month")), re("year");
      }, Oe = () => {
        p.value = p.value.subtract(1, "month"), n.unlinkPanels || (m.value = p.value.add(1, "month")), re("month");
      }, De = () => {
        n.unlinkPanels ? m.value = se(z.value, m.value, !0) : (p.value = se(z.value, p.value, !0), m.value = p.value.add(1, "month")), re("year");
      }, we = () => {
        n.unlinkPanels ? m.value = m.value.add(1, "month") : (p.value = p.value.add(1, "month"), m.value = p.value.add(1, "month")), re("month");
      }, me = () => {
        p.value = se(N.value, p.value, !0), re("year");
      }, Pe = () => {
        p.value = p.value.add(1, "month"), re("month");
      }, Me = () => {
        m.value = se(z.value, m.value, !1), re("year");
      }, Be = () => {
        m.value = m.value.subtract(1, "month"), re("month");
      }, pe = S(() => {
        const xe = (D.value + 1) % 12, wt = D.value + 1 >= 12 ? 1 : 0;
        return n.unlinkPanels && new Date(M.value + wt, xe) < new Date(R.value, L.value);
      }), Le = S(() => n.unlinkPanels && R.value * 12 + L.value - (M.value * 12 + D.value + 1) >= 12), Xe = S(() => !(h.value && g.value && !b.value.selecting && Ni([h.value, g.value]))), ut = S(() => n.type === "datetime" || n.type === "datetimerange"), Nt = (xe, wt) => {
        if (xe)
          return i ? st(i[wt] || i).locale(v.value).year(xe.year()).month(xe.month()).date(xe.date()) : xe;
      }, Ye = (xe, wt = !0) => {
        const ht = xe.minDate, sn = xe.maxDate, Co = Nt(ht, 0), uo = Nt(sn, 1);
        g.value === uo && h.value === Co || (t("calendar-change", [ht.toDate(), sn && sn.toDate()]), g.value = uo, h.value = Co, !ut.value && wt && (wt = !Co || !uo), E(wt));
      }, tt = A(!1), fe = A(!1), He = () => {
        tt.value = !1;
      }, Qe = () => {
        fe.value = !1;
      }, ve = (xe, wt) => {
        P.value[wt] = xe;
        const ht = st(xe, ge.value).locale(v.value);
        if (ht.isValid()) {
          if (a && a(ht.toDate()))
            return;
          wt === "min" ? (p.value = ht, h.value = (h.value || p.value).year(ht.year()).month(ht.month()).date(ht.date()), !n.unlinkPanels && (!g.value || g.value.isBefore(h.value)) && (m.value = ht.add(1, "month"), g.value = h.value.add(1, "month"))) : (m.value = ht, g.value = (g.value || m.value).year(ht.year()).month(ht.month()).date(ht.date()), !n.unlinkPanels && (!h.value || h.value.isAfter(g.value)) && (p.value = ht.subtract(1, "month"), h.value = g.value.subtract(1, "month"))), $n(h.value, g.value), E(!0);
        }
      }, Ke = (xe, wt) => {
        P.value[wt] = null;
      }, St = (xe, wt) => {
        O.value[wt] = xe;
        const ht = st(xe, ce.value).locale(v.value);
        ht.isValid() && (wt === "min" ? (tt.value = !0, h.value = (h.value || p.value).hour(ht.hour()).minute(ht.minute()).second(ht.second()), p.value = h.value) : (fe.value = !0, g.value = (g.value || m.value).hour(ht.hour()).minute(ht.minute()).second(ht.second()), m.value = g.value));
      }, Ft = (xe, wt) => {
        O.value[wt] = null, wt === "min" ? (p.value = h.value, tt.value = !1, (!g.value || g.value.isBefore(h.value)) && (g.value = h.value)) : (m.value = g.value, fe.value = !1, g.value && g.value.isBefore(h.value) && (h.value = g.value)), E(!0);
      }, Se = (xe, wt, ht) => {
        O.value.min || (xe && (p.value = xe, h.value = (h.value || p.value).hour(xe.hour()).minute(xe.minute()).second(xe.second())), ht || (tt.value = wt), (!g.value || g.value.isBefore(h.value)) && (g.value = h.value, m.value = xe, Re(() => {
          x(n.parsedValue);
        })), E(!0));
      }, Je = (xe, wt, ht) => {
        O.value.max || (xe && (m.value = xe, g.value = (g.value || m.value).hour(xe.hour()).minute(xe.minute()).second(xe.second())), ht || (fe.value = wt), g.value && g.value.isBefore(h.value) && (h.value = g.value), E(!0));
      }, lt = () => {
        let xe = null;
        o != null && o.emptyValues && (xe = o.emptyValues.valueOnClear.value), p.value = Kd(s(f), {
          lang: s(v),
          unit: "month",
          unlinkPanels: n.unlinkPanels
        })[0], m.value = p.value.add(1, "month"), g.value = void 0, h.value = void 0, E(!0), t("pick", xe);
      }, Yt = (xe) => ds(xe, c.value || "", v.value, l);
      function $n(xe, wt) {
        if (n.unlinkPanels && wt) {
          const ht = (xe == null ? void 0 : xe.year()) || 0, sn = (xe == null ? void 0 : xe.month()) || 0, Co = wt.year(), uo = wt.month();
          m.value = ht === Co && sn === uo ? wt.add(1, Vu) : wt;
        } else
          m.value = p.value.add(1, Vu), wt && (m.value = m.value.hour(wt.hour()).minute(wt.minute()).second(wt.second()));
      }
      return t("set-picker-option", ["isValidValue", be]), t("set-picker-option", ["parseUserInput", Yt]), t("set-picker-option", ["handleClear", lt]), (xe, wt) => (_(), B("div", {
        class: $([
          s(C).b(),
          s(w).b(),
          s(C).is("border", xe.border),
          s(C).is("disabled", xe.disabled),
          {
            "has-sidebar": xe.$slots.sidebar || s(ne),
            "has-time": s(ut)
          }
        ])
      }, [
        W("div", {
          class: $(s(C).e("body-wrapper"))
        }, [
          ee(xe.$slots, "sidebar", {
            class: $(s(C).e("sidebar"))
          }),
          s(ne) ? (_(), B("div", {
            key: 0,
            class: $(s(C).e("sidebar"))
          }, [
            (_(!0), B(We, null, bt(s(d), (ht, sn) => (_(), B("button", {
              key: sn,
              type: "button",
              disabled: xe.disabled,
              class: $(s(C).e("shortcut")),
              onClick: (Co) => s(k)(ht)
            }, ke(ht.text), 11, ["disabled", "onClick"]))), 128))
          ], 2)) : oe("v-if", !0),
          W("div", {
            class: $(s(C).e("body"))
          }, [
            s(ut) ? (_(), B("div", {
              key: 0,
              class: $(s(w).e("time-header"))
            }, [
              W("span", {
                class: $(s(w).e("editors-wrap"))
              }, [
                W("span", {
                  class: $(s(w).e("time-picker-wrap"))
                }, [
                  q(s(Wn), {
                    size: "small",
                    disabled: s(b).selecting || xe.disabled,
                    placeholder: s(I)("el.datepicker.startDate"),
                    class: $(s(w).e("editor")),
                    "model-value": s(le),
                    "validate-event": !1,
                    onInput: (ht) => ve(ht, "min"),
                    onChange: (ht) => Ke(ht, "min")
                  }, null, 8, ["disabled", "placeholder", "class", "model-value", "onInput", "onChange"])
                ], 2),
                it((_(), B("span", {
                  class: $(s(w).e("time-picker-wrap"))
                }, [
                  q(s(Wn), {
                    size: "small",
                    class: $(s(w).e("editor")),
                    disabled: s(b).selecting || xe.disabled,
                    placeholder: s(I)("el.datepicker.startTime"),
                    "model-value": s(j),
                    "validate-event": !1,
                    onFocus: (ht) => tt.value = !0,
                    onInput: (ht) => St(ht, "min"),
                    onChange: (ht) => Ft(ht, "min")
                  }, null, 8, ["class", "disabled", "placeholder", "model-value", "onFocus", "onInput", "onChange"]),
                  q(s(Kc), {
                    visible: tt.value,
                    format: s(ce),
                    "datetime-role": "start",
                    "parsed-value": p.value,
                    onPick: Se
                  }, null, 8, ["visible", "format", "parsed-value"])
                ], 2)), [
                  [s(Jl), He]
                ])
              ], 2),
              W("span", null, [
                q(s(ze), null, {
                  default: Q(() => [
                    q(s(Un))
                  ]),
                  _: 1
                })
              ]),
              W("span", {
                class: $([s(w).e("editors-wrap"), "is-right"])
              }, [
                W("span", {
                  class: $(s(w).e("time-picker-wrap"))
                }, [
                  q(s(Wn), {
                    size: "small",
                    class: $(s(w).e("editor")),
                    disabled: s(b).selecting || xe.disabled,
                    placeholder: s(I)("el.datepicker.endDate"),
                    "model-value": s(Ce),
                    readonly: !s(h),
                    "validate-event": !1,
                    onInput: (ht) => ve(ht, "max"),
                    onChange: (ht) => Ke(ht, "max")
                  }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly", "onInput", "onChange"])
                ], 2),
                it((_(), B("span", {
                  class: $(s(w).e("time-picker-wrap"))
                }, [
                  q(s(Wn), {
                    size: "small",
                    class: $(s(w).e("editor")),
                    disabled: s(b).selecting || xe.disabled,
                    placeholder: s(I)("el.datepicker.endTime"),
                    "model-value": s(te),
                    readonly: !s(h),
                    "validate-event": !1,
                    onFocus: (ht) => s(h) && (fe.value = !0),
                    onInput: (ht) => St(ht, "max"),
                    onChange: (ht) => Ft(ht, "max")
                  }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly", "onFocus", "onInput", "onChange"]),
                  q(s(Kc), {
                    "datetime-role": "end",
                    visible: fe.value,
                    format: s(ce),
                    "parsed-value": m.value,
                    onPick: Je
                  }, null, 8, ["visible", "format", "parsed-value"])
                ], 2)), [
                  [s(Jl), Qe]
                ])
              ], 2)
            ], 2)) : oe("v-if", !0),
            W("div", {
              class: $([[s(C).e("content"), s(w).e("content")], "is-left"])
            }, [
              W("div", {
                class: $(s(w).e("header"))
              }, [
                W("button", {
                  type: "button",
                  class: $([s(C).e("icon-btn"), "d-arrow-left"]),
                  "aria-label": s(I)("el.datepicker.prevYear"),
                  disabled: xe.disabled,
                  onClick: Ee
                }, [
                  ee(xe.$slots, "prev-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Oa))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["aria-label", "disabled"]),
                it(W("button", {
                  type: "button",
                  class: $([s(C).e("icon-btn"), "arrow-left"]),
                  "aria-label": s(I)("el.datepicker.prevMonth"),
                  disabled: xe.disabled,
                  onClick: Oe
                }, [
                  ee(xe.$slots, "prev-month", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(ql))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["aria-label", "disabled"]), [
                  [Mt, s(N) === "date"]
                ]),
                xe.unlinkPanels ? (_(), B("button", {
                  key: 0,
                  type: "button",
                  disabled: !s(Le) || xe.disabled,
                  class: $([[
                    s(C).e("icon-btn"),
                    s(C).is("disabled", !s(Le) || xe.disabled)
                  ], "d-arrow-right"]),
                  "aria-label": s(I)("el.datepicker.nextYear"),
                  onClick: me
                }, [
                  ee(xe.$slots, "next-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Ia))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "aria-label"])) : oe("v-if", !0),
                xe.unlinkPanels && s(N) === "date" ? (_(), B("button", {
                  key: 1,
                  type: "button",
                  disabled: !s(pe) || xe.disabled,
                  class: $([[
                    s(C).e("icon-btn"),
                    s(C).is("disabled", !s(pe) || xe.disabled)
                  ], "arrow-right"]),
                  "aria-label": s(I)("el.datepicker.nextMonth"),
                  onClick: Pe
                }, [
                  ee(xe.$slots, "next-month", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Un))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "aria-label"])) : oe("v-if", !0),
                W("div", null, [
                  W("span", {
                    role: "button",
                    class: $(s(w).e("header-label")),
                    "aria-live": "polite",
                    tabindex: "0",
                    onKeydown: on((ht) => s(H)("year"), ["enter"]),
                    onClick: (ht) => s(H)("year")
                  }, ke(s(V)), 43, ["onKeydown", "onClick"]),
                  it(W("span", {
                    role: "button",
                    "aria-live": "polite",
                    tabindex: "0",
                    class: $([
                      s(w).e("header-label"),
                      { active: s(N) === "month" }
                    ]),
                    onKeydown: on((ht) => s(H)("month"), ["enter"]),
                    onClick: (ht) => s(H)("month")
                  }, ke(s(I)(`el.datepicker.month${p.value.month() + 1}`)), 43, ["onKeydown", "onClick"]), [
                    [Mt, s(N) === "date"]
                  ])
                ])
              ], 2),
              s(N) === "date" ? (_(), ae(Pp, {
                key: 0,
                ref_key: "leftCurrentViewRef",
                ref: Y,
                "selection-mode": "range",
                date: p.value,
                "min-date": s(h),
                "max-date": s(g),
                "range-state": s(b),
                "disabled-date": s(a),
                "cell-class-name": s(r),
                "show-week-number": xe.showWeekNumber,
                disabled: xe.disabled,
                onChangerange: s(y),
                onPick: Ye,
                onSelect: s(T)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "show-week-number", "disabled", "onChangerange", "onSelect"])) : oe("v-if", !0),
              s(N) === "year" ? (_(), ae(Oi, {
                key: 1,
                ref_key: "leftCurrentViewRef",
                ref: Y,
                "selection-mode": "year",
                date: p.value,
                "disabled-date": s(a),
                "parsed-value": xe.parsedValue,
                disabled: xe.disabled,
                onPick: s(Z)
              }, null, 8, ["date", "disabled-date", "parsed-value", "disabled", "onPick"])) : oe("v-if", !0),
              s(N) === "month" ? (_(), ae($i, {
                key: 2,
                ref_key: "leftCurrentViewRef",
                ref: Y,
                "selection-mode": "month",
                date: p.value,
                "parsed-value": xe.parsedValue,
                "disabled-date": s(a),
                disabled: xe.disabled,
                onPick: s(ie)
              }, null, 8, ["date", "parsed-value", "disabled-date", "disabled", "onPick"])) : oe("v-if", !0)
            ], 2),
            W("div", {
              class: $([[s(C).e("content"), s(w).e("content")], "is-right"])
            }, [
              W("div", {
                class: $([
                  s(w).e("header"),
                  s(C).is("disabled", !s(Le) || xe.disabled)
                ])
              }, [
                xe.unlinkPanels ? (_(), B("button", {
                  key: 0,
                  type: "button",
                  disabled: !s(Le) || xe.disabled,
                  class: $([s(C).e("icon-btn"), "d-arrow-left"]),
                  "aria-label": s(I)("el.datepicker.prevYear"),
                  onClick: Me
                }, [
                  ee(xe.$slots, "prev-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Oa))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "aria-label"])) : oe("v-if", !0),
                xe.unlinkPanels && s(z) === "date" ? (_(), B("button", {
                  key: 1,
                  type: "button",
                  disabled: !s(pe) || xe.disabled,
                  class: $([s(C).e("icon-btn"), "arrow-left"]),
                  "aria-label": s(I)("el.datepicker.prevMonth"),
                  onClick: Be
                }, [
                  ee(xe.$slots, "prev-month", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(ql))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "aria-label"])) : oe("v-if", !0),
                W("button", {
                  type: "button",
                  "aria-label": s(I)("el.datepicker.nextYear"),
                  class: $([s(C).e("icon-btn"), "d-arrow-right"]),
                  disabled: xe.disabled,
                  onClick: De
                }, [
                  ee(xe.$slots, "next-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Ia))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["aria-label", "disabled"]),
                it(W("button", {
                  type: "button",
                  class: $([s(C).e("icon-btn"), "arrow-right"]),
                  disabled: xe.disabled,
                  "aria-label": s(I)("el.datepicker.nextMonth"),
                  onClick: we
                }, [
                  ee(xe.$slots, "next-month", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Un))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "aria-label"]), [
                  [Mt, s(z) === "date"]
                ]),
                W("div", null, [
                  W("span", {
                    role: "button",
                    class: $(s(w).e("header-label")),
                    "aria-live": "polite",
                    tabindex: "0",
                    onKeydown: on((ht) => s(K)("year"), ["enter"]),
                    onClick: (ht) => s(K)("year")
                  }, ke(s(F)), 43, ["onKeydown", "onClick"]),
                  it(W("span", {
                    role: "button",
                    "aria-live": "polite",
                    tabindex: "0",
                    class: $([
                      s(w).e("header-label"),
                      { active: s(z) === "month" }
                    ]),
                    onKeydown: on((ht) => s(K)("month"), ["enter"]),
                    onClick: (ht) => s(K)("month")
                  }, ke(s(I)(`el.datepicker.month${m.value.month() + 1}`)), 43, ["onKeydown", "onClick"]), [
                    [Mt, s(z) === "date"]
                  ])
                ])
              ], 2),
              s(z) === "date" ? (_(), ae(Pp, {
                key: 0,
                ref_key: "rightCurrentViewRef",
                ref: G,
                "selection-mode": "range",
                date: m.value,
                "min-date": s(h),
                "max-date": s(g),
                "range-state": s(b),
                "disabled-date": s(a),
                "cell-class-name": s(r),
                "show-week-number": xe.showWeekNumber,
                disabled: xe.disabled,
                onChangerange: s(y),
                onPick: Ye,
                onSelect: s(T)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "show-week-number", "disabled", "onChangerange", "onSelect"])) : oe("v-if", !0),
              s(z) === "year" ? (_(), ae(Oi, {
                key: 1,
                ref_key: "rightCurrentViewRef",
                ref: G,
                "selection-mode": "year",
                date: m.value,
                "disabled-date": s(a),
                "parsed-value": xe.parsedValue,
                disabled: xe.disabled,
                onPick: s(J)
              }, null, 8, ["date", "disabled-date", "parsed-value", "disabled", "onPick"])) : oe("v-if", !0),
              s(z) === "month" ? (_(), ae($i, {
                key: 2,
                ref_key: "rightCurrentViewRef",
                ref: G,
                "selection-mode": "month",
                date: m.value,
                "parsed-value": xe.parsedValue,
                "disabled-date": s(a),
                disabled: xe.disabled,
                onPick: s(ue)
              }, null, 8, ["date", "parsed-value", "disabled-date", "disabled", "onPick"])) : oe("v-if", !0)
            ], 2)
          ], 2)
        ], 2),
        xe.showFooter && s(ut) && (xe.showConfirm || s(u)) ? (_(), B("div", {
          key: 0,
          class: $(s(C).e("footer"))
        }, [
          s(u) ? (_(), ae(s(_n), {
            key: 0,
            text: "",
            size: "small",
            class: $(s(C).e("link-btn")),
            onClick: lt
          }, {
            default: Q(() => [
              Ct(ke(s(I)("el.datepicker.clear")), 1)
            ]),
            _: 1
          }, 8, ["class"])) : oe("v-if", !0),
          xe.showConfirm ? (_(), ae(s(_n), {
            key: 1,
            plain: "",
            size: "small",
            class: $(s(C).e("link-btn")),
            disabled: s(Xe),
            onClick: (ht) => s(E)(!1)
          }, {
            default: Q(() => [
              Ct(ke(s(I)("el.datepicker.confirm")), 1)
            ]),
            _: 1
          }, 8, ["class", "disabled", "onClick"])) : oe("v-if", !0)
        ], 2)) : oe("v-if", !0)
      ], 2));
    }
  });
  var D6 = /* @__PURE__ */ Ne(R6, [["__file", "panel-date-range.vue"]]);
  const A6 = Te({
    ...Vh
  }), V6 = [
    "pick",
    "set-picker-option",
    "calendar-change"
  ], L6 = ({
    unlinkPanels: e,
    leftDate: t,
    rightDate: n
  }) => {
    const { t: o } = _t(), l = () => {
      t.value = t.value.subtract(1, "year"), e.value || (n.value = n.value.subtract(1, "year"));
    }, a = () => {
      e.value || (t.value = t.value.add(1, "year")), n.value = n.value.add(1, "year");
    }, r = () => {
      t.value = t.value.add(1, "year");
    }, i = () => {
      n.value = n.value.subtract(1, "year");
    }, u = S(() => `${t.value.year()} ${o("el.datepicker.year")}`), c = S(() => `${n.value.year()} ${o("el.datepicker.year")}`), d = S(() => t.value.year()), f = S(() => n.value.year() === t.value.year() ? t.value.year() + 1 : n.value.year());
    return {
      leftPrevYear: l,
      rightNextYear: a,
      leftNextYear: r,
      rightPrevYear: i,
      leftLabel: u,
      rightLabel: c,
      leftYear: d,
      rightYear: f
    };
  }, Lu = "year", B6 = /* @__PURE__ */ U({
    name: "DatePickerMonthRange"
  }), F6 = /* @__PURE__ */ U({
    ...B6,
    props: A6,
    emits: V6,
    setup(e, { emit: t }) {
      const n = e, { lang: o } = _t(), l = Ve(Xo), a = Ve(cu, void 0), { shortcuts: r, disabledDate: i, cellClassName: u } = l.props, c = At(l.props, "format"), d = At(l.props, "defaultValue"), f = A(st().locale(o.value)), v = A(st().locale(o.value).add(1, Lu)), {
        minDate: p,
        maxDate: m,
        rangeState: h,
        ppNs: g,
        drpNs: b,
        handleChangeRange: C,
        handleRangeConfirm: w,
        handleShortcutClick: y,
        onSelect: E,
        parseValue: k
      } = Fh(n, {
        defaultValue: d,
        leftDate: f,
        rightDate: v,
        unit: Lu,
        sortDates: V
      }), T = S(() => !!r.length), {
        leftPrevYear: x,
        rightNextYear: I,
        leftNextYear: P,
        rightPrevYear: O,
        leftLabel: N,
        rightLabel: z,
        leftYear: Y,
        rightYear: G
      } = L6({
        unlinkPanels: At(n, "unlinkPanels"),
        leftDate: f,
        rightDate: v
      }), M = S(() => n.unlinkPanels && G.value > Y.value + 1), R = (F, H = !0) => {
        const K = F.minDate, Z = F.maxDate;
        m.value === Z && p.value === K || (t("calendar-change", [K.toDate(), Z && Z.toDate()]), m.value = Z, p.value = K, H && w());
      }, D = () => {
        let F = null;
        l != null && l.emptyValues && (F = l.emptyValues.valueOnClear.value), f.value = Kd(s(d), {
          lang: s(o),
          unit: "year",
          unlinkPanels: n.unlinkPanels
        })[0], v.value = f.value.add(1, "year"), t("pick", F);
      }, L = (F) => ds(F, c.value, o.value, a);
      function V(F, H) {
        if (n.unlinkPanels && H) {
          const K = (F == null ? void 0 : F.year()) || 0, Z = H.year();
          v.value = K === Z ? H.add(1, Lu) : H;
        } else
          v.value = f.value.add(1, Lu);
      }
      return de(() => n.visible, (F) => {
        !F && h.value.selecting && (k(n.parsedValue), E(!1));
      }), t("set-picker-option", ["isValidValue", Ni]), t("set-picker-option", ["parseUserInput", L]), t("set-picker-option", ["handleClear", D]), (F, H) => (_(), B("div", {
        class: $([
          s(g).b(),
          s(b).b(),
          s(g).is("border", F.border),
          s(g).is("disabled", F.disabled),
          {
            "has-sidebar": !!F.$slots.sidebar || s(T)
          }
        ])
      }, [
        W("div", {
          class: $(s(g).e("body-wrapper"))
        }, [
          ee(F.$slots, "sidebar", {
            class: $(s(g).e("sidebar"))
          }),
          s(T) ? (_(), B("div", {
            key: 0,
            class: $(s(g).e("sidebar"))
          }, [
            (_(!0), B(We, null, bt(s(r), (K, Z) => (_(), B("button", {
              key: Z,
              type: "button",
              class: $(s(g).e("shortcut")),
              disabled: F.disabled,
              onClick: (J) => s(y)(K)
            }, ke(K.text), 11, ["disabled", "onClick"]))), 128))
          ], 2)) : oe("v-if", !0),
          W("div", {
            class: $(s(g).e("body"))
          }, [
            W("div", {
              class: $([[s(g).e("content"), s(b).e("content")], "is-left"])
            }, [
              W("div", {
                class: $(s(b).e("header"))
              }, [
                W("button", {
                  type: "button",
                  class: $([s(g).e("icon-btn"), "d-arrow-left"]),
                  disabled: F.disabled,
                  onClick: s(x)
                }, [
                  ee(F.$slots, "prev-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Oa))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "onClick"]),
                F.unlinkPanels ? (_(), B("button", {
                  key: 0,
                  type: "button",
                  disabled: !s(M) || F.disabled,
                  class: $([[
                    s(g).e("icon-btn"),
                    s(g).is("disabled", !s(M))
                  ], "d-arrow-right"]),
                  onClick: s(P)
                }, [
                  ee(F.$slots, "next-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Ia))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "onClick"])) : oe("v-if", !0),
                W("div", null, ke(s(N)), 1)
              ], 2),
              q($i, {
                "selection-mode": "range",
                date: f.value,
                "min-date": s(p),
                "max-date": s(m),
                "range-state": s(h),
                "disabled-date": s(i),
                disabled: F.disabled,
                "cell-class-name": s(u),
                onChangerange: s(C),
                onPick: R,
                onSelect: s(E)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "disabled", "cell-class-name", "onChangerange", "onSelect"])
            ], 2),
            W("div", {
              class: $([[s(g).e("content"), s(b).e("content")], "is-right"])
            }, [
              W("div", {
                class: $(s(b).e("header"))
              }, [
                F.unlinkPanels ? (_(), B("button", {
                  key: 0,
                  type: "button",
                  disabled: !s(M) || F.disabled,
                  class: $([[
                    s(g).e("icon-btn"),
                    s(g).is("disabled", !s(M))
                  ], "d-arrow-left"]),
                  onClick: s(O)
                }, [
                  ee(F.$slots, "prev-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Oa))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "onClick"])) : oe("v-if", !0),
                W("button", {
                  type: "button",
                  class: $([s(g).e("icon-btn"), "d-arrow-right"]),
                  disabled: F.disabled,
                  onClick: s(I)
                }, [
                  ee(F.$slots, "next-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Ia))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "onClick"]),
                W("div", null, ke(s(z)), 1)
              ], 2),
              q($i, {
                "selection-mode": "range",
                date: v.value,
                "min-date": s(p),
                "max-date": s(m),
                "range-state": s(h),
                "disabled-date": s(i),
                disabled: F.disabled,
                "cell-class-name": s(u),
                onChangerange: s(C),
                onPick: R,
                onSelect: s(E)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "disabled", "cell-class-name", "onChangerange", "onSelect"])
            ], 2)
          ], 2)
        ], 2)
      ], 2));
    }
  });
  var z6 = /* @__PURE__ */ Ne(F6, [["__file", "panel-month-range.vue"]]);
  const H6 = Te({
    ...Vh
  }), K6 = [
    "pick",
    "set-picker-option",
    "calendar-change"
  ], W6 = ({
    unlinkPanels: e,
    leftDate: t,
    rightDate: n
  }) => {
    const o = () => {
      t.value = t.value.subtract(10, "year"), e.value || (n.value = n.value.subtract(10, "year"));
    }, l = () => {
      e.value || (t.value = t.value.add(10, "year")), n.value = n.value.add(10, "year");
    }, a = () => {
      t.value = t.value.add(10, "year");
    }, r = () => {
      n.value = n.value.subtract(10, "year");
    }, i = S(() => {
      const f = Math.floor(t.value.year() / 10) * 10;
      return `${f}-${f + 9}`;
    }), u = S(() => {
      const f = Math.floor(n.value.year() / 10) * 10;
      return `${f}-${f + 9}`;
    }), c = S(() => Math.floor(t.value.year() / 10) * 10 + 9), d = S(() => Math.floor(n.value.year() / 10) * 10);
    return {
      leftPrevYear: o,
      rightNextYear: l,
      leftNextYear: a,
      rightPrevYear: r,
      leftLabel: i,
      rightLabel: u,
      leftYear: c,
      rightYear: d
    };
  }, Or = 10, Ls = "year", j6 = /* @__PURE__ */ U({
    name: "DatePickerYearRange"
  }), U6 = /* @__PURE__ */ U({
    ...j6,
    props: H6,
    emits: K6,
    setup(e, { emit: t }) {
      const n = e, { lang: o } = _t(), l = A(st().locale(o.value)), a = A(st().locale(o.value).add(Or, Ls)), r = Ve(cu, void 0), i = Ve(Xo), { shortcuts: u, disabledDate: c, cellClassName: d } = i.props, f = At(i.props, "format"), v = At(i.props, "defaultValue"), {
        minDate: p,
        maxDate: m,
        rangeState: h,
        ppNs: g,
        drpNs: b,
        handleChangeRange: C,
        handleRangeConfirm: w,
        handleShortcutClick: y,
        onSelect: E,
        parseValue: k
      } = Fh(n, {
        defaultValue: v,
        leftDate: l,
        rightDate: a,
        step: Or,
        unit: Ls,
        sortDates: Z
      }), {
        leftPrevYear: T,
        rightNextYear: x,
        leftNextYear: I,
        rightPrevYear: P,
        leftLabel: O,
        rightLabel: N,
        leftYear: z,
        rightYear: Y
      } = W6({
        unlinkPanels: At(n, "unlinkPanels"),
        leftDate: l,
        rightDate: a
      }), G = S(() => !!u.length), M = S(() => [
        g.b(),
        b.b(),
        g.is("border", n.border),
        g.is("disabled", n.disabled),
        {
          "has-sidebar": !!hn().sidebar || G.value
        }
      ]), R = S(() => ({
        content: [g.e("content"), b.e("content"), "is-left"],
        arrowLeftBtn: [g.e("icon-btn"), "d-arrow-left"],
        arrowRightBtn: [
          g.e("icon-btn"),
          g.is("disabled", !L.value),
          "d-arrow-right"
        ]
      })), D = S(() => ({
        content: [g.e("content"), b.e("content"), "is-right"],
        arrowLeftBtn: [
          g.e("icon-btn"),
          g.is("disabled", !L.value),
          "d-arrow-left"
        ],
        arrowRightBtn: [g.e("icon-btn"), "d-arrow-right"]
      })), L = S(() => n.unlinkPanels && Y.value > z.value + 1), V = (J, ie = !0) => {
        const ue = J.minDate, re = J.maxDate;
        m.value === re && p.value === ue || (t("calendar-change", [ue.toDate(), re && re.toDate()]), m.value = re, p.value = ue, ie && w());
      }, F = (J) => ds(J, f.value, o.value, r), H = (J) => Ni(J) && (c ? !c(J[0].toDate()) && !c(J[1].toDate()) : !0), K = () => {
        let J = null;
        i != null && i.emptyValues && (J = i.emptyValues.valueOnClear.value);
        const ie = Kd(s(v), {
          lang: s(o),
          step: Or,
          unit: Ls,
          unlinkPanels: n.unlinkPanels
        });
        l.value = ie[0], a.value = ie[1], t("pick", J);
      };
      function Z(J, ie) {
        if (n.unlinkPanels && ie) {
          const ue = (J == null ? void 0 : J.year()) || 0, re = ie.year();
          a.value = ue + Or > re ? ie.add(Or, Ls) : ie;
        } else
          a.value = l.value.add(Or, Ls);
      }
      return de(() => n.visible, (J) => {
        !J && h.value.selecting && (k(n.parsedValue), E(!1));
      }), t("set-picker-option", ["isValidValue", H]), t("set-picker-option", ["parseUserInput", F]), t("set-picker-option", ["handleClear", K]), (J, ie) => (_(), B("div", {
        class: $(s(M))
      }, [
        W("div", {
          class: $(s(g).e("body-wrapper"))
        }, [
          ee(J.$slots, "sidebar", {
            class: $(s(g).e("sidebar"))
          }),
          s(G) ? (_(), B("div", {
            key: 0,
            class: $(s(g).e("sidebar"))
          }, [
            (_(!0), B(We, null, bt(s(u), (ue, re) => (_(), B("button", {
              key: re,
              type: "button",
              class: $(s(g).e("shortcut")),
              disabled: J.disabled,
              onClick: (se) => s(y)(ue)
            }, ke(ue.text), 11, ["disabled", "onClick"]))), 128))
          ], 2)) : oe("v-if", !0),
          W("div", {
            class: $(s(g).e("body"))
          }, [
            W("div", {
              class: $(s(R).content)
            }, [
              W("div", {
                class: $(s(b).e("header"))
              }, [
                W("button", {
                  type: "button",
                  class: $(s(R).arrowLeftBtn),
                  disabled: J.disabled,
                  onClick: s(T)
                }, [
                  ee(J.$slots, "prev-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Oa))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "onClick"]),
                J.unlinkPanels ? (_(), B("button", {
                  key: 0,
                  type: "button",
                  disabled: !s(L) || J.disabled,
                  class: $(s(R).arrowRightBtn),
                  onClick: s(I)
                }, [
                  ee(J.$slots, "next-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Ia))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "onClick"])) : oe("v-if", !0),
                W("div", null, ke(s(O)), 1)
              ], 2),
              q(Oi, {
                "selection-mode": "range",
                date: l.value,
                "min-date": s(p),
                "max-date": s(m),
                "range-state": s(h),
                "disabled-date": s(c),
                disabled: J.disabled,
                "cell-class-name": s(d),
                onChangerange: s(C),
                onPick: V,
                onSelect: s(E)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "disabled", "cell-class-name", "onChangerange", "onSelect"])
            ], 2),
            W("div", {
              class: $(s(D).content)
            }, [
              W("div", {
                class: $(s(b).e("header"))
              }, [
                J.unlinkPanels ? (_(), B("button", {
                  key: 0,
                  type: "button",
                  disabled: !s(L) || J.disabled,
                  class: $(s(D).arrowLeftBtn),
                  onClick: s(P)
                }, [
                  ee(J.$slots, "prev-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Oa))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "onClick"])) : oe("v-if", !0),
                W("button", {
                  type: "button",
                  class: $(s(D).arrowRightBtn),
                  disabled: J.disabled,
                  onClick: s(x)
                }, [
                  ee(J.$slots, "next-year", {}, () => [
                    q(s(ze), null, {
                      default: Q(() => [
                        q(s(Ia))
                      ]),
                      _: 1
                    })
                  ])
                ], 10, ["disabled", "onClick"]),
                W("div", null, ke(s(N)), 1)
              ], 2),
              q(Oi, {
                "selection-mode": "range",
                date: a.value,
                "min-date": s(p),
                "max-date": s(m),
                "range-state": s(h),
                "disabled-date": s(c),
                disabled: J.disabled,
                "cell-class-name": s(d),
                onChangerange: s(C),
                onPick: V,
                onSelect: s(E)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "disabled", "cell-class-name", "onChangerange", "onSelect"])
            ], 2)
          ], 2)
        ], 2)
      ], 2));
    }
  });
  var Y6 = /* @__PURE__ */ Ne(U6, [["__file", "panel-year-range.vue"]]);
  const q6 = function(e) {
    switch (e) {
      case "daterange":
      case "datetimerange":
        return D6;
      case "monthrange":
        return z6;
      case "yearrange":
        return Y6;
      default:
        return I6;
    }
  };
  function G6(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Wt(e);
  }
  st.extend(hS);
  st.extend(l6);
  st.extend(Mh);
  st.extend(r6);
  st.extend(i6);
  st.extend(c6);
  st.extend(f6);
  st.extend(v6);
  var X6 = /* @__PURE__ */ U({
    name: "ElDatePickerPanel",
    install: null,
    props: h6,
    emits: [et, "calendar-change", "panel-change", "visible-change", "pick"],
    setup(e, {
      slots: t,
      emit: n
    }) {
      const o = he("picker-panel"), l = Ve(Xo, void 0);
      if (kt(l)) {
        const d = Rt({
          ...wn(e)
        });
        yt(Xo, {
          props: d
        });
      }
      yt(Dh, {
        slots: t,
        pickerNs: o
      });
      const {
        parsedValue: a,
        onCalendarChange: r,
        onPanelChange: i,
        onSetPickerOption: u,
        onPick: c
      } = Ve(eE, () => tE(e, n), !0);
      return () => {
        const d = q6(e.type);
        return q(d, pt(e, {
          parsedValue: a.value,
          "onSet-picker-option": u,
          "onCalendar-change": r,
          "onPanel-change": i,
          onPick: c
        }), G6(t) ? t : {
          default: () => [t]
        });
      };
    }
  });
  const hE = rt(X6), J6 = Te({
    ...Rh,
    type: {
      type: X(String),
      default: "date"
    }
  });
  function Z6(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Wt(e);
  }
  var Q6 = /* @__PURE__ */ U({
    name: "ElDatePicker",
    install: null,
    props: J6,
    emits: [et],
    setup(e, {
      expose: t,
      emit: n,
      slots: o
    }) {
      const l = S(() => !e.format);
      yt(cu, l), yt(xh, Rt(At(e, "popperOptions")));
      const a = A();
      t({
        focus: () => {
          var u;
          (u = a.value) == null || u.focus();
        },
        blur: () => {
          var u;
          (u = a.value) == null || u.blur();
        },
        handleOpen: () => {
          var u;
          (u = a.value) == null || u.handleOpen();
        },
        handleClose: () => {
          var u;
          (u = a.value) == null || u.handleClose();
        }
      });
      const i = (u) => {
        n(et, u);
      };
      return () => {
        var u;
        const c = (u = e.format) != null ? u : BB[e.type] || ga;
        return q(oE, pt(e, {
          format: c,
          type: e.type,
          ref: a,
          "onUpdate:modelValue": i
        }), {
          default: (d) => q(hE, pt({
            border: !1
          }, d), Z6(o) ? o : {
            default: () => [o]
          }),
          "range-separator": o["range-separator"]
        });
      };
    }
  });
  const eF = rt(Q6), zh = Symbol("elDescriptions");
  var Bs = /* @__PURE__ */ U({
    name: "ElDescriptionsCell",
    props: {
      cell: {
        type: Object
      },
      tag: {
        type: String,
        default: "td"
      },
      type: {
        type: String
      }
    },
    setup() {
      return {
        descriptions: Ve(zh, {})
      };
    },
    render() {
      var e;
      const t = lL(this.cell), n = (((e = this.cell) == null ? void 0 : e.dirs) || []).map((b) => {
        const { dir: C, arg: w, modifiers: y, value: E } = b;
        return [C, E, w, y];
      }), { border: o, direction: l } = this.descriptions, a = l === "vertical", r = () => {
        var b, C, w;
        return ((w = (C = (b = this.cell) == null ? void 0 : b.children) == null ? void 0 : C.label) == null ? void 0 : w.call(C)) || t.label;
      }, i = () => {
        var b, C, w;
        return (w = (C = (b = this.cell) == null ? void 0 : b.children) == null ? void 0 : C.default) == null ? void 0 : w.call(C);
      }, u = t.span, c = t.rowspan, d = t.align ? `is-${t.align}` : "", f = t.labelAlign ? `is-${t.labelAlign}` : d, v = t.className, p = t.labelClassName, m = this.type === "label" && (t.labelWidth || this.descriptions.labelWidth) || t.width, h = {
        width: tn(m),
        minWidth: tn(t.minWidth)
      }, g = he("descriptions");
      switch (this.type) {
        case "label":
          return it(qe(this.tag, {
            style: h,
            class: [
              g.e("cell"),
              g.e("label"),
              g.is("bordered-label", o),
              g.is("vertical-label", a),
              f,
              p
            ],
            colSpan: a ? u : 1,
            rowspan: a ? 1 : c
          }, r()), n);
        case "content":
          return it(qe(this.tag, {
            style: h,
            class: [
              g.e("cell"),
              g.e("content"),
              g.is("bordered-content", o),
              g.is("vertical-content", a),
              d,
              v
            ],
            colSpan: a ? u : u * 2 - 1,
            rowspan: a ? c * 2 - 1 : c
          }, i()), n);
        default: {
          const b = r(), C = {}, w = tn(t.labelWidth || this.descriptions.labelWidth);
          return w && (C.width = w, C.display = "inline-block"), it(qe("td", {
            style: h,
            class: [g.e("cell"), d],
            colSpan: u,
            rowspan: c
          }, [
            cn(b) ? void 0 : qe("span", {
              style: C,
              class: [g.e("label"), p]
            }, b),
            qe("span", {
              class: [g.e("content"), v]
            }, i())
          ]), n);
        }
      }
    }
  });
  const tF = Te({
    row: {
      type: X(Array),
      default: () => []
    }
  }), nF = /* @__PURE__ */ U({
    name: "ElDescriptionsRow"
  }), oF = /* @__PURE__ */ U({
    ...nF,
    props: tF,
    setup(e) {
      const t = Ve(zh, {});
      return (n, o) => s(t).direction === "vertical" ? (_(), B(We, { key: 0 }, [
        W("tr", null, [
          (_(!0), B(We, null, bt(n.row, (l, a) => (_(), ae(s(Bs), {
            key: `tr1-${a}`,
            cell: l,
            tag: "th",
            type: "label"
          }, null, 8, ["cell"]))), 128))
        ]),
        W("tr", null, [
          (_(!0), B(We, null, bt(n.row, (l, a) => (_(), ae(s(Bs), {
            key: `tr2-${a}`,
            cell: l,
            tag: "td",
            type: "content"
          }, null, 8, ["cell"]))), 128))
        ])
      ], 64)) : (_(), B("tr", { key: 1 }, [
        (_(!0), B(We, null, bt(n.row, (l, a) => (_(), B(We, {
          key: `tr3-${a}`
        }, [
          s(t).border ? (_(), B(We, { key: 0 }, [
            q(s(Bs), {
              cell: l,
              tag: "td",
              type: "label"
            }, null, 8, ["cell"]),
            q(s(Bs), {
              cell: l,
              tag: "td",
              type: "content"
            }, null, 8, ["cell"])
          ], 64)) : (_(), ae(s(Bs), {
            key: 1,
            cell: l,
            tag: "td",
            type: "both"
          }, null, 8, ["cell"]))
        ], 64))), 128))
      ]));
    }
  });
  var lF = /* @__PURE__ */ Ne(oF, [["__file", "descriptions-row.vue"]]);
  const aF = Te({
    border: Boolean,
    column: {
      type: Number,
      default: 3
    },
    direction: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "horizontal"
    },
    size: mn,
    title: {
      type: String,
      default: ""
    },
    extra: {
      type: String,
      default: ""
    },
    labelWidth: {
      type: [String, Number],
      default: ""
    }
  }), mE = "ElDescriptionsItem", rF = /* @__PURE__ */ U({
    name: "ElDescriptions"
  }), sF = /* @__PURE__ */ U({
    ...rF,
    props: aF,
    setup(e) {
      const t = e, n = he("descriptions"), o = vn(), l = hn();
      yt(zh, t);
      const a = S(() => [n.b(), n.m(o.value)]), r = (u, c, d, f = !1) => (u.props || (u.props = {}), c > d && (u.props.span = d), f && (u.props.span = c), u), i = () => {
        if (!l.default)
          return [];
        const u = cl(l.default()).filter((m) => {
          var h;
          return ((h = m == null ? void 0 : m.type) == null ? void 0 : h.name) === mE;
        }), c = [];
        let d = [], f = t.column, v = 0;
        const p = [];
        return u.forEach((m, h) => {
          var g, b, C;
          const w = ((g = m.props) == null ? void 0 : g.span) || 1, y = ((b = m.props) == null ? void 0 : b.rowspan) || 1, E = c.length;
          if (p[E] || (p[E] = 0), y > 1)
            for (let k = 1; k < y; k++)
              p[C = E + k] || (p[C] = 0), p[E + k]++, v++;
          if (p[E] > 0 && (f -= p[E], p[E] = 0), h < u.length - 1 && (v += w > f ? f : w), h === u.length - 1) {
            const k = t.column - v % t.column;
            d.push(r(m, k, f, !0)), c.push(d);
            return;
          }
          w < f ? (f -= w, d.push(m)) : (d.push(r(m, w, f)), c.push(d), f = t.column, d = []);
        }), c;
      };
      return (u, c) => (_(), B("div", {
        class: $(s(a))
      }, [
        u.title || u.extra || u.$slots.title || u.$slots.extra ? (_(), B("div", {
          key: 0,
          class: $(s(n).e("header"))
        }, [
          W("div", {
            class: $(s(n).e("title"))
          }, [
            ee(u.$slots, "title", {}, () => [
              Ct(ke(u.title), 1)
            ])
          ], 2),
          W("div", {
            class: $(s(n).e("extra"))
          }, [
            ee(u.$slots, "extra", {}, () => [
              Ct(ke(u.extra), 1)
            ])
          ], 2)
        ], 2)) : oe("v-if", !0),
        W("div", {
          class: $(s(n).e("body"))
        }, [
          W("table", {
            class: $([s(n).e("table"), s(n).is("bordered", u.border)])
          }, [
            W("tbody", null, [
              (_(!0), B(We, null, bt(i(), (d, f) => (_(), ae(lF, {
                key: f,
                row: d
              }, null, 8, ["row"]))), 128))
            ])
          ], 2)
        ], 2)
      ], 2));
    }
  });
  var iF = /* @__PURE__ */ Ne(sF, [["__file", "description.vue"]]);
  const vy = ["left", "center", "right"], uF = Te({
    label: {
      type: String,
      default: ""
    },
    span: {
      type: Number,
      default: 1
    },
    rowspan: {
      type: Number,
      default: 1
    },
    width: {
      type: [String, Number],
      default: ""
    },
    minWidth: {
      type: [String, Number],
      default: ""
    },
    labelWidth: {
      type: [String, Number],
      default: ""
    },
    align: {
      type: String,
      values: vy,
      default: "left"
    },
    labelAlign: {
      type: String,
      values: vy
    },
    className: {
      type: String,
      default: ""
    },
    labelClassName: {
      type: String,
      default: ""
    }
  }), gE = /* @__PURE__ */ U({
    name: mE,
    props: uF
  }), cF = rt(iF, {
    DescriptionsItem: gE
  }), dF = nn(gE), Hh = (e) => {
    if (!e)
      return { onClick: It, onMousedown: It, onMouseup: It };
    let t = !1, n = !1;
    return { onClick: (r) => {
      t && n && e(r), t = n = !1;
    }, onMousedown: (r) => {
      t = r.target === r.currentTarget;
    }, onMouseup: (r) => {
      n = r.target === r.currentTarget;
    } };
  }, fF = Te({
    mask: {
      type: Boolean,
      default: !0
    },
    customMaskEvent: Boolean,
    overlayClass: {
      type: X([
        String,
        Array,
        Object
      ])
    },
    zIndex: {
      type: X([String, Number])
    }
  }), pF = {
    click: (e) => e instanceof MouseEvent
  }, vF = "overlay";
  var hF = /* @__PURE__ */ U({
    name: "ElOverlay",
    props: fF,
    emits: pF,
    setup(e, { slots: t, emit: n }) {
      const o = he(vF), l = (u) => {
        n("click", u);
      }, { onClick: a, onMousedown: r, onMouseup: i } = Hh(e.customMaskEvent ? void 0 : l);
      return () => e.mask ? q("div", {
        class: [o.b(), e.overlayClass],
        style: {
          zIndex: e.zIndex
        },
        onClick: a,
        onMousedown: r,
        onMouseup: i
      }, [ee(t, "default")], ko.STYLE | ko.CLASS | ko.PROPS, ["onClick", "onMouseup", "onMousedown"]) : qe("div", {
        class: e.overlayClass,
        style: {
          zIndex: e.zIndex,
          position: "fixed",
          top: "0px",
          right: "0px",
          bottom: "0px",
          left: "0px"
        }
      }, [ee(t, "default")]);
    }
  });
  const Kh = hF, bE = Symbol("dialogInjectionKey"), Vf = "dialog-fade", yE = Te({
    center: Boolean,
    alignCenter: {
      type: Boolean,
      default: void 0
    },
    closeIcon: {
      type: Lt
    },
    draggable: {
      type: Boolean,
      default: void 0
    },
    overflow: {
      type: Boolean,
      default: void 0
    },
    fullscreen: Boolean,
    headerClass: String,
    bodyClass: String,
    footerClass: String,
    showClose: {
      type: Boolean,
      default: !0
    },
    title: {
      type: String,
      default: ""
    },
    ariaLevel: {
      type: String,
      default: "2"
    }
  }), mF = {
    close: () => !0
  }, wE = (e, t, n, o) => {
    const l = {
      offsetX: 0,
      offsetY: 0
    }, a = A(!1), r = (v, p) => {
      if (e.value) {
        const { offsetX: m, offsetY: h } = l, g = e.value.getBoundingClientRect(), b = g.left, C = g.top, w = g.width, y = g.height, E = document.documentElement.clientWidth, k = document.documentElement.clientHeight, T = -b + m, x = -C + h, I = E - b - w + m, P = k - C - (y < k ? y : 0) + h;
        o != null && o.value || (v = Math.min(Math.max(v, T), I), p = Math.min(Math.max(p, x), P)), l.offsetX = v, l.offsetY = p, e.value.style.transform = `translate(${tn(v)}, ${tn(p)})`;
      }
    }, i = (v) => {
      const p = v.clientX, m = v.clientY, { offsetX: h, offsetY: g } = l, b = (w) => {
        a.value || (a.value = !0);
        const y = h + w.clientX - p, E = g + w.clientY - m;
        r(y, E);
      }, C = () => {
        a.value = !1, document.removeEventListener("mousemove", b), document.removeEventListener("mouseup", C);
      };
      document.addEventListener("mousemove", b), document.addEventListener("mouseup", C);
    }, u = () => {
      t.value && e.value && (t.value.addEventListener("mousedown", i), window.addEventListener("resize", f));
    }, c = () => {
      t.value && e.value && (t.value.removeEventListener("mousedown", i), window.removeEventListener("resize", f));
    }, d = () => {
      l.offsetX = 0, l.offsetY = 0, e.value && (e.value.style.transform = "");
    }, f = () => {
      const { offsetX: v, offsetY: p } = l;
      r(v, p);
    };
    return ft(() => {
      to(() => {
        n.value ? u() : c();
      });
    }), Bt(() => {
      c();
    }), {
      isDragging: a,
      resetPosition: d,
      updatePosition: f
    };
  }, Wh = (...e) => (t) => {
    e.forEach((n) => {
      n.value = t;
    });
  }, gF = /* @__PURE__ */ U({ name: "ElDialogContent" }), bF = /* @__PURE__ */ U({
    ...gF,
    props: yE,
    emits: mF,
    setup(e, { expose: t }) {
      const n = e, { t: o } = _t(), { Close: l } = SC, { dialogRef: a, headerRef: r, bodyId: i, ns: u, style: c } = Ve(bE), { focusTrapRef: d } = Ve(VC), f = Wh(d, a), v = S(() => !!n.draggable), p = S(() => !!n.overflow), { resetPosition: m, updatePosition: h, isDragging: g } = wE(a, r, v, p), b = S(() => [
        u.b(),
        u.is("fullscreen", n.fullscreen),
        u.is("draggable", v.value),
        u.is("dragging", g.value),
        u.is("align-center", !!n.alignCenter),
        { [u.m("center")]: n.center }
      ]);
      return t({
        resetPosition: m,
        updatePosition: h
      }), (C, w) => (_(), B("div", {
        ref: s(f),
        class: $(s(b)),
        style: Ue(s(c)),
        tabindex: "-1"
      }, [
        W("header", {
          ref_key: "headerRef",
          ref: r,
          class: $([s(u).e("header"), C.headerClass, { "show-close": C.showClose }])
        }, [
          ee(C.$slots, "header", {}, () => [
            W("span", {
              role: "heading",
              "aria-level": C.ariaLevel,
              class: $(s(u).e("title"))
            }, ke(C.title), 11, ["aria-level"])
          ]),
          C.showClose ? (_(), B("button", {
            key: 0,
            "aria-label": s(o)("el.dialog.close"),
            class: $(s(u).e("headerbtn")),
            type: "button",
            onClick: (y) => C.$emit("close")
          }, [
            q(s(ze), {
              class: $(s(u).e("close"))
            }, {
              default: Q(() => [
                (_(), ae(ct(C.closeIcon || s(l))))
              ]),
              _: 1
            }, 8, ["class"])
          ], 10, ["aria-label", "onClick"])) : oe("v-if", !0)
        ], 2),
        W("div", {
          id: s(i),
          class: $([s(u).e("body"), C.bodyClass])
        }, [
          ee(C.$slots, "default")
        ], 10, ["id"]),
        C.$slots.footer ? (_(), B("footer", {
          key: 0,
          class: $([s(u).e("footer"), C.footerClass])
        }, [
          ee(C.$slots, "footer")
        ], 2)) : oe("v-if", !0)
      ], 6));
    }
  });
  var yF = /* @__PURE__ */ Ne(bF, [["__file", "dialog-content.vue"]]);
  const CE = Te({
    ...yE,
    appendToBody: Boolean,
    appendTo: {
      type: Bd.to.type,
      default: "body"
    },
    beforeClose: {
      type: X(Function)
    },
    destroyOnClose: Boolean,
    closeOnClickModal: {
      type: Boolean,
      default: !0
    },
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    lockScroll: {
      type: Boolean,
      default: !0
    },
    modal: {
      type: Boolean,
      default: !0
    },
    modalPenetrable: Boolean,
    openDelay: {
      type: Number,
      default: 0
    },
    closeDelay: {
      type: Number,
      default: 0
    },
    top: {
      type: String
    },
    modelValue: Boolean,
    modalClass: String,
    headerClass: String,
    bodyClass: String,
    footerClass: String,
    width: {
      type: [String, Number]
    },
    zIndex: {
      type: Number
    },
    trapFocus: Boolean,
    headerAriaLevel: {
      type: String,
      default: "2"
    },
    transition: {
      type: X([String, Object]),
      default: void 0
    }
  }), SE = {
    open: () => !0,
    opened: () => !0,
    close: () => !0,
    closed: () => !0,
    [et]: (e) => Vt(e),
    openAutoFocus: () => !0,
    closeAutoFocus: () => !0
  }, Wd = (e, t = {}) => {
    Kt(e) || Zt("[useLockscreen]", "You need to pass a ref param to this function");
    const n = t.ns || he("popup"), o = S(() => n.bm("parent", "hidden"));
    let l = 0, a = !1, r = "0";
    const i = () => {
      setTimeout(() => {
        typeof document > "u" || a && document && (document.body.style.width = r, jn(document.body, o.value));
      }, 200);
    };
    de(e, (u) => {
      if (!u) {
        i();
        return;
      }
      a = !Lo(document.body, o.value), a && (r = document.body.style.width, _o(document.body, o.value)), l = fC(n.namespace.value);
      const c = document.documentElement.clientHeight < document.body.scrollHeight, d = Bl(document.body, "overflowY");
      l > 0 && (c || d === "scroll") && a && (document.body.style.width = `calc(100% - ${l}px)`);
    }), O0(() => i());
  }, wF = "ElDialog", EE = (e, t) => {
    var n;
    const l = dt().emit, { nextZIndex: a } = tu();
    let r = "";
    const i = xn(), u = xn(), c = A(!1), d = A(!1), f = A(!1), v = A((n = e.zIndex) != null ? n : a());
    let p, m;
    const h = ks(), g = S(() => {
      var F, H;
      return (H = (F = h.value) == null ? void 0 : F.namespace) != null ? H : Qs;
    }), b = S(() => {
      var F;
      return (F = h.value) == null ? void 0 : F.dialog;
    }), C = S(() => {
      const F = {}, H = `--${g.value}-dialog`;
      return e.fullscreen || (e.top && (F[`${H}-margin-top`] = e.top), e.width && (F[`${H}-width`] = tn(e.width))), F;
    }), w = S(() => {
      var F, H, K;
      return ((K = (H = e.draggable) != null ? H : (F = b.value) == null ? void 0 : F.draggable) != null ? K : !1) && !e.fullscreen;
    }), y = S(() => {
      var F, H, K;
      return (K = (H = e.alignCenter) != null ? H : (F = b.value) == null ? void 0 : F.alignCenter) != null ? K : !1;
    }), E = S(() => {
      var F, H, K;
      return (K = (H = e.overflow) != null ? H : (F = b.value) == null ? void 0 : F.overflow) != null ? K : !1;
    }), k = S(() => y.value ? { display: "flex" } : {}), T = S(() => {
      var F, H, K;
      const Z = (K = (H = e.transition) != null ? H : (F = b.value) == null ? void 0 : F.transition) != null ? K : Vf, J = {
        name: Z,
        onAfterEnter: x,
        onBeforeLeave: P,
        onAfterLeave: I
      };
      if (ot(Z)) {
        const ie = { ...Z }, ue = (re, se) => (ne) => {
          ye(re) ? re.forEach((le) => {
            Fe(le) && le(ne);
          }) : Fe(re) && re(ne), se();
        };
        return ie.onAfterEnter = ue(ie.onAfterEnter, x), ie.onBeforeLeave = ue(ie.onBeforeLeave, P), ie.onAfterLeave = ue(ie.onAfterLeave, I), ie.name || (ie.name = Vf, vt(wF, `transition.name is missing when using object syntax, fallback to '${Vf}'`)), ie;
      }
      return J;
    });
    function x() {
      l("opened");
    }
    function I() {
      l("closed"), l(et, !1), e.destroyOnClose && (f.value = !1);
    }
    function P() {
      l("close");
    }
    function O() {
      m == null || m(), p == null || p(), e.openDelay && e.openDelay > 0 ? { stop: p } = os(() => G(), e.openDelay) : G();
    }
    function N() {
      p == null || p(), m == null || m(), e.closeDelay && e.closeDelay > 0 ? { stop: m } = os(() => M(), e.closeDelay) : M();
    }
    function z() {
      function F(H) {
        H || (d.value = !0, c.value = !1);
      }
      e.beforeClose ? e.beforeClose(F) : N();
    }
    function Y() {
      e.closeOnClickModal && z();
    }
    function G() {
      xt && (c.value = !0);
    }
    function M() {
      c.value = !1;
    }
    function R() {
      l("openAutoFocus");
    }
    function D() {
      l("closeAutoFocus");
    }
    function L(F) {
      var H;
      ((H = F.detail) == null ? void 0 : H.focusReason) === "pointer" && F.preventDefault();
    }
    e.lockScroll && Wd(c);
    function V() {
      e.closeOnPressEscape && z();
    }
    return de(() => e.zIndex, () => {
      var F;
      v.value = (F = e.zIndex) != null ? F : a();
    }), de(() => e.modelValue, (F) => {
      var H;
      F ? (d.value = !1, O(), f.value = !0, v.value = (H = e.zIndex) != null ? H : a(), Re(() => {
        l("open"), t.value && (t.value.parentElement.scrollTop = 0, t.value.parentElement.scrollLeft = 0, t.value.scrollTop = 0);
      })) : c.value && N();
    }), de(() => e.fullscreen, (F) => {
      t.value && (F ? (r = t.value.style.transform, t.value.style.transform = "") : t.value.style.transform = r);
    }), ft(() => {
      e.modelValue && (c.value = !0, f.value = !0, O());
    }), {
      afterEnter: x,
      afterLeave: I,
      beforeLeave: P,
      handleClose: z,
      onModalClick: Y,
      close: N,
      doClose: M,
      onOpenAutoFocus: R,
      onCloseAutoFocus: D,
      onCloseRequested: V,
      onFocusoutPrevented: L,
      titleId: i,
      bodyId: u,
      closed: d,
      style: C,
      overlayDialogStyle: k,
      rendered: f,
      visible: c,
      zIndex: v,
      transitionConfig: T,
      _draggable: w,
      _alignCenter: y,
      _overflow: E
    };
  }, CF = /* @__PURE__ */ U({
    name: "ElDialog",
    inheritAttrs: !1
  }), SF = /* @__PURE__ */ U({
    ...CF,
    props: CE,
    emits: SE,
    setup(e, { expose: t }) {
      const n = e, o = hn();
      hl({
        scope: "el-dialog",
        from: "the title slot",
        replacement: "the header slot",
        version: "3.0.0",
        ref: "https://element-plus.org/en-US/component/dialog.html#slots"
      }, S(() => !!o.title));
      const l = he("dialog"), a = A(), r = A(), i = A(), {
        visible: u,
        titleId: c,
        bodyId: d,
        style: f,
        overlayDialogStyle: v,
        rendered: p,
        transitionConfig: m,
        zIndex: h,
        _draggable: g,
        _alignCenter: b,
        _overflow: C,
        handleClose: w,
        onModalClick: y,
        onOpenAutoFocus: E,
        onCloseAutoFocus: k,
        onCloseRequested: T,
        onFocusoutPrevented: x
      } = EE(n, a);
      yt(bE, {
        dialogRef: a,
        headerRef: r,
        bodyId: d,
        ns: l,
        rendered: p,
        style: f
      });
      const I = Hh(y), P = S(() => n.modalPenetrable && !n.modal && !n.fullscreen);
      return t({
        visible: u,
        dialogContentRef: i,
        resetPosition: () => {
          var N;
          (N = i.value) == null || N.resetPosition();
        },
        handleClose: w
      }), (N, z) => (_(), ae(s(uu), {
        to: N.appendTo,
        disabled: N.appendTo !== "body" ? !1 : !N.appendToBody
      }, {
        default: Q(() => [
          q(Mn, pt(s(m), { persisted: "" }), {
            default: Q(() => {
              var Y;
              return [
                it(q(s(Kh), {
                  "custom-mask-event": "",
                  mask: N.modal,
                  "overlay-class": [
                    (Y = N.modalClass) != null ? Y : "",
                    `${s(l).namespace.value}-modal-dialog`,
                    s(l).is("penetrable", s(P))
                  ],
                  "z-index": s(h)
                }, {
                  default: Q(() => [
                    W("div", {
                      role: "dialog",
                      "aria-modal": "true",
                      "aria-label": N.title || void 0,
                      "aria-labelledby": N.title ? void 0 : s(c),
                      "aria-describedby": s(d),
                      class: $(`${s(l).namespace.value}-overlay-dialog`),
                      style: Ue(s(v)),
                      onClick: s(I).onClick,
                      onMousedown: s(I).onMousedown,
                      onMouseup: s(I).onMouseup
                    }, [
                      q(s(_s), {
                        loop: "",
                        trapped: s(u),
                        "focus-start-el": "container",
                        onFocusAfterTrapped: s(E),
                        onFocusAfterReleased: s(k),
                        onFocusoutPrevented: s(x),
                        onReleaseRequested: s(T)
                      }, {
                        default: Q(() => [
                          s(p) ? (_(), ae(yF, pt({
                            key: 0,
                            ref_key: "dialogContentRef",
                            ref: i
                          }, N.$attrs, {
                            center: N.center,
                            "align-center": s(b),
                            "close-icon": N.closeIcon,
                            draggable: s(g),
                            overflow: s(C),
                            fullscreen: N.fullscreen,
                            "header-class": N.headerClass,
                            "body-class": N.bodyClass,
                            "footer-class": N.footerClass,
                            "show-close": N.showClose,
                            title: N.title,
                            "aria-level": N.headerAriaLevel,
                            onClose: s(w)
                          }), io({
                            header: Q(() => [
                              N.$slots.title ? ee(N.$slots, "title", { key: 1 }) : ee(N.$slots, "header", {
                                key: 0,
                                close: s(w),
                                titleId: s(c),
                                titleClass: s(l).e("title")
                              })
                            ]),
                            default: Q(() => [
                              ee(N.$slots, "default")
                            ]),
                            _: 2
                          }, [
                            N.$slots.footer ? {
                              name: "footer",
                              fn: Q(() => [
                                ee(N.$slots, "footer")
                              ])
                            } : void 0
                          ]), 1040, ["center", "align-center", "close-icon", "draggable", "overflow", "fullscreen", "header-class", "body-class", "footer-class", "show-close", "title", "aria-level", "onClose"])) : oe("v-if", !0)
                        ]),
                        _: 3
                      }, 8, ["trapped", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                    ], 46, ["aria-label", "aria-labelledby", "aria-describedby", "onClick", "onMousedown", "onMouseup"])
                  ]),
                  _: 3
                }, 8, ["mask", "overlay-class", "z-index"]), [
                  [Mt, s(u)]
                ])
              ];
            }),
            _: 3
          }, 16)
        ]),
        _: 3
      }, 8, ["to", "disabled"]));
    }
  });
  var EF = /* @__PURE__ */ Ne(SF, [["__file", "dialog.vue"]]);
  const kF = rt(EF), _F = Te({
    direction: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "horizontal"
    },
    contentPosition: {
      type: String,
      values: ["left", "center", "right"],
      default: "center"
    },
    borderStyle: {
      type: X(String),
      default: "solid"
    }
  }), TF = /* @__PURE__ */ U({
    name: "ElDivider"
  }), NF = /* @__PURE__ */ U({
    ...TF,
    props: _F,
    setup(e) {
      const t = e, n = he("divider"), o = S(() => n.cssVar({
        "border-style": t.borderStyle
      }));
      return (l, a) => (_(), B("div", {
        class: $([s(n).b(), s(n).m(l.direction)]),
        style: Ue(s(o)),
        role: "separator"
      }, [
        l.$slots.default && l.direction !== "vertical" ? (_(), B("div", {
          key: 0,
          class: $([s(n).e("text"), s(n).is(l.contentPosition)])
        }, [
          ee(l.$slots, "default")
        ], 2)) : oe("v-if", !0)
      ], 6));
    }
  });
  var $F = /* @__PURE__ */ Ne(NF, [["__file", "divider.vue"]]);
  const kE = rt($F), OF = Te({
    ...CE,
    direction: {
      type: String,
      default: "rtl",
      values: ["ltr", "rtl", "ttb", "btt"]
    },
    resizable: Boolean,
    size: {
      type: [String, Number],
      default: "30%"
    },
    withHeader: {
      type: Boolean,
      default: !0
    },
    modalFade: {
      type: Boolean,
      default: !0
    },
    headerAriaLevel: {
      type: String,
      default: "2"
    }
  }), IF = {
    ...SE,
    "resize-start": (e, t) => e instanceof MouseEvent && typeof t == "number",
    resize: (e, t) => e instanceof MouseEvent && typeof t == "number",
    "resize-end": (e, t) => e instanceof MouseEvent && typeof t == "number"
  };
  function MF(e, t, n) {
    const { width: o, height: l } = sh(), a = S(() => ["ltr", "rtl"].includes(e.direction)), r = S(() => ["ltr", "ttb"].includes(e.direction) ? 1 : -1), i = S(() => a.value ? o.value : l.value), u = S(() => X1(c.value + r.value * d.value, 4, i.value)), c = A(0), d = A(0), f = A(!1), v = A(!1);
    let p = [], m = [];
    const h = () => {
      var y;
      const E = (y = t.value) == null ? void 0 : y.closest('[aria-modal="true"]');
      return E ? a.value ? E.offsetWidth : E.offsetHeight : 100;
    };
    de(() => [e.size, e.resizable], () => {
      v.value = !1, c.value = 0, d.value = 0, C();
    });
    const g = (y) => {
      e.resizable && (v.value || (c.value = h(), v.value = !0), p = [y.pageX, y.pageY], f.value = !0, n("resize-start", y, c.value), m.push(Dt(window, "mouseup", C), Dt(window, "mousemove", b)));
    }, b = (y) => {
      const { pageX: E, pageY: k } = y, T = E - p[0], x = k - p[1];
      d.value = a.value ? T : x, n("resize", y, u.value);
    }, C = (y) => {
      f.value && (p = [], c.value = u.value, d.value = 0, f.value = !1, m.forEach((E) => E == null ? void 0 : E()), m = [], y && n("resize-end", y, c.value));
    }, w = Dt(t, "mousedown", g);
    return Bt(() => {
      w(), C();
    }), {
      size: S(() => v.value ? `${u.value}px` : tn(e.size)),
      isResizing: f,
      isHorizontal: a
    };
  }
  const xF = /* @__PURE__ */ U({
    name: "ElDrawer",
    inheritAttrs: !1
  }), PF = /* @__PURE__ */ U({
    ...xF,
    props: OF,
    emits: IF,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = hn();
      hl({
        scope: "el-drawer",
        from: "the title slot",
        replacement: "the header slot",
        version: "3.0.0",
        ref: "https://element-plus.org/en-US/component/drawer.html#slots"
      }, S(() => !!l.title));
      const a = A(), r = A(), i = A(), u = he("drawer"), { t: c } = _t(), {
        afterEnter: d,
        afterLeave: f,
        beforeLeave: v,
        visible: p,
        rendered: m,
        titleId: h,
        bodyId: g,
        zIndex: b,
        onModalClick: C,
        onOpenAutoFocus: w,
        onCloseAutoFocus: y,
        onFocusoutPrevented: E,
        onCloseRequested: k,
        handleClose: T
      } = EE(o, a), { isHorizontal: x, size: I, isResizing: P } = MF(o, i, n), O = S(() => o.modalPenetrable && !o.modal);
      return t({
        handleClose: T,
        afterEnter: d,
        afterLeave: f
      }), (N, z) => (_(), ae(s(uu), {
        to: N.appendTo,
        disabled: N.appendTo !== "body" ? !1 : !N.appendToBody
      }, {
        default: Q(() => [
          q(Mn, {
            name: s(u).b("fade"),
            onAfterEnter: s(d),
            onAfterLeave: s(f),
            onBeforeLeave: s(v),
            persisted: ""
          }, {
            default: Q(() => {
              var Y;
              return [
                it(q(s(Kh), {
                  mask: N.modal,
                  "overlay-class": [
                    s(u).is("drawer"),
                    (Y = N.modalClass) != null ? Y : "",
                    `${s(u).namespace.value}-modal-drawer`,
                    s(u).is("penetrable", s(O))
                  ],
                  "z-index": s(b),
                  onClick: s(C)
                }, {
                  default: Q(() => [
                    q(s(_s), {
                      loop: "",
                      trapped: s(p),
                      "focus-trap-el": a.value,
                      "focus-start-el": r.value,
                      onFocusAfterTrapped: s(w),
                      onFocusAfterReleased: s(y),
                      onFocusoutPrevented: s(E),
                      onReleaseRequested: s(k)
                    }, {
                      default: Q(() => [
                        W("div", pt({
                          ref_key: "drawerRef",
                          ref: a,
                          "aria-modal": "true",
                          "aria-label": N.title || void 0,
                          "aria-labelledby": N.title ? void 0 : s(h),
                          "aria-describedby": s(g)
                        }, N.$attrs, {
                          class: [
                            s(u).b(),
                            N.direction,
                            s(p) && "open",
                            s(u).is("dragging", s(P))
                          ],
                          style: { [s(x) ? "width" : "height"]: s(I) },
                          role: "dialog",
                          onClick: Ze(() => {
                          }, ["stop"])
                        }), [
                          W("span", {
                            ref_key: "focusStartRef",
                            ref: r,
                            class: $(s(u).e("sr-focus")),
                            tabindex: "-1"
                          }, null, 2),
                          N.withHeader ? (_(), B("header", {
                            key: 0,
                            class: $([s(u).e("header"), N.headerClass])
                          }, [
                            N.$slots.title ? ee(N.$slots, "title", { key: 1 }, () => [
                              oe(" DEPRECATED SLOT ")
                            ]) : ee(N.$slots, "header", {
                              key: 0,
                              close: s(T),
                              titleId: s(h),
                              titleClass: s(u).e("title")
                            }, () => [
                              W("span", {
                                id: s(h),
                                role: "heading",
                                "aria-level": N.headerAriaLevel,
                                class: $(s(u).e("title"))
                              }, ke(N.title), 11, ["id", "aria-level"])
                            ]),
                            N.showClose ? (_(), B("button", {
                              key: 2,
                              "aria-label": s(c)("el.drawer.close"),
                              class: $(s(u).e("close-btn")),
                              type: "button",
                              onClick: s(T)
                            }, [
                              q(s(ze), {
                                class: $(s(u).e("close"))
                              }, {
                                default: Q(() => [
                                  q(s(Oo))
                                ]),
                                _: 1
                              }, 8, ["class"])
                            ], 10, ["aria-label", "onClick"])) : oe("v-if", !0)
                          ], 2)) : oe("v-if", !0),
                          s(m) ? (_(), B("div", {
                            key: 1,
                            id: s(g),
                            class: $([s(u).e("body"), N.bodyClass])
                          }, [
                            ee(N.$slots, "default")
                          ], 10, ["id"])) : oe("v-if", !0),
                          N.$slots.footer ? (_(), B("div", {
                            key: 2,
                            class: $([s(u).e("footer"), N.footerClass])
                          }, [
                            ee(N.$slots, "footer")
                          ], 2)) : oe("v-if", !0),
                          N.resizable ? (_(), B("div", {
                            key: 3,
                            ref_key: "draggerRef",
                            ref: i,
                            style: Ue({ zIndex: s(b) }),
                            class: $(s(u).e("dragger"))
                          }, null, 6)) : oe("v-if", !0)
                        ], 16, ["aria-label", "aria-labelledby", "aria-describedby", "onClick"])
                      ]),
                      _: 3
                    }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onFocusAfterTrapped", "onFocusAfterReleased", "onFocusoutPrevented", "onReleaseRequested"])
                  ]),
                  _: 3
                }, 8, ["mask", "overlay-class", "z-index", "onClick"]), [
                  [Mt, s(p)]
                ])
              ];
            }),
            _: 3
          }, 8, ["name", "onAfterEnter", "onAfterLeave", "onBeforeLeave"])
        ]),
        _: 3
      }, 8, ["to", "disabled"]));
    }
  });
  var RF = /* @__PURE__ */ Ne(PF, [["__file", "drawer.vue"]]);
  const DF = rt(RF), AF = /* @__PURE__ */ U({
    inheritAttrs: !1
  });
  function VF(e, t, n, o, l, a) {
    return ee(e.$slots, "default");
  }
  var LF = /* @__PURE__ */ Ne(AF, [["render", VF], ["__file", "collection.vue"]]);
  const BF = /* @__PURE__ */ U({
    name: "ElCollectionItem",
    inheritAttrs: !1
  });
  function FF(e, t, n, o, l, a) {
    return ee(e.$slots, "default");
  }
  var zF = /* @__PURE__ */ Ne(BF, [["render", FF], ["__file", "collection-item.vue"]]);
  const _E = "data-el-collection-item", HF = (e) => {
    const t = `El${e}Collection`, n = `${t}Item`, o = Symbol(t), l = Symbol(n), a = {
      ...LF,
      name: t,
      setup() {
        const i = A(), u = /* @__PURE__ */ new Map();
        yt(o, {
          itemMap: u,
          getItems: () => {
            const d = s(i);
            if (!d)
              return [];
            const f = Array.from(d.querySelectorAll(`[${_E}]`));
            return [...u.values()].sort((p, m) => f.indexOf(p.ref) - f.indexOf(m.ref));
          },
          collectionRef: i
        });
      }
    }, r = {
      ...zF,
      name: n,
      setup(i, { attrs: u }) {
        const c = A(), d = Ve(o, void 0);
        yt(l, {
          collectionItemRef: c
        }), ft(() => {
          const f = s(c);
          f && d.itemMap.set(f, {
            ref: f,
            ...u
          });
        }), Bt(() => {
          const f = s(c);
          d.itemMap.delete(f);
        });
      }
    };
    return {
      COLLECTION_INJECTION_KEY: o,
      COLLECTION_ITEM_INJECTION_KEY: l,
      ElCollection: a,
      ElCollectionItem: r
    };
  }, KF = Te({
    style: { type: X([String, Array, Object]) },
    currentTabId: {
      type: X(String)
    },
    defaultCurrentTabId: String,
    loop: Boolean,
    dir: {
      type: String,
      values: ["ltr", "rtl"],
      default: "ltr"
    },
    orientation: {
      type: X(String)
    },
    onBlur: Function,
    onFocus: Function,
    onMousedown: Function
  }), {
    ElCollection: WF,
    ElCollectionItem: jF,
    COLLECTION_INJECTION_KEY: TE,
    COLLECTION_ITEM_INJECTION_KEY: UF
  } = HF("RovingFocusGroup"), jh = Symbol("elRovingFocusGroup"), NE = Symbol("elRovingFocusGroupItem"), YF = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  }, qF = (e, t) => e, GF = (e, t, n) => {
    const o = Ht(e), l = qF(o);
    return YF[l];
  }, XF = (e, t) => e.map((n, o) => e[(o + t) % e.length]), hy = (e) => {
    const { activeElement: t } = document;
    for (const n of e)
      if (n === t || (n.focus(), t !== document.activeElement))
        return;
  }, my = "currentTabIdChange", gy = "rovingFocusGroup.entryFocus", JF = { bubbles: !1, cancelable: !0 }, ZF = /* @__PURE__ */ U({
    name: "ElRovingFocusGroupImpl",
    inheritAttrs: !1,
    props: KF,
    emits: [my, "entryFocus"],
    setup(e, { emit: t }) {
      var n;
      const o = A((n = e.currentTabId || e.defaultCurrentTabId) != null ? n : null), l = A(!1), a = A(!1), r = A(), { getItems: i } = Ve(TE, void 0), u = S(() => [
        {
          outline: "none"
        },
        e.style
      ]), c = (g) => {
        t(my, g);
      }, d = () => {
        l.value = !0;
      }, f = bn((g) => {
        var b;
        (b = e.onMousedown) == null || b.call(e, g);
      }, () => {
        a.value = !0;
      }), v = bn((g) => {
        var b;
        (b = e.onFocus) == null || b.call(e, g);
      }, (g) => {
        const b = !s(a), { target: C, currentTarget: w } = g;
        if (C === w && b && !s(l)) {
          const y = new Event(gy, JF);
          if (w == null || w.dispatchEvent(y), !y.defaultPrevented) {
            const E = i().filter((P) => P.focusable), k = E.find((P) => P.active), T = E.find((P) => P.id === s(o)), I = [k, T, ...E].filter(Boolean).map((P) => P.ref);
            hy(I);
          }
        }
        a.value = !1;
      }), p = bn((g) => {
        var b;
        (b = e.onBlur) == null || b.call(e, g);
      }, () => {
        l.value = !1;
      }), m = (...g) => {
        t("entryFocus", ...g);
      }, h = (g) => {
        const b = GF(g);
        if (b) {
          g.preventDefault();
          let w = i().filter((y) => y.focusable).map((y) => y.ref);
          switch (b) {
            case "last": {
              w.reverse();
              break;
            }
            case "prev":
            case "next": {
              b === "prev" && w.reverse();
              const y = w.indexOf(g.currentTarget);
              w = e.loop ? XF(w, y + 1) : w.slice(y + 1);
              break;
            }
          }
          Re(() => {
            hy(w);
          });
        }
      };
      yt(jh, {
        currentTabbedId: ir(o),
        loop: At(e, "loop"),
        tabIndex: S(() => s(l) ? -1 : 0),
        rovingFocusGroupRef: r,
        rovingFocusGroupRootStyle: u,
        orientation: At(e, "orientation"),
        dir: At(e, "dir"),
        onItemFocus: c,
        onItemShiftTab: d,
        onBlur: p,
        onFocus: v,
        onMousedown: f,
        onKeydown: h
      }), de(() => e.currentTabId, (g) => {
        o.value = g ?? null;
      }), Dt(r, gy, m);
    }
  });
  function QF(e, t, n, o, l, a) {
    return ee(e.$slots, "default");
  }
  var ez = /* @__PURE__ */ Ne(ZF, [["render", QF], ["__file", "roving-focus-group-impl.vue"]]);
  const tz = /* @__PURE__ */ U({
    name: "ElRovingFocusGroup",
    components: {
      ElFocusGroupCollection: WF,
      ElRovingFocusGroupImpl: ez
    }
  });
  function nz(e, t, n, o, l, a) {
    const r = $t("el-roving-focus-group-impl"), i = $t("el-focus-group-collection");
    return _(), ae(i, null, {
      default: Q(() => [
        q(r, Bo(fl(e.$attrs)), {
          default: Q(() => [
            ee(e.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    });
  }
  var oz = /* @__PURE__ */ Ne(tz, [["render", nz], ["__file", "roving-focus-group.vue"]]);
  const oc = Te({
    trigger: {
      ...vl.trigger,
      type: X([
        String,
        Array
      ])
    },
    triggerKeys: {
      type: X(Array),
      default: () => [
        _e.enter,
        _e.numpadEnter,
        _e.space,
        _e.down
      ]
    },
    virtualTriggering: vl.virtualTriggering,
    virtualRef: vl.virtualRef,
    effect: {
      ...zt.effect,
      default: "light"
    },
    type: {
      type: X(String)
    },
    placement: {
      type: X(String),
      default: "bottom"
    },
    popperOptions: {
      type: X(Object),
      default: () => ({})
    },
    id: String,
    size: {
      type: String,
      default: ""
    },
    splitButton: Boolean,
    hideOnClick: {
      type: Boolean,
      default: !0
    },
    loop: {
      type: Boolean,
      default: !0
    },
    showArrow: {
      type: Boolean,
      default: !0
    },
    showTimeout: {
      type: Number,
      default: 150
    },
    hideTimeout: {
      type: Number,
      default: 150
    },
    tabindex: {
      type: X([Number, String]),
      default: 0
    },
    maxHeight: {
      type: X([Number, String]),
      default: ""
    },
    popperClass: zt.popperClass,
    popperStyle: zt.popperStyle,
    disabled: Boolean,
    role: {
      type: String,
      values: MC,
      default: "menu"
    },
    buttonProps: {
      type: X(Object)
    },
    teleported: zt.teleported,
    persistent: {
      type: Boolean,
      default: !0
    }
  }), $E = Te({
    command: {
      type: [Object, String, Number],
      default: () => ({})
    },
    disabled: Boolean,
    divided: Boolean,
    textValue: String,
    icon: {
      type: Lt
    }
  }), lz = Te({
    onKeydown: { type: X(Function) }
  }), jd = Symbol("elDropdown"), OE = "elDropdown", { ButtonGroup: az } = _n, rz = /* @__PURE__ */ U({
    name: "ElDropdown",
    components: {
      ElButton: _n,
      ElButtonGroup: az,
      ElScrollbar: Go,
      ElTooltip: Pn,
      ElRovingFocusGroup: oz,
      ElOnlyChild: DC,
      ElIcon: ze,
      ArrowDown: Nl
    },
    props: oc,
    emits: ["visible-change", "click", "command"],
    setup(e, { emit: t }) {
      const n = dt(), o = he("dropdown"), { t: l } = _t(), a = A(), r = A(), i = A(), u = A(), c = A(null), d = A(null), f = A(!1), v = S(() => ({
        maxHeight: tn(e.maxHeight)
      })), p = S(() => [o.m(y.value)]), m = S(() => En(e.trigger)), h = xn().value, g = S(() => e.id || h);
      function b() {
        var z;
        (z = i.value) == null || z.onClose(void 0, 0);
      }
      function C() {
        var z;
        (z = i.value) == null || z.onClose();
      }
      function w() {
        var z;
        (z = i.value) == null || z.onOpen();
      }
      const y = vn();
      function E(...z) {
        t("command", ...z);
      }
      function k() {
      }
      function T() {
        const z = s(u);
        m.value.includes("hover") && (z == null || z.focus({
          preventScroll: !0
        })), d.value = null;
      }
      function x(z) {
        d.value = z;
      }
      function I() {
        t("visible-change", !0);
      }
      function P(z) {
        var Y;
        f.value = (z == null ? void 0 : z.type) === "keydown", (Y = u.value) == null || Y.focus();
      }
      function O() {
        t("visible-change", !1);
      }
      return yt(jd, {
        contentRef: u,
        role: S(() => e.role),
        triggerId: g,
        isUsingKeyboard: f,
        onItemEnter: k,
        onItemLeave: T,
        handleClose: C
      }), yt(OE, {
        instance: n,
        dropdownSize: y,
        handleClick: b,
        commandHandler: E,
        trigger: At(e, "trigger"),
        hideOnClick: At(e, "hideOnClick")
      }), {
        t: l,
        ns: o,
        scrollbar: c,
        wrapStyle: v,
        dropdownTriggerKls: p,
        dropdownSize: y,
        triggerId: g,
        currentTabId: d,
        handleCurrentTabIdChange: x,
        handlerMainButtonClick: (z) => {
          t("click", z);
        },
        handleClose: C,
        handleOpen: w,
        handleBeforeShowTooltip: I,
        handleShowTooltip: P,
        handleBeforeHideTooltip: O,
        popperRef: i,
        contentRef: u,
        triggeringElementRef: a,
        referenceElementRef: r
      };
    }
  });
  function sz(e, t, n, o, l, a) {
    var r;
    const i = $t("el-roving-focus-group"), u = $t("el-scrollbar"), c = $t("el-only-child"), d = $t("el-tooltip"), f = $t("el-button"), v = $t("arrow-down"), p = $t("el-icon"), m = $t("el-button-group");
    return _(), B("div", {
      class: $([e.ns.b(), e.ns.is("disabled", e.disabled)])
    }, [
      q(d, {
        ref: "popperRef",
        role: e.role,
        effect: e.effect,
        "fallback-placements": ["bottom", "top"],
        "popper-options": e.popperOptions,
        "gpu-acceleration": !1,
        placement: e.placement,
        "popper-class": [e.ns.e("popper"), e.popperClass],
        "popper-style": e.popperStyle,
        trigger: e.trigger,
        "trigger-keys": e.triggerKeys,
        "trigger-target-el": e.contentRef,
        "show-arrow": e.showArrow,
        "show-after": e.trigger === "hover" ? e.showTimeout : 0,
        "hide-after": e.trigger === "hover" ? e.hideTimeout : 0,
        "virtual-ref": (r = e.virtualRef) != null ? r : e.triggeringElementRef,
        "virtual-triggering": e.virtualTriggering || e.splitButton,
        disabled: e.disabled,
        transition: `${e.ns.namespace.value}-zoom-in-top`,
        teleported: e.teleported,
        pure: "",
        "focus-on-target": "",
        persistent: e.persistent,
        onBeforeShow: e.handleBeforeShowTooltip,
        onShow: e.handleShowTooltip,
        onBeforeHide: e.handleBeforeHideTooltip
      }, io({
        content: Q(() => [
          q(u, {
            ref: "scrollbar",
            "wrap-style": e.wrapStyle,
            tag: "div",
            "view-class": e.ns.e("list")
          }, {
            default: Q(() => [
              q(i, {
                loop: e.loop,
                "current-tab-id": e.currentTabId,
                orientation: "horizontal",
                onCurrentTabIdChange: e.handleCurrentTabIdChange
              }, {
                default: Q(() => [
                  ee(e.$slots, "dropdown")
                ]),
                _: 3
              }, 8, ["loop", "current-tab-id", "onCurrentTabIdChange"])
            ]),
            _: 3
          }, 8, ["wrap-style", "view-class"])
        ]),
        _: 2
      }, [
        e.splitButton ? void 0 : {
          name: "default",
          fn: Q(() => [
            q(c, {
              id: e.triggerId,
              ref: "triggeringElementRef",
              role: "button",
              tabindex: e.tabindex
            }, {
              default: Q(() => [
                ee(e.$slots, "default")
              ]),
              _: 3
            }, 8, ["id", "tabindex"])
          ])
        }
      ]), 1032, ["role", "effect", "popper-options", "placement", "popper-class", "popper-style", "trigger", "trigger-keys", "trigger-target-el", "show-arrow", "show-after", "hide-after", "virtual-ref", "virtual-triggering", "disabled", "transition", "teleported", "persistent", "onBeforeShow", "onShow", "onBeforeHide"]),
      e.splitButton ? (_(), ae(m, { key: 0 }, {
        default: Q(() => [
          q(f, pt({ ref: "referenceElementRef" }, e.buttonProps, {
            size: e.dropdownSize,
            type: e.type,
            disabled: e.disabled,
            tabindex: e.tabindex,
            onClick: e.handlerMainButtonClick
          }), {
            default: Q(() => [
              ee(e.$slots, "default")
            ]),
            _: 3
          }, 16, ["size", "type", "disabled", "tabindex", "onClick"]),
          q(f, pt({
            id: e.triggerId,
            ref: "triggeringElementRef"
          }, e.buttonProps, {
            role: "button",
            size: e.dropdownSize,
            type: e.type,
            class: e.ns.e("caret-button"),
            disabled: e.disabled,
            tabindex: e.tabindex,
            "aria-label": e.t("el.dropdown.toggleDropdown")
          }), {
            default: Q(() => [
              q(p, {
                class: $(e.ns.e("icon"))
              }, {
                default: Q(() => [
                  q(v)
                ]),
                _: 1
              }, 8, ["class"])
            ]),
            _: 1
          }, 16, ["id", "size", "type", "class", "disabled", "tabindex", "aria-label"])
        ]),
        _: 3
      })) : oe("v-if", !0)
    ], 2);
  }
  var iz = /* @__PURE__ */ Ne(rz, [["render", sz], ["__file", "dropdown.vue"]]);
  const uz = /* @__PURE__ */ U({
    components: {
      ElRovingFocusCollectionItem: jF
    },
    props: {
      focusable: {
        type: Boolean,
        default: !0
      },
      active: Boolean
    },
    emits: ["mousedown", "focus", "keydown"],
    setup(e, { emit: t }) {
      const { currentTabbedId: n, onItemFocus: o, onItemShiftTab: l, onKeydown: a } = Ve(jh, void 0), r = xn(), i = A(), u = bn((v) => {
        t("mousedown", v);
      }, (v) => {
        e.focusable ? o(s(r)) : v.preventDefault();
      }), c = bn((v) => {
        t("focus", v);
      }, () => {
        o(s(r));
      }), d = bn((v) => {
        t("keydown", v);
      }, (v) => {
        const { shiftKey: p, target: m, currentTarget: h } = v;
        if (Ht(v) === _e.tab && p) {
          l();
          return;
        }
        m === h && a(v);
      }), f = S(() => n.value === s(r));
      return yt(NE, {
        rovingFocusGroupItemRef: i,
        tabIndex: S(() => s(f) ? 0 : -1),
        handleMousedown: u,
        handleFocus: c,
        handleKeydown: d
      }), {
        id: r,
        handleKeydown: d,
        handleFocus: c,
        handleMousedown: u
      };
    }
  });
  function cz(e, t, n, o, l, a) {
    const r = $t("el-roving-focus-collection-item");
    return _(), ae(r, {
      id: e.id,
      focusable: e.focusable,
      active: e.active
    }, {
      default: Q(() => [
        ee(e.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "focusable", "active"]);
  }
  var dz = /* @__PURE__ */ Ne(uz, [["render", cz], ["__file", "roving-focus-item.vue"]]);
  const fz = /* @__PURE__ */ U({
    name: "DropdownItemImpl",
    components: {
      ElIcon: ze
    },
    props: $E,
    emits: ["pointermove", "pointerleave", "click", "clickimpl"],
    setup(e, { emit: t }) {
      const n = he("dropdown"), { role: o } = Ve(jd, void 0), { collectionItemRef: l } = Ve(UF, void 0), {
        rovingFocusGroupItemRef: a,
        tabIndex: r,
        handleFocus: i,
        handleKeydown: u,
        handleMousedown: c
      } = Ve(NE, void 0), d = Wh(l, a), f = S(() => o.value === "menu" ? "menuitem" : o.value === "navigation" ? "link" : "button"), v = bn((p) => {
        const m = Ht(p);
        if ([_e.enter, _e.numpadEnter, _e.space].includes(m))
          return p.preventDefault(), p.stopImmediatePropagation(), t("clickimpl", p), !0;
      }, u);
      return {
        ns: n,
        itemRef: d,
        dataset: {
          [_E]: ""
        },
        role: f,
        tabIndex: r,
        handleFocus: i,
        handleKeydown: v,
        handleMousedown: c
      };
    }
  });
  function pz(e, t, n, o, l, a) {
    const r = $t("el-icon");
    return _(), B(We, null, [
      e.divided ? (_(), B("li", {
        key: 0,
        role: "separator",
        class: $(e.ns.bem("menu", "item", "divided"))
      }, null, 2)) : oe("v-if", !0),
      W("li", pt({ ref: e.itemRef }, { ...e.dataset, ...e.$attrs }, {
        "aria-disabled": e.disabled,
        class: [e.ns.be("menu", "item"), e.ns.is("disabled", e.disabled)],
        tabindex: e.tabIndex,
        role: e.role,
        onClick: (i) => e.$emit("clickimpl", i),
        onFocus: e.handleFocus,
        onKeydown: Ze(e.handleKeydown, ["self"]),
        onMousedown: e.handleMousedown,
        onPointermove: (i) => e.$emit("pointermove", i),
        onPointerleave: (i) => e.$emit("pointerleave", i)
      }), [
        e.icon ? (_(), ae(r, { key: 0 }, {
          default: Q(() => [
            (_(), ae(ct(e.icon)))
          ]),
          _: 1
        })) : oe("v-if", !0),
        ee(e.$slots, "default")
      ], 16, ["aria-disabled", "tabindex", "role", "onClick", "onFocus", "onKeydown", "onMousedown", "onPointermove", "onPointerleave"])
    ], 64);
  }
  var vz = /* @__PURE__ */ Ne(fz, [["render", pz], ["__file", "dropdown-item-impl.vue"]]);
  const IE = () => {
    const e = Ve(OE, {}), t = S(() => e == null ? void 0 : e.dropdownSize);
    return {
      elDropdown: e,
      _elDropdownSize: t
    };
  }, hz = /* @__PURE__ */ U({
    name: "ElDropdownItem",
    components: {
      ElRovingFocusItem: dz,
      ElDropdownItemImpl: vz
    },
    inheritAttrs: !1,
    props: $E,
    emits: ["pointermove", "pointerleave", "click"],
    setup(e, { emit: t, attrs: n }) {
      const { elDropdown: o } = IE(), l = dt(), { onItemEnter: a, onItemLeave: r } = Ve(jd, void 0), i = bn((f) => (t("pointermove", f), f.defaultPrevented), Ab((f) => {
        if (e.disabled) {
          r(f);
          return;
        }
        const v = f.currentTarget;
        v === document.activeElement || v.contains(document.activeElement) || (a(f), f.defaultPrevented || v == null || v.focus({
          preventScroll: !0
        }));
      })), u = bn((f) => (t("pointerleave", f), f.defaultPrevented), Ab(r)), c = bn((f) => {
        if (!e.disabled)
          return t("click", f), f.type !== "keydown" && f.defaultPrevented;
      }, (f) => {
        var v, p, m;
        if (e.disabled) {
          f.stopImmediatePropagation();
          return;
        }
        (v = o == null ? void 0 : o.hideOnClick) != null && v.value && ((p = o.handleClick) == null || p.call(o)), (m = o.commandHandler) == null || m.call(o, e.command, l, f);
      }), d = S(() => ({ ...e, ...n }));
      return {
        handleClick: c,
        handlePointerMove: i,
        handlePointerLeave: u,
        propsAndAttrs: d
      };
    }
  });
  function mz(e, t, n, o, l, a) {
    const r = $t("el-dropdown-item-impl"), i = $t("el-roving-focus-item");
    return _(), ae(i, {
      focusable: !e.disabled
    }, {
      default: Q(() => [
        q(r, pt(e.propsAndAttrs, {
          onPointerleave: e.handlePointerLeave,
          onPointermove: e.handlePointerMove,
          onClickimpl: e.handleClick
        }), {
          default: Q(() => [
            ee(e.$slots, "default")
          ]),
          _: 3
        }, 16, ["onPointerleave", "onPointermove", "onClickimpl"])
      ]),
      _: 3
    }, 8, ["focusable"]);
  }
  var ME = /* @__PURE__ */ Ne(hz, [["render", mz], ["__file", "dropdown-item.vue"]]);
  const gz = /* @__PURE__ */ U({
    name: "ElDropdownMenu",
    props: lz,
    setup(e) {
      const t = he("dropdown"), { _elDropdownSize: n } = IE(), o = n.value, { contentRef: l, role: a, triggerId: r, isUsingKeyboard: i, handleClose: u } = Ve(jd, void 0), {
        rovingFocusGroupRef: c,
        rovingFocusGroupRootStyle: d,
        onBlur: f,
        onFocus: v,
        onKeydown: p,
        onMousedown: m
      } = Ve(jh, void 0), { collectionRef: h } = Ve(TE, void 0), g = S(() => [t.b("menu"), t.bm("menu", o == null ? void 0 : o.value)]), b = Wh(l, c, h), C = bn((y) => {
        var E;
        (E = e.onKeydown) == null || E.call(e, y);
      }, (y) => {
        const { currentTarget: E, target: k } = y, T = Ht(y);
        if (E.contains(k), _e.tab === T)
          return u();
        p(y);
      });
      function w(y) {
        i.value && v(y);
      }
      return {
        size: o,
        rovingFocusGroupRootStyle: d,
        dropdownKls: g,
        role: a,
        triggerId: r,
        dropdownListWrapperRef: b,
        handleKeydown: C,
        onBlur: f,
        handleFocus: w,
        onMousedown: m
      };
    }
  });
  function bz(e, t, n, o, l, a) {
    return _(), B("ul", {
      ref: e.dropdownListWrapperRef,
      class: $(e.dropdownKls),
      style: Ue(e.rovingFocusGroupRootStyle),
      tabindex: -1,
      role: e.role,
      "aria-labelledby": e.triggerId,
      onFocusin: e.handleFocus,
      onFocusout: e.onBlur,
      onKeydown: Ze(e.handleKeydown, ["self"]),
      onMousedown: Ze(e.onMousedown, ["self"])
    }, [
      ee(e.$slots, "default")
    ], 46, ["role", "aria-labelledby", "onFocusin", "onFocusout", "onKeydown", "onMousedown"]);
  }
  var xE = /* @__PURE__ */ Ne(gz, [["render", bz], ["__file", "dropdown-menu.vue"]]);
  const yz = rt(iz, {
    DropdownItem: ME,
    DropdownMenu: xE
  }), wz = nn(ME), Cz = nn(xE), Sz = /* @__PURE__ */ U({
    name: "ImgEmpty"
  }), Ez = /* @__PURE__ */ U({
    ...Sz,
    setup(e) {
      const t = he("empty"), n = xn();
      return (o, l) => (_(), B("svg", {
        viewBox: "0 0 79 86",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink"
      }, [
        W("defs", null, [
          W("linearGradient", {
            id: `linearGradient-1-${s(n)}`,
            x1: "38.8503086%",
            y1: "0%",
            x2: "61.1496914%",
            y2: "100%"
          }, [
            W("stop", {
              "stop-color": `var(${s(t).cssVarBlockName("fill-color-1")})`,
              offset: "0%"
            }, null, 8, ["stop-color"]),
            W("stop", {
              "stop-color": `var(${s(t).cssVarBlockName("fill-color-4")})`,
              offset: "100%"
            }, null, 8, ["stop-color"])
          ], 8, ["id"]),
          W("linearGradient", {
            id: `linearGradient-2-${s(n)}`,
            x1: "0%",
            y1: "9.5%",
            x2: "100%",
            y2: "90.5%"
          }, [
            W("stop", {
              "stop-color": `var(${s(t).cssVarBlockName("fill-color-1")})`,
              offset: "0%"
            }, null, 8, ["stop-color"]),
            W("stop", {
              "stop-color": `var(${s(t).cssVarBlockName("fill-color-6")})`,
              offset: "100%"
            }, null, 8, ["stop-color"])
          ], 8, ["id"]),
          W("rect", {
            id: `path-3-${s(n)}`,
            x: "0",
            y: "0",
            width: "17",
            height: "36"
          }, null, 8, ["id"])
        ]),
        W("g", {
          stroke: "none",
          "stroke-width": "1",
          fill: "none",
          "fill-rule": "evenodd"
        }, [
          W("g", { transform: "translate(-1268.000000, -535.000000)" }, [
            W("g", { transform: "translate(1268.000000, 535.000000)" }, [
              W("path", {
                d: "M39.5,86 C61.3152476,86 79,83.9106622 79,81.3333333 C79,78.7560045 57.3152476,78 35.5,78 C13.6847524,78 0,78.7560045 0,81.3333333 C0,83.9106622 17.6847524,86 39.5,86 Z",
                fill: `var(${s(t).cssVarBlockName("fill-color-3")})`
              }, null, 8, ["fill"]),
              W("polygon", {
                fill: `var(${s(t).cssVarBlockName("fill-color-7")})`,
                transform: "translate(27.500000, 51.500000) scale(1, -1) translate(-27.500000, -51.500000) ",
                points: "13 58 53 58 42 45 2 45"
              }, null, 8, ["fill"]),
              W("g", { transform: "translate(34.500000, 31.500000) scale(-1, 1) rotate(-25.000000) translate(-34.500000, -31.500000) translate(7.000000, 10.000000)" }, [
                W("polygon", {
                  fill: `var(${s(t).cssVarBlockName("fill-color-7")})`,
                  transform: "translate(11.500000, 5.000000) scale(1, -1) translate(-11.500000, -5.000000) ",
                  points: "2.84078316e-14 3 18 3 23 7 5 7"
                }, null, 8, ["fill"]),
                W("polygon", {
                  fill: `var(${s(t).cssVarBlockName("fill-color-5")})`,
                  points: "-3.69149156e-15 7 38 7 38 43 -3.69149156e-15 43"
                }, null, 8, ["fill"]),
                W("rect", {
                  fill: `url(#linearGradient-1-${s(n)})`,
                  transform: "translate(46.500000, 25.000000) scale(-1, 1) translate(-46.500000, -25.000000) ",
                  x: "38",
                  y: "7",
                  width: "17",
                  height: "36"
                }, null, 8, ["fill"]),
                W("polygon", {
                  fill: `var(${s(t).cssVarBlockName("fill-color-2")})`,
                  transform: "translate(39.500000, 3.500000) scale(-1, 1) translate(-39.500000, -3.500000) ",
                  points: "24 7 41 7 55 -3.63806207e-12 38 -3.63806207e-12"
                }, null, 8, ["fill"])
              ]),
              W("rect", {
                fill: `url(#linearGradient-2-${s(n)})`,
                x: "13",
                y: "45",
                width: "40",
                height: "36"
              }, null, 8, ["fill"]),
              W("g", { transform: "translate(53.000000, 45.000000)" }, [
                W("use", {
                  fill: `var(${s(t).cssVarBlockName("fill-color-8")})`,
                  transform: "translate(8.500000, 18.000000) scale(-1, 1) translate(-8.500000, -18.000000) ",
                  "xlink:href": `#path-3-${s(n)}`
                }, null, 8, ["fill", "xlink:href"]),
                W("polygon", {
                  fill: `var(${s(t).cssVarBlockName("fill-color-9")})`,
                  mask: `url(#mask-4-${s(n)})`,
                  transform: "translate(12.000000, 9.000000) scale(-1, 1) translate(-12.000000, -9.000000) ",
                  points: "7 0 24 0 20 18 7 16.5"
                }, null, 8, ["fill", "mask"])
              ]),
              W("polygon", {
                fill: `var(${s(t).cssVarBlockName("fill-color-2")})`,
                transform: "translate(66.000000, 51.500000) scale(-1, 1) translate(-66.000000, -51.500000) ",
                points: "62 45 79 45 70 58 53 58"
              }, null, 8, ["fill"])
            ])
          ])
        ])
      ]));
    }
  });
  var kz = /* @__PURE__ */ Ne(Ez, [["__file", "img-empty.vue"]]);
  const _z = Te({
    image: {
      type: String,
      default: ""
    },
    imageSize: Number,
    description: {
      type: String,
      default: ""
    }
  }), Tz = /* @__PURE__ */ U({
    name: "ElEmpty"
  }), Nz = /* @__PURE__ */ U({
    ...Tz,
    props: _z,
    setup(e) {
      const t = e, { t: n } = _t(), o = he("empty"), l = S(() => t.description || n("el.table.emptyText")), a = S(() => ({
        width: tn(t.imageSize)
      }));
      return (r, i) => (_(), B("div", {
        class: $(s(o).b())
      }, [
        W("div", {
          class: $(s(o).e("image")),
          style: Ue(s(a))
        }, [
          r.image ? (_(), B("img", {
            key: 0,
            src: r.image,
            ondragstart: "return false"
          }, null, 8, ["src"])) : ee(r.$slots, "image", { key: 1 }, () => [
            q(kz)
          ])
        ], 6),
        W("div", {
          class: $(s(o).e("description"))
        }, [
          r.$slots.description ? ee(r.$slots, "description", { key: 0 }) : (_(), B("p", { key: 1 }, ke(s(l)), 1))
        ], 2),
        r.$slots.default ? (_(), B("div", {
          key: 0,
          class: $(s(o).e("bottom"))
        }, [
          ee(r.$slots, "default")
        ], 2)) : oe("v-if", !0)
      ], 2));
    }
  });
  var $z = /* @__PURE__ */ Ne(Nz, [["__file", "empty.vue"]]);
  const PE = rt($z), Oz = Te({
    size: {
      type: String,
      values: Tl
    },
    disabled: Boolean
  }), Iz = Te({
    ...Oz,
    model: Object,
    rules: {
      type: X(Object)
    },
    labelPosition: {
      type: String,
      values: ["left", "right", "top"],
      default: "right"
    },
    requireAsteriskPosition: {
      type: String,
      values: ["left", "right"],
      default: "left"
    },
    labelWidth: {
      type: [String, Number],
      default: ""
    },
    labelSuffix: {
      type: String,
      default: ""
    },
    inline: Boolean,
    inlineMessage: Boolean,
    statusIcon: Boolean,
    showMessage: {
      type: Boolean,
      default: !0
    },
    validateOnRuleChange: {
      type: Boolean,
      default: !0
    },
    hideRequiredAsterisk: Boolean,
    scrollToError: Boolean,
    scrollIntoViewOptions: {
      type: X([Object, Boolean]),
      default: !0
    }
  }), Mz = {
    validate: (e, t, n) => (ye(e) || Ae(e)) && Vt(t) && Ae(n)
  }, xz = "ElForm";
  function Pz() {
    const e = A([]), t = S(() => {
      if (!e.value.length)
        return "0";
      const a = Math.max(...e.value);
      return a ? `${a}px` : "";
    });
    function n(a) {
      const r = e.value.indexOf(a);
      return r === -1 && t.value === "0" && vt(xz, `unexpected width ${a}`), r;
    }
    function o(a, r) {
      if (a && r) {
        const i = n(r);
        e.value.splice(i, 1, a);
      } else a && e.value.push(a);
    }
    function l(a) {
      const r = n(a);
      r > -1 && e.value.splice(r, 1);
    }
    return {
      autoLabelWidth: t,
      registerLabelWidth: o,
      deregisterLabelWidth: l
    };
  }
  const Bu = (e, t) => {
    const n = En(t).map((o) => ye(o) ? o.join(".") : o);
    return n.length > 0 ? e.filter((o) => o.propString && n.includes(o.propString)) : e;
  }, lc = "ElForm", Rz = /* @__PURE__ */ U({
    name: lc
  }), Dz = /* @__PURE__ */ U({
    ...Rz,
    props: Iz,
    emits: Mz,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = A(), a = Rt([]), r = vn(), i = he("form"), u = S(() => {
        const { labelPosition: y, inline: E } = o;
        return [
          i.b(),
          i.m(r.value || "default"),
          {
            [i.m(`label-${y}`)]: y,
            [i.m("inline")]: E
          }
        ];
      }), c = (y) => Bu(a, [y])[0], d = (y) => {
        a.push(y);
      }, f = (y) => {
        y.prop && a.splice(a.indexOf(y), 1);
      }, v = (y = []) => {
        if (!o.model) {
          vt(lc, "model is required for resetFields to work.");
          return;
        }
        Bu(a, y).forEach((E) => E.resetField());
      }, p = (y = []) => {
        Bu(a, y).forEach((E) => E.clearValidate());
      }, m = S(() => {
        const y = !!o.model;
        return y || vt(lc, "model is required for validate to work."), y;
      }), h = (y) => {
        if (a.length === 0)
          return [];
        const E = Bu(a, y);
        return E.length ? E : (vt(lc, "please pass correct props!"), []);
      }, g = async (y) => C(void 0, y), b = async (y = []) => {
        if (!m.value)
          return !1;
        const E = h(y);
        if (E.length === 0)
          return !0;
        let k = {};
        for (const T of E)
          try {
            await T.validate(""), T.validateState === "error" && !T.error && T.resetField();
          } catch (x) {
            k = {
              ...k,
              ...x
            };
          }
        return Object.keys(k).length === 0 ? !0 : Promise.reject(k);
      }, C = async (y = [], E) => {
        let k = !1;
        const T = !Fe(E);
        try {
          return k = await b(y), k === !0 && await (E == null ? void 0 : E(k)), k;
        } catch (x) {
          if (x instanceof Error)
            throw x;
          const I = x;
          if (o.scrollToError && l.value) {
            const P = l.value.querySelector(`.${i.b()}-item.is-error`);
            P == null || P.scrollIntoView(o.scrollIntoViewOptions);
          }
          return !k && await (E == null ? void 0 : E(!1, I)), T && Promise.reject(I);
        }
      }, w = (y) => {
        var E;
        const k = c(y);
        k && ((E = k.$el) == null || E.scrollIntoView(o.scrollIntoViewOptions));
      };
      return de(() => o.rules, () => {
        o.validateOnRuleChange && g().catch((y) => vt(y));
      }, { deep: !0, flush: "post" }), yt(Sr, Rt({
        ...wn(o),
        emit: n,
        resetFields: v,
        clearValidate: p,
        validateField: C,
        getField: c,
        addField: d,
        removeField: f,
        ...Pz()
      })), t({
        validate: g,
        validateField: C,
        resetFields: v,
        clearValidate: p,
        scrollToField: w,
        getField: c,
        fields: a
      }), (y, E) => (_(), B("form", {
        ref_key: "formRef",
        ref: l,
        class: $(s(u))
      }, [
        ee(y.$slots, "default")
      ], 2));
    }
  });
  var Az = /* @__PURE__ */ Ne(Dz, [["__file", "form.vue"]]);
  function qa() {
    return qa = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var o in n)
          Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
      }
      return e;
    }, qa.apply(this, arguments);
  }
  function Vz(e, t) {
    e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Ii(e, t);
  }
  function Rp(e) {
    return Rp = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
      return n.__proto__ || Object.getPrototypeOf(n);
    }, Rp(e);
  }
  function Ii(e, t) {
    return Ii = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, l) {
      return o.__proto__ = l, o;
    }, Ii(e, t);
  }
  function Lz() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function ac(e, t, n) {
    return Lz() ? ac = Reflect.construct.bind() : ac = function(l, a, r) {
      var i = [null];
      i.push.apply(i, a);
      var u = Function.bind.apply(l, i), c = new u();
      return r && Ii(c, r.prototype), c;
    }, ac.apply(null, arguments);
  }
  function Bz(e) {
    return Function.toString.call(e).indexOf("[native code]") !== -1;
  }
  function Dp(e) {
    var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return Dp = function(o) {
      if (o === null || !Bz(o)) return o;
      if (typeof o != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof t < "u") {
        if (t.has(o)) return t.get(o);
        t.set(o, l);
      }
      function l() {
        return ac(o, arguments, Rp(this).constructor);
      }
      return l.prototype = Object.create(o.prototype, {
        constructor: {
          value: l,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), Ii(l, o);
    }, Dp(e);
  }
  var Fz = /%[sdj%]/g, RE = function() {
  };
  typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (RE = function(t, n) {
    typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && n.every(function(o) {
      return typeof o == "string";
    }) && console.warn(t, n);
  });
  function Ap(e) {
    if (!e || !e.length) return null;
    var t = {};
    return e.forEach(function(n) {
      var o = n.field;
      t[o] = t[o] || [], t[o].push(n);
    }), t;
  }
  function vo(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
      n[o - 1] = arguments[o];
    var l = 0, a = n.length;
    if (typeof e == "function")
      return e.apply(null, n);
    if (typeof e == "string") {
      var r = e.replace(Fz, function(i) {
        if (i === "%%")
          return "%";
        if (l >= a)
          return i;
        switch (i) {
          case "%s":
            return String(n[l++]);
          case "%d":
            return Number(n[l++]);
          case "%j":
            try {
              return JSON.stringify(n[l++]);
            } catch {
              return "[Circular]";
            }
            break;
          default:
            return i;
        }
      });
      return r;
    }
    return e;
  }
  function zz(e) {
    return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
  }
  function Tn(e, t) {
    return !!(e == null || t === "array" && Array.isArray(e) && !e.length || zz(t) && typeof e == "string" && !e);
  }
  function Hz(e, t, n) {
    var o = [], l = 0, a = e.length;
    function r(i) {
      o.push.apply(o, i || []), l++, l === a && n(o);
    }
    e.forEach(function(i) {
      t(i, r);
    });
  }
  function by(e, t, n) {
    var o = 0, l = e.length;
    function a(r) {
      if (r && r.length) {
        n(r);
        return;
      }
      var i = o;
      o = o + 1, i < l ? t(e[i], a) : n([]);
    }
    a([]);
  }
  function Kz(e) {
    var t = [];
    return Object.keys(e).forEach(function(n) {
      t.push.apply(t, e[n] || []);
    }), t;
  }
  var yy = /* @__PURE__ */ function(e) {
    Vz(t, e);
    function t(n, o) {
      var l;
      return l = e.call(this, "Async Validation Error") || this, l.errors = n, l.fields = o, l;
    }
    return t;
  }(/* @__PURE__ */ Dp(Error));
  function Wz(e, t, n, o, l) {
    if (t.first) {
      var a = new Promise(function(v, p) {
        var m = function(b) {
          return o(b), b.length ? p(new yy(b, Ap(b))) : v(l);
        }, h = Kz(e);
        by(h, n, m);
      });
      return a.catch(function(v) {
        return v;
      }), a;
    }
    var r = t.firstFields === !0 ? Object.keys(e) : t.firstFields || [], i = Object.keys(e), u = i.length, c = 0, d = [], f = new Promise(function(v, p) {
      var m = function(g) {
        if (d.push.apply(d, g), c++, c === u)
          return o(d), d.length ? p(new yy(d, Ap(d))) : v(l);
      };
      i.length || (o(d), v(l)), i.forEach(function(h) {
        var g = e[h];
        r.indexOf(h) !== -1 ? by(g, n, m) : Hz(g, n, m);
      });
    });
    return f.catch(function(v) {
      return v;
    }), f;
  }
  function jz(e) {
    return !!(e && e.message !== void 0);
  }
  function Uz(e, t) {
    for (var n = e, o = 0; o < t.length; o++) {
      if (n == null)
        return n;
      n = n[t[o]];
    }
    return n;
  }
  function wy(e, t) {
    return function(n) {
      var o;
      return e.fullFields ? o = Uz(t, e.fullFields) : o = t[n.field || e.fullField], jz(n) ? (n.field = n.field || e.fullField, n.fieldValue = o, n) : {
        message: typeof n == "function" ? n() : n,
        fieldValue: o,
        field: n.field || e.fullField
      };
    };
  }
  function Cy(e, t) {
    if (t) {
      for (var n in t)
        if (t.hasOwnProperty(n)) {
          var o = t[n];
          typeof o == "object" && typeof e[n] == "object" ? e[n] = qa({}, e[n], o) : e[n] = o;
        }
    }
    return e;
  }
  var DE = function(t, n, o, l, a, r) {
    t.required && (!o.hasOwnProperty(t.field) || Tn(n, r || t.type)) && l.push(vo(a.messages.required, t.fullField));
  }, Yz = function(t, n, o, l, a) {
    (/^\s+$/.test(n) || n === "") && l.push(vo(a.messages.whitespace, t.fullField));
  }, Fu, qz = function() {
    if (Fu)
      return Fu;
    var e = "[a-fA-F\\d:]", t = function(y) {
      return y && y.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : "";
    }, n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", o = "[a-fA-F\\d]{1,4}", l = (`
(?:
(?:` + o + ":){7}(?:" + o + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + o + ":){6}(?:" + n + "|:" + o + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + o + ":){5}(?::" + n + "|(?::" + o + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + o + ":){4}(?:(?::" + o + "){0,1}:" + n + "|(?::" + o + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + o + ":){3}(?:(?::" + o + "){0,2}:" + n + "|(?::" + o + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + o + ":){2}(?:(?::" + o + "){0,3}:" + n + "|(?::" + o + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + o + ":){1}(?:(?::" + o + "){0,4}:" + n + "|(?::" + o + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + o + "){0,5}:" + n + "|(?::" + o + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), a = new RegExp("(?:^" + n + "$)|(?:^" + l + "$)"), r = new RegExp("^" + n + "$"), i = new RegExp("^" + l + "$"), u = function(y) {
      return y && y.exact ? a : new RegExp("(?:" + t(y) + n + t(y) + ")|(?:" + t(y) + l + t(y) + ")", "g");
    };
    u.v4 = function(w) {
      return w && w.exact ? r : new RegExp("" + t(w) + n + t(w), "g");
    }, u.v6 = function(w) {
      return w && w.exact ? i : new RegExp("" + t(w) + l + t(w), "g");
    };
    var c = "(?:(?:[a-z]+:)?//)", d = "(?:\\S+(?::\\S*)?@)?", f = u.v4().source, v = u.v6().source, p = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", m = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", h = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", g = "(?::\\d{2,5})?", b = '(?:[/?#][^\\s"]*)?', C = "(?:" + c + "|www\\.)" + d + "(?:localhost|" + f + "|" + v + "|" + p + m + h + ")" + g + b;
    return Fu = new RegExp("(?:^" + C + "$)", "i"), Fu;
  }, Sy = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    // url: new RegExp(
    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
    //   'i',
    // ),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  }, Ks = {
    integer: function(t) {
      return Ks.number(t) && parseInt(t, 10) === t;
    },
    float: function(t) {
      return Ks.number(t) && !Ks.integer(t);
    },
    array: function(t) {
      return Array.isArray(t);
    },
    regexp: function(t) {
      if (t instanceof RegExp)
        return !0;
      try {
        return !!new RegExp(t);
      } catch {
        return !1;
      }
    },
    date: function(t) {
      return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
    },
    number: function(t) {
      return isNaN(t) ? !1 : typeof t == "number";
    },
    object: function(t) {
      return typeof t == "object" && !Ks.array(t);
    },
    method: function(t) {
      return typeof t == "function";
    },
    email: function(t) {
      return typeof t == "string" && t.length <= 320 && !!t.match(Sy.email);
    },
    url: function(t) {
      return typeof t == "string" && t.length <= 2048 && !!t.match(qz());
    },
    hex: function(t) {
      return typeof t == "string" && !!t.match(Sy.hex);
    }
  }, Gz = function(t, n, o, l, a) {
    if (t.required && n === void 0) {
      DE(t, n, o, l, a);
      return;
    }
    var r = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], i = t.type;
    r.indexOf(i) > -1 ? Ks[i](n) || l.push(vo(a.messages.types[i], t.fullField, t.type)) : i && typeof n !== t.type && l.push(vo(a.messages.types[i], t.fullField, t.type));
  }, Xz = function(t, n, o, l, a) {
    var r = typeof t.len == "number", i = typeof t.min == "number", u = typeof t.max == "number", c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, d = n, f = null, v = typeof n == "number", p = typeof n == "string", m = Array.isArray(n);
    if (v ? f = "number" : p ? f = "string" : m && (f = "array"), !f)
      return !1;
    m && (d = n.length), p && (d = n.replace(c, "_").length), r ? d !== t.len && l.push(vo(a.messages[f].len, t.fullField, t.len)) : i && !u && d < t.min ? l.push(vo(a.messages[f].min, t.fullField, t.min)) : u && !i && d > t.max ? l.push(vo(a.messages[f].max, t.fullField, t.max)) : i && u && (d < t.min || d > t.max) && l.push(vo(a.messages[f].range, t.fullField, t.min, t.max));
  }, Ir = "enum", Jz = function(t, n, o, l, a) {
    t[Ir] = Array.isArray(t[Ir]) ? t[Ir] : [], t[Ir].indexOf(n) === -1 && l.push(vo(a.messages[Ir], t.fullField, t[Ir].join(", ")));
  }, Zz = function(t, n, o, l, a) {
    if (t.pattern) {
      if (t.pattern instanceof RegExp)
        t.pattern.lastIndex = 0, t.pattern.test(n) || l.push(vo(a.messages.pattern.mismatch, t.fullField, n, t.pattern));
      else if (typeof t.pattern == "string") {
        var r = new RegExp(t.pattern);
        r.test(n) || l.push(vo(a.messages.pattern.mismatch, t.fullField, n, t.pattern));
      }
    }
  }, jt = {
    required: DE,
    whitespace: Yz,
    type: Gz,
    range: Xz,
    enum: Jz,
    pattern: Zz
  }, Qz = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (Tn(n, "string") && !t.required)
        return o();
      jt.required(t, n, l, r, a, "string"), Tn(n, "string") || (jt.type(t, n, l, r, a), jt.range(t, n, l, r, a), jt.pattern(t, n, l, r, a), t.whitespace === !0 && jt.whitespace(t, n, l, r, a));
    }
    o(r);
  }, eH = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (Tn(n) && !t.required)
        return o();
      jt.required(t, n, l, r, a), n !== void 0 && jt.type(t, n, l, r, a);
    }
    o(r);
  }, tH = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (n === "" && (n = void 0), Tn(n) && !t.required)
        return o();
      jt.required(t, n, l, r, a), n !== void 0 && (jt.type(t, n, l, r, a), jt.range(t, n, l, r, a));
    }
    o(r);
  }, nH = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (Tn(n) && !t.required)
        return o();
      jt.required(t, n, l, r, a), n !== void 0 && jt.type(t, n, l, r, a);
    }
    o(r);
  }, oH = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (Tn(n) && !t.required)
        return o();
      jt.required(t, n, l, r, a), Tn(n) || jt.type(t, n, l, r, a);
    }
    o(r);
  }, lH = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (Tn(n) && !t.required)
        return o();
      jt.required(t, n, l, r, a), n !== void 0 && (jt.type(t, n, l, r, a), jt.range(t, n, l, r, a));
    }
    o(r);
  }, aH = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (Tn(n) && !t.required)
        return o();
      jt.required(t, n, l, r, a), n !== void 0 && (jt.type(t, n, l, r, a), jt.range(t, n, l, r, a));
    }
    o(r);
  }, rH = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (n == null && !t.required)
        return o();
      jt.required(t, n, l, r, a, "array"), n != null && (jt.type(t, n, l, r, a), jt.range(t, n, l, r, a));
    }
    o(r);
  }, sH = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (Tn(n) && !t.required)
        return o();
      jt.required(t, n, l, r, a), n !== void 0 && jt.type(t, n, l, r, a);
    }
    o(r);
  }, iH = "enum", uH = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (Tn(n) && !t.required)
        return o();
      jt.required(t, n, l, r, a), n !== void 0 && jt[iH](t, n, l, r, a);
    }
    o(r);
  }, cH = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (Tn(n, "string") && !t.required)
        return o();
      jt.required(t, n, l, r, a), Tn(n, "string") || jt.pattern(t, n, l, r, a);
    }
    o(r);
  }, dH = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (Tn(n, "date") && !t.required)
        return o();
      if (jt.required(t, n, l, r, a), !Tn(n, "date")) {
        var u;
        n instanceof Date ? u = n : u = new Date(n), jt.type(t, u, l, r, a), u && jt.range(t, u.getTime(), l, r, a);
      }
    }
    o(r);
  }, fH = function(t, n, o, l, a) {
    var r = [], i = Array.isArray(n) ? "array" : typeof n;
    jt.required(t, n, l, r, a, i), o(r);
  }, Lf = function(t, n, o, l, a) {
    var r = t.type, i = [], u = t.required || !t.required && l.hasOwnProperty(t.field);
    if (u) {
      if (Tn(n, r) && !t.required)
        return o();
      jt.required(t, n, l, i, a, r), Tn(n, r) || jt.type(t, n, l, i, a);
    }
    o(i);
  }, pH = function(t, n, o, l, a) {
    var r = [], i = t.required || !t.required && l.hasOwnProperty(t.field);
    if (i) {
      if (Tn(n) && !t.required)
        return o();
      jt.required(t, n, l, r, a);
    }
    o(r);
  }, ai = {
    string: Qz,
    method: eH,
    number: tH,
    boolean: nH,
    regexp: oH,
    integer: lH,
    float: aH,
    array: rH,
    object: sH,
    enum: uH,
    pattern: cH,
    date: dH,
    url: Lf,
    hex: Lf,
    email: Lf,
    required: fH,
    any: pH
  };
  function Vp() {
    return {
      default: "Validation error on field %s",
      required: "%s is required",
      enum: "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid"
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        boolean: "%s is not a %s",
        integer: "%s is not an %s",
        float: "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s"
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters"
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s"
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length"
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s"
      },
      clone: function() {
        var t = JSON.parse(JSON.stringify(this));
        return t.clone = this.clone, t;
      }
    };
  }
  var Lp = Vp(), du = /* @__PURE__ */ function() {
    function e(n) {
      this.rules = null, this._messages = Lp, this.define(n);
    }
    var t = e.prototype;
    return t.define = function(o) {
      var l = this;
      if (!o)
        throw new Error("Cannot configure a schema with no rules");
      if (typeof o != "object" || Array.isArray(o))
        throw new Error("Rules must be an object");
      this.rules = {}, Object.keys(o).forEach(function(a) {
        var r = o[a];
        l.rules[a] = Array.isArray(r) ? r : [r];
      });
    }, t.messages = function(o) {
      return o && (this._messages = Cy(Vp(), o)), this._messages;
    }, t.validate = function(o, l, a) {
      var r = this;
      l === void 0 && (l = {}), a === void 0 && (a = function() {
      });
      var i = o, u = l, c = a;
      if (typeof u == "function" && (c = u, u = {}), !this.rules || Object.keys(this.rules).length === 0)
        return c && c(null, i), Promise.resolve(i);
      function d(h) {
        var g = [], b = {};
        function C(y) {
          if (Array.isArray(y)) {
            var E;
            g = (E = g).concat.apply(E, y);
          } else
            g.push(y);
        }
        for (var w = 0; w < h.length; w++)
          C(h[w]);
        g.length ? (b = Ap(g), c(g, b)) : c(null, i);
      }
      if (u.messages) {
        var f = this.messages();
        f === Lp && (f = Vp()), Cy(f, u.messages), u.messages = f;
      } else
        u.messages = this.messages();
      var v = {}, p = u.keys || Object.keys(this.rules);
      p.forEach(function(h) {
        var g = r.rules[h], b = i[h];
        g.forEach(function(C) {
          var w = C;
          typeof w.transform == "function" && (i === o && (i = qa({}, i)), b = i[h] = w.transform(b)), typeof w == "function" ? w = {
            validator: w
          } : w = qa({}, w), w.validator = r.getValidationMethod(w), w.validator && (w.field = h, w.fullField = w.fullField || h, w.type = r.getType(w), v[h] = v[h] || [], v[h].push({
            rule: w,
            value: b,
            source: i,
            field: h
          }));
        });
      });
      var m = {};
      return Wz(v, u, function(h, g) {
        var b = h.rule, C = (b.type === "object" || b.type === "array") && (typeof b.fields == "object" || typeof b.defaultField == "object");
        C = C && (b.required || !b.required && h.value), b.field = h.field;
        function w(k, T) {
          return qa({}, T, {
            fullField: b.fullField + "." + k,
            fullFields: b.fullFields ? [].concat(b.fullFields, [k]) : [k]
          });
        }
        function y(k) {
          k === void 0 && (k = []);
          var T = Array.isArray(k) ? k : [k];
          !u.suppressWarning && T.length && e.warning("async-validator:", T), T.length && b.message !== void 0 && (T = [].concat(b.message));
          var x = T.map(wy(b, i));
          if (u.first && x.length)
            return m[b.field] = 1, g(x);
          if (!C)
            g(x);
          else {
            if (b.required && !h.value)
              return b.message !== void 0 ? x = [].concat(b.message).map(wy(b, i)) : u.error && (x = [u.error(b, vo(u.messages.required, b.field))]), g(x);
            var I = {};
            b.defaultField && Object.keys(h.value).map(function(N) {
              I[N] = b.defaultField;
            }), I = qa({}, I, h.rule.fields);
            var P = {};
            Object.keys(I).forEach(function(N) {
              var z = I[N], Y = Array.isArray(z) ? z : [z];
              P[N] = Y.map(w.bind(null, N));
            });
            var O = new e(P);
            O.messages(u.messages), h.rule.options && (h.rule.options.messages = u.messages, h.rule.options.error = u.error), O.validate(h.value, h.rule.options || u, function(N) {
              var z = [];
              x && x.length && z.push.apply(z, x), N && N.length && z.push.apply(z, N), g(z.length ? z : null);
            });
          }
        }
        var E;
        if (b.asyncValidator)
          E = b.asyncValidator(b, h.value, y, h.source, u);
        else if (b.validator) {
          try {
            E = b.validator(b, h.value, y, h.source, u);
          } catch (k) {
            console.error == null || console.error(k), u.suppressValidatorError || setTimeout(function() {
              throw k;
            }, 0), y(k.message);
          }
          E === !0 ? y() : E === !1 ? y(typeof b.message == "function" ? b.message(b.fullField || b.field) : b.message || (b.fullField || b.field) + " fails") : E instanceof Array ? y(E) : E instanceof Error && y(E.message);
        }
        E && E.then && E.then(function() {
          return y();
        }, function(k) {
          return y(k);
        });
      }, function(h) {
        d(h);
      }, i);
    }, t.getType = function(o) {
      if (o.type === void 0 && o.pattern instanceof RegExp && (o.type = "pattern"), typeof o.validator != "function" && o.type && !ai.hasOwnProperty(o.type))
        throw new Error(vo("Unknown rule type %s", o.type));
      return o.type || "string";
    }, t.getValidationMethod = function(o) {
      if (typeof o.validator == "function")
        return o.validator;
      var l = Object.keys(o), a = l.indexOf("message");
      return a !== -1 && l.splice(a, 1), l.length === 1 && l[0] === "required" ? ai.required : ai[this.getType(o)] || void 0;
    }, e;
  }();
  du.register = function(t, n) {
    if (typeof n != "function")
      throw new Error("Cannot register a validator by type, validator is not a function");
    ai[t] = n;
  };
  du.warning = RE;
  du.messages = Lp;
  du.validators = ai;
  const vH = [
    "",
    "error",
    "validating",
    "success"
  ], hH = Te({
    label: String,
    labelWidth: {
      type: [String, Number],
      default: ""
    },
    labelPosition: {
      type: String,
      values: ["left", "right", "top", ""],
      default: ""
    },
    prop: {
      type: X([String, Array])
    },
    required: {
      type: Boolean,
      default: void 0
    },
    rules: {
      type: X([Object, Array])
    },
    error: String,
    validateStatus: {
      type: String,
      values: vH
    },
    for: String,
    inlineMessage: {
      type: Boolean,
      default: void 0
    },
    showMessage: {
      type: Boolean,
      default: !0
    },
    size: {
      type: String,
      values: Tl
    }
  }), Ey = "ElLabelWrap";
  var mH = /* @__PURE__ */ U({
    name: Ey,
    props: {
      isAutoWidth: Boolean,
      updateAll: Boolean
    },
    setup(e, {
      slots: t
    }) {
      const n = Ve(Sr, void 0), o = Ve(Sl);
      o || Zt(Ey, "usage: <el-form-item><label-wrap /></el-form-item>");
      const l = he("form"), a = A(), r = A(0), i = () => {
        var d;
        if ((d = a.value) != null && d.firstElementChild) {
          const f = window.getComputedStyle(a.value.firstElementChild).width;
          return Math.ceil(Number.parseFloat(f));
        } else
          return 0;
      }, u = (d = "update") => {
        Re(() => {
          t.default && e.isAutoWidth && (d === "update" ? r.value = i() : d === "remove" && (n == null || n.deregisterLabelWidth(r.value)));
        });
      }, c = () => u("update");
      return ft(() => {
        c();
      }), Bt(() => {
        u("remove");
      }), Qo(() => c()), de(r, (d, f) => {
        e.updateAll && (n == null || n.registerLabelWidth(d, f));
      }), qt(S(() => {
        var d, f;
        return (f = (d = a.value) == null ? void 0 : d.firstElementChild) != null ? f : null;
      }), c), () => {
        var d, f;
        if (!t)
          return null;
        const {
          isAutoWidth: v
        } = e;
        if (v) {
          const p = n == null ? void 0 : n.autoLabelWidth, m = o == null ? void 0 : o.hasLabel, h = {};
          if (m && p && p !== "auto") {
            const g = Math.max(0, Number.parseInt(p, 10) - r.value), C = (o.labelPosition || n.labelPosition) === "left" ? "marginRight" : "marginLeft";
            g && (h[C] = `${g}px`);
          }
          return q("div", {
            ref: a,
            class: [l.be("item", "label-wrap")],
            style: h
          }, [(d = t.default) == null ? void 0 : d.call(t)]);
        } else
          return q(We, {
            ref: a
          }, [(f = t.default) == null ? void 0 : f.call(t)]);
      };
    }
  });
  const gH = /* @__PURE__ */ U({
    name: "ElFormItem"
  }), bH = /* @__PURE__ */ U({
    ...gH,
    props: hH,
    setup(e, { expose: t }) {
      const n = e, o = hn(), l = Ve(Sr, void 0), a = Ve(Sl, void 0), r = vn(void 0, { formItem: !1 }), i = he("form-item"), u = xn().value, c = A([]), d = A(""), f = zP(d, 100), v = A(""), p = A();
      let m, h = !1;
      const g = S(() => n.labelPosition || (l == null ? void 0 : l.labelPosition)), b = S(() => {
        if (g.value === "top")
          return {};
        const re = tn(n.labelWidth || (l == null ? void 0 : l.labelWidth) || "");
        return re ? { width: re } : {};
      }), C = S(() => {
        if (g.value === "top" || l != null && l.inline)
          return {};
        if (!n.label && !n.labelWidth && P)
          return {};
        const re = tn(n.labelWidth || (l == null ? void 0 : l.labelWidth) || "");
        return !n.label && !o.label ? { marginLeft: re } : {};
      }), w = S(() => [
        i.b(),
        i.m(r.value),
        i.is("error", d.value === "error"),
        i.is("validating", d.value === "validating"),
        i.is("success", d.value === "success"),
        i.is("required", G.value || n.required),
        i.is("no-asterisk", l == null ? void 0 : l.hideRequiredAsterisk),
        (l == null ? void 0 : l.requireAsteriskPosition) === "right" ? "asterisk-right" : "asterisk-left",
        {
          [i.m("feedback")]: l == null ? void 0 : l.statusIcon,
          [i.m(`label-${g.value}`)]: g.value
        }
      ]), y = S(() => Vt(n.inlineMessage) ? n.inlineMessage : (l == null ? void 0 : l.inlineMessage) || !1), E = S(() => [
        i.e("error"),
        { [i.em("error", "inline")]: y.value }
      ]), k = S(() => n.prop ? ye(n.prop) ? n.prop.join(".") : n.prop : ""), T = S(() => !!(n.label || o.label)), x = S(() => {
        var re;
        return (re = n.for) != null ? re : c.value.length === 1 ? c.value[0] : void 0;
      }), I = S(() => !x.value && T.value), P = !!a, O = S(() => {
        const re = l == null ? void 0 : l.model;
        if (!(!re || !n.prop))
          return ni(re, n.prop).value;
      }), N = S(() => {
        const { required: re } = n, se = [];
        n.rules && se.push(...En(n.rules));
        const ne = l == null ? void 0 : l.rules;
        if (ne && n.prop) {
          const le = ni(ne, n.prop).value;
          le && se.push(...En(le));
        }
        if (re !== void 0) {
          const le = se.map((Ce, j) => [Ce, j]).filter(([Ce]) => "required" in Ce);
          if (le.length > 0)
            for (const [Ce, j] of le)
              Ce.required !== re && (se[j] = { ...Ce, required: re });
          else
            se.push({ required: re });
        }
        return se;
      }), z = S(() => N.value.length > 0), Y = (re) => N.value.filter((ne) => !ne.trigger || !re ? !0 : ye(ne.trigger) ? ne.trigger.includes(re) : ne.trigger === re).map(({ trigger: ne, ...le }) => le), G = S(() => N.value.some((re) => re.required)), M = S(() => {
        var re;
        return f.value === "error" && n.showMessage && ((re = l == null ? void 0 : l.showMessage) != null ? re : !0);
      }), R = S(() => `${n.label || ""}${(l == null ? void 0 : l.labelSuffix) || ""}`), D = (re) => {
        d.value = re;
      }, L = (re) => {
        var se, ne;
        const { errors: le, fields: Ce } = re;
        (!le || !Ce) && console.error(re), D("error"), v.value = le ? (ne = (se = le == null ? void 0 : le[0]) == null ? void 0 : se.message) != null ? ne : `${n.prop} is required` : "", l == null || l.emit("validate", n.prop, !1, v.value);
      }, V = () => {
        D("success"), l == null || l.emit("validate", n.prop, !0, "");
      }, F = async (re) => {
        const se = k.value;
        return new du({
          [se]: re
        }).validate({ [se]: O.value }, { firstFields: !0 }).then(() => (V(), !0)).catch((le) => (L(le), Promise.reject(le)));
      }, H = async (re, se) => {
        if (h || !n.prop)
          return !1;
        const ne = Fe(se);
        if (!z.value)
          return se == null || se(!1), !1;
        const le = Y(re);
        return le.length === 0 ? (se == null || se(!0), !0) : (D("validating"), F(le).then(() => (se == null || se(!0), !0)).catch((Ce) => {
          const { fields: j } = Ce;
          return se == null || se(!1, j), ne ? !1 : Promise.reject(j);
        }));
      }, K = () => {
        D(""), v.value = "", h = !1;
      }, Z = async () => {
        const re = l == null ? void 0 : l.model;
        if (!re || !n.prop)
          return;
        const se = ni(re, n.prop);
        h = !0, se.value = Qg(m), await Re(), K(), h = !1;
      }, J = (re) => {
        c.value.includes(re) || c.value.push(re);
      }, ie = (re) => {
        c.value = c.value.filter((se) => se !== re);
      };
      de(() => n.error, (re) => {
        v.value = re || "", D(re ? "error" : "");
      }, { immediate: !0 }), de(() => n.validateStatus, (re) => D(re || ""));
      const ue = Rt({
        ...wn(n),
        $el: p,
        size: r,
        validateMessage: v,
        validateState: d,
        labelId: u,
        inputIds: c,
        isGroup: I,
        hasLabel: T,
        fieldValue: O,
        addInputId: J,
        removeInputId: ie,
        resetField: Z,
        clearValidate: K,
        validate: H,
        propString: k
      });
      return yt(Sl, ue), ft(() => {
        n.prop && (l == null || l.addField(ue), m = Qg(O.value));
      }), Bt(() => {
        l == null || l.removeField(ue);
      }), t({
        size: r,
        validateMessage: v,
        validateState: d,
        validate: H,
        clearValidate: K,
        resetField: Z
      }), (re, se) => {
        var ne;
        return _(), B("div", {
          ref_key: "formItemRef",
          ref: p,
          class: $(s(w)),
          role: s(I) ? "group" : void 0,
          "aria-labelledby": s(I) ? s(u) : void 0
        }, [
          q(s(mH), {
            "is-auto-width": s(b).width === "auto",
            "update-all": ((ne = s(l)) == null ? void 0 : ne.labelWidth) === "auto"
          }, {
            default: Q(() => [
              re.label || re.$slots.label ? (_(), ae(ct(s(x) ? "label" : "div"), {
                key: 0,
                id: s(u),
                for: s(x),
                class: $(s(i).e("label")),
                style: Ue(s(b))
              }, {
                default: Q(() => [
                  ee(re.$slots, "label", { label: s(R) }, () => [
                    Ct(ke(s(R)), 1)
                  ])
                ]),
                _: 3
              }, 8, ["id", "for", "class", "style"])) : oe("v-if", !0)
            ]),
            _: 3
          }, 8, ["is-auto-width", "update-all"]),
          W("div", {
            class: $(s(i).e("content")),
            style: Ue(s(C))
          }, [
            ee(re.$slots, "default"),
            q(e1, {
              name: `${s(i).namespace.value}-zoom-in-top`
            }, {
              default: Q(() => [
                s(M) ? ee(re.$slots, "error", {
                  key: 0,
                  error: v.value
                }, () => [
                  W("div", {
                    class: $(s(E))
                  }, ke(v.value), 3)
                ]) : oe("v-if", !0)
              ]),
              _: 3
            }, 8, ["name"])
          ], 6)
        ], 10, ["role", "aria-labelledby"]);
      };
    }
  });
  var AE = /* @__PURE__ */ Ne(bH, [["__file", "form-item.vue"]]);
  const yH = rt(Az, {
    FormItem: AE
  }), wH = nn(AE), CH = Te({
    urlList: {
      type: X(Array),
      default: () => en([])
    },
    zIndex: {
      type: Number
    },
    initialIndex: {
      type: Number,
      default: 0
    },
    infinite: {
      type: Boolean,
      default: !0
    },
    hideOnClickModal: Boolean,
    teleported: Boolean,
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    zoomRate: {
      type: Number,
      default: 1.2
    },
    scale: {
      type: Number,
      default: 1
    },
    minScale: {
      type: Number,
      default: 0.2
    },
    maxScale: {
      type: Number,
      default: 7
    },
    showProgress: Boolean,
    crossorigin: {
      type: X(String)
    }
  }), SH = {
    close: () => !0,
    error: (e) => e instanceof Event,
    switch: (e) => je(e),
    rotate: (e) => je(e)
  }, EH = /* @__PURE__ */ U({
    name: "ElImageViewer"
  }), kH = /* @__PURE__ */ U({
    ...EH,
    props: CH,
    emits: SH,
    setup(e, { expose: t, emit: n }) {
      var o;
      const l = e, a = {
        CONTAIN: {
          name: "contain",
          icon: zl(oD)
        },
        ORIGINAL: {
          name: "original",
          icon: zl(ED)
        }
      };
      let r;
      const { t: i } = _t(), u = he("image-viewer"), { nextZIndex: c } = tu(), d = A(), f = A(), v = l2(), p = S(() => {
        const { scale: re, minScale: se, maxScale: ne } = l;
        return X1(re, se, ne);
      }), m = A(!0), h = A(!1), g = A(!1), b = A(l.initialIndex), C = Ut(a.CONTAIN), w = A({
        scale: p.value,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: !1
      }), y = A((o = l.zIndex) != null ? o : c());
      Wd(g, { ns: u });
      const E = S(() => {
        const { urlList: re } = l;
        return re.length <= 1;
      }), k = S(() => b.value === 0), T = S(() => b.value === l.urlList.length - 1), x = S(() => l.urlList[b.value]), I = S(() => [
        u.e("btn"),
        u.e("prev"),
        u.is("disabled", !l.infinite && k.value)
      ]), P = S(() => [
        u.e("btn"),
        u.e("next"),
        u.is("disabled", !l.infinite && T.value)
      ]), O = S(() => {
        const { scale: re, deg: se, offsetX: ne, offsetY: le, enableTransition: Ce } = w.value;
        let j = ne / re, te = le / re;
        const ce = se * Math.PI / 180, ge = Math.cos(ce), be = Math.sin(ce);
        j = j * ge + te * be, te = te * ge - ne / re * be;
        const Ee = {
          transform: `scale(${re}) rotate(${se}deg) translate(${j}px, ${te}px)`,
          transition: Ce ? "transform .3s" : ""
        };
        return C.value.name === a.CONTAIN.name && (Ee.maxWidth = Ee.maxHeight = "100%"), Ee;
      }), N = S(() => `${b.value + 1} / ${l.urlList.length}`);
      function z() {
        G(), r == null || r(), g.value = !1, n("close");
      }
      function Y() {
        const re = lr((ne) => {
          switch (Ht(ne)) {
            case _e.esc:
              l.closeOnPressEscape && z();
              break;
            case _e.space:
              V();
              break;
            case _e.left:
              H();
              break;
            case _e.up:
              Z("zoomIn");
              break;
            case _e.right:
              K();
              break;
            case _e.down:
              Z("zoomOut");
              break;
          }
        }), se = lr((ne) => {
          const le = ne.deltaY || ne.deltaX;
          Z(le < 0 ? "zoomIn" : "zoomOut", {
            zoomRate: l.zoomRate,
            enableTransition: !1
          });
        });
        v.run(() => {
          Dt(document, "keydown", re), Dt(d, "wheel", se);
        });
      }
      function G() {
        v.stop();
      }
      function M() {
        m.value = !1;
      }
      function R(re) {
        h.value = !0, m.value = !1, n("error", re), re.target.alt = i("el.image.error");
      }
      function D(re) {
        if (m.value || re.button !== 0 || !d.value)
          return;
        w.value.enableTransition = !1;
        const { offsetX: se, offsetY: ne } = w.value, le = re.pageX, Ce = re.pageY, j = lr((ce) => {
          w.value = {
            ...w.value,
            offsetX: se + ce.pageX - le,
            offsetY: ne + ce.pageY - Ce
          };
        }), te = Dt(document, "mousemove", j);
        Dt(document, "mouseup", () => {
          te();
        }), re.preventDefault();
      }
      function L() {
        w.value = {
          scale: p.value,
          deg: 0,
          offsetX: 0,
          offsetY: 0,
          enableTransition: !1
        };
      }
      function V() {
        if (m.value || h.value)
          return;
        const re = Ci(a), se = Object.values(a), ne = C.value.name, Ce = (se.findIndex((j) => j.name === ne) + 1) % re.length;
        C.value = a[re[Ce]], L();
      }
      function F(re) {
        h.value = !1;
        const se = l.urlList.length;
        b.value = (re + se) % se;
      }
      function H() {
        k.value && !l.infinite || F(b.value - 1);
      }
      function K() {
        T.value && !l.infinite || F(b.value + 1);
      }
      function Z(re, se = {}) {
        if (m.value || h.value)
          return;
        const { minScale: ne, maxScale: le } = l, { zoomRate: Ce, rotateDeg: j, enableTransition: te } = {
          zoomRate: l.zoomRate,
          rotateDeg: 90,
          enableTransition: !0,
          ...se
        };
        switch (re) {
          case "zoomOut":
            w.value.scale > ne && (w.value.scale = Number.parseFloat((w.value.scale / Ce).toFixed(3)));
            break;
          case "zoomIn":
            w.value.scale < le && (w.value.scale = Number.parseFloat((w.value.scale * Ce).toFixed(3)));
            break;
          case "clockwise":
            w.value.deg += j, n("rotate", w.value.deg);
            break;
          case "anticlockwise":
            w.value.deg -= j, n("rotate", w.value.deg);
            break;
        }
        w.value.enableTransition = te;
      }
      function J(re) {
        var se;
        ((se = re.detail) == null ? void 0 : se.focusReason) === "pointer" && re.preventDefault();
      }
      function ie() {
        l.closeOnPressEscape && z();
      }
      function ue(re) {
        if (re.ctrlKey) {
          if (re.deltaY < 0)
            return re.preventDefault(), !1;
          if (re.deltaY > 0)
            return re.preventDefault(), !1;
        }
      }
      return de(() => p.value, (re) => {
        w.value.scale = re;
      }), de(x, () => {
        Re(() => {
          const re = f.value;
          re != null && re.complete || (m.value = !0);
        });
      }), de(b, (re) => {
        L(), n("switch", re);
      }), ft(() => {
        g.value = !0, Y(), r = Dt("wheel", ue, {
          passive: !1
        });
      }), t({
        setActiveItem: F
      }), (re, se) => (_(), ae(s(uu), {
        to: "body",
        disabled: !re.teleported
      }, {
        default: Q(() => [
          q(Mn, {
            name: "viewer-fade",
            appear: ""
          }, {
            default: Q(() => [
              W("div", {
                ref_key: "wrapper",
                ref: d,
                tabindex: -1,
                class: $(s(u).e("wrapper")),
                style: Ue({ zIndex: y.value })
              }, [
                q(s(_s), {
                  loop: "",
                  trapped: "",
                  "focus-trap-el": d.value,
                  "focus-start-el": "container",
                  onFocusoutPrevented: J,
                  onReleaseRequested: ie
                }, {
                  default: Q(() => [
                    W("div", {
                      class: $(s(u).e("mask")),
                      onClick: Ze((ne) => re.hideOnClickModal && z(), ["self"])
                    }, null, 10, ["onClick"]),
                    oe(" CLOSE "),
                    W("span", {
                      class: $([s(u).e("btn"), s(u).e("close")]),
                      onClick: z
                    }, [
                      q(s(ze), null, {
                        default: Q(() => [
                          q(s(Oo))
                        ]),
                        _: 1
                      })
                    ], 2),
                    oe(" ARROW "),
                    s(E) ? oe("v-if", !0) : (_(), B(We, { key: 0 }, [
                      W("span", {
                        class: $(s(I)),
                        onClick: H
                      }, [
                        q(s(ze), null, {
                          default: Q(() => [
                            q(s(ql))
                          ]),
                          _: 1
                        })
                      ], 2),
                      W("span", {
                        class: $(s(P)),
                        onClick: K
                      }, [
                        q(s(ze), null, {
                          default: Q(() => [
                            q(s(Un))
                          ]),
                          _: 1
                        })
                      ], 2)
                    ], 64)),
                    re.$slots.progress || re.showProgress ? (_(), B("div", {
                      key: 1,
                      class: $([s(u).e("btn"), s(u).e("progress")])
                    }, [
                      ee(re.$slots, "progress", {
                        activeIndex: b.value,
                        total: re.urlList.length
                      }, () => [
                        Ct(ke(s(N)), 1)
                      ])
                    ], 2)) : oe("v-if", !0),
                    oe(" ACTIONS "),
                    W("div", {
                      class: $([s(u).e("btn"), s(u).e("actions")])
                    }, [
                      W("div", {
                        class: $(s(u).e("actions__inner"))
                      }, [
                        ee(re.$slots, "toolbar", {
                          actions: Z,
                          prev: H,
                          next: K,
                          reset: V,
                          activeIndex: b.value,
                          setActiveItem: F
                        }, () => [
                          q(s(ze), {
                            onClick: (ne) => Z("zoomOut")
                          }, {
                            default: Q(() => [
                              q(s(BD))
                            ]),
                            _: 1
                          }, 8, ["onClick"]),
                          q(s(ze), {
                            onClick: (ne) => Z("zoomIn")
                          }, {
                            default: Q(() => [
                              q(s(CC))
                            ]),
                            _: 1
                          }, 8, ["onClick"]),
                          W("i", {
                            class: $(s(u).e("actions__divider"))
                          }, null, 2),
                          q(s(ze), { onClick: V }, {
                            default: Q(() => [
                              (_(), ae(ct(s(C).icon)))
                            ]),
                            _: 1
                          }),
                          W("i", {
                            class: $(s(u).e("actions__divider"))
                          }, null, 2),
                          q(s(ze), {
                            onClick: (ne) => Z("anticlockwise")
                          }, {
                            default: Q(() => [
                              q(s(yD))
                            ]),
                            _: 1
                          }, 8, ["onClick"]),
                          q(s(ze), {
                            onClick: (ne) => Z("clockwise")
                          }, {
                            default: Q(() => [
                              q(s(CD))
                            ]),
                            _: 1
                          }, 8, ["onClick"])
                        ])
                      ], 2)
                    ], 2),
                    oe(" CANVAS "),
                    W("div", {
                      class: $(s(u).e("canvas"))
                    }, [
                      h.value && re.$slots["viewer-error"] ? ee(re.$slots, "viewer-error", {
                        key: 0,
                        activeIndex: b.value,
                        src: s(x)
                      }) : (_(), B("img", {
                        ref_key: "imgRef",
                        ref: f,
                        key: s(x),
                        src: s(x),
                        style: Ue(s(O)),
                        class: $(s(u).e("img")),
                        crossorigin: re.crossorigin,
                        onLoad: M,
                        onError: R,
                        onMousedown: D
                      }, null, 46, ["src", "crossorigin"]))
                    ], 2),
                    ee(re.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["focus-trap-el"])
              ], 6)
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 8, ["disabled"]));
    }
  });
  var _H = /* @__PURE__ */ Ne(kH, [["__file", "image-viewer.vue"]]);
  const VE = rt(_H), TH = Te({
    hideOnClickModal: Boolean,
    src: {
      type: String,
      default: ""
    },
    fit: {
      type: String,
      values: ["", "contain", "cover", "fill", "none", "scale-down"],
      default: ""
    },
    loading: {
      type: String,
      values: ["eager", "lazy"]
    },
    lazy: Boolean,
    scrollContainer: {
      type: X([String, Object])
    },
    previewSrcList: {
      type: X(Array),
      default: () => en([])
    },
    previewTeleported: Boolean,
    zIndex: {
      type: Number
    },
    initialIndex: {
      type: Number,
      default: 0
    },
    infinite: {
      type: Boolean,
      default: !0
    },
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    zoomRate: {
      type: Number,
      default: 1.2
    },
    scale: {
      type: Number,
      default: 1
    },
    minScale: {
      type: Number,
      default: 0.2
    },
    maxScale: {
      type: Number,
      default: 7
    },
    showProgress: Boolean,
    crossorigin: {
      type: X(String)
    }
  }), NH = {
    load: (e) => e instanceof Event,
    error: (e) => e instanceof Event,
    switch: (e) => je(e),
    close: () => !0,
    show: () => !0
  }, $H = /* @__PURE__ */ U({
    name: "ElImage",
    inheritAttrs: !1
  }), OH = /* @__PURE__ */ U({
    ...$H,
    props: TH,
    emits: NH,
    setup(e, { expose: t, emit: n }) {
      const o = e, { t: l } = _t(), a = he("image"), r = ea(), i = S(() => wi(Object.entries(r).filter(([M]) => /^(data-|on[A-Z])/i.test(M) || ["id", "style"].includes(M)))), u = Ad({
        excludeListeners: !0,
        excludeKeys: S(() => Object.keys(i.value))
      }), c = A(), d = A(!1), f = A(!0), v = A(!1), p = A(), m = A(), h = xt && "loading" in HTMLImageElement.prototype;
      let g;
      const b = S(() => [
        a.e("inner"),
        w.value && a.e("preview"),
        f.value && a.is("loading")
      ]), C = S(() => {
        const { fit: M } = o;
        return xt && M ? { objectFit: M } : {};
      }), w = S(() => {
        const { previewSrcList: M } = o;
        return ye(M) && M.length > 0;
      }), y = S(() => {
        const { previewSrcList: M, initialIndex: R } = o;
        let D = R;
        return R > M.length - 1 && (D = 0), D;
      }), E = S(() => o.loading === "eager" ? !1 : !h && o.loading === "lazy" || o.lazy), k = () => {
        xt && (f.value = !0, d.value = !1, c.value = o.src);
      };
      function T(M) {
        f.value = !1, d.value = !1, n("load", M);
      }
      function x(M) {
        f.value = !1, d.value = !0, n("error", M);
      }
      function I(M) {
        M && (k(), N());
      }
      const P = Z1(I, 200, !0);
      async function O() {
        var M;
        if (!xt)
          return;
        await Re();
        const { scrollContainer: R } = o;
        if (Qn(R))
          m.value = R;
        else if (Ae(R) && R !== "")
          m.value = (M = document.querySelector(R)) != null ? M : void 0;
        else if (p.value) {
          const L = uh(p.value);
          m.value = Qi(L) ? void 0 : L;
        }
        const { stop: D } = XP(p, ([L]) => {
          P(L.isIntersecting);
        }, { root: m });
        g = D;
      }
      function N() {
        !xt || !P || (g == null || g(), m.value = void 0, g = void 0);
      }
      function z() {
        w.value && (v.value = !0, n("show"));
      }
      function Y() {
        v.value = !1, n("close");
      }
      function G(M) {
        n("switch", M);
      }
      return de(() => o.src, () => {
        E.value ? (f.value = !0, d.value = !1, N(), O()) : k();
      }), ft(() => {
        E.value ? O() : k();
      }), t({
        showPreview: z
      }), (M, R) => (_(), B("div", pt({
        ref_key: "container",
        ref: p
      }, s(i), {
        class: [s(a).b(), M.$attrs.class]
      }), [
        d.value ? ee(M.$slots, "error", { key: 0 }, () => [
          W("div", {
            class: $(s(a).e("error"))
          }, ke(s(l)("el.image.error")), 3)
        ]) : (_(), B(We, { key: 1 }, [
          c.value !== void 0 ? (_(), B("img", pt({ key: 0 }, s(u), {
            src: c.value,
            loading: M.loading,
            style: s(C),
            class: s(b),
            crossorigin: M.crossorigin,
            onClick: z,
            onLoad: T,
            onError: x
          }), null, 16, ["src", "loading", "crossorigin"])) : oe("v-if", !0),
          f.value ? (_(), B("div", {
            key: 1,
            class: $(s(a).e("wrapper"))
          }, [
            ee(M.$slots, "placeholder", {}, () => [
              W("div", {
                class: $(s(a).e("placeholder"))
              }, null, 2)
            ])
          ], 2)) : oe("v-if", !0)
        ], 64)),
        s(w) ? (_(), B(We, { key: 2 }, [
          v.value ? (_(), ae(s(VE), {
            key: 0,
            "z-index": M.zIndex,
            "initial-index": s(y),
            infinite: M.infinite,
            "zoom-rate": M.zoomRate,
            "min-scale": M.minScale,
            "max-scale": M.maxScale,
            "show-progress": M.showProgress,
            "url-list": M.previewSrcList,
            scale: M.scale,
            crossorigin: M.crossorigin,
            "hide-on-click-modal": M.hideOnClickModal,
            teleported: M.previewTeleported,
            "close-on-press-escape": M.closeOnPressEscape,
            onClose: Y,
            onSwitch: G
          }, io({
            toolbar: Q((D) => [
              ee(M.$slots, "toolbar", Bo(fl(D)))
            ]),
            default: Q(() => [
              M.$slots.viewer ? (_(), B("div", { key: 0 }, [
                ee(M.$slots, "viewer")
              ])) : oe("v-if", !0)
            ]),
            _: 2
          }, [
            M.$slots.progress ? {
              name: "progress",
              fn: Q((D) => [
                ee(M.$slots, "progress", Bo(fl(D)))
              ])
            } : void 0,
            M.$slots["viewer-error"] ? {
              name: "viewer-error",
              fn: Q((D) => [
                ee(M.$slots, "viewer-error", Bo(fl(D)))
              ])
            } : void 0
          ]), 1032, ["z-index", "initial-index", "infinite", "zoom-rate", "min-scale", "max-scale", "show-progress", "url-list", "scale", "crossorigin", "hide-on-click-modal", "teleported", "close-on-press-escape"])) : oe("v-if", !0)
        ], 64)) : oe("v-if", !0)
      ], 16));
    }
  });
  var IH = /* @__PURE__ */ Ne(OH, [["__file", "image.vue"]]);
  const MH = rt(IH), xH = Te({
    id: {
      type: String,
      default: void 0
    },
    step: {
      type: Number,
      default: 1
    },
    stepStrictly: Boolean,
    max: {
      type: Number,
      default: Number.MAX_SAFE_INTEGER
    },
    min: {
      type: Number,
      default: Number.MIN_SAFE_INTEGER
    },
    modelValue: {
      type: [Number, null]
    },
    readonly: Boolean,
    disabled: Boolean,
    size: mn,
    controls: {
      type: Boolean,
      default: !0
    },
    controlsPosition: {
      type: String,
      default: "",
      values: ["", "right"]
    },
    valueOnClear: {
      type: [String, Number, null],
      validator: (e) => e === null || je(e) || ["min", "max"].includes(e),
      default: null
    },
    name: String,
    placeholder: String,
    precision: {
      type: Number,
      validator: (e) => e >= 0 && e === Number.parseInt(`${e}`, 10)
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    ...Yn(["ariaLabel"]),
    inputmode: {
      type: X(String),
      default: void 0
    },
    align: {
      type: X(String),
      default: "center"
    },
    disabledScientific: Boolean
  }), PH = {
    [gt]: (e, t) => t !== e,
    blur: (e) => e instanceof FocusEvent,
    focus: (e) => e instanceof FocusEvent,
    [fn]: (e) => je(e) || cn(e),
    [et]: (e) => je(e) || cn(e)
  }, RH = /* @__PURE__ */ U({
    name: "ElInputNumber"
  }), DH = /* @__PURE__ */ U({
    ...RH,
    props: xH,
    emits: PH,
    setup(e, { expose: t, emit: n }) {
      const o = e, { t: l } = _t(), a = he("input-number"), r = A(), i = Rt({
        currentValue: o.modelValue,
        userInput: null
      }), { formItem: u } = Nn(), c = S(() => je(o.modelValue) && o.modelValue <= o.min), d = S(() => je(o.modelValue) && o.modelValue >= o.max), f = S(() => {
        const M = b(o.step);
        return kt(o.precision) ? Math.max(b(o.modelValue), M) : (M > o.precision && vt("InputNumber", "precision should not be less than the decimal places of step"), o.precision);
      }), v = S(() => o.controls && o.controlsPosition === "right"), p = vn(), m = Cn(), h = S(() => {
        if (i.userInput !== null)
          return i.userInput;
        let M = i.currentValue;
        if (cn(M))
          return "";
        if (je(M)) {
          if (Number.isNaN(M))
            return "";
          kt(o.precision) || (M = M.toFixed(o.precision));
        }
        return M;
      }), g = (M, R) => {
        if (kt(R) && (R = f.value), R === 0)
          return Math.round(M);
        let D = String(M);
        const L = D.indexOf(".");
        if (L === -1 || !D.replace(".", "").split("")[L + R])
          return M;
        const H = D.length;
        return D.charAt(H - 1) === "5" && (D = `${D.slice(0, Math.max(0, H - 1))}6`), Number.parseFloat(Number(D).toFixed(R));
      }, b = (M) => {
        if (cn(M))
          return 0;
        const R = M.toString(), D = R.indexOf(".");
        let L = 0;
        return D !== -1 && (L = R.length - D - 1), L;
      }, C = (M, R = 1) => je(M) ? M >= Number.MAX_SAFE_INTEGER && R === 1 ? (vt("InputNumber", "The value has reached the maximum safe integer limit."), M) : M <= Number.MIN_SAFE_INTEGER && R === -1 ? (vt("InputNumber", "The value has reached the minimum safe integer limit."), M) : g(M + o.step * R) : i.currentValue, w = (M) => {
        const R = Ht(M), D = BC(M);
        if (o.disabledScientific && ["e", "E"].includes(D)) {
          M.preventDefault();
          return;
        }
        switch (R) {
          case _e.up: {
            M.preventDefault(), y();
            break;
          }
          case _e.down: {
            M.preventDefault(), E();
            break;
          }
        }
      }, y = () => {
        if (o.readonly || m.value || d.value)
          return;
        const M = Number(h.value) || 0, R = C(M);
        T(R), n(fn, i.currentValue), Y();
      }, E = () => {
        if (o.readonly || m.value || c.value)
          return;
        const M = Number(h.value) || 0, R = C(M, -1);
        T(R), n(fn, i.currentValue), Y();
      }, k = (M, R) => {
        const { max: D, min: L, step: V, precision: F, stepStrictly: H, valueOnClear: K } = o;
        D < L && Zt("InputNumber", "min should not be greater than max.");
        let Z = Number(M);
        if (cn(M) || Number.isNaN(Z))
          return null;
        if (M === "") {
          if (K === null)
            return null;
          Z = Ae(K) ? { min: L, max: D }[K] : K;
        }
        return H && (Z = g(Math.round(g(Z / V)) * V, F), Z !== M && R && n(et, Z)), kt(F) || (Z = g(Z, F)), (Z > D || Z < L) && (Z = Z > D ? D : L, R && n(et, Z)), Z;
      }, T = (M, R = !0) => {
        var D;
        const L = i.currentValue, V = k(M);
        if (!R) {
          n(et, V);
          return;
        }
        i.userInput = null, !(L === V && M) && (n(et, V), L !== V && n(gt, V, L), o.validateEvent && ((D = u == null ? void 0 : u.validate) == null || D.call(u, "change").catch((F) => vt(F))), i.currentValue = V);
      }, x = (M) => {
        i.userInput = M;
        const R = M === "" ? null : Number(M);
        n(fn, R), T(R, !1);
      }, I = (M) => {
        const R = M !== "" ? Number(M) : "";
        (je(R) && !Number.isNaN(R) || M === "") && T(R), Y(), i.userInput = null;
      }, P = () => {
        var M, R;
        (R = (M = r.value) == null ? void 0 : M.focus) == null || R.call(M);
      }, O = () => {
        var M, R;
        (R = (M = r.value) == null ? void 0 : M.blur) == null || R.call(M);
      }, N = (M) => {
        n("focus", M);
      }, z = (M) => {
        var R, D;
        i.userInput = null, i.currentValue === null && ((R = r.value) != null && R.input) && (r.value.input.value = ""), n("blur", M), o.validateEvent && ((D = u == null ? void 0 : u.validate) == null || D.call(u, "blur").catch((L) => vt(L)));
      }, Y = () => {
        i.currentValue !== o.modelValue && (i.currentValue = o.modelValue);
      }, G = (M) => {
        document.activeElement === M.target && M.preventDefault();
      };
      return de(() => o.modelValue, (M, R) => {
        const D = k(M, !0);
        i.userInput === null && D !== R && (i.currentValue = D);
      }, { immediate: !0 }), de(() => o.precision, () => {
        i.currentValue = k(o.modelValue);
      }), ft(() => {
        var M;
        const { min: R, max: D, modelValue: L } = o, V = (M = r.value) == null ? void 0 : M.input;
        if (V.setAttribute("role", "spinbutton"), Number.isFinite(D) ? V.setAttribute("aria-valuemax", String(D)) : V.removeAttribute("aria-valuemax"), Number.isFinite(R) ? V.setAttribute("aria-valuemin", String(R)) : V.removeAttribute("aria-valuemin"), V.setAttribute("aria-valuenow", i.currentValue || i.currentValue === 0 ? String(i.currentValue) : ""), V.setAttribute("aria-disabled", String(m.value)), !je(L) && L != null) {
          let F = Number(L);
          Number.isNaN(F) && (F = null), n(et, F);
        }
        V.addEventListener("wheel", G, { passive: !1 });
      }), Qo(() => {
        var M, R;
        const D = (M = r.value) == null ? void 0 : M.input;
        D == null || D.setAttribute("aria-valuenow", `${(R = i.currentValue) != null ? R : ""}`);
      }), t({
        focus: P,
        blur: O
      }), (M, R) => (_(), B("div", {
        class: $([
          s(a).b(),
          s(a).m(s(p)),
          s(a).is("disabled", s(m)),
          s(a).is("without-controls", !M.controls),
          s(a).is("controls-right", s(v)),
          s(a).is(M.align, !!M.align)
        ]),
        onDragstart: Ze(() => {
        }, ["prevent"])
      }, [
        M.controls ? it((_(), B("span", {
          key: 0,
          role: "button",
          "aria-label": s(l)("el.inputNumber.decrease"),
          class: $([s(a).e("decrease"), s(a).is("disabled", s(c))]),
          onKeydown: on(E, ["enter"])
        }, [
          ee(M.$slots, "decrease-icon", {}, () => [
            q(s(ze), null, {
              default: Q(() => [
                s(v) ? (_(), ae(s(Nl), { key: 0 })) : (_(), ae(s(uD), { key: 1 }))
              ]),
              _: 1
            })
          ])
        ], 42, ["aria-label", "onKeydown"])), [
          [s(Hc), E]
        ]) : oe("v-if", !0),
        M.controls ? it((_(), B("span", {
          key: 1,
          role: "button",
          "aria-label": s(l)("el.inputNumber.increase"),
          class: $([s(a).e("increase"), s(a).is("disabled", s(d))]),
          onKeydown: on(y, ["enter"])
        }, [
          ee(M.$slots, "increase-icon", {}, () => [
            q(s(ze), null, {
              default: Q(() => [
                s(v) ? (_(), ae(s(Pd), { key: 0 })) : (_(), ae(s(yC), { key: 1 }))
              ]),
              _: 1
            })
          ])
        ], 42, ["aria-label", "onKeydown"])), [
          [s(Hc), y]
        ]) : oe("v-if", !0),
        q(s(Wn), {
          id: M.id,
          ref_key: "input",
          ref: r,
          type: "number",
          step: M.step,
          "model-value": s(h),
          placeholder: M.placeholder,
          readonly: M.readonly,
          disabled: s(m),
          size: s(p),
          max: M.max,
          min: M.min,
          name: M.name,
          "aria-label": M.ariaLabel,
          "validate-event": !1,
          inputmode: M.inputmode,
          onKeydown: w,
          onBlur: z,
          onFocus: N,
          onInput: x,
          onChange: I
        }, io({
          _: 2
        }, [
          M.$slots.prefix ? {
            name: "prefix",
            fn: Q(() => [
              ee(M.$slots, "prefix")
            ])
          } : void 0,
          M.$slots.suffix ? {
            name: "suffix",
            fn: Q(() => [
              ee(M.$slots, "suffix")
            ])
          } : void 0
        ]), 1032, ["id", "step", "model-value", "placeholder", "readonly", "disabled", "size", "max", "min", "name", "aria-label", "inputmode"])
      ], 42, ["onDragstart"]));
    }
  });
  var AH = /* @__PURE__ */ Ne(DH, [["__file", "input-number.vue"]]);
  const LE = rt(AH), VH = Te({
    modelValue: {
      type: X(Array)
    },
    max: Number,
    tagType: { ...Xl.type, default: "info" },
    tagEffect: Xl.effect,
    trigger: {
      type: X(String),
      default: _e.enter
    },
    draggable: Boolean,
    delimiter: {
      type: [String, RegExp],
      default: ""
    },
    size: mn,
    clearable: Boolean,
    clearIcon: {
      type: Lt,
      default: oa
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    readonly: Boolean,
    autofocus: Boolean,
    id: {
      type: String,
      default: void 0
    },
    tabindex: {
      type: [String, Number],
      default: 0
    },
    maxlength: {
      type: [String, Number]
    },
    minlength: {
      type: [String, Number]
    },
    placeholder: String,
    autocomplete: {
      type: X(String),
      default: "off"
    },
    saveOnBlur: {
      type: Boolean,
      default: !0
    },
    collapseTags: Boolean,
    collapseTagsTooltip: Boolean,
    maxCollapseTags: {
      type: Number,
      default: 1
    },
    ariaLabel: String
  }), LH = {
    [et]: (e) => ye(e) || kt(e),
    [gt]: (e) => ye(e) || kt(e),
    [fn]: (e) => Ae(e),
    "add-tag": (e) => Ae(e) || ye(e),
    "remove-tag": (e, t) => Ae(e) && je(t),
    "drag-tag": (e, t, n) => je(e) && je(t) && Ae(n),
    focus: (e) => e instanceof FocusEvent,
    blur: (e) => e instanceof FocusEvent,
    clear: () => !0
  };
  function BH({ props: e, emit: t, formItem: n }) {
    const o = Cn(), l = vn(), a = Ut(), r = A(), i = A(), u = S(() => ["small"].includes(l.value) ? "small" : "default"), c = S(() => {
      var G;
      return (G = e.modelValue) != null && G.length ? void 0 : e.placeholder;
    }), d = S(() => !(e.readonly || o.value)), f = S(() => {
      var G, M;
      return kt(e.max) ? !1 : ((M = (G = e.modelValue) == null ? void 0 : G.length) != null ? M : 0) >= e.max;
    }), v = S(() => {
      var G;
      return e.collapseTags ? (G = e.modelValue) == null ? void 0 : G.slice(0, e.maxCollapseTags) : e.modelValue;
    }), p = S(() => {
      var G;
      return e.collapseTags ? (G = e.modelValue) == null ? void 0 : G.slice(e.maxCollapseTags) : [];
    }), m = (G) => {
      var M;
      const R = [...(M = e.modelValue) != null ? M : [], ...En(G)];
      t(et, R), t(gt, R), t("add-tag", G), r.value = void 0;
    }, h = (G) => {
      var M, R;
      const D = G.split(e.delimiter).filter((L) => L && L !== G);
      if (e.max) {
        const L = e.max - ((R = (M = e.modelValue) == null ? void 0 : M.length) != null ? R : 0);
        D.splice(L);
      }
      return D.length === 1 ? D[0] : D;
    }, g = (G) => {
      if (f.value) {
        r.value = void 0;
        return;
      }
      if (!O.value) {
        if (e.delimiter && r.value) {
          const M = h(r.value);
          M.length && m(M);
        }
        t(fn, G.target.value);
      }
    }, b = (G) => {
      var M;
      if (O.value)
        return;
      switch (Ht(G)) {
        case e.trigger:
          G.preventDefault(), G.stopPropagation(), w();
          break;
        case _e.numpadEnter:
          e.trigger === _e.enter && (G.preventDefault(), G.stopPropagation(), w());
          break;
        case _e.backspace:
          !r.value && ((M = e.modelValue) != null && M.length) && (G.preventDefault(), G.stopPropagation(), y(e.modelValue.length - 1));
          break;
      }
    }, C = (G) => {
      if (O.value || !EC())
        return;
      switch (Ht(G)) {
        case _e.space:
          e.trigger === _e.space && (G.preventDefault(), G.stopPropagation(), w());
          break;
      }
    }, w = () => {
      var G;
      const M = (G = r.value) == null ? void 0 : G.trim();
      !M || f.value || m(M);
    }, y = (G) => {
      var M;
      const R = ((M = e.modelValue) != null ? M : []).slice(), [D] = R.splice(G, 1);
      t(et, R), t(gt, R), t("remove-tag", D, G);
    }, E = () => {
      r.value = void 0, t(et, void 0), t(gt, void 0), t("clear");
    }, k = (G, M, R) => {
      var D;
      const L = ((D = e.modelValue) != null ? D : []).slice(), [V] = L.splice(G, 1), F = M > G && R === "before" ? -1 : M < G && R === "after" ? 1 : 0;
      L.splice(M + F, 0, V), t(et, L), t(gt, L), t("drag-tag", G, M + F, V);
    }, T = () => {
      var G;
      (G = a.value) == null || G.focus();
    }, x = () => {
      var G;
      (G = a.value) == null || G.blur();
    }, { wrapperRef: I, isFocused: P } = la(a, {
      disabled: o,
      beforeBlur(G) {
        var M;
        return (M = i.value) == null ? void 0 : M.isFocusInsideContent(G);
      },
      afterBlur() {
        var G;
        e.saveOnBlur ? w() : r.value = void 0, e.validateEvent && ((G = n == null ? void 0 : n.validate) == null || G.call(n, "blur").catch((M) => vt(M)));
      }
    }), {
      isComposing: O,
      handleCompositionStart: N,
      handleCompositionUpdate: z,
      handleCompositionEnd: Y
    } = ru({ afterComposition: g });
    return de(() => e.modelValue, () => {
      var G;
      e.validateEvent && ((G = n == null ? void 0 : n.validate) == null || G.call(n, gt).catch((M) => vt(M)));
    }), {
      inputRef: a,
      wrapperRef: I,
      tagTooltipRef: i,
      isFocused: P,
      isComposing: O,
      inputValue: r,
      size: l,
      tagSize: u,
      placeholder: c,
      closable: d,
      disabled: o,
      inputLimit: f,
      showTagList: v,
      collapseTagList: p,
      handleDragged: k,
      handleInput: g,
      handleKeydown: b,
      handleKeyup: C,
      handleAddTag: w,
      handleRemoveTag: y,
      handleClear: E,
      handleCompositionStart: N,
      handleCompositionUpdate: z,
      handleCompositionEnd: Y,
      focus: T,
      blur: x
    };
  }
  function FH() {
    const e = A(!1);
    return {
      hovering: e,
      handleMouseEnter: () => {
        e.value = !0;
      },
      handleMouseLeave: () => {
        e.value = !1;
      }
    };
  }
  const Ud = 11, BE = 2;
  function Uh() {
    const e = Ut(), t = A(0), n = S(() => ({
      minWidth: `${Math.max(t.value, Ud)}px`
    }));
    return qt(e, () => {
      var l, a;
      t.value = (a = (l = e.value) == null ? void 0 : l.getBoundingClientRect().width) != null ? a : 0;
    }), {
      calculatorRef: e,
      calculatorWidth: t,
      inputStyle: n
    };
  }
  function zH({
    wrapperRef: e,
    handleDragged: t,
    afterDragged: n
  }) {
    const o = he("input-tag"), l = Ut(), a = A(!1);
    let r, i, u, c;
    function d(m) {
      return `.${o.e("inner")} .${o.namespace.value}-tag:nth-child(${m + 1})`;
    }
    function f(m, h) {
      r = h, i = e.value.querySelector(d(h)), i && (i.style.opacity = "0.5"), m.dataTransfer.effectAllowed = "move";
    }
    function v(m, h) {
      if (u = h, m.preventDefault(), m.dataTransfer.dropEffect = "move", kt(r) || r === h) {
        a.value = !1;
        return;
      }
      const g = e.value.querySelector(d(h)).getBoundingClientRect(), b = r + 1 !== h, C = r - 1 !== h, w = m.clientX - g.left, y = b ? C ? 0.5 : 1 : -1, E = C ? b ? 0.5 : 0 : 1;
      w <= g.width * y ? c = "before" : w > g.width * E ? c = "after" : c = void 0;
      const k = e.value.querySelector(`.${o.e("inner")}`), T = k.getBoundingClientRect(), x = Number.parseFloat(Bl(k, "gap")) / 2, I = g.top - T.top;
      let P = -9999;
      if (c === "before")
        P = Math.max(g.left - T.left - x, Math.floor(-x / 2));
      else if (c === "after") {
        const O = g.right - T.left;
        P = O + (T.width === O ? Math.floor(x / 2) : x);
      }
      dC(l.value, {
        top: `${I}px`,
        left: `${P}px`
      }), a.value = !!c;
    }
    function p(m) {
      m.preventDefault(), i && (i.style.opacity = ""), c && !kt(r) && !kt(u) && r !== u && t(r, u, c), a.value = !1, r = void 0, i = null, u = void 0, c = void 0, n == null || n();
    }
    return {
      dropIndicatorRef: l,
      showDropIndicator: a,
      handleDragStart: f,
      handleDragOver: v,
      handleDragEnd: p
    };
  }
  function HH({
    props: e,
    isFocused: t,
    hovering: n,
    disabled: o,
    inputValue: l,
    size: a,
    validateState: r,
    validateIcon: i,
    needStatusIcon: u
  }) {
    const c = ea(), d = hn(), f = he("input-tag"), v = he("input"), p = A(), m = A(), h = S(() => [
      f.b(),
      f.is("focused", t.value),
      f.is("hovering", n.value),
      f.is("disabled", o.value),
      f.m(a.value),
      f.e("wrapper"),
      c.class
    ]), g = S(() => [c.style]), b = S(() => {
      var I, P;
      return [
        f.e("inner"),
        f.is("draggable", e.draggable),
        f.is("left-space", !((I = e.modelValue) != null && I.length) && !d.prefix),
        f.is("right-space", !((P = e.modelValue) != null && P.length) && !w.value)
      ];
    }), C = S(() => {
      var I;
      return e.clearable && !o.value && !e.readonly && (((I = e.modelValue) == null ? void 0 : I.length) || l.value) && (t.value || n.value);
    }), w = S(() => d.suffix || C.value || r.value && i.value && u.value), y = Rt({
      innerWidth: 0,
      collapseItemWidth: 0
    }), E = () => {
      if (!m.value)
        return 0;
      const I = window.getComputedStyle(m.value);
      return Number.parseFloat(I.gap || "6px");
    }, k = () => {
      y.innerWidth = Number.parseFloat(window.getComputedStyle(m.value).width);
    }, T = () => {
      y.collapseItemWidth = p.value.getBoundingClientRect().width;
    }, x = S(() => {
      if (!e.collapseTags)
        return {};
      const I = E(), P = I + Ud, O = p.value && e.maxCollapseTags === 1 ? y.innerWidth - y.collapseItemWidth - I - P : y.innerWidth - P;
      return { maxWidth: `${Math.max(O, 0)}px` };
    });
    return qt(m, k), qt(p, T), {
      ns: f,
      nsInput: v,
      containerKls: h,
      containerStyle: g,
      innerKls: b,
      showClear: C,
      showSuffix: w,
      tagStyle: x,
      collapseItemRef: p,
      innerRef: m
    };
  }
  const KH = /* @__PURE__ */ U({
    name: "ElInputTag",
    inheritAttrs: !1
  }), WH = /* @__PURE__ */ U({
    ...KH,
    props: VH,
    emits: LH,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = Ad(), a = hn(), { form: r, formItem: i } = Nn(), { inputId: u } = wo(o, { formItemContext: i }), c = S(() => {
        var Oe;
        return (Oe = r == null ? void 0 : r.statusIcon) != null ? Oe : !1;
      }), d = S(() => (i == null ? void 0 : i.validateState) || ""), f = S(() => d.value && Dd[d.value]), {
        inputRef: v,
        wrapperRef: p,
        tagTooltipRef: m,
        isFocused: h,
        inputValue: g,
        size: b,
        tagSize: C,
        placeholder: w,
        closable: y,
        disabled: E,
        showTagList: k,
        collapseTagList: T,
        handleDragged: x,
        handleInput: I,
        handleKeydown: P,
        handleKeyup: O,
        handleRemoveTag: N,
        handleClear: z,
        handleCompositionStart: Y,
        handleCompositionUpdate: G,
        handleCompositionEnd: M,
        focus: R,
        blur: D
      } = BH({ props: o, emit: n, formItem: i }), { hovering: L, handleMouseEnter: V, handleMouseLeave: F } = FH(), { calculatorRef: H, inputStyle: K } = Uh(), {
        dropIndicatorRef: Z,
        showDropIndicator: J,
        handleDragStart: ie,
        handleDragOver: ue,
        handleDragEnd: re
      } = zH({ wrapperRef: p, handleDragged: x, afterDragged: R }), {
        ns: se,
        nsInput: ne,
        containerKls: le,
        containerStyle: Ce,
        innerKls: j,
        showClear: te,
        showSuffix: ce,
        tagStyle: ge,
        collapseItemRef: be,
        innerRef: Ee
      } = HH({
        props: o,
        hovering: L,
        isFocused: h,
        inputValue: g,
        disabled: E,
        size: b,
        validateState: d,
        validateIcon: f,
        needStatusIcon: c
      });
      return t({
        focus: R,
        blur: D
      }), (Oe, De) => (_(), B("div", {
        ref_key: "wrapperRef",
        ref: p,
        class: $(s(le)),
        style: Ue(s(Ce)),
        onMouseenter: s(V),
        onMouseleave: s(F)
      }, [
        s(a).prefix ? (_(), B("div", {
          key: 0,
          class: $(s(se).e("prefix"))
        }, [
          ee(Oe.$slots, "prefix")
        ], 2)) : oe("v-if", !0),
        W("div", {
          ref_key: "innerRef",
          ref: Ee,
          class: $(s(j))
        }, [
          (_(!0), B(We, null, bt(s(k), (we, me) => (_(), ae(s(Wl), {
            key: me,
            size: s(C),
            closable: s(y),
            type: Oe.tagType,
            effect: Oe.tagEffect,
            draggable: s(y) && Oe.draggable,
            style: Ue(s(ge)),
            "disable-transitions": "",
            onClose: (Pe) => s(N)(me),
            onDragstart: (Pe) => s(ie)(Pe, me),
            onDragover: (Pe) => s(ue)(Pe, me),
            onDragend: s(re),
            onDrop: Ze(() => {
            }, ["stop"])
          }, {
            default: Q(() => [
              ee(Oe.$slots, "tag", {
                value: we,
                index: me
              }, () => [
                Ct(ke(we), 1)
              ])
            ]),
            _: 2
          }, 1032, ["size", "closable", "type", "effect", "draggable", "style", "onClose", "onDragstart", "onDragover", "onDragend", "onDrop"]))), 128)),
          Oe.collapseTags && Oe.modelValue && Oe.modelValue.length > Oe.maxCollapseTags ? (_(), ae(s(Pn), {
            key: 0,
            ref_key: "tagTooltipRef",
            ref: m,
            disabled: !Oe.collapseTagsTooltip,
            "fallback-placements": ["bottom", "top", "right", "left"],
            effect: Oe.tagEffect,
            placement: "bottom"
          }, {
            default: Q(() => [
              W("div", {
                ref_key: "collapseItemRef",
                ref: be
              }, [
                q(s(Wl), {
                  closable: !1,
                  size: s(C),
                  type: Oe.tagType,
                  effect: Oe.tagEffect,
                  "disable-transitions": ""
                }, {
                  default: Q(() => [
                    Ct(" + " + ke(Oe.modelValue.length - Oe.maxCollapseTags), 1)
                  ]),
                  _: 1
                }, 8, ["size", "type", "effect"])
              ], 512)
            ]),
            content: Q(() => [
              W("div", {
                class: $(s(se).e("input-tag-list"))
              }, [
                (_(!0), B(We, null, bt(s(T), (we, me) => (_(), ae(s(Wl), {
                  key: me,
                  size: s(C),
                  closable: s(y),
                  type: Oe.tagType,
                  effect: Oe.tagEffect,
                  "disable-transitions": "",
                  onClose: (Pe) => s(N)(me + Oe.maxCollapseTags)
                }, {
                  default: Q(() => [
                    ee(Oe.$slots, "tag", {
                      value: we,
                      index: me + Oe.maxCollapseTags
                    }, () => [
                      Ct(ke(we), 1)
                    ])
                  ]),
                  _: 2
                }, 1032, ["size", "closable", "type", "effect", "onClose"]))), 128))
              ], 2)
            ]),
            _: 3
          }, 8, ["disabled", "effect"])) : oe("v-if", !0),
          W("div", {
            class: $(s(se).e("input-wrapper"))
          }, [
            it(W("input", pt({
              id: s(u),
              ref_key: "inputRef",
              ref: v,
              "onUpdate:modelValue": (we) => Kt(g) ? g.value = we : null
            }, s(l), {
              type: "text",
              minlength: Oe.minlength,
              maxlength: Oe.maxlength,
              disabled: s(E),
              readonly: Oe.readonly,
              autocomplete: Oe.autocomplete,
              tabindex: Oe.tabindex,
              placeholder: s(w),
              autofocus: Oe.autofocus,
              ariaLabel: Oe.ariaLabel,
              class: s(se).e("input"),
              style: s(K),
              onCompositionstart: s(Y),
              onCompositionupdate: s(G),
              onCompositionend: s(M),
              onInput: s(I),
              onKeydown: s(P),
              onKeyup: s(O)
            }), null, 16, ["id", "onUpdate:modelValue", "minlength", "maxlength", "disabled", "readonly", "autocomplete", "tabindex", "placeholder", "autofocus", "ariaLabel", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onInput", "onKeydown", "onKeyup"]), [
              [Sd, s(g)]
            ]),
            W("span", {
              ref_key: "calculatorRef",
              ref: H,
              "aria-hidden": "true",
              class: $(s(se).e("input-calculator")),
              textContent: ke(s(g))
            }, null, 10, ["textContent"])
          ], 2),
          it(W("div", {
            ref_key: "dropIndicatorRef",
            ref: Z,
            class: $(s(se).e("drop-indicator"))
          }, null, 2), [
            [Mt, s(J)]
          ])
        ], 2),
        s(ce) ? (_(), B("div", {
          key: 1,
          class: $(s(se).e("suffix"))
        }, [
          ee(Oe.$slots, "suffix"),
          s(te) ? (_(), ae(s(ze), {
            key: 0,
            class: $([s(se).e("icon"), s(se).e("clear")]),
            onMousedown: Ze(s(It), ["prevent"]),
            onClick: s(z)
          }, {
            default: Q(() => [
              (_(), ae(ct(Oe.clearIcon)))
            ]),
            _: 1
          }, 8, ["class", "onMousedown", "onClick"])) : oe("v-if", !0),
          s(d) && s(f) && s(c) ? (_(), ae(s(ze), {
            key: 1,
            class: $([
              s(ne).e("icon"),
              s(ne).e("validateIcon"),
              s(ne).is("loading", s(d) === "validating")
            ])
          }, {
            default: Q(() => [
              (_(), ae(ct(s(f))))
            ]),
            _: 1
          }, 8, ["class"])) : oe("v-if", !0)
        ], 2)) : oe("v-if", !0)
      ], 46, ["onMouseenter", "onMouseleave"]));
    }
  });
  var jH = /* @__PURE__ */ Ne(WH, [["__file", "input-tag.vue"]]);
  const UH = rt(jH), YH = Te({
    type: {
      type: String,
      values: ["primary", "success", "warning", "info", "danger", "default"],
      default: void 0
    },
    underline: {
      type: [Boolean, String],
      values: [!0, !1, "always", "never", "hover"],
      default: void 0
    },
    disabled: Boolean,
    href: { type: String, default: "" },
    target: {
      type: String,
      default: "_self"
    },
    icon: {
      type: Lt
    }
  }), qH = {
    click: (e) => e instanceof MouseEvent
  }, GH = /* @__PURE__ */ U({
    name: "ElLink"
  }), XH = /* @__PURE__ */ U({
    ...GH,
    props: YH,
    emits: qH,
    setup(e, { emit: t }) {
      const n = e, o = ks("link");
      hl({
        scope: "el-link",
        from: "The underline option (boolean)",
        replacement: "'always' | 'hover' | 'never'",
        version: "3.0.0",
        ref: "https://element-plus.org/en-US/component/link.html#underline"
      }, S(() => Vt(n.underline)));
      const l = he("link"), a = S(() => {
        var u, c, d;
        return [
          l.b(),
          l.m((d = (c = n.type) != null ? c : (u = o.value) == null ? void 0 : u.type) != null ? d : "default"),
          l.is("disabled", n.disabled),
          l.is("underline", r.value === "always"),
          l.is("hover-underline", r.value === "hover" && !n.disabled)
        ];
      }), r = S(() => {
        var u, c, d;
        return Vt(n.underline) ? n.underline ? "hover" : "never" : (d = (c = n.underline) != null ? c : (u = o.value) == null ? void 0 : u.underline) != null ? d : "hover";
      });
      function i(u) {
        n.disabled || t("click", u);
      }
      return (u, c) => (_(), B("a", {
        class: $(s(a)),
        href: u.disabled || !u.href ? void 0 : u.href,
        target: u.disabled || !u.href ? void 0 : u.target,
        onClick: i
      }, [
        u.icon ? (_(), ae(s(ze), { key: 0 }, {
          default: Q(() => [
            (_(), ae(ct(u.icon)))
          ]),
          _: 1
        })) : oe("v-if", !0),
        u.$slots.default ? (_(), B("span", {
          key: 1,
          class: $(s(l).e("inner"))
        }, [
          ee(u.$slots, "default")
        ], 2)) : oe("v-if", !0),
        u.$slots.icon ? ee(u.$slots, "icon", { key: 2 }) : oe("v-if", !0)
      ], 10, ["href", "target"]));
    }
  });
  var JH = /* @__PURE__ */ Ne(XH, [["__file", "link.vue"]]);
  const ZH = rt(JH);
  let QH = class {
    constructor(t, n) {
      this.parent = t, this.domNode = n, this.subIndex = 0, this.subIndex = 0, this.init();
    }
    init() {
      this.subMenuItems = this.domNode.querySelectorAll("li"), this.addListeners();
    }
    gotoSubIndex(t) {
      t === this.subMenuItems.length ? t = 0 : t < 0 && (t = this.subMenuItems.length - 1), this.subMenuItems[t].focus(), this.subIndex = t;
    }
    addListeners() {
      const t = this.parent.domNode;
      Array.prototype.forEach.call(this.subMenuItems, (n) => {
        n.addEventListener("keydown", (o) => {
          const l = Ht(o);
          let a = !1;
          switch (l) {
            case _e.down: {
              this.gotoSubIndex(this.subIndex + 1), a = !0;
              break;
            }
            case _e.up: {
              this.gotoSubIndex(this.subIndex - 1), a = !0;
              break;
            }
            case _e.tab: {
              Qu(t, "mouseleave");
              break;
            }
            case _e.enter:
            case _e.numpadEnter:
            case _e.space: {
              a = !0, o.currentTarget.click();
              break;
            }
          }
          return a && (o.preventDefault(), o.stopPropagation()), !1;
        });
      });
    }
  }, e5 = class {
    constructor(t, n) {
      this.domNode = t, this.submenu = null, this.submenu = null, this.init(n);
    }
    init(t) {
      this.domNode.setAttribute("tabindex", "0");
      const n = this.domNode.querySelector(`.${t}-menu`);
      n && (this.submenu = new QH(this, n)), this.addListeners();
    }
    addListeners() {
      this.domNode.addEventListener("keydown", (t) => {
        const n = Ht(t);
        let o = !1;
        switch (n) {
          case _e.down: {
            Qu(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(0), o = !0;
            break;
          }
          case _e.up: {
            Qu(t.currentTarget, "mouseenter"), this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1), o = !0;
            break;
          }
          case _e.tab: {
            Qu(t.currentTarget, "mouseleave");
            break;
          }
          case _e.enter:
          case _e.numpadEnter:
          case _e.space: {
            o = !0, t.currentTarget.click();
            break;
          }
        }
        o && t.preventDefault();
      });
    }
  }, t5 = class {
    constructor(t, n) {
      this.domNode = t, this.init(n);
    }
    init(t) {
      const n = this.domNode.childNodes;
      Array.from(n).forEach((o) => {
        o.nodeType === 1 && new e5(o, t);
      });
    }
  };
  const n5 = /* @__PURE__ */ U({
    name: "ElMenuCollapseTransition"
  }), o5 = /* @__PURE__ */ U({
    ...n5,
    setup(e) {
      const t = he("menu"), n = {
        onBeforeEnter: (o) => o.style.opacity = "0.2",
        onEnter(o, l) {
          _o(o, `${t.namespace.value}-opacity-transition`), o.style.opacity = "1", l();
        },
        onAfterEnter(o) {
          jn(o, `${t.namespace.value}-opacity-transition`), o.style.opacity = "";
        },
        onBeforeLeave(o) {
          o.dataset || (o.dataset = {}), Lo(o, t.m("collapse")) ? (jn(o, t.m("collapse")), o.dataset.oldOverflow = o.style.overflow, o.dataset.scrollWidth = o.clientWidth.toString(), _o(o, t.m("collapse"))) : (_o(o, t.m("collapse")), o.dataset.oldOverflow = o.style.overflow, o.dataset.scrollWidth = o.clientWidth.toString(), jn(o, t.m("collapse"))), o.style.width = `${o.scrollWidth}px`, o.style.overflow = "hidden";
        },
        onLeave(o) {
          _o(o, "horizontal-collapse-transition"), o.style.width = `${o.dataset.scrollWidth}px`;
        }
      };
      return (o, l) => (_(), ae(Mn, pt({ mode: "out-in" }, s(n)), {
        default: Q(() => [
          ee(o.$slots, "default")
        ]),
        _: 3
      }, 16));
    }
  });
  var l5 = /* @__PURE__ */ Ne(o5, [["__file", "menu-collapse-transition.vue"]]);
  function FE(e, t) {
    const n = S(() => {
      let l = e.parent;
      const a = [t.value];
      for (; l.type.name !== "ElMenu"; )
        l.props.index && a.unshift(l.props.index), l = l.parent;
      return a;
    });
    return {
      parentMenu: S(() => {
        let l = e.parent;
        for (; l && !["ElMenu", "ElSubMenu"].includes(l.type.name); )
          l = l.parent;
        return l;
      }),
      indexPath: n
    };
  }
  function a5(e) {
    return S(() => {
      const n = e.backgroundColor;
      return n ? new Lr(n).shade(20).toString() : "";
    });
  }
  const zE = (e, t) => {
    const n = he("menu");
    return S(() => n.cssVarBlock({
      "text-color": e.textColor || "",
      "hover-text-color": e.textColor || "",
      "bg-color": e.backgroundColor || "",
      "hover-bg-color": a5(e).value || "",
      "active-color": e.activeTextColor || "",
      level: `${t}`
    }));
  }, Yh = "rootMenu", Yc = "subMenu:", r5 = Te({
    index: {
      type: String,
      required: !0
    },
    showTimeout: Number,
    hideTimeout: Number,
    popperClass: String,
    popperStyle: {
      type: X([String, Object])
    },
    disabled: Boolean,
    teleported: {
      type: Boolean,
      default: void 0
    },
    popperOffset: Number,
    expandCloseIcon: {
      type: Lt
    },
    expandOpenIcon: {
      type: Lt
    },
    collapseCloseIcon: {
      type: Lt
    },
    collapseOpenIcon: {
      type: Lt
    }
  }), Bf = "ElSubMenu";
  var qh = /* @__PURE__ */ U({
    name: Bf,
    props: r5,
    setup(e, { slots: t, expose: n }) {
      const o = dt(), { indexPath: l, parentMenu: a } = FE(o, S(() => e.index)), r = he("menu"), i = he("sub-menu"), u = Ve(Yh);
      u || Zt(Bf, "can not inject root menu");
      const c = Ve(`${Yc}${a.value.uid}`);
      c || Zt(Bf, "can not inject sub menu");
      const d = A({}), f = A({});
      let v;
      const p = A(!1), m = A(), h = A(), g = S(() => c.level === 0), b = S(() => x.value === "horizontal" && g.value ? "bottom-start" : "right-start"), C = S(() => x.value === "horizontal" && g.value || x.value === "vertical" && !u.props.collapse ? e.expandCloseIcon && e.expandOpenIcon ? k.value ? e.expandOpenIcon : e.expandCloseIcon : Nl : e.collapseCloseIcon && e.collapseOpenIcon ? k.value ? e.collapseOpenIcon : e.collapseCloseIcon : Un), w = S(() => {
        const H = e.teleported;
        return kt(H) ? g.value : H;
      }), y = S(() => u.props.collapse ? `${r.namespace.value}-zoom-in-left` : `${r.namespace.value}-zoom-in-top`), E = S(() => x.value === "horizontal" && g.value ? [
        "bottom-start",
        "bottom-end",
        "top-start",
        "top-end",
        "right-start",
        "left-start"
      ] : [
        "right-start",
        "right",
        "right-end",
        "left-start",
        "bottom-start",
        "bottom-end",
        "top-start",
        "top-end"
      ]), k = S(() => u.openedMenus.includes(e.index)), T = S(() => [...Object.values(d.value), ...Object.values(f.value)].some(({ active: H }) => H)), x = S(() => u.props.mode), I = S(() => u.props.persistent), P = Rt({
        index: e.index,
        indexPath: l,
        active: T
      }), O = zE(u.props, c.level + 1), N = S(() => {
        var H;
        return (H = e.popperOffset) != null ? H : u.props.popperOffset;
      }), z = S(() => {
        var H;
        return (H = e.popperClass) != null ? H : u.props.popperClass;
      }), Y = S(() => {
        var H;
        return (H = e.popperStyle) != null ? H : u.props.popperStyle;
      }), G = S(() => {
        var H;
        return (H = e.showTimeout) != null ? H : u.props.showTimeout;
      }), M = S(() => {
        var H;
        return (H = e.hideTimeout) != null ? H : u.props.hideTimeout;
      }), R = () => {
        var H, K, Z;
        return (Z = (K = (H = h.value) == null ? void 0 : H.popperRef) == null ? void 0 : K.popperInstanceRef) == null ? void 0 : Z.destroy();
      }, D = (H) => {
        H || R();
      }, L = () => {
        u.props.menuTrigger === "hover" && u.props.mode === "horizontal" || u.props.collapse && u.props.mode === "vertical" || e.disabled || u.handleSubMenuClick({
          index: e.index,
          indexPath: l.value,
          active: T.value
        });
      }, V = (H, K = G.value) => {
        var Z;
        if (H.type !== "focus") {
          if (u.props.menuTrigger === "click" && u.props.mode === "horizontal" || !u.props.collapse && u.props.mode === "vertical" || e.disabled) {
            c.mouseInChild.value = !0;
            return;
          }
          c.mouseInChild.value = !0, v == null || v(), { stop: v } = os(() => {
            u.openMenu(e.index, l.value);
          }, K), w.value && ((Z = a.value.vnode.el) == null || Z.dispatchEvent(new MouseEvent("mouseenter"))), H.type === "mouseenter" && H.target && Re(() => {
            au(H.target, { preventScroll: !0 });
          });
        }
      }, F = (H = !1) => {
        var K;
        if (u.props.menuTrigger === "click" && u.props.mode === "horizontal" || !u.props.collapse && u.props.mode === "vertical") {
          c.mouseInChild.value = !1;
          return;
        }
        v == null || v(), c.mouseInChild.value = !1, { stop: v } = os(() => !p.value && u.closeMenu(e.index, l.value), M.value), w.value && H && ((K = c.handleMouseleave) == null || K.call(c, !0));
      };
      de(() => u.props.collapse, (H) => D(!!H));
      {
        const H = (Z) => {
          f.value[Z.index] = Z;
        }, K = (Z) => {
          delete f.value[Z.index];
        };
        yt(`${Yc}${o.uid}`, {
          addSubMenu: H,
          removeSubMenu: K,
          handleMouseleave: F,
          mouseInChild: p,
          level: c.level + 1
        });
      }
      return n({
        opened: k
      }), ft(() => {
        u.addSubMenu(P), c.addSubMenu(P);
      }), Bt(() => {
        c.removeSubMenu(P), u.removeSubMenu(P);
      }), () => {
        var H;
        const K = [
          (H = t.title) == null ? void 0 : H.call(t),
          qe(ze, {
            class: i.e("icon-arrow"),
            style: {
              transform: k.value ? e.expandCloseIcon && e.expandOpenIcon || e.collapseCloseIcon && e.collapseOpenIcon && u.props.collapse ? "none" : "rotateZ(180deg)" : "none"
            }
          }, {
            default: () => Ae(C.value) ? qe(o.appContext.components[C.value]) : qe(C.value)
          })
        ], Z = u.isMenuPopup ? qe(Pn, {
          ref: h,
          visible: k.value,
          effect: "light",
          pure: !0,
          offset: N.value,
          showArrow: !1,
          persistent: I.value,
          popperClass: z.value,
          popperStyle: Y.value,
          placement: b.value,
          teleported: w.value,
          fallbackPlacements: E.value,
          transition: y.value,
          gpuAcceleration: !1
        }, {
          content: () => {
            var J;
            return qe("div", {
              class: [
                r.m(x.value),
                r.m("popup-container"),
                z.value
              ],
              onMouseenter: (ie) => V(ie, 100),
              onMouseleave: () => F(!0),
              onFocus: (ie) => V(ie, 100)
            }, [
              qe("ul", {
                class: [
                  r.b(),
                  r.m("popup"),
                  r.m(`popup-${b.value}`)
                ],
                style: O.value
              }, [(J = t.default) == null ? void 0 : J.call(t)])
            ]);
          },
          default: () => qe("div", {
            class: i.e("title"),
            onClick: L
          }, K)
        }) : qe(We, {}, [
          qe("div", {
            class: i.e("title"),
            ref: m,
            onClick: L
          }, K),
          qe(Hd, {}, {
            default: () => {
              var J;
              return it(qe("ul", {
                role: "menu",
                class: [r.b(), r.m("inline")],
                style: O.value
              }, [(J = t.default) == null ? void 0 : J.call(t)]), [[Mt, k.value]]);
            }
          })
        ]);
        return qe("li", {
          class: [
            i.b(),
            i.is("active", T.value),
            i.is("opened", k.value),
            i.is("disabled", e.disabled)
          ],
          role: "menuitem",
          ariaHaspopup: !0,
          ariaExpanded: k.value,
          onMouseenter: V,
          onMouseleave: () => F(),
          onFocus: V
        }, [Z]);
      };
    }
  });
  const s5 = Te({
    mode: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "vertical"
    },
    defaultActive: {
      type: String,
      default: ""
    },
    defaultOpeneds: {
      type: X(Array),
      default: () => en([])
    },
    uniqueOpened: Boolean,
    router: Boolean,
    menuTrigger: {
      type: String,
      values: ["hover", "click"],
      default: "hover"
    },
    collapse: Boolean,
    backgroundColor: String,
    textColor: String,
    activeTextColor: String,
    closeOnClickOutside: Boolean,
    collapseTransition: {
      type: Boolean,
      default: !0
    },
    ellipsis: {
      type: Boolean,
      default: !0
    },
    popperOffset: {
      type: Number,
      default: 6
    },
    ellipsisIcon: {
      type: Lt,
      default: () => fD
    },
    popperEffect: {
      type: X(String),
      default: "dark"
    },
    popperClass: String,
    popperStyle: {
      type: X([String, Object])
    },
    showTimeout: {
      type: Number,
      default: 300
    },
    hideTimeout: {
      type: Number,
      default: 300
    },
    persistent: {
      type: Boolean,
      default: !0
    }
  }), Ff = (e) => ye(e) && e.every((t) => Ae(t)), i5 = {
    close: (e, t) => Ae(e) && Ff(t),
    open: (e, t) => Ae(e) && Ff(t),
    select: (e, t, n, o) => Ae(e) && Ff(t) && ot(n) && (kt(o) || o instanceof Promise)
  }, ky = 64;
  var u5 = /* @__PURE__ */ U({
    name: "ElMenu",
    props: s5,
    emits: i5,
    setup(e, { emit: t, slots: n, expose: o }) {
      const l = dt(), a = l.appContext.config.globalProperties.$router, r = A(), i = A(), u = he("menu"), c = he("sub-menu");
      let d = ky;
      const f = A(-1), v = A(e.defaultOpeneds && !e.collapse ? e.defaultOpeneds.slice(0) : []), p = A(e.defaultActive), m = A({}), h = A({}), g = S(() => e.mode === "horizontal" || e.mode === "vertical" && e.collapse), b = () => {
        const R = p.value && m.value[p.value];
        if (!R || e.mode === "horizontal" || e.collapse)
          return;
        R.indexPath.forEach((L) => {
          const V = h.value[L];
          V && C(L, V.indexPath);
        });
      }, C = (R, D) => {
        v.value.includes(R) || (e.uniqueOpened && (v.value = v.value.filter((L) => D.includes(L))), v.value.push(R), t("open", R, D));
      }, w = (R) => {
        const D = v.value.indexOf(R);
        D !== -1 && v.value.splice(D, 1);
      }, y = (R, D) => {
        w(R), t("close", R, D);
      }, E = ({
        index: R,
        indexPath: D
      }) => {
        v.value.includes(R) ? y(R, D) : C(R, D);
      }, k = (R) => {
        (e.mode === "horizontal" || e.collapse) && (v.value = []);
        const { index: D, indexPath: L } = R;
        if (!(cn(D) || cn(L)))
          if (e.router && a) {
            const V = R.route || D, F = a.push(V).then((H) => (H || (p.value = D), H));
            t("select", D, L, { index: D, indexPath: L, route: V }, F);
          } else
            p.value = D, t("select", D, L, { index: D, indexPath: L });
      }, T = (R) => {
        var D;
        const L = m.value, V = L[R] || p.value && L[p.value] || L[e.defaultActive];
        p.value = (D = V == null ? void 0 : V.index) != null ? D : R;
      }, x = (R) => {
        const D = getComputedStyle(R), L = Number.parseInt(D.marginLeft, 10), V = Number.parseInt(D.marginRight, 10);
        return R.offsetWidth + L + V || 0;
      }, I = () => {
        if (!r.value)
          return -1;
        const R = Array.from(r.value.childNodes).filter((Z) => Z.nodeName !== "#comment" && (Z.nodeName !== "#text" || Z.nodeValue)), D = getComputedStyle(r.value), L = Number.parseInt(D.paddingLeft, 10), V = Number.parseInt(D.paddingRight, 10), F = r.value.clientWidth - L - V;
        let H = 0, K = 0;
        return R.forEach((Z, J) => {
          H += x(Z), H <= F - d && (K = J + 1);
        }), K === R.length ? -1 : K;
      }, P = (R) => h.value[R].indexPath, O = (R, D = 33.34) => {
        let L;
        return () => {
          L && clearTimeout(L), L = setTimeout(() => {
            R();
          }, D);
        };
      };
      let N = !0;
      const z = () => {
        const R = kn(i);
        if (R && (d = x(R) || ky), f.value === I())
          return;
        const D = () => {
          f.value = -1, Re(() => {
            f.value = I();
          });
        };
        N ? D() : O(D)(), N = !1;
      };
      de(() => e.defaultActive, (R) => {
        m.value[R] || (p.value = ""), T(R);
      }), de(() => e.collapse, (R) => {
        R && (v.value = []);
      }), de(m.value, b);
      let Y;
      to(() => {
        e.mode === "horizontal" && e.ellipsis ? Y = qt(r, z).stop : Y == null || Y();
      });
      const G = A(!1);
      {
        const R = (F) => {
          h.value[F.index] = F;
        }, D = (F) => {
          delete h.value[F.index];
        };
        yt(Yh, Rt({
          props: e,
          openedMenus: v,
          items: m,
          subMenus: h,
          activeIndex: p,
          isMenuPopup: g,
          addMenuItem: (F) => {
            m.value[F.index] = F;
          },
          removeMenuItem: (F) => {
            delete m.value[F.index];
          },
          addSubMenu: R,
          removeSubMenu: D,
          openMenu: C,
          closeMenu: y,
          handleMenuItemClick: k,
          handleSubMenuClick: E
        })), yt(`${Yc}${l.uid}`, {
          addSubMenu: R,
          removeSubMenu: D,
          mouseInChild: G,
          level: 0
        });
      }
      ft(() => {
        e.mode === "horizontal" && new t5(l.vnode.el, u.namespace.value);
      }), o({
        open: (D) => {
          const { indexPath: L } = h.value[D];
          L.forEach((V) => C(V, L));
        },
        close: w,
        updateActiveIndex: T,
        handleResize: z
      });
      const M = zE(e, 0);
      return () => {
        var R, D;
        let L = (D = (R = n.default) == null ? void 0 : R.call(n)) != null ? D : [];
        const V = [];
        if (e.mode === "horizontal" && r.value) {
          const K = cl(L).filter((ie) => (ie == null ? void 0 : ie.shapeFlag) !== 8), Z = f.value === -1 ? K : K.slice(0, f.value), J = f.value === -1 ? [] : K.slice(f.value);
          J != null && J.length && e.ellipsis && (L = Z, V.push(qe(qh, {
            ref: i,
            index: "sub-menu-more",
            class: c.e("hide-arrow"),
            popperOffset: e.popperOffset
          }, {
            title: () => qe(ze, {
              class: c.e("icon-more")
            }, {
              default: () => qe(e.ellipsisIcon)
            }),
            default: () => J
          })));
        }
        const F = e.closeOnClickOutside ? [
          [
            Jl,
            () => {
              v.value.length && (G.value || (v.value.forEach((K) => t("close", K, P(K))), v.value = []));
            }
          ]
        ] : [], H = it(qe("ul", {
          key: String(e.collapse),
          role: "menubar",
          ref: r,
          style: M.value,
          class: {
            [u.b()]: !0,
            [u.m(e.mode)]: !0,
            [u.m("collapse")]: e.collapse
          }
        }, [...L, ...V]), F);
        return e.collapseTransition && e.mode === "vertical" ? qe(l5, () => H) : H;
      };
    }
  });
  const c5 = Te({
    index: {
      type: X([String, null]),
      default: null
    },
    route: {
      type: X([String, Object])
    },
    disabled: Boolean
  }), d5 = {
    click: (e) => Ae(e.index) && ye(e.indexPath)
  }, rc = "ElMenuItem", f5 = /* @__PURE__ */ U({
    name: rc
  }), p5 = /* @__PURE__ */ U({
    ...f5,
    props: c5,
    emits: d5,
    setup(e, { expose: t, emit: n }) {
      const o = e;
      go(o.index) && vt(rc, 'Missing required prop: "index"');
      const l = dt(), a = Ve(Yh), r = he("menu"), i = he("menu-item");
      a || Zt(rc, "can not inject root menu");
      const { parentMenu: u, indexPath: c } = FE(l, At(o, "index")), d = Ve(`${Yc}${u.value.uid}`);
      d || Zt(rc, "can not inject sub menu");
      const f = S(() => o.index === a.activeIndex), v = Rt({
        index: o.index,
        indexPath: c,
        active: f
      }), p = () => {
        o.disabled || (a.handleMenuItemClick({
          index: o.index,
          indexPath: c.value,
          route: o.route
        }), n("click", v));
      };
      return ft(() => {
        d.addSubMenu(v), a.addMenuItem(v);
      }), Bt(() => {
        d.removeSubMenu(v), a.removeMenuItem(v);
      }), t({
        parentMenu: u,
        rootMenu: a,
        active: f,
        nsMenu: r,
        nsMenuItem: i,
        handleClick: p
      }), (m, h) => (_(), B("li", {
        class: $([
          s(i).b(),
          s(i).is("active", s(f)),
          s(i).is("disabled", m.disabled)
        ]),
        role: "menuitem",
        tabindex: "-1",
        onClick: p
      }, [
        s(u).type.name === "ElMenu" && s(a).props.collapse && m.$slots.title ? (_(), ae(s(Pn), {
          key: 0,
          effect: s(a).props.popperEffect,
          placement: "right",
          "fallback-placements": ["left"],
          persistent: s(a).props.persistent,
          "focus-on-target": ""
        }, {
          content: Q(() => [
            ee(m.$slots, "title")
          ]),
          default: Q(() => [
            W("div", {
              class: $(s(r).be("tooltip", "trigger"))
            }, [
              ee(m.$slots, "default")
            ], 2)
          ]),
          _: 3
        }, 8, ["effect", "persistent"])) : (_(), B(We, { key: 1 }, [
          ee(m.$slots, "default"),
          ee(m.$slots, "title")
        ], 64))
      ], 2));
    }
  });
  var HE = /* @__PURE__ */ Ne(p5, [["__file", "menu-item.vue"]]);
  const v5 = {
    title: String
  }, h5 = /* @__PURE__ */ U({
    name: "ElMenuItemGroup"
  }), m5 = /* @__PURE__ */ U({
    ...h5,
    props: v5,
    setup(e) {
      const t = he("menu-item-group");
      return (n, o) => (_(), B("li", {
        class: $(s(t).b())
      }, [
        W("div", {
          class: $(s(t).e("title"))
        }, [
          n.$slots.title ? ee(n.$slots, "title", { key: 1 }) : (_(), B(We, { key: 0 }, [
            Ct(ke(n.title), 1)
          ], 64))
        ], 2),
        W("ul", null, [
          ee(n.$slots, "default")
        ])
      ], 2));
    }
  });
  var KE = /* @__PURE__ */ Ne(m5, [["__file", "menu-item-group.vue"]]);
  const g5 = rt(u5, {
    MenuItem: HE,
    MenuItemGroup: KE,
    SubMenu: qh
  }), b5 = nn(HE), y5 = nn(KE), w5 = nn(qh), C5 = Te({
    icon: {
      type: Lt,
      default: () => AR
    },
    title: String,
    content: {
      type: String,
      default: ""
    }
  }), S5 = {
    back: () => !0
  }, E5 = /* @__PURE__ */ U({
    name: "ElPageHeader"
  }), k5 = /* @__PURE__ */ U({
    ...E5,
    props: C5,
    emits: S5,
    setup(e, { emit: t }) {
      const { t: n } = _t(), o = he("page-header");
      function l() {
        t("back");
      }
      return (a, r) => (_(), B("div", {
        class: $([
          s(o).b(),
          s(o).is("contentful", !!a.$slots.default),
          {
            [s(o).m("has-breadcrumb")]: !!a.$slots.breadcrumb,
            [s(o).m("has-extra")]: !!a.$slots.extra
          }
        ])
      }, [
        a.$slots.breadcrumb ? (_(), B("div", {
          key: 0,
          class: $(s(o).e("breadcrumb"))
        }, [
          ee(a.$slots, "breadcrumb")
        ], 2)) : oe("v-if", !0),
        W("div", {
          class: $(s(o).e("header"))
        }, [
          W("div", {
            class: $(s(o).e("left"))
          }, [
            W("div", {
              class: $(s(o).e("back")),
              role: "button",
              tabindex: "0",
              onClick: l
            }, [
              a.icon || a.$slots.icon ? (_(), B("div", {
                key: 0,
                "aria-label": a.title || s(n)("el.pageHeader.title"),
                class: $(s(o).e("icon"))
              }, [
                ee(a.$slots, "icon", {}, () => [
                  a.icon ? (_(), ae(s(ze), { key: 0 }, {
                    default: Q(() => [
                      (_(), ae(ct(a.icon)))
                    ]),
                    _: 1
                  })) : oe("v-if", !0)
                ])
              ], 10, ["aria-label"])) : oe("v-if", !0),
              W("div", {
                class: $(s(o).e("title"))
              }, [
                ee(a.$slots, "title", {}, () => [
                  Ct(ke(a.title || s(n)("el.pageHeader.title")), 1)
                ])
              ], 2)
            ], 2),
            q(s(kE), { direction: "vertical" }),
            W("div", {
              class: $(s(o).e("content"))
            }, [
              ee(a.$slots, "content", {}, () => [
                Ct(ke(a.content), 1)
              ])
            ], 2)
          ], 2),
          a.$slots.extra ? (_(), B("div", {
            key: 0,
            class: $(s(o).e("extra"))
          }, [
            ee(a.$slots, "extra")
          ], 2)) : oe("v-if", !0)
        ], 2),
        a.$slots.default ? (_(), B("div", {
          key: 1,
          class: $(s(o).e("main"))
        }, [
          ee(a.$slots, "default")
        ], 2)) : oe("v-if", !0)
      ], 2));
    }
  });
  var _5 = /* @__PURE__ */ Ne(k5, [["__file", "page-header.vue"]]);
  const T5 = rt(_5), WE = Symbol("elPaginationKey"), N5 = Te({
    disabled: Boolean,
    currentPage: {
      type: Number,
      default: 1
    },
    prevText: {
      type: String
    },
    prevIcon: {
      type: Lt
    }
  }), $5 = {
    click: (e) => e instanceof MouseEvent
  }, O5 = /* @__PURE__ */ U({
    name: "ElPaginationPrev"
  }), I5 = /* @__PURE__ */ U({
    ...O5,
    props: N5,
    emits: $5,
    setup(e) {
      const t = e, { t: n } = _t(), o = S(() => t.disabled || t.currentPage <= 1);
      return (l, a) => (_(), B("button", {
        type: "button",
        class: "btn-prev",
        disabled: s(o),
        "aria-label": l.prevText || s(n)("el.pagination.prev"),
        "aria-disabled": s(o),
        onClick: (r) => l.$emit("click", r)
      }, [
        l.prevText ? (_(), B("span", { key: 0 }, ke(l.prevText), 1)) : (_(), ae(s(ze), { key: 1 }, {
          default: Q(() => [
            (_(), ae(ct(l.prevIcon)))
          ]),
          _: 1
        }))
      ], 8, ["disabled", "aria-label", "aria-disabled", "onClick"]));
    }
  });
  var M5 = /* @__PURE__ */ Ne(I5, [["__file", "prev.vue"]]);
  const x5 = Te({
    disabled: Boolean,
    currentPage: {
      type: Number,
      default: 1
    },
    pageCount: {
      type: Number,
      default: 50
    },
    nextText: {
      type: String
    },
    nextIcon: {
      type: Lt
    }
  }), P5 = /* @__PURE__ */ U({
    name: "ElPaginationNext"
  }), R5 = /* @__PURE__ */ U({
    ...P5,
    props: x5,
    emits: ["click"],
    setup(e) {
      const t = e, { t: n } = _t(), o = S(() => t.disabled || t.currentPage === t.pageCount || t.pageCount === 0);
      return (l, a) => (_(), B("button", {
        type: "button",
        class: "btn-next",
        disabled: s(o),
        "aria-label": l.nextText || s(n)("el.pagination.next"),
        "aria-disabled": s(o),
        onClick: (r) => l.$emit("click", r)
      }, [
        l.nextText ? (_(), B("span", { key: 0 }, ke(l.nextText), 1)) : (_(), ae(s(ze), { key: 1 }, {
          default: Q(() => [
            (_(), ae(ct(l.nextIcon)))
          ]),
          _: 1
        }))
      ], 8, ["disabled", "aria-label", "aria-disabled", "onClick"]));
    }
  });
  var D5 = /* @__PURE__ */ Ne(R5, [["__file", "next.vue"]]);
  const Gh = {
    label: "label",
    value: "value",
    disabled: "disabled",
    options: "options"
  };
  function fu(e) {
    const t = S(() => ({ ...Gh, ...e.props }));
    return {
      aliasProps: t,
      getLabel: (r) => dn(r, t.value.label),
      getValue: (r) => dn(r, t.value.value),
      getDisabled: (r) => dn(r, t.value.disabled),
      getOptions: (r) => dn(r, t.value.options)
    };
  }
  const jE = Symbol("ElSelectGroup"), pu = Symbol("ElSelect"), Bp = "ElOption", A5 = Te({
    value: {
      type: [String, Number, Boolean, Object],
      required: !0
    },
    label: {
      type: [String, Number]
    },
    created: Boolean,
    disabled: Boolean
  }), Xh = (e = "") => e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d"), ba = (e) => Ta(e);
  function V5(e, t) {
    const n = Ve(pu);
    n || Zt(Bp, "usage: <el-select><el-option /></el-select/>");
    const o = Ve(jE, { disabled: !1 }), l = S(() => d(En(n.props.modelValue), e.value)), a = S(() => {
      var p;
      if (n.props.multiple) {
        const m = En((p = n.props.modelValue) != null ? p : []);
        return !l.value && m.length >= n.props.multipleLimit && n.props.multipleLimit > 0;
      } else
        return !1;
    }), r = S(() => {
      var p;
      return (p = e.label) != null ? p : ot(e.value) ? "" : e.value;
    }), i = S(() => e.value || e.label || ""), u = S(() => e.disabled || t.groupDisabled || a.value), c = dt(), d = (p = [], m) => {
      if (ot(e.value)) {
        const h = n.props.valueKey;
        return p && p.some((g) => Pt(dn(g, h)) === dn(m, h));
      } else
        return p && p.includes(m);
    }, f = () => {
      !e.disabled && !o.disabled && (n.states.hoveringIndex = n.optionsArray.indexOf(c.proxy));
    }, v = (p) => {
      const m = new RegExp(Xh(p), "i");
      t.visible = m.test(String(r.value)) || e.created;
    };
    return de(() => r.value, () => {
      !e.created && !n.props.remote && n.setSelected();
    }), de(() => e.value, (p, m) => {
      const { remote: h, valueKey: g } = n.props;
      if ((h ? p !== m : !ln(p, m)) && (n.onOptionDestroy(m, c.proxy), n.onOptionCreate(c.proxy)), !e.created && !h) {
        if (g && ot(p) && ot(m) && p[g] === m[g])
          return;
        n.setSelected();
      }
    }), de(() => o.disabled, () => {
      t.groupDisabled = o.disabled;
    }, { immediate: !0 }), {
      select: n,
      currentLabel: r,
      currentValue: i,
      itemSelected: l,
      isDisabled: u,
      hoverItem: f,
      updateOption: v
    };
  }
  const L5 = /* @__PURE__ */ U({
    name: Bp,
    componentName: Bp,
    props: A5,
    setup(e) {
      const t = he("select"), n = xn(), o = S(() => [
        t.be("dropdown", "item"),
        t.is("disabled", s(i)),
        t.is("selected", s(r)),
        t.is("hovering", s(v))
      ]), l = Rt({
        index: -1,
        groupDisabled: !1,
        visible: !0,
        hover: !1
      }), {
        currentLabel: a,
        itemSelected: r,
        isDisabled: i,
        select: u,
        hoverItem: c,
        updateOption: d
      } = V5(e, l), { visible: f, hover: v } = wn(l), p = dt().proxy;
      u.onOptionCreate(p), Bt(() => {
        const h = p.value;
        Re(() => {
          const { selected: g } = u.states, b = g.some((C) => C.value === p.value);
          u.states.cachedOptions.get(h) === p && !b && u.states.cachedOptions.delete(h);
        }), u.onOptionDestroy(h, p);
      });
      function m() {
        i.value || u.handleOptionSelect(p);
      }
      return {
        ns: t,
        id: n,
        containerKls: o,
        currentLabel: a,
        itemSelected: r,
        isDisabled: i,
        select: u,
        visible: f,
        hover: v,
        states: l,
        hoverItem: c,
        updateOption: d,
        selectOptionClick: m
      };
    }
  });
  function B5(e, t) {
    return it((_(), B("li", {
      id: e.id,
      class: $(e.containerKls),
      role: "option",
      "aria-disabled": e.isDisabled || void 0,
      "aria-selected": e.itemSelected,
      onMousemove: e.hoverItem,
      onClick: Ze(e.selectOptionClick, ["stop"])
    }, [
      ee(e.$slots, "default", {}, () => [
        W("span", null, ke(e.currentLabel), 1)
      ])
    ], 42, ["id", "aria-disabled", "aria-selected", "onMousemove", "onClick"])), [
      [Mt, e.visible]
    ]);
  }
  var Jh = /* @__PURE__ */ Ne(L5, [["render", B5], ["__file", "option.vue"]]);
  const F5 = /* @__PURE__ */ U({
    name: "ElSelectDropdown",
    componentName: "ElSelectDropdown",
    setup() {
      const e = Ve(pu), t = he("select"), n = S(() => e.props.popperClass), o = S(() => e.props.multiple), l = S(() => e.props.fitInputWidth), a = A("");
      function r() {
        var i;
        const u = (i = e.selectRef) == null ? void 0 : i.offsetWidth;
        u ? a.value = `${u - BE}px` : a.value = "";
      }
      return ft(() => {
        r(), qt(e.selectRef, r);
      }), {
        ns: t,
        minWidth: a,
        popperClass: n,
        isMultiple: o,
        isFitInputWidth: l
      };
    }
  });
  function z5(e, t, n, o, l, a) {
    return _(), B("div", {
      class: $([e.ns.b("dropdown"), e.ns.is("multiple", e.isMultiple), e.popperClass]),
      style: Ue({ [e.isFitInputWidth ? "width" : "minWidth"]: e.minWidth })
    }, [
      e.$slots.header ? (_(), B("div", {
        key: 0,
        class: $(e.ns.be("dropdown", "header"))
      }, [
        ee(e.$slots, "header")
      ], 2)) : oe("v-if", !0),
      ee(e.$slots, "default"),
      e.$slots.footer ? (_(), B("div", {
        key: 1,
        class: $(e.ns.be("dropdown", "footer"))
      }, [
        ee(e.$slots, "footer")
      ], 2)) : oe("v-if", !0)
    ], 6);
  }
  var H5 = /* @__PURE__ */ Ne(F5, [["render", z5], ["__file", "select-dropdown.vue"]]);
  const K5 = (e, t) => {
    const { t: n } = _t(), o = xn(), l = he("select"), a = he("input"), r = Rt({
      inputValue: "",
      options: /* @__PURE__ */ new Map(),
      cachedOptions: /* @__PURE__ */ new Map(),
      optionValues: [],
      selected: [],
      selectionWidth: 0,
      collapseItemWidth: 0,
      selectedLabel: "",
      hoveringIndex: -1,
      previousQuery: null,
      inputHovering: !1,
      menuVisibleOnFocus: !1,
      isBeforeHide: !1
    }), i = A(), u = A(), c = A(), d = A(), f = A(), v = A(), p = A(), m = A(), h = A(), g = A(), b = A(), C = A(!1), w = A(), y = A(!1), { form: E, formItem: k } = Nn(), { inputId: T } = wo(e, {
      formItemContext: k
    }), { valueOnClear: x, isEmptyValue: I } = nu(e), {
      isComposing: P,
      handleCompositionStart: O,
      handleCompositionUpdate: N,
      handleCompositionEnd: z
    } = ru({
      afterComposition: ($e) => ut($e)
    }), Y = S(() => e.disabled || !!(E != null && E.disabled)), { wrapperRef: G, isFocused: M, handleBlur: R } = la(f, {
      disabled: Y,
      afterFocus() {
        e.automaticDropdown && !C.value && (C.value = !0, r.menuVisibleOnFocus = !0);
      },
      beforeBlur($e) {
        var nt, Tt;
        return ((nt = c.value) == null ? void 0 : nt.isFocusInsideContent($e)) || ((Tt = d.value) == null ? void 0 : Tt.isFocusInsideContent($e));
      },
      afterBlur() {
        var $e;
        C.value = !1, r.menuVisibleOnFocus = !1, e.validateEvent && (($e = k == null ? void 0 : k.validate) == null || $e.call(k, "blur").catch((nt) => vt(nt)));
      }
    }), D = S(() => ye(e.modelValue) ? e.modelValue.length > 0 : !I(e.modelValue)), L = S(() => {
      var $e;
      return ($e = E == null ? void 0 : E.statusIcon) != null ? $e : !1;
    }), V = S(() => e.clearable && !Y.value && D.value && (M.value || r.inputHovering)), F = S(() => e.remote && e.filterable && !e.remoteShowSuffix ? "" : e.suffixIcon), H = S(() => l.is("reverse", !!(F.value && C.value))), K = S(() => (k == null ? void 0 : k.validateState) || ""), Z = S(() => K.value && Dd[K.value]), J = S(() => e.remote ? e.debounce : 0), ie = S(() => e.remote && !r.inputValue && r.options.size === 0), ue = S(() => e.loading ? e.loadingText || n("el.select.loading") : e.filterable && r.inputValue && r.options.size > 0 && re.value === 0 ? e.noMatchText || n("el.select.noMatch") : r.options.size === 0 ? e.noDataText || n("el.select.noData") : null), re = S(() => se.value.filter(($e) => $e.visible).length), se = S(() => {
      const $e = Array.from(r.options.values()), nt = [];
      return r.optionValues.forEach((Tt) => {
        const Gt = $e.findIndex((an) => an.value === Tt);
        Gt > -1 && nt.push($e[Gt]);
      }), nt.length >= $e.length ? nt : $e;
    }), ne = S(() => Array.from(r.cachedOptions.values())), le = S(() => {
      const $e = se.value.filter((nt) => !nt.created).some((nt) => nt.currentLabel === r.inputValue);
      return e.filterable && e.allowCreate && r.inputValue !== "" && !$e;
    }), Ce = () => {
      e.filterable && Fe(e.filterMethod) || e.filterable && e.remote && Fe(e.remoteMethod) || se.value.forEach(($e) => {
        var nt;
        (nt = $e.updateOption) == null || nt.call($e, r.inputValue);
      });
    }, j = vn(), te = S(() => ["small"].includes(j.value) ? "small" : "default"), ce = S({
      get() {
        return C.value && (e.loading || !ie.value) && (!y.value || !Zn(r.previousQuery));
      },
      set($e) {
        C.value = $e;
      }
    }), ge = S(() => {
      if (e.multiple && !kt(e.modelValue))
        return En(e.modelValue).length === 0 && !r.inputValue;
      const $e = ye(e.modelValue) ? e.modelValue[0] : e.modelValue;
      return e.filterable || kt($e) ? !r.inputValue : !0;
    }), be = S(() => {
      var $e;
      const nt = ($e = e.placeholder) != null ? $e : n("el.select.placeholder");
      return e.multiple || !D.value ? nt : r.selectedLabel;
    }), Ee = S(() => Lc ? null : "mouseenter");
    de(() => e.modelValue, ($e, nt) => {
      e.multiple && e.filterable && !e.reserveKeyword && (r.inputValue = "", Oe("")), we(), !ln($e, nt) && e.validateEvent && (k == null || k.validate("change").catch((Tt) => vt(Tt)));
    }, {
      flush: "post",
      deep: !0
    }), de(() => C.value, ($e) => {
      $e ? Oe(r.inputValue) : (r.inputValue = "", r.previousQuery = null, r.isBeforeHide = !0), t("visible-change", $e);
    }), de(() => r.options.entries(), () => {
      xt && (we(), e.defaultFirstOption && (e.filterable || e.remote) && re.value && De());
    }, {
      flush: "post"
    }), de([() => r.hoveringIndex, se], ([$e]) => {
      je($e) && $e > -1 ? w.value = se.value[$e] || {} : w.value = {}, se.value.forEach((nt) => {
        nt.hover = w.value === nt;
      });
    }), to(() => {
      r.isBeforeHide || Ce();
    });
    const Oe = ($e) => {
      r.previousQuery === $e || P.value || (r.previousQuery = $e, e.filterable && Fe(e.filterMethod) ? e.filterMethod($e) : e.filterable && e.remote && Fe(e.remoteMethod) && e.remoteMethod($e), e.defaultFirstOption && (e.filterable || e.remote) && re.value ? Re(De) : Re(Pe));
    }, De = () => {
      const $e = se.value.filter((an) => an.visible && !an.disabled && !an.states.groupDisabled), nt = $e.find((an) => an.created), Tt = $e[0], Gt = se.value.map((an) => an.value);
      r.hoveringIndex = Ke(Gt, nt || Tt);
    }, we = () => {
      if (e.multiple)
        r.selectedLabel = "";
      else {
        const nt = ye(e.modelValue) ? e.modelValue[0] : e.modelValue, Tt = me(nt);
        r.selectedLabel = Tt.currentLabel, r.selected = [Tt];
        return;
      }
      const $e = [];
      kt(e.modelValue) || En(e.modelValue).forEach((nt) => {
        $e.push(me(nt));
      }), r.selected = $e;
    }, me = ($e) => {
      let nt;
      const Tt = si($e);
      for (let Ln = r.cachedOptions.size - 1; Ln >= 0; Ln--) {
        const Rn = ne.value[Ln];
        if (Tt ? dn(Rn.value, e.valueKey) === dn($e, e.valueKey) : Rn.value === $e) {
          nt = {
            index: se.value.filter((Il) => !Il.created).indexOf(Rn),
            value: $e,
            currentLabel: Rn.currentLabel,
            get isDisabled() {
              return Rn.isDisabled;
            }
          };
          break;
        }
      }
      if (nt)
        return nt;
      const Gt = Tt ? $e.label : $e ?? "";
      return {
        index: -1,
        value: $e,
        currentLabel: Gt
      };
    }, Pe = () => {
      r.hoveringIndex = se.value.findIndex(($e) => r.selected.some((nt) => uo(nt) === uo($e)));
    }, Me = () => {
      r.selectionWidth = Number.parseFloat(window.getComputedStyle(u.value).width);
    }, Be = () => {
      r.collapseItemWidth = g.value.getBoundingClientRect().width;
    }, pe = () => {
      var $e, nt;
      (nt = ($e = c.value) == null ? void 0 : $e.updatePopper) == null || nt.call($e);
    }, Le = () => {
      var $e, nt;
      (nt = ($e = d.value) == null ? void 0 : $e.updatePopper) == null || nt.call($e);
    }, Xe = () => {
      r.inputValue.length > 0 && !C.value && (C.value = !0), Oe(r.inputValue);
    }, ut = ($e) => {
      if (r.inputValue = $e.target.value, e.remote)
        y.value = !0, Nt();
      else
        return Xe();
    }, Nt = eu(() => {
      Xe(), y.value = !1;
    }, J), Ye = ($e) => {
      ln(e.modelValue, $e) || t(gt, $e);
    }, tt = ($e) => U1($e, (nt) => {
      const Tt = r.cachedOptions.get(nt);
      return !(Tt != null && Tt.disabled) && !(Tt != null && Tt.states.groupDisabled);
    }), fe = ($e) => {
      const nt = Ht($e);
      if (e.multiple && nt !== _e.delete && $e.target.value.length <= 0) {
        const Tt = En(e.modelValue).slice(), Gt = tt(Tt);
        if (Gt < 0)
          return;
        const an = Tt[Gt];
        Tt.splice(Gt, 1), t(et, Tt), Ye(Tt), t("remove-tag", an);
      }
    }, He = ($e, nt) => {
      const Tt = r.selected.indexOf(nt);
      if (Tt > -1 && !Y.value) {
        const Gt = En(e.modelValue).slice();
        Gt.splice(Tt, 1), t(et, Gt), Ye(Gt), t("remove-tag", nt.value);
      }
      $e.stopPropagation(), Yt();
    }, Qe = ($e) => {
      $e.stopPropagation();
      const nt = e.multiple ? [] : x.value;
      if (e.multiple)
        for (const Tt of r.selected)
          Tt.isDisabled && nt.push(Tt.value);
      t(et, nt), Ye(nt), r.hoveringIndex = -1, C.value = !1, t("clear"), Yt();
    }, ve = ($e) => {
      var nt;
      if (e.multiple) {
        const Tt = En((nt = e.modelValue) != null ? nt : []).slice(), Gt = Ke(Tt, $e);
        Gt > -1 ? Tt.splice(Gt, 1) : (e.multipleLimit <= 0 || Tt.length < e.multipleLimit) && Tt.push($e.value), t(et, Tt), Ye(Tt), $e.created && Oe(""), e.filterable && !e.reserveKeyword && (r.inputValue = "");
      } else
        !ln(e.modelValue, $e.value) && t(et, $e.value), Ye($e.value), C.value = !1;
      Yt(), !C.value && Re(() => {
        St($e);
      });
    }, Ke = ($e, nt) => kt(nt) ? -1 : ot(nt.value) ? $e.findIndex((Tt) => ln(dn(Tt, e.valueKey), uo(nt))) : $e.indexOf(nt.value), St = ($e) => {
      var nt, Tt, Gt, an, Ln;
      const Rn = ye($e) ? $e[0] : $e;
      let ll = null;
      if (!cn(Rn == null ? void 0 : Rn.value)) {
        const Il = se.value.filter((Er) => Er.value === Rn.value);
        Il.length > 0 && (ll = Il[0].$el);
      }
      if (c.value && ll) {
        const Il = (an = (Gt = (Tt = (nt = c.value) == null ? void 0 : nt.popperRef) == null ? void 0 : Tt.contentRef) == null ? void 0 : Gt.querySelector) == null ? void 0 : an.call(Gt, `.${l.be("dropdown", "wrap")}`);
        Il && ch(Il, ll);
      }
      (Ln = b.value) == null || Ln.handleScroll();
    }, Ft = ($e) => {
      r.options.set($e.value, $e), r.cachedOptions.set($e.value, $e);
    }, Se = ($e, nt) => {
      r.options.get($e) === nt && r.options.delete($e);
    }, Je = S(() => {
      var $e, nt;
      return (nt = ($e = c.value) == null ? void 0 : $e.popperRef) == null ? void 0 : nt.contentRef;
    }), lt = () => {
      r.isBeforeHide = !1, Re(() => {
        var $e;
        ($e = b.value) == null || $e.update(), St(r.selected);
      });
    }, Yt = () => {
      var $e;
      ($e = f.value) == null || $e.focus();
    }, $n = () => {
      var $e;
      if (C.value) {
        C.value = !1, Re(() => {
          var nt;
          return (nt = f.value) == null ? void 0 : nt.blur();
        });
        return;
      }
      ($e = f.value) == null || $e.blur();
    }, xe = ($e) => {
      Qe($e);
    }, wt = ($e) => {
      if (C.value = !1, M.value) {
        const nt = new FocusEvent("blur", $e);
        Re(() => R(nt));
      }
    }, ht = () => {
      r.inputValue.length > 0 ? r.inputValue = "" : C.value = !1;
    }, sn = () => {
      Y.value || (Lc && (r.inputHovering = !0), r.menuVisibleOnFocus ? r.menuVisibleOnFocus = !1 : C.value = !C.value);
    }, Co = () => {
      if (!C.value)
        sn();
      else {
        const $e = se.value[r.hoveringIndex];
        $e && !$e.isDisabled && ve($e);
      }
    }, uo = ($e) => ot($e.value) ? dn($e.value, e.valueKey) : $e.value, ef = S(() => se.value.filter(($e) => $e.visible).every(($e) => $e.isDisabled)), Os = S(() => e.multiple ? e.collapseTags ? r.selected.slice(0, e.maxCollapseTags) : r.selected : []), yu = S(() => e.multiple ? e.collapseTags ? r.selected.slice(e.maxCollapseTags) : [] : []), Da = ($e) => {
      if (!C.value) {
        C.value = !0;
        return;
      }
      if (!(r.options.size === 0 || re.value === 0 || P.value) && !ef.value) {
        $e === "next" ? (r.hoveringIndex++, r.hoveringIndex === r.options.size && (r.hoveringIndex = 0)) : $e === "prev" && (r.hoveringIndex--, r.hoveringIndex < 0 && (r.hoveringIndex = r.options.size - 1));
        const nt = se.value[r.hoveringIndex];
        (nt.isDisabled || !nt.visible) && Da($e), Re(() => St(w.value));
      }
    }, wu = ($e, nt, Tt, Gt) => {
      for (let an = nt; an >= 0 && an < Gt; an += Tt) {
        const Ln = $e[an];
        if (!(Ln != null && Ln.isDisabled) && (Ln != null && Ln.visible))
          return an;
      }
      return null;
    }, Ol = ($e, nt) => {
      var Tt;
      const Gt = r.options.size;
      if (Gt === 0)
        return;
      const an = Od($e, 0, Gt - 1), Ln = se.value, Rn = nt === "up" ? -1 : 1, ll = (Tt = wu(Ln, an, Rn, Gt)) != null ? Tt : wu(Ln, an - Rn, -Rn, Gt);
      ll != null && (r.hoveringIndex = ll, Re(() => St(w.value)));
    }, tf = ($e) => {
      const nt = Ht($e);
      let Tt = !0;
      switch (nt) {
        case _e.up:
          Da("prev");
          break;
        case _e.down:
          Da("next");
          break;
        case _e.enter:
        case _e.numpadEnter:
          Co();
          break;
        case _e.esc:
          ht();
          break;
        case _e.backspace:
          Tt = !1, fe($e);
          return;
        case _e.home:
          if (!C.value)
            return;
          Ol(0, "down");
          break;
        case _e.end:
          if (!C.value)
            return;
          Ol(r.options.size - 1, "up");
          break;
        case _e.pageUp:
          if (!C.value)
            return;
          Ol(r.hoveringIndex - 10, "up");
          break;
        case _e.pageDown:
          if (!C.value)
            return;
          Ol(r.hoveringIndex + 10, "down");
          break;
        default:
          Tt = !1;
          break;
      }
      Tt && ($e.preventDefault(), $e.stopPropagation());
    }, nf = () => {
      if (!u.value)
        return 0;
      const $e = window.getComputedStyle(u.value);
      return Number.parseFloat($e.gap || "6px");
    }, of = S(() => {
      const $e = nf(), nt = e.filterable ? $e + Ud : 0;
      return { maxWidth: `${g.value && e.maxCollapseTags === 1 ? r.selectionWidth - r.collapseItemWidth - $e - nt : r.selectionWidth - nt}px` };
    }), lf = S(() => ({ maxWidth: `${r.selectionWidth}px` })), af = ($e) => {
      t("popup-scroll", $e);
    };
    qt(u, Me), qt(G, pe), qt(h, Le), qt(g, Be);
    let Aa;
    return de(() => ce.value, ($e) => {
      $e ? Aa = qt(m, pe).stop : (Aa == null || Aa(), Aa = void 0);
    }), ft(() => {
      we();
    }), {
      inputId: T,
      contentId: o,
      nsSelect: l,
      nsInput: a,
      states: r,
      isFocused: M,
      expanded: C,
      optionsArray: se,
      hoverOption: w,
      selectSize: j,
      filteredOptionsCount: re,
      updateTooltip: pe,
      updateTagTooltip: Le,
      debouncedOnInputChange: Nt,
      onInput: ut,
      deletePrevTag: fe,
      deleteTag: He,
      deleteSelected: Qe,
      handleOptionSelect: ve,
      scrollToOption: St,
      hasModelValue: D,
      shouldShowPlaceholder: ge,
      currentPlaceholder: be,
      mouseEnterEventName: Ee,
      needStatusIcon: L,
      showClearBtn: V,
      iconComponent: F,
      iconReverse: H,
      validateState: K,
      validateIcon: Z,
      showNewOption: le,
      updateOptions: Ce,
      collapseTagSize: te,
      setSelected: we,
      selectDisabled: Y,
      emptyText: ue,
      handleCompositionStart: O,
      handleCompositionUpdate: N,
      handleCompositionEnd: z,
      handleKeydown: tf,
      onOptionCreate: Ft,
      onOptionDestroy: Se,
      handleMenuEnter: lt,
      focus: Yt,
      blur: $n,
      handleClearClick: xe,
      handleClickOutside: wt,
      handleEsc: ht,
      toggleMenu: sn,
      selectOption: Co,
      getValueKey: uo,
      navigateOptions: Da,
      dropdownMenuVisible: ce,
      showTagList: Os,
      collapseTagList: yu,
      popupScroll: af,
      getOption: me,
      tagStyle: of,
      collapseTagStyle: lf,
      popperRef: Je,
      inputRef: f,
      tooltipRef: c,
      tagTooltipRef: d,
      prefixRef: v,
      suffixRef: p,
      selectRef: i,
      wrapperRef: G,
      selectionRef: u,
      scrollbarRef: b,
      menuRef: m,
      tagMenuRef: h,
      collapseItemRef: g
    };
  };
  var W5 = /* @__PURE__ */ U({
    name: "ElOptions",
    setup(e, { slots: t }) {
      const n = Ve(pu);
      let o = [];
      return () => {
        var l, a;
        const r = (l = t.default) == null ? void 0 : l.call(t), i = [];
        function u(c) {
          ye(c) && c.forEach((d) => {
            var f, v, p, m;
            const h = (f = (d == null ? void 0 : d.type) || {}) == null ? void 0 : f.name;
            h === "ElOptionGroup" ? u(!Ae(d.children) && !ye(d.children) && Fe((v = d.children) == null ? void 0 : v.default) ? (p = d.children) == null ? void 0 : p.default() : d.children) : h === "ElOption" ? i.push((m = d.props) == null ? void 0 : m.value) : ye(d.children) && u(d.children);
          });
        }
        return r.length && u((a = r[0]) == null ? void 0 : a.children), ln(i, o) || (o = i, n && (n.states.optionValues = i)), r;
      };
    }
  });
  const j5 = Te({
    name: String,
    id: String,
    modelValue: {
      type: X([
        Array,
        String,
        Number,
        Boolean,
        Object
      ]),
      default: void 0
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    automaticDropdown: Boolean,
    size: mn,
    effect: {
      type: X(String),
      default: "light"
    },
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: {
      type: String,
      default: ""
    },
    popperStyle: {
      type: X([String, Object])
    },
    popperOptions: {
      type: X(Object),
      default: () => ({})
    },
    remote: Boolean,
    debounce: {
      type: Number,
      default: 300
    },
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: {
      type: X(Function)
    },
    filterMethod: {
      type: X(Function)
    },
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String
    },
    defaultFirstOption: Boolean,
    reserveKeyword: {
      type: Boolean,
      default: !0
    },
    valueKey: {
      type: String,
      default: "value"
    },
    collapseTags: Boolean,
    collapseTagsTooltip: Boolean,
    maxCollapseTags: {
      type: Number,
      default: 1
    },
    teleported: zt.teleported,
    persistent: {
      type: Boolean,
      default: !0
    },
    clearIcon: {
      type: Lt,
      default: oa
    },
    fitInputWidth: Boolean,
    suffixIcon: {
      type: Lt,
      default: Nl
    },
    tagType: { ...Xl.type, default: "info" },
    tagEffect: { ...Xl.effect, default: "light" },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    remoteShowSuffix: Boolean,
    showArrow: {
      type: Boolean,
      default: !0
    },
    offset: {
      type: Number,
      default: 12
    },
    placement: {
      type: X(String),
      values: aa,
      default: "bottom-start"
    },
    fallbackPlacements: {
      type: X(Array),
      default: ["bottom-start", "top-start", "right", "left"]
    },
    tabindex: {
      type: [String, Number],
      default: 0
    },
    appendTo: zt.appendTo,
    options: {
      type: X(Array)
    },
    props: {
      type: X(Object),
      default: () => Gh
    },
    ...Cr,
    ...Yn(["ariaLabel"])
  });
  OC.scroll;
  const U5 = /* @__PURE__ */ U({
    name: "ElOptionGroup",
    componentName: "ElOptionGroup",
    props: {
      label: String,
      disabled: Boolean
    },
    setup(e) {
      const t = he("select"), n = A(), o = dt(), l = A([]);
      yt(jE, Rt({
        ...wn(e)
      }));
      const a = S(() => l.value.some((c) => c.visible === !0)), r = (c) => {
        var d;
        return c.type.name === "ElOption" && !!((d = c.component) != null && d.proxy);
      }, i = (c) => {
        const d = En(c), f = [];
        return d.forEach((v) => {
          var p;
          Wt(v) && (r(v) ? f.push(v.component.proxy) : ye(v.children) && v.children.length ? f.push(...i(v.children)) : (p = v.component) != null && p.subTree && f.push(...i(v.component.subTree)));
        }), f;
      }, u = () => {
        l.value = i(o.subTree);
      };
      return ft(() => {
        u();
      }), Q1(n, u, {
        attributes: !0,
        subtree: !0,
        childList: !0
      }), {
        groupRef: n,
        visible: a,
        ns: t
      };
    }
  });
  function Y5(e, t, n, o, l, a) {
    return it((_(), B("ul", {
      ref: "groupRef",
      class: $(e.ns.be("group", "wrap"))
    }, [
      W("li", {
        class: $(e.ns.be("group", "title"))
      }, ke(e.label), 3),
      W("li", null, [
        W("ul", {
          class: $(e.ns.b("group"))
        }, [
          ee(e.$slots, "default")
        ], 2)
      ])
    ], 2)), [
      [Mt, e.visible]
    ]);
  }
  var Zh = /* @__PURE__ */ Ne(U5, [["render", Y5], ["__file", "option-group.vue"]]);
  const _y = "ElSelect", Mi = /* @__PURE__ */ new WeakMap(), q5 = (e) => (...t) => {
    var n, o;
    const l = t[0];
    if (!l || l.includes('Slot "default" invoked outside of the render function') && ((n = t[2]) != null && n.includes("ElTreeSelect")))
      return;
    const a = (o = Mi.get(e)) == null ? void 0 : o.originalWarnHandler;
    if (a) {
      a(...t);
      return;
    }
    console.warn(...t);
  }, G5 = (e) => {
    let t = Mi.get(e);
    return t || (t = {
      originalWarnHandler: e.config.warnHandler,
      handler: q5(e),
      count: 0
    }, Mi.set(e, t)), t;
  }, X5 = /* @__PURE__ */ U({
    name: _y,
    componentName: _y,
    components: {
      ElSelectMenu: H5,
      ElOption: Jh,
      ElOptions: W5,
      ElOptionGroup: Zh,
      ElTag: Wl,
      ElScrollbar: Go,
      ElTooltip: Pn,
      ElIcon: ze
    },
    directives: { ClickOutside: Jl },
    props: j5,
    emits: [
      et,
      gt,
      "remove-tag",
      "clear",
      "visible-change",
      "focus",
      "blur",
      "popup-scroll"
    ],
    setup(e, { emit: t, slots: n }) {
      const o = dt(), l = G5(o.appContext);
      l.count += 1, o.appContext.config.warnHandler = l.handler;
      const a = S(() => {
        const { modelValue: C, multiple: w } = e, y = w ? [] : void 0;
        return ye(C) ? w ? C : y : w ? y : C;
      }), r = Rt({
        ...wn(e),
        modelValue: a
      }), i = K5(r, t), { calculatorRef: u, inputStyle: c } = Uh(), { getLabel: d, getValue: f, getOptions: v, getDisabled: p } = fu(e), m = (C) => ({
        label: d(C),
        value: f(C),
        disabled: p(C)
      }), h = (C) => C.reduce((w, y) => (w.push(y), y.children && y.children.length > 0 && w.push(...h(y.children)), w), []), g = (C) => {
        cl(C || []).forEach((y) => {
          var E;
          if (ot(y) && (y.type.name === "ElOption" || y.type.name === "ElTree")) {
            const k = y.type.name;
            if (k === "ElTree") {
              const T = ((E = y.props) == null ? void 0 : E.data) || [];
              h(T).forEach((I) => {
                I.currentLabel = I.label || (ot(I.value) ? "" : I.value), i.onOptionCreate(I);
              });
            } else if (k === "ElOption") {
              const T = { ...y.props };
              T.currentLabel = T.label || (ot(T.value) ? "" : T.value), i.onOptionCreate(T);
            }
          }
        });
      };
      de(() => {
        var C;
        return [(C = n.default) == null ? void 0 : C.call(n), a.value];
      }, () => {
        var C;
        e.persistent || i.expanded.value || (i.states.options.clear(), g((C = n.default) == null ? void 0 : C.call(n)));
      }, {
        immediate: !0
      }), yt(pu, Rt({
        props: r,
        states: i.states,
        selectRef: i.selectRef,
        optionsArray: i.optionsArray,
        setSelected: i.setSelected,
        handleOptionSelect: i.handleOptionSelect,
        onOptionCreate: i.onOptionCreate,
        onOptionDestroy: i.onOptionDestroy
      }));
      const b = S(() => e.multiple ? i.states.selected.map((C) => C.currentLabel) : i.states.selectedLabel);
      return Bt(() => {
        const C = Mi.get(o.appContext);
        C && (C.count -= 1, C.count <= 0 && (o.appContext.config.warnHandler = C.originalWarnHandler, Mi.delete(o.appContext)));
      }), {
        ...i,
        modelValue: a,
        selectedLabel: b,
        calculatorRef: u,
        inputStyle: c,
        getLabel: d,
        getValue: f,
        getOptions: v,
        getDisabled: p,
        getOptionProps: m
      };
    }
  });
  function J5(e, t) {
    const n = $t("el-tag"), o = $t("el-tooltip"), l = $t("el-icon"), a = $t("el-option"), r = $t("el-option-group"), i = $t("el-options"), u = $t("el-scrollbar"), c = $t("el-select-menu"), d = bd("click-outside");
    return it((_(), B("div", {
      ref: "selectRef",
      class: $([e.nsSelect.b(), e.nsSelect.m(e.selectSize)]),
      [Rl(e.mouseEnterEventName)]: (f) => e.states.inputHovering = !0,
      onMouseleave: (f) => e.states.inputHovering = !1
    }, [
      q(o, {
        ref: "tooltipRef",
        visible: e.dropdownMenuVisible,
        placement: e.placement,
        teleported: e.teleported,
        "popper-class": [e.nsSelect.e("popper"), e.popperClass],
        "popper-style": e.popperStyle,
        "popper-options": e.popperOptions,
        "fallback-placements": e.fallbackPlacements,
        effect: e.effect,
        pure: "",
        trigger: "click",
        transition: `${e.nsSelect.namespace.value}-zoom-in-top`,
        "stop-popper-mouse-event": !1,
        "gpu-acceleration": !1,
        persistent: e.persistent,
        "append-to": e.appendTo,
        "show-arrow": e.showArrow,
        offset: e.offset,
        onBeforeShow: e.handleMenuEnter,
        onHide: (f) => e.states.isBeforeHide = !1
      }, {
        default: Q(() => {
          var f;
          return [
            W("div", {
              ref: "wrapperRef",
              class: $([
                e.nsSelect.e("wrapper"),
                e.nsSelect.is("focused", e.isFocused),
                e.nsSelect.is("hovering", e.states.inputHovering),
                e.nsSelect.is("filterable", e.filterable),
                e.nsSelect.is("disabled", e.selectDisabled)
              ]),
              onClick: Ze(e.toggleMenu, ["prevent"])
            }, [
              e.$slots.prefix ? (_(), B("div", {
                key: 0,
                ref: "prefixRef",
                class: $(e.nsSelect.e("prefix"))
              }, [
                ee(e.$slots, "prefix")
              ], 2)) : oe("v-if", !0),
              W("div", {
                ref: "selectionRef",
                class: $([
                  e.nsSelect.e("selection"),
                  e.nsSelect.is("near", e.multiple && !e.$slots.prefix && !!e.states.selected.length)
                ])
              }, [
                e.multiple ? ee(e.$slots, "tag", {
                  key: 0,
                  data: e.states.selected,
                  deleteTag: e.deleteTag,
                  selectDisabled: e.selectDisabled
                }, () => [
                  (_(!0), B(We, null, bt(e.showTagList, (v) => (_(), B("div", {
                    key: e.getValueKey(v),
                    class: $(e.nsSelect.e("selected-item"))
                  }, [
                    q(n, {
                      closable: !e.selectDisabled && !v.isDisabled,
                      size: e.collapseTagSize,
                      type: e.tagType,
                      effect: e.tagEffect,
                      "disable-transitions": "",
                      style: Ue(e.tagStyle),
                      onClose: (p) => e.deleteTag(p, v)
                    }, {
                      default: Q(() => [
                        W("span", {
                          class: $(e.nsSelect.e("tags-text"))
                        }, [
                          ee(e.$slots, "label", {
                            index: v.index,
                            label: v.currentLabel,
                            value: v.value
                          }, () => [
                            Ct(ke(v.currentLabel), 1)
                          ])
                        ], 2)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "type", "effect", "style", "onClose"])
                  ], 2))), 128)),
                  e.collapseTags && e.states.selected.length > e.maxCollapseTags ? (_(), ae(o, {
                    key: 0,
                    ref: "tagTooltipRef",
                    disabled: e.dropdownMenuVisible || !e.collapseTagsTooltip,
                    "fallback-placements": ["bottom", "top", "right", "left"],
                    effect: e.effect,
                    placement: "bottom",
                    "popper-class": e.popperClass,
                    "popper-style": e.popperStyle,
                    teleported: e.teleported
                  }, {
                    default: Q(() => [
                      W("div", {
                        ref: "collapseItemRef",
                        class: $(e.nsSelect.e("selected-item"))
                      }, [
                        q(n, {
                          closable: !1,
                          size: e.collapseTagSize,
                          type: e.tagType,
                          effect: e.tagEffect,
                          "disable-transitions": "",
                          style: Ue(e.collapseTagStyle)
                        }, {
                          default: Q(() => [
                            W("span", {
                              class: $(e.nsSelect.e("tags-text"))
                            }, " + " + ke(e.states.selected.length - e.maxCollapseTags), 3)
                          ]),
                          _: 1
                        }, 8, ["size", "type", "effect", "style"])
                      ], 2)
                    ]),
                    content: Q(() => [
                      W("div", {
                        ref: "tagMenuRef",
                        class: $(e.nsSelect.e("selection"))
                      }, [
                        (_(!0), B(We, null, bt(e.collapseTagList, (v) => (_(), B("div", {
                          key: e.getValueKey(v),
                          class: $(e.nsSelect.e("selected-item"))
                        }, [
                          q(n, {
                            class: "in-tooltip",
                            closable: !e.selectDisabled && !v.isDisabled,
                            size: e.collapseTagSize,
                            type: e.tagType,
                            effect: e.tagEffect,
                            "disable-transitions": "",
                            onClose: (p) => e.deleteTag(p, v)
                          }, {
                            default: Q(() => [
                              W("span", {
                                class: $(e.nsSelect.e("tags-text"))
                              }, [
                                ee(e.$slots, "label", {
                                  index: v.index,
                                  label: v.currentLabel,
                                  value: v.value
                                }, () => [
                                  Ct(ke(v.currentLabel), 1)
                                ])
                              ], 2)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "type", "effect", "onClose"])
                        ], 2))), 128))
                      ], 2)
                    ]),
                    _: 3
                  }, 8, ["disabled", "effect", "popper-class", "popper-style", "teleported"])) : oe("v-if", !0)
                ]) : oe("v-if", !0),
                W("div", {
                  class: $([
                    e.nsSelect.e("selected-item"),
                    e.nsSelect.e("input-wrapper"),
                    e.nsSelect.is("hidden", !e.filterable || e.selectDisabled)
                  ])
                }, [
                  it(W("input", {
                    id: e.inputId,
                    ref: "inputRef",
                    "onUpdate:modelValue": (v) => e.states.inputValue = v,
                    type: "text",
                    name: e.name,
                    class: $([e.nsSelect.e("input"), e.nsSelect.is(e.selectSize)]),
                    disabled: e.selectDisabled,
                    autocomplete: e.autocomplete,
                    style: Ue(e.inputStyle),
                    tabindex: e.tabindex,
                    role: "combobox",
                    readonly: !e.filterable,
                    spellcheck: "false",
                    "aria-activedescendant": ((f = e.hoverOption) == null ? void 0 : f.id) || "",
                    "aria-controls": e.contentId,
                    "aria-expanded": e.dropdownMenuVisible,
                    "aria-label": e.ariaLabel,
                    "aria-autocomplete": "none",
                    "aria-haspopup": "listbox",
                    onKeydown: e.handleKeydown,
                    onCompositionstart: e.handleCompositionStart,
                    onCompositionupdate: e.handleCompositionUpdate,
                    onCompositionend: e.handleCompositionEnd,
                    onInput: e.onInput,
                    onClick: Ze(e.toggleMenu, ["stop"])
                  }, null, 46, ["id", "onUpdate:modelValue", "name", "disabled", "autocomplete", "tabindex", "readonly", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label", "onKeydown", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onInput", "onClick"]), [
                    [Sd, e.states.inputValue]
                  ]),
                  e.filterable ? (_(), B("span", {
                    key: 0,
                    ref: "calculatorRef",
                    "aria-hidden": "true",
                    class: $(e.nsSelect.e("input-calculator")),
                    textContent: ke(e.states.inputValue)
                  }, null, 10, ["textContent"])) : oe("v-if", !0)
                ], 2),
                e.shouldShowPlaceholder ? (_(), B("div", {
                  key: 1,
                  class: $([
                    e.nsSelect.e("selected-item"),
                    e.nsSelect.e("placeholder"),
                    e.nsSelect.is("transparent", !e.hasModelValue || e.expanded && !e.states.inputValue)
                  ])
                }, [
                  e.hasModelValue ? ee(e.$slots, "label", {
                    key: 0,
                    index: e.getOption(e.modelValue).index,
                    label: e.currentPlaceholder,
                    value: e.modelValue
                  }, () => [
                    W("span", null, ke(e.currentPlaceholder), 1)
                  ]) : (_(), B("span", { key: 1 }, ke(e.currentPlaceholder), 1))
                ], 2)) : oe("v-if", !0)
              ], 2),
              W("div", {
                ref: "suffixRef",
                class: $(e.nsSelect.e("suffix"))
              }, [
                e.iconComponent && !e.showClearBtn ? (_(), ae(l, {
                  key: 0,
                  class: $([e.nsSelect.e("caret"), e.nsSelect.e("icon"), e.iconReverse])
                }, {
                  default: Q(() => [
                    (_(), ae(ct(e.iconComponent)))
                  ]),
                  _: 1
                }, 8, ["class"])) : oe("v-if", !0),
                e.showClearBtn && e.clearIcon ? (_(), ae(l, {
                  key: 1,
                  class: $([
                    e.nsSelect.e("caret"),
                    e.nsSelect.e("icon"),
                    e.nsSelect.e("clear")
                  ]),
                  onClick: e.handleClearClick
                }, {
                  default: Q(() => [
                    (_(), ae(ct(e.clearIcon)))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : oe("v-if", !0),
                e.validateState && e.validateIcon && e.needStatusIcon ? (_(), ae(l, {
                  key: 2,
                  class: $([
                    e.nsInput.e("icon"),
                    e.nsInput.e("validateIcon"),
                    e.nsInput.is("loading", e.validateState === "validating")
                  ])
                }, {
                  default: Q(() => [
                    (_(), ae(ct(e.validateIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : oe("v-if", !0)
              ], 2)
            ], 10, ["onClick"])
          ];
        }),
        content: Q(() => [
          q(c, { ref: "menuRef" }, {
            default: Q(() => [
              e.$slots.header ? (_(), B("div", {
                key: 0,
                class: $(e.nsSelect.be("dropdown", "header")),
                onClick: Ze(() => {
                }, ["stop"])
              }, [
                ee(e.$slots, "header")
              ], 10, ["onClick"])) : oe("v-if", !0),
              it(q(u, {
                id: e.contentId,
                ref: "scrollbarRef",
                tag: "ul",
                "wrap-class": e.nsSelect.be("dropdown", "wrap"),
                "view-class": e.nsSelect.be("dropdown", "list"),
                class: $([e.nsSelect.is("empty", e.filteredOptionsCount === 0)]),
                role: "listbox",
                "aria-label": e.ariaLabel,
                "aria-orientation": "vertical",
                onScroll: e.popupScroll
              }, {
                default: Q(() => [
                  e.showNewOption ? (_(), ae(a, {
                    key: 0,
                    value: e.states.inputValue,
                    created: !0
                  }, null, 8, ["value"])) : oe("v-if", !0),
                  q(i, null, {
                    default: Q(() => [
                      ee(e.$slots, "default", {}, () => [
                        (_(!0), B(We, null, bt(e.options, (f, v) => {
                          var p;
                          return _(), B(We, { key: v }, [
                            (p = e.getOptions(f)) != null && p.length ? (_(), ae(r, {
                              key: 0,
                              label: e.getLabel(f),
                              disabled: e.getDisabled(f)
                            }, {
                              default: Q(() => [
                                (_(!0), B(We, null, bt(e.getOptions(f), (m) => (_(), ae(a, pt({
                                  key: e.getValue(m)
                                }, e.getOptionProps(m)), null, 16))), 128))
                              ]),
                              _: 2
                            }, 1032, ["label", "disabled"])) : (_(), ae(a, Bo(pt({ key: 1 }, e.getOptionProps(f))), null, 16))
                          ], 64);
                        }), 128))
                      ])
                    ]),
                    _: 3
                  })
                ]),
                _: 3
              }, 8, ["id", "wrap-class", "view-class", "class", "aria-label", "onScroll"]), [
                [Mt, e.states.options.size > 0 && !e.loading]
              ]),
              e.$slots.loading && e.loading ? (_(), B("div", {
                key: 1,
                class: $(e.nsSelect.be("dropdown", "loading"))
              }, [
                ee(e.$slots, "loading")
              ], 2)) : e.loading || e.filteredOptionsCount === 0 ? (_(), B("div", {
                key: 2,
                class: $(e.nsSelect.be("dropdown", "empty"))
              }, [
                ee(e.$slots, "empty", {}, () => [
                  W("span", null, ke(e.emptyText), 1)
                ])
              ], 2)) : oe("v-if", !0),
              e.$slots.footer ? (_(), B("div", {
                key: 3,
                class: $(e.nsSelect.be("dropdown", "footer")),
                onClick: Ze(() => {
                }, ["stop"])
              }, [
                ee(e.$slots, "footer")
              ], 10, ["onClick"])) : oe("v-if", !0)
            ]),
            _: 3
          }, 512)
        ]),
        _: 3
      }, 8, ["visible", "placement", "teleported", "popper-class", "popper-style", "popper-options", "fallback-placements", "effect", "transition", "persistent", "append-to", "show-arrow", "offset", "onBeforeShow", "onHide"])
    ], 16, ["onMouseleave"])), [
      [d, e.handleClickOutside, e.popperRef]
    ]);
  }
  var Z5 = /* @__PURE__ */ Ne(X5, [["render", J5], ["__file", "select.vue"]]);
  const fr = rt(Z5, {
    Option: Jh,
    OptionGroup: Zh
  }), qc = nn(Jh), Q5 = nn(Zh), Qh = () => Ve(WE, {}), eK = Te({
    pageSize: {
      type: Number,
      required: !0
    },
    pageSizes: {
      type: X(Array),
      default: () => en([10, 20, 30, 40, 50, 100])
    },
    popperClass: {
      type: String
    },
    popperStyle: {
      type: X([String, Object])
    },
    disabled: Boolean,
    teleported: Boolean,
    size: {
      type: String,
      values: Tl
    },
    appendSizeTo: String
  }), tK = /* @__PURE__ */ U({
    name: "ElPaginationSizes"
  }), nK = /* @__PURE__ */ U({
    ...tK,
    props: eK,
    emits: ["page-size-change"],
    setup(e, { emit: t }) {
      const n = e, { t: o } = _t(), l = he("pagination"), a = Qh(), r = A(n.pageSize);
      de(() => n.pageSizes, (c, d) => {
        if (!ln(c, d) && ye(c)) {
          const f = c.includes(n.pageSize) ? n.pageSize : n.pageSizes[0];
          t("page-size-change", f);
        }
      }), de(() => n.pageSize, (c) => {
        r.value = c;
      });
      const i = S(() => n.pageSizes);
      function u(c) {
        var d;
        c !== r.value && (r.value = c, (d = a.handleSizeChange) == null || d.call(a, Number(c)));
      }
      return (c, d) => (_(), B("span", {
        class: $(s(l).e("sizes"))
      }, [
        q(s(fr), {
          "model-value": r.value,
          disabled: c.disabled,
          "popper-class": c.popperClass,
          "popper-style": c.popperStyle,
          size: c.size,
          teleported: c.teleported,
          "validate-event": !1,
          "append-to": c.appendSizeTo,
          onChange: u
        }, {
          default: Q(() => [
            (_(!0), B(We, null, bt(s(i), (f) => (_(), ae(s(qc), {
              key: f,
              value: f,
              label: f + s(o)("el.pagination.pagesize")
            }, null, 8, ["value", "label"]))), 128))
          ]),
          _: 1
        }, 8, ["model-value", "disabled", "popper-class", "popper-style", "size", "teleported", "append-to"])
      ], 2));
    }
  });
  var oK = /* @__PURE__ */ Ne(nK, [["__file", "sizes.vue"]]);
  const lK = Te({
    size: {
      type: String,
      values: Tl
    }
  }), aK = /* @__PURE__ */ U({
    name: "ElPaginationJumper"
  }), rK = /* @__PURE__ */ U({
    ...aK,
    props: lK,
    setup(e) {
      const { t } = _t(), n = he("pagination"), { pageCount: o, disabled: l, currentPage: a, changeEvent: r } = Qh(), i = A(), u = S(() => {
        var f;
        return (f = i.value) != null ? f : a == null ? void 0 : a.value;
      });
      function c(f) {
        i.value = f ? +f : "";
      }
      function d(f) {
        f = Math.trunc(+f), r == null || r(f), i.value = void 0;
      }
      return (f, v) => (_(), B("span", {
        class: $(s(n).e("jump")),
        disabled: s(l)
      }, [
        W("span", {
          class: $([s(n).e("goto")])
        }, ke(s(t)("el.pagination.goto")), 3),
        q(s(Wn), {
          size: f.size,
          class: $([s(n).e("editor"), s(n).is("in-pagination")]),
          min: 1,
          max: s(o),
          disabled: s(l),
          "model-value": s(u),
          "validate-event": !1,
          "aria-label": s(t)("el.pagination.page"),
          type: "number",
          "onUpdate:modelValue": c,
          onChange: d
        }, null, 8, ["size", "class", "max", "disabled", "model-value", "aria-label"]),
        W("span", {
          class: $([s(n).e("classifier")])
        }, ke(s(t)("el.pagination.pageClassifier")), 3)
      ], 10, ["disabled"]));
    }
  });
  var sK = /* @__PURE__ */ Ne(rK, [["__file", "jumper.vue"]]);
  const iK = Te({
    total: {
      type: Number,
      default: 1e3
    }
  }), uK = /* @__PURE__ */ U({
    name: "ElPaginationTotal"
  }), cK = /* @__PURE__ */ U({
    ...uK,
    props: iK,
    setup(e) {
      const { t } = _t(), n = he("pagination"), { disabled: o } = Qh();
      return (l, a) => (_(), B("span", {
        class: $(s(n).e("total")),
        disabled: s(o)
      }, ke(s(t)("el.pagination.total", {
        total: l.total
      })), 11, ["disabled"]));
    }
  });
  var dK = /* @__PURE__ */ Ne(cK, [["__file", "total.vue"]]);
  const fK = Te({
    currentPage: {
      type: Number,
      default: 1
    },
    pageCount: {
      type: Number,
      required: !0
    },
    pagerCount: {
      type: Number,
      default: 7
    },
    disabled: Boolean
  }), pK = /* @__PURE__ */ U({
    name: "ElPaginationPager"
  }), vK = /* @__PURE__ */ U({
    ...pK,
    props: fK,
    emits: [gt],
    setup(e, { emit: t }) {
      const n = e, o = he("pager"), l = he("icon"), { t: a } = _t(), r = A(!1), i = A(!1), u = A(!1), c = A(!1), d = A(!1), f = A(!1), v = S(() => {
        const y = n.pagerCount, E = (y - 1) / 2, k = Number(n.currentPage), T = Number(n.pageCount);
        let x = !1, I = !1;
        T > y && (k > y - E && (x = !0), k < T - E && (I = !0));
        const P = [];
        if (x && !I) {
          const O = T - (y - 2);
          for (let N = O; N < T; N++)
            P.push(N);
        } else if (!x && I)
          for (let O = 2; O < y; O++)
            P.push(O);
        else if (x && I) {
          const O = Math.floor(y / 2) - 1;
          for (let N = k - O; N <= k + O; N++)
            P.push(N);
        } else
          for (let O = 2; O < T; O++)
            P.push(O);
        return P;
      }), p = S(() => [
        "more",
        "btn-quickprev",
        l.b(),
        o.is("disabled", n.disabled)
      ]), m = S(() => [
        "more",
        "btn-quicknext",
        l.b(),
        o.is("disabled", n.disabled)
      ]), h = S(() => n.disabled ? -1 : 0);
      de(() => [n.pageCount, n.pagerCount, n.currentPage], ([y, E, k]) => {
        const T = (E - 1) / 2;
        let x = !1, I = !1;
        y > E && (x = k > E - T, I = k < y - T), u.value && (u.value = x), c.value && (c.value = I), r.value = x, i.value = I;
      }, { immediate: !0 });
      function g(y = !1) {
        n.disabled || (y ? u.value = !0 : c.value = !0);
      }
      function b(y = !1) {
        y ? d.value = !0 : f.value = !0;
      }
      function C(y) {
        const E = y.target;
        if (E.tagName.toLowerCase() === "li" && Array.from(E.classList).includes("number")) {
          const k = Number(E.textContent);
          k !== n.currentPage && t(gt, k);
        } else E.tagName.toLowerCase() === "li" && Array.from(E.classList).includes("more") && w(y);
      }
      function w(y) {
        const E = y.target;
        if (E.tagName.toLowerCase() === "ul" || n.disabled)
          return;
        let k = Number(E.textContent);
        const T = n.pageCount, x = n.currentPage, I = n.pagerCount - 2;
        E.className.includes("more") && (E.className.includes("quickprev") ? k = x - I : E.className.includes("quicknext") && (k = x + I)), Number.isNaN(+k) || (k < 1 && (k = 1), k > T && (k = T)), k !== x && t(gt, k);
      }
      return (y, E) => (_(), B("ul", {
        class: $(s(o).b()),
        onClick: w,
        onKeyup: on(C, ["enter"])
      }, [
        y.pageCount > 0 ? (_(), B("li", {
          key: 0,
          class: $([[
            s(o).is("active", y.currentPage === 1),
            s(o).is("disabled", y.disabled)
          ], "number"]),
          "aria-current": y.currentPage === 1,
          "aria-label": s(a)("el.pagination.currentPage", { pager: 1 }),
          tabindex: s(h)
        }, " 1 ", 10, ["aria-current", "aria-label", "tabindex"])) : oe("v-if", !0),
        r.value ? (_(), B("li", {
          key: 1,
          class: $(s(p)),
          tabindex: s(h),
          "aria-label": s(a)("el.pagination.prevPages", { pager: y.pagerCount - 2 }),
          onMouseenter: (k) => g(!0),
          onMouseleave: (k) => u.value = !1,
          onFocus: (k) => b(!0),
          onBlur: (k) => d.value = !1
        }, [
          (u.value || d.value) && !y.disabled ? (_(), ae(s(Oa), { key: 0 })) : (_(), ae(s(Sb), { key: 1 }))
        ], 42, ["tabindex", "aria-label", "onMouseenter", "onMouseleave", "onFocus", "onBlur"])) : oe("v-if", !0),
        (_(!0), B(We, null, bt(s(v), (k) => (_(), B("li", {
          key: k,
          class: $([[
            s(o).is("active", y.currentPage === k),
            s(o).is("disabled", y.disabled)
          ], "number"]),
          "aria-current": y.currentPage === k,
          "aria-label": s(a)("el.pagination.currentPage", { pager: k }),
          tabindex: s(h)
        }, ke(k), 11, ["aria-current", "aria-label", "tabindex"]))), 128)),
        i.value ? (_(), B("li", {
          key: 2,
          class: $(s(m)),
          tabindex: s(h),
          "aria-label": s(a)("el.pagination.nextPages", { pager: y.pagerCount - 2 }),
          onMouseenter: (k) => g(),
          onMouseleave: (k) => c.value = !1,
          onFocus: (k) => b(),
          onBlur: (k) => f.value = !1
        }, [
          (c.value || f.value) && !y.disabled ? (_(), ae(s(Ia), { key: 0 })) : (_(), ae(s(Sb), { key: 1 }))
        ], 42, ["tabindex", "aria-label", "onMouseenter", "onMouseleave", "onFocus", "onBlur"])) : oe("v-if", !0),
        y.pageCount > 1 ? (_(), B("li", {
          key: 3,
          class: $([[
            s(o).is("active", y.currentPage === y.pageCount),
            s(o).is("disabled", y.disabled)
          ], "number"]),
          "aria-current": y.currentPage === y.pageCount,
          "aria-label": s(a)("el.pagination.currentPage", { pager: y.pageCount }),
          tabindex: s(h)
        }, ke(y.pageCount), 11, ["aria-current", "aria-label", "tabindex"])) : oe("v-if", !0)
      ], 42, ["onKeyup"]));
    }
  });
  var hK = /* @__PURE__ */ Ne(vK, [["__file", "pager.vue"]]);
  const qn = (e) => typeof e != "number", mK = Te({
    pageSize: Number,
    defaultPageSize: Number,
    total: Number,
    pageCount: Number,
    pagerCount: {
      type: Number,
      validator: (e) => je(e) && Math.trunc(e) === e && e > 4 && e < 22 && e % 2 === 1,
      default: 7
    },
    currentPage: Number,
    defaultCurrentPage: Number,
    layout: {
      type: String,
      default: ["prev", "pager", "next", "jumper", "->", "total"].join(", ")
    },
    pageSizes: {
      type: X(Array),
      default: () => en([10, 20, 30, 40, 50, 100])
    },
    popperClass: {
      type: String,
      default: ""
    },
    popperStyle: {
      type: X([String, Object])
    },
    prevText: {
      type: String,
      default: ""
    },
    prevIcon: {
      type: Lt,
      default: () => ql
    },
    nextText: {
      type: String,
      default: ""
    },
    nextIcon: {
      type: Lt,
      default: () => Un
    },
    teleported: {
      type: Boolean,
      default: !0
    },
    small: Boolean,
    size: mn,
    background: Boolean,
    disabled: Boolean,
    hideOnSinglePage: Boolean,
    appendSizeTo: String
  }), gK = {
    "update:current-page": (e) => je(e),
    "update:page-size": (e) => je(e),
    "size-change": (e) => je(e),
    change: (e, t) => je(e) && je(t),
    "current-change": (e) => je(e),
    "prev-click": (e) => je(e),
    "next-click": (e) => je(e)
  }, Ty = "ElPagination";
  var bK = /* @__PURE__ */ U({
    name: Ty,
    props: mK,
    emits: gK,
    setup(e, { emit: t, slots: n }) {
      const { t: o } = _t(), l = he("pagination"), a = dt().vnode.props || {}, r = sC(), i = S(() => {
        var E;
        return e.small ? "small" : (E = e.size) != null ? E : r.value;
      });
      hl({
        from: "small",
        replacement: "size",
        version: "3.0.0",
        scope: "el-pagination",
        ref: "https://element-plus.org/zh-CN/component/pagination.html"
      }, S(() => !!e.small));
      const u = "onUpdate:currentPage" in a || "onUpdate:current-page" in a || "onCurrentChange" in a, c = "onUpdate:pageSize" in a || "onUpdate:page-size" in a || "onSizeChange" in a, d = S(() => {
        if (qn(e.total) && qn(e.pageCount) || !qn(e.currentPage) && !u)
          return !1;
        if (e.layout.includes("sizes")) {
          if (qn(e.pageCount)) {
            if (!qn(e.total) && !qn(e.pageSize) && !c)
              return !1;
          } else if (!c)
            return !1;
        }
        return !0;
      }), f = A(qn(e.defaultPageSize) ? 10 : e.defaultPageSize), v = A(qn(e.defaultCurrentPage) ? 1 : e.defaultCurrentPage), p = S({
        get() {
          return qn(e.pageSize) ? f.value : e.pageSize;
        },
        set(E) {
          qn(e.pageSize) && (f.value = E), c && (t("update:page-size", E), t("size-change", E));
        }
      }), m = S(() => {
        let E = 0;
        return qn(e.pageCount) ? qn(e.total) || (E = Math.max(1, Math.ceil(e.total / p.value))) : E = e.pageCount, E;
      }), h = S({
        get() {
          return qn(e.currentPage) ? v.value : e.currentPage;
        },
        set(E) {
          let k = E;
          E < 1 ? k = 1 : E > m.value && (k = m.value), qn(e.currentPage) && (v.value = k), u && (t("update:current-page", k), t("current-change", k));
        }
      });
      de(m, (E) => {
        h.value > E && (h.value = E);
      }), de([h, p], (E) => {
        t(gt, ...E);
      }, { flush: "post" });
      function g(E) {
        h.value = E;
      }
      function b(E) {
        p.value = E;
        const k = m.value;
        h.value > k && (h.value = k);
      }
      function C() {
        e.disabled || (h.value -= 1, t("prev-click", h.value));
      }
      function w() {
        e.disabled || (h.value += 1, t("next-click", h.value));
      }
      function y(E, k) {
        E && (E.props || (E.props = {}), E.props.class = [E.props.class, k].join(" "));
      }
      return yt(WE, {
        pageCount: m,
        disabled: S(() => e.disabled),
        currentPage: h,
        changeEvent: g,
        handleSizeChange: b
      }), () => {
        var E, k;
        if (!d.value)
          return vt(Ty, o("el.pagination.deprecationWarning")), null;
        if (!e.layout || e.hideOnSinglePage && m.value <= 1)
          return null;
        const T = [], x = [], I = qe("div", { class: l.e("rightwrapper") }, x), P = {
          prev: qe(M5, {
            disabled: e.disabled,
            currentPage: h.value,
            prevText: e.prevText,
            prevIcon: e.prevIcon,
            onClick: C
          }),
          jumper: qe(sK, {
            size: i.value
          }),
          pager: qe(hK, {
            currentPage: h.value,
            pageCount: m.value,
            pagerCount: e.pagerCount,
            onChange: g,
            disabled: e.disabled
          }),
          next: qe(D5, {
            disabled: e.disabled,
            currentPage: h.value,
            pageCount: m.value,
            nextText: e.nextText,
            nextIcon: e.nextIcon,
            onClick: w
          }),
          sizes: qe(oK, {
            pageSize: p.value,
            pageSizes: e.pageSizes,
            popperClass: e.popperClass,
            popperStyle: e.popperStyle,
            disabled: e.disabled,
            teleported: e.teleported,
            size: i.value,
            appendSizeTo: e.appendSizeTo
          }),
          slot: (k = (E = n == null ? void 0 : n.default) == null ? void 0 : E.call(n)) != null ? k : null,
          total: qe(dK, { total: qn(e.total) ? 0 : e.total })
        }, O = e.layout.split(",").map((z) => z.trim());
        let N = !1;
        return O.forEach((z) => {
          if (z === "->") {
            N = !0;
            return;
          }
          N ? x.push(P[z]) : T.push(P[z]);
        }), y(T[0], l.is("first")), y(T[T.length - 1], l.is("last")), N && x.length > 0 && (y(x[0], l.is("first")), y(x[x.length - 1], l.is("last")), T.push(I)), qe("div", {
          class: [
            l.b(),
            l.is("background", e.background),
            l.m(i.value)
          ]
        }, T);
      };
    }
  });
  const yK = rt(bK), wK = Te({
    title: String,
    confirmButtonText: String,
    cancelButtonText: String,
    confirmButtonType: {
      type: String,
      values: Ep,
      default: "primary"
    },
    cancelButtonType: {
      type: String,
      values: Ep,
      default: "text"
    },
    icon: {
      type: Lt,
      default: () => gD
    },
    iconColor: {
      type: String,
      default: "#f90"
    },
    hideIcon: Boolean,
    hideAfter: {
      type: Number,
      default: 200
    },
    effect: {
      ...zt.effect,
      default: "light"
    },
    teleported: zt.teleported,
    persistent: zt.persistent,
    width: {
      type: [String, Number],
      default: 150
    },
    virtualTriggering: vl.virtualTriggering,
    virtualRef: vl.virtualRef
  }), CK = {
    confirm: (e) => e instanceof MouseEvent,
    cancel: (e) => e instanceof MouseEvent
  }, SK = /* @__PURE__ */ U({
    name: "ElPopconfirm"
  }), EK = /* @__PURE__ */ U({
    ...SK,
    props: wK,
    emits: CK,
    setup(e, { expose: t, emit: n }) {
      const o = e, { t: l } = _t(), a = he("popconfirm"), r = A(), i = A(), u = S(() => {
        var g;
        return (g = s(r)) == null ? void 0 : g.popperRef;
      }), c = () => {
        var g, b;
        (b = (g = i.value) == null ? void 0 : g.focus) == null || b.call(g);
      }, d = () => {
        var g, b;
        (b = (g = r.value) == null ? void 0 : g.onClose) == null || b.call(g);
      }, f = S(() => ({
        width: tn(o.width)
      })), v = (g) => {
        n("confirm", g), d();
      }, p = (g) => {
        n("cancel", g), d();
      }, m = S(() => o.confirmButtonText || l("el.popconfirm.confirmButtonText")), h = S(() => o.cancelButtonText || l("el.popconfirm.cancelButtonText"));
      return t({
        popperRef: u,
        hide: d
      }), (g, b) => (_(), ae(s(Pn), pt({
        ref_key: "tooltipRef",
        ref: r,
        trigger: "click",
        effect: g.effect
      }, g.$attrs, {
        "popper-class": `${s(a).namespace.value}-popover`,
        "popper-style": s(f),
        teleported: g.teleported,
        "fallback-placements": ["bottom", "top", "right", "left"],
        "hide-after": g.hideAfter,
        persistent: g.persistent,
        loop: "",
        onShow: c
      }), {
        content: Q(() => [
          W("div", {
            ref_key: "rootRef",
            ref: i,
            tabindex: "-1",
            class: $(s(a).b())
          }, [
            W("div", {
              class: $(s(a).e("main"))
            }, [
              !g.hideIcon && g.icon ? (_(), ae(s(ze), {
                key: 0,
                class: $(s(a).e("icon")),
                style: Ue({ color: g.iconColor })
              }, {
                default: Q(() => [
                  (_(), ae(ct(g.icon)))
                ]),
                _: 1
              }, 8, ["class", "style"])) : oe("v-if", !0),
              Ct(" " + ke(g.title), 1)
            ], 2),
            W("div", {
              class: $(s(a).e("action"))
            }, [
              ee(g.$slots, "actions", {
                confirm: v,
                cancel: p
              }, () => [
                q(s(_n), {
                  size: "small",
                  type: g.cancelButtonType === "text" ? "" : g.cancelButtonType,
                  text: g.cancelButtonType === "text",
                  onClick: p
                }, {
                  default: Q(() => [
                    Ct(ke(s(h)), 1)
                  ]),
                  _: 1
                }, 8, ["type", "text"]),
                q(s(_n), {
                  size: "small",
                  type: g.confirmButtonType === "text" ? "" : g.confirmButtonType,
                  text: g.confirmButtonType === "text",
                  onClick: v
                }, {
                  default: Q(() => [
                    Ct(ke(s(m)), 1)
                  ]),
                  _: 1
                }, 8, ["type", "text"])
              ])
            ], 2)
          ], 2)
        ]),
        default: Q(() => [
          g.$slots.reference ? ee(g.$slots, "reference", { key: 0 }) : oe("v-if", !0)
        ]),
        _: 3
      }, 16, ["effect", "popper-class", "popper-style", "teleported", "hide-after", "persistent"]));
    }
  });
  var kK = /* @__PURE__ */ Ne(EK, [["__file", "popconfirm.vue"]]);
  const _K = rt(kK), TK = Te({
    trigger: vl.trigger,
    triggerKeys: vl.triggerKeys,
    placement: oc.placement,
    disabled: vl.disabled,
    visible: zt.visible,
    transition: zt.transition,
    popperOptions: oc.popperOptions,
    tabindex: oc.tabindex,
    content: zt.content,
    popperStyle: zt.popperStyle,
    popperClass: zt.popperClass,
    enterable: {
      ...zt.enterable,
      default: !0
    },
    effect: {
      ...zt.effect,
      default: "light"
    },
    teleported: zt.teleported,
    appendTo: zt.appendTo,
    title: String,
    width: {
      type: [String, Number],
      default: 150
    },
    offset: {
      type: Number,
      default: void 0
    },
    showAfter: {
      type: Number,
      default: 0
    },
    hideAfter: {
      type: Number,
      default: 200
    },
    autoClose: {
      type: Number,
      default: 0
    },
    showArrow: {
      type: Boolean,
      default: !0
    },
    persistent: {
      type: Boolean,
      default: !0
    },
    "onUpdate:visible": {
      type: Function
    }
  }), NK = {
    "update:visible": (e) => Vt(e),
    "before-enter": () => !0,
    "before-leave": () => !0,
    "after-enter": () => !0,
    "after-leave": () => !0
  }, $K = "onUpdate:visible", OK = /* @__PURE__ */ U({
    name: "ElPopover"
  }), IK = /* @__PURE__ */ U({
    ...OK,
    props: TK,
    emits: NK,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = S(() => o[$K]), a = he("popover"), r = A(), i = S(() => {
        var g;
        return (g = s(r)) == null ? void 0 : g.popperRef;
      }), u = S(() => [
        {
          width: tn(o.width)
        },
        o.popperStyle
      ]), c = S(() => [a.b(), o.popperClass, { [a.m("plain")]: !!o.content }]), d = S(() => o.transition === `${a.namespace.value}-fade-in-linear`), f = () => {
        var g;
        (g = r.value) == null || g.hide();
      }, v = () => {
        n("before-enter");
      }, p = () => {
        n("before-leave");
      }, m = () => {
        n("after-enter");
      }, h = () => {
        n("update:visible", !1), n("after-leave");
      };
      return t({
        popperRef: i,
        hide: f
      }), (g, b) => (_(), ae(s(Pn), pt({
        ref_key: "tooltipRef",
        ref: r
      }, g.$attrs, {
        trigger: g.trigger,
        "trigger-keys": g.triggerKeys,
        placement: g.placement,
        disabled: g.disabled,
        visible: g.visible,
        transition: g.transition,
        "popper-options": g.popperOptions,
        tabindex: g.tabindex,
        content: g.content,
        offset: g.offset,
        "show-after": g.showAfter,
        "hide-after": g.hideAfter,
        "auto-close": g.autoClose,
        "show-arrow": g.showArrow,
        "aria-label": g.title,
        effect: g.effect,
        enterable: g.enterable,
        "popper-class": s(c),
        "popper-style": s(u),
        teleported: g.teleported,
        "append-to": g.appendTo,
        persistent: g.persistent,
        "gpu-acceleration": s(d),
        "onUpdate:visible": s(l),
        onBeforeShow: v,
        onBeforeHide: p,
        onShow: m,
        onHide: h
      }), {
        content: Q(() => [
          g.title ? (_(), B("div", {
            key: 0,
            class: $(s(a).e("title")),
            role: "title"
          }, ke(g.title), 3)) : oe("v-if", !0),
          ee(g.$slots, "default", {}, () => [
            Ct(ke(g.content), 1)
          ])
        ]),
        default: Q(() => [
          g.$slots.reference ? ee(g.$slots, "reference", { key: 0 }) : oe("v-if", !0)
        ]),
        _: 3
      }, 16, ["trigger", "trigger-keys", "placement", "disabled", "visible", "transition", "popper-options", "tabindex", "content", "offset", "show-after", "hide-after", "auto-close", "show-arrow", "aria-label", "effect", "enterable", "popper-class", "popper-style", "teleported", "append-to", "persistent", "gpu-acceleration", "onUpdate:visible"]));
    }
  });
  var MK = /* @__PURE__ */ Ne(IK, [["__file", "popover.vue"]]);
  const Ny = (e, t) => {
    const n = t.arg || t.value, o = n == null ? void 0 : n.popperRef;
    o && (o.triggerRef = e);
  };
  var xK = {
    mounted(e, t) {
      Ny(e, t);
    },
    updated(e, t) {
      Ny(e, t);
    }
  };
  const PK = "popover", UE = _R(xK, PK), RK = rt(MK, {
    directive: UE
  }), DK = Te({
    type: {
      type: String,
      default: "line",
      values: ["line", "circle", "dashboard"]
    },
    percentage: {
      type: Number,
      default: 0,
      validator: (e) => e >= 0 && e <= 100
    },
    status: {
      type: String,
      default: "",
      values: ["", "success", "exception", "warning"]
    },
    indeterminate: Boolean,
    duration: {
      type: Number,
      default: 3
    },
    strokeWidth: {
      type: Number,
      default: 6
    },
    strokeLinecap: {
      type: X(String),
      default: "round"
    },
    textInside: Boolean,
    width: {
      type: Number,
      default: 126
    },
    showText: {
      type: Boolean,
      default: !0
    },
    color: {
      type: X([
        String,
        Array,
        Function
      ]),
      default: ""
    },
    striped: Boolean,
    stripedFlow: Boolean,
    format: {
      type: X(Function),
      default: (e) => `${e}%`
    }
  }), AK = /* @__PURE__ */ U({
    name: "ElProgress"
  }), VK = /* @__PURE__ */ U({
    ...AK,
    props: DK,
    setup(e) {
      const t = e, n = {
        success: "#13ce66",
        exception: "#ff4949",
        warning: "#e6a23c",
        default: "#20a0ff"
      }, o = he("progress"), l = S(() => {
        const w = {
          width: `${t.percentage}%`,
          animationDuration: `${t.duration}s`
        }, y = C(t.percentage);
        return y.includes("gradient") ? w.background = y : w.backgroundColor = y, w;
      }), a = S(() => (t.strokeWidth / t.width * 100).toFixed(1)), r = S(() => ["circle", "dashboard"].includes(t.type) ? Number.parseInt(`${50 - Number.parseFloat(a.value) / 2}`, 10) : 0), i = S(() => {
        const w = r.value, y = t.type === "dashboard";
        return `
          M 50 50
          m 0 ${y ? "" : "-"}${w}
          a ${w} ${w} 0 1 1 0 ${y ? "-" : ""}${w * 2}
          a ${w} ${w} 0 1 1 0 ${y ? "" : "-"}${w * 2}
          `;
      }), u = S(() => 2 * Math.PI * r.value), c = S(() => t.type === "dashboard" ? 0.75 : 1), d = S(() => `${-1 * u.value * (1 - c.value) / 2}px`), f = S(() => ({
        strokeDasharray: `${u.value * c.value}px, ${u.value}px`,
        strokeDashoffset: d.value
      })), v = S(() => ({
        strokeDasharray: `${u.value * c.value * (t.percentage / 100)}px, ${u.value}px`,
        strokeDashoffset: d.value,
        transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease, opacity ease 0.6s"
      })), p = S(() => {
        let w;
        return t.color ? w = C(t.percentage) : w = n[t.status] || n.default, w;
      }), m = S(() => t.status === "warning" ? Rd : t.type === "line" ? t.status === "success" ? dh : oa : t.status === "success" ? ou : Oo), h = S(() => t.type === "line" ? 12 + t.strokeWidth * 0.4 : t.width * 0.111111 + 2), g = S(() => t.format(t.percentage));
      function b(w) {
        const y = 100 / w.length;
        return w.map((k, T) => Ae(k) ? {
          color: k,
          percentage: (T + 1) * y
        } : k).sort((k, T) => k.percentage - T.percentage);
      }
      const C = (w) => {
        var y;
        const { color: E } = t;
        if (Fe(E))
          return E(w);
        if (Ae(E))
          return E;
        {
          const k = b(E);
          for (const T of k)
            if (T.percentage > w)
              return T.color;
          return (y = k[k.length - 1]) == null ? void 0 : y.color;
        }
      };
      return (w, y) => (_(), B("div", {
        class: $([
          s(o).b(),
          s(o).m(w.type),
          s(o).is(w.status),
          {
            [s(o).m("without-text")]: !w.showText,
            [s(o).m("text-inside")]: w.textInside
          }
        ]),
        role: "progressbar",
        "aria-valuenow": w.percentage,
        "aria-valuemin": "0",
        "aria-valuemax": "100"
      }, [
        w.type === "line" ? (_(), B("div", {
          key: 0,
          class: $(s(o).b("bar"))
        }, [
          W("div", {
            class: $(s(o).be("bar", "outer")),
            style: Ue({ height: `${w.strokeWidth}px` })
          }, [
            W("div", {
              class: $([
                s(o).be("bar", "inner"),
                { [s(o).bem("bar", "inner", "indeterminate")]: w.indeterminate },
                { [s(o).bem("bar", "inner", "striped")]: w.striped },
                { [s(o).bem("bar", "inner", "striped-flow")]: w.stripedFlow }
              ]),
              style: Ue(s(l))
            }, [
              (w.showText || w.$slots.default) && w.textInside ? (_(), B("div", {
                key: 0,
                class: $(s(o).be("bar", "innerText"))
              }, [
                ee(w.$slots, "default", { percentage: w.percentage }, () => [
                  W("span", null, ke(s(g)), 1)
                ])
              ], 2)) : oe("v-if", !0)
            ], 6)
          ], 6)
        ], 2)) : (_(), B("div", {
          key: 1,
          class: $(s(o).b("circle")),
          style: Ue({ height: `${w.width}px`, width: `${w.width}px` })
        }, [
          (_(), B("svg", { viewBox: "0 0 100 100" }, [
            W("path", {
              class: $(s(o).be("circle", "track")),
              d: s(i),
              stroke: `var(${s(o).cssVarName("fill-color-light")}, #e5e9f2)`,
              "stroke-linecap": w.strokeLinecap,
              "stroke-width": s(a),
              fill: "none",
              style: Ue(s(f))
            }, null, 14, ["d", "stroke", "stroke-linecap", "stroke-width"]),
            W("path", {
              class: $(s(o).be("circle", "path")),
              d: s(i),
              stroke: s(p),
              fill: "none",
              opacity: w.percentage ? 1 : 0,
              "stroke-linecap": w.strokeLinecap,
              "stroke-width": s(a),
              style: Ue(s(v))
            }, null, 14, ["d", "stroke", "opacity", "stroke-linecap", "stroke-width"])
          ]))
        ], 6)),
        (w.showText || w.$slots.default) && !w.textInside ? (_(), B("div", {
          key: 2,
          class: $(s(o).e("text")),
          style: Ue({ fontSize: `${s(h)}px` })
        }, [
          ee(w.$slots, "default", { percentage: w.percentage }, () => [
            w.status ? (_(), ae(s(ze), { key: 1 }, {
              default: Q(() => [
                (_(), ae(ct(s(m))))
              ]),
              _: 1
            })) : (_(), B("span", { key: 0 }, ke(s(g)), 1))
          ])
        ], 6)) : oe("v-if", !0)
      ], 10, ["aria-valuenow"]));
    }
  });
  var LK = /* @__PURE__ */ Ne(VK, [["__file", "progress.vue"]]);
  const YE = rt(LK), BK = Te({
    modelValue: {
      type: Number,
      default: 0
    },
    id: {
      type: String,
      default: void 0
    },
    lowThreshold: {
      type: Number,
      default: 2
    },
    highThreshold: {
      type: Number,
      default: 4
    },
    max: {
      type: Number,
      default: 5
    },
    colors: {
      type: X([Array, Object]),
      default: () => en(["", "", ""])
    },
    voidColor: {
      type: String,
      default: ""
    },
    disabledVoidColor: {
      type: String,
      default: ""
    },
    icons: {
      type: X([Array, Object]),
      default: () => [Ou, Ou, Ou]
    },
    voidIcon: {
      type: Lt,
      default: () => xD
    },
    disabledVoidIcon: {
      type: Lt,
      default: () => Ou
    },
    disabled: Boolean,
    allowHalf: Boolean,
    showText: Boolean,
    showScore: Boolean,
    textColor: {
      type: String,
      default: ""
    },
    texts: {
      type: X(Array),
      default: () => en([
        "Extremely bad",
        "Disappointed",
        "Fair",
        "Satisfied",
        "Surprise"
      ])
    },
    scoreTemplate: {
      type: String,
      default: "{value}"
    },
    size: mn,
    clearable: Boolean,
    ...Yn(["ariaLabel"])
  }), FK = {
    [gt]: (e) => je(e),
    [et]: (e) => je(e)
  }, zK = /* @__PURE__ */ U({
    name: "ElRate"
  }), HK = /* @__PURE__ */ U({
    ...zK,
    props: BK,
    emits: FK,
    setup(e, { expose: t, emit: n }) {
      const o = e;
      function l(D, L) {
        const V = (K) => ot(K), F = Object.keys(L).map((K) => +K).filter((K) => {
          const Z = L[K];
          return (V(Z) ? Z.excluded : !1) ? D < K : D <= K;
        }).sort((K, Z) => K - Z), H = L[F[0]];
        return V(H) && H.value || H;
      }
      const a = Ve(Sr, void 0), r = Ve(Sl, void 0), i = vn(), u = he("rate"), { inputId: c, isLabeledByFormItem: d } = wo(o, {
        formItemContext: r
      }), f = A(o.modelValue), v = A(-1), p = A(!0), m = A([]), h = S(() => m.value.map((D) => D.$el.clientWidth)), g = S(() => [u.b(), u.m(i.value)]), b = S(() => o.disabled || (a == null ? void 0 : a.disabled)), C = S(() => u.cssVarBlock({
        "void-color": o.voidColor,
        "disabled-void-color": o.disabledVoidColor,
        "fill-color": k.value
      })), w = S(() => {
        let D = "";
        return o.showScore ? D = o.scoreTemplate.replace(/\{\s*value\s*\}/, b.value ? `${o.modelValue}` : `${f.value}`) : o.showText && (D = o.texts[Math.ceil(f.value) - 1]), D;
      }), y = S(() => o.modelValue * 100 - Math.floor(o.modelValue) * 100), E = S(() => ye(o.colors) ? {
        [o.lowThreshold]: o.colors[0],
        [o.highThreshold]: { value: o.colors[1], excluded: !0 },
        [o.max]: o.colors[2]
      } : o.colors), k = S(() => {
        const D = l(f.value, E.value);
        return ot(D) ? "" : D;
      }), T = S(() => {
        let D = "";
        return b.value ? D = `${y.value}%` : o.allowHalf && (D = "50%"), {
          color: k.value,
          width: D
        };
      }), x = S(() => {
        let D = ye(o.icons) ? [...o.icons] : { ...o.icons };
        return D = zl(D), ye(D) ? {
          [o.lowThreshold]: D[0],
          [o.highThreshold]: {
            value: D[1],
            excluded: !0
          },
          [o.max]: D[2]
        } : D;
      }), I = S(() => l(o.modelValue, x.value)), P = S(() => b.value ? Ae(o.disabledVoidIcon) ? o.disabledVoidIcon : zl(o.disabledVoidIcon) : Ae(o.voidIcon) ? o.voidIcon : zl(o.voidIcon)), O = S(() => l(f.value, x.value));
      function N(D) {
        const L = b.value && y.value > 0 && D - 1 < o.modelValue && D > o.modelValue, V = o.allowHalf && p.value && D - 0.5 <= f.value && D > f.value;
        return L || V;
      }
      function z(D) {
        o.clearable && D === o.modelValue && (D = 0), n(et, D), o.modelValue !== D && n(gt, D);
      }
      function Y(D) {
        b.value || (o.allowHalf && p.value ? z(f.value) : z(D));
      }
      function G(D) {
        if (b.value)
          return;
        const L = Ht(D), V = o.allowHalf ? 0.5 : 1;
        let F = f.value;
        switch (L) {
          case _e.up:
          case _e.right:
            F += V;
            break;
          case _e.left:
          case _e.down:
            F -= V;
            break;
        }
        if (F = Od(F, 0, o.max), F !== f.value)
          return D.stopPropagation(), D.preventDefault(), n(et, F), n(gt, F), F;
      }
      function M(D, L) {
        b.value || (o.allowHalf && L ? (p.value = L.offsetX * 2 <= h.value[D - 1], f.value = p.value ? D - 0.5 : D) : f.value = D, v.value = D);
      }
      function R() {
        b.value || (o.allowHalf && (p.value = o.modelValue !== Math.floor(o.modelValue)), f.value = o.modelValue, v.value = -1);
      }
      return de(() => o.modelValue, (D) => {
        f.value = D, p.value = o.modelValue !== Math.floor(o.modelValue);
      }), o.modelValue || n(et, 0), t({
        setCurrentValue: M,
        resetCurrentValue: R
      }), (D, L) => {
        var V;
        return _(), B("div", {
          id: s(c),
          class: $([s(g), s(u).is("disabled", s(b))]),
          role: "slider",
          "aria-label": s(d) ? void 0 : D.ariaLabel || "rating",
          "aria-labelledby": s(d) ? (V = s(r)) == null ? void 0 : V.labelId : void 0,
          "aria-valuenow": f.value,
          "aria-valuetext": s(w) || void 0,
          "aria-valuemin": "0",
          "aria-valuemax": D.max,
          tabindex: "0",
          style: Ue(s(C)),
          onKeydown: G
        }, [
          (_(!0), B(We, null, bt(D.max, (F, H) => (_(), B("span", {
            key: H,
            class: $(s(u).e("item")),
            onMousemove: (K) => M(F, K),
            onMouseleave: R,
            onClick: (K) => Y(F)
          }, [
            q(s(ze), {
              ref_for: !0,
              ref_key: "iconRefs",
              ref: m,
              class: $([
                s(u).e("icon"),
                { hover: v.value === F },
                s(u).is("active", F <= f.value),
                s(u).is("focus-visible", F === Math.ceil(f.value || 1))
              ])
            }, {
              default: Q(() => [
                it((_(), ae(ct(s(O)), null, null, 512)), [
                  [Mt, !N(F) && F <= f.value]
                ]),
                it((_(), ae(ct(s(P)), null, null, 512)), [
                  [Mt, !N(F) && F > f.value]
                ]),
                it((_(), ae(ct(s(P)), {
                  class: $([s(u).em("decimal", "box")])
                }, null, 8, ["class"])), [
                  [Mt, N(F)]
                ]),
                it(q(s(ze), {
                  style: Ue(s(T)),
                  class: $([s(u).e("icon"), s(u).e("decimal")])
                }, {
                  default: Q(() => [
                    (_(), ae(ct(s(I))))
                  ]),
                  _: 2
                }, 1032, ["style", "class"]), [
                  [Mt, N(F)]
                ])
              ]),
              _: 2
            }, 1032, ["class"])
          ], 42, ["onMousemove", "onClick"]))), 128)),
          D.showText || D.showScore ? (_(), B("span", {
            key: 0,
            class: $(s(u).e("text")),
            style: Ue({ color: D.textColor })
          }, ke(s(w)), 7)) : oe("v-if", !0)
        ], 46, ["id", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuetext", "aria-valuemax"]);
      };
    }
  });
  var KK = /* @__PURE__ */ Ne(HK, [["__file", "rate.vue"]]);
  const WK = rt(KK), Wa = {
    primary: "icon-primary",
    success: "icon-success",
    warning: "icon-warning",
    error: "icon-error",
    info: "icon-info"
  }, $y = {
    [Wa.primary]: Si,
    [Wa.success]: WR,
    [Wa.warning]: Rd,
    [Wa.error]: fh,
    [Wa.info]: Si
  }, jK = Te({
    title: {
      type: String,
      default: ""
    },
    subTitle: {
      type: String,
      default: ""
    },
    icon: {
      type: String,
      values: ["primary", "success", "warning", "info", "error"],
      default: "info"
    }
  }), UK = /* @__PURE__ */ U({
    name: "ElResult"
  }), YK = /* @__PURE__ */ U({
    ...UK,
    props: jK,
    setup(e) {
      const t = e, n = he("result"), o = S(() => {
        const l = t.icon, a = l && Wa[l] ? Wa[l] : "icon-info", r = $y[a] || $y["icon-info"];
        return {
          class: a,
          component: r
        };
      });
      return (l, a) => (_(), B("div", {
        class: $(s(n).b())
      }, [
        W("div", {
          class: $(s(n).e("icon"))
        }, [
          ee(l.$slots, "icon", {}, () => [
            s(o).component ? (_(), ae(ct(s(o).component), {
              key: 0,
              class: $(s(o).class)
            }, null, 8, ["class"])) : oe("v-if", !0)
          ])
        ], 2),
        l.title || l.$slots.title ? (_(), B("div", {
          key: 0,
          class: $(s(n).e("title"))
        }, [
          ee(l.$slots, "title", {}, () => [
            W("p", null, ke(l.title), 1)
          ])
        ], 2)) : oe("v-if", !0),
        l.subTitle || l.$slots["sub-title"] ? (_(), B("div", {
          key: 1,
          class: $(s(n).e("subtitle"))
        }, [
          ee(l.$slots, "sub-title", {}, () => [
            W("p", null, ke(l.subTitle), 1)
          ])
        ], 2)) : oe("v-if", !0),
        l.$slots.extra ? (_(), B("div", {
          key: 2,
          class: $(s(n).e("extra"))
        }, [
          ee(l.$slots, "extra")
        ], 2)) : oe("v-if", !0)
      ], 2));
    }
  });
  var qK = /* @__PURE__ */ Ne(YK, [["__file", "result.vue"]]);
  const GK = rt(qK), XK = [
    "start",
    "center",
    "end",
    "space-around",
    "space-between",
    "space-evenly"
  ], JK = ["top", "middle", "bottom"], ZK = Te({
    tag: {
      type: String,
      default: "div"
    },
    gutter: {
      type: Number,
      default: 0
    },
    justify: {
      type: String,
      values: XK,
      default: "start"
    },
    align: {
      type: String,
      values: JK
    }
  }), QK = /* @__PURE__ */ U({
    name: "ElRow"
  }), eW = /* @__PURE__ */ U({
    ...QK,
    props: ZK,
    setup(e) {
      const t = e, n = he("row"), o = S(() => t.gutter);
      yt(VS, {
        gutter: o
      });
      const l = S(() => {
        const r = {};
        return t.gutter && (r.marginRight = r.marginLeft = `-${t.gutter / 2}px`), r;
      }), a = S(() => [
        n.b(),
        n.is(`justify-${t.justify}`, t.justify !== "start"),
        n.is(`align-${t.align}`, !!t.align)
      ]);
      return (r, i) => (_(), ae(ct(r.tag), {
        class: $(s(a)),
        style: Ue(s(l))
      }, {
        default: Q(() => [
          ee(r.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style"]));
    }
  });
  var tW = /* @__PURE__ */ Ne(eW, [["__file", "row.vue"]]);
  const nW = rt(tW), oW = /* @__PURE__ */ U({
    props: {
      item: {
        type: Object,
        required: !0
      },
      style: {
        type: Object
      },
      height: Number
    },
    setup() {
      return {
        ns: he("select")
      };
    }
  });
  function lW(e, t, n, o, l, a) {
    return _(), B("div", {
      class: $(e.ns.be("group", "title")),
      style: Ue({ ...e.style, lineHeight: `${e.height}px` })
    }, ke(e.item.label), 7);
  }
  var aW = /* @__PURE__ */ Ne(oW, [["render", lW], ["__file", "group-item.vue"]]);
  function rW(e, { emit: t }) {
    return {
      hoverItem: () => {
        e.disabled || t("hover", e.index);
      },
      selectOptionClick: () => {
        e.disabled || t("select", e.item, e.index);
      }
    };
  }
  const sW = Te({
    allowCreate: Boolean,
    autocomplete: {
      type: X(String),
      default: "none"
    },
    automaticDropdown: Boolean,
    clearable: Boolean,
    clearIcon: {
      type: Lt,
      default: oa
    },
    effect: {
      type: X(String),
      default: "light"
    },
    collapseTags: Boolean,
    collapseTagsTooltip: Boolean,
    maxCollapseTags: {
      type: Number,
      default: 1
    },
    defaultFirstOption: Boolean,
    disabled: Boolean,
    estimatedOptionHeight: {
      type: Number,
      default: void 0
    },
    filterable: Boolean,
    filterMethod: {
      type: X(Function)
    },
    height: {
      type: Number,
      default: 274
    },
    itemHeight: {
      type: Number,
      default: 34
    },
    id: String,
    loading: Boolean,
    loadingText: String,
    modelValue: {
      type: X([Array, String, Number, Boolean, Object]),
      default: void 0
    },
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    name: String,
    noDataText: String,
    noMatchText: String,
    remoteMethod: {
      type: X(Function)
    },
    reserveKeyword: {
      type: Boolean,
      default: !0
    },
    options: {
      type: X(Array),
      required: !0
    },
    placeholder: {
      type: String
    },
    teleported: zt.teleported,
    persistent: {
      type: Boolean,
      default: !0
    },
    popperClass: zt.popperClass,
    popperStyle: zt.popperStyle,
    popperOptions: {
      type: X(Object),
      default: () => ({})
    },
    remote: Boolean,
    debounce: {
      type: Number,
      default: 300
    },
    size: mn,
    props: {
      type: X(Object),
      default: () => Gh
    },
    valueKey: {
      type: String,
      default: "value"
    },
    scrollbarAlwaysOn: Boolean,
    validateEvent: {
      type: Boolean,
      default: !0
    },
    offset: {
      type: Number,
      default: 12
    },
    showArrow: {
      type: Boolean,
      default: !0
    },
    placement: {
      type: X(String),
      values: aa,
      default: "bottom-start"
    },
    fallbackPlacements: {
      type: X(Array),
      default: ["bottom-start", "top-start", "right", "left"]
    },
    tagType: { ...Xl.type, default: "info" },
    tagEffect: { ...Xl.effect, default: "light" },
    tabindex: {
      type: [String, Number],
      default: 0
    },
    appendTo: zt.appendTo,
    fitInputWidth: {
      type: [Boolean, Number],
      default: !0,
      validator(e) {
        return Vt(e) || je(e);
      }
    },
    suffixIcon: {
      type: Lt,
      default: Nl
    },
    ...Cr,
    ...Yn(["ariaLabel"])
  }), iW = Te({
    data: Array,
    disabled: Boolean,
    hovering: Boolean,
    item: {
      type: X(Object),
      required: !0
    },
    index: Number,
    style: Object,
    selected: Boolean,
    created: Boolean
  }), uW = {
    [et]: (e) => !0,
    [gt]: (e) => !0,
    "remove-tag": (e) => !0,
    "visible-change": (e) => !0,
    focus: (e) => e instanceof FocusEvent,
    blur: (e) => e instanceof FocusEvent,
    clear: () => !0
  }, cW = {
    hover: (e) => je(e),
    select: (e, t) => !0
  }, em = Symbol("ElSelectV2Injection"), dW = /* @__PURE__ */ U({
    props: iW,
    emits: cW,
    setup(e, { emit: t }) {
      const n = Ve(em), o = he("select"), { hoverItem: l, selectOptionClick: a } = rW(e, { emit: t }), { getLabel: r } = fu(n.props), i = n.contentId;
      return {
        ns: o,
        contentId: i,
        hoverItem: l,
        selectOptionClick: a,
        getLabel: r
      };
    }
  });
  function fW(e, t, n, o, l, a) {
    return _(), B("li", {
      id: `${e.contentId}-${e.index}`,
      role: "option",
      "aria-selected": e.selected,
      "aria-disabled": e.disabled || void 0,
      style: Ue(e.style),
      class: $([
        e.ns.be("dropdown", "item"),
        e.ns.is("selected", e.selected),
        e.ns.is("disabled", e.disabled),
        e.ns.is("created", e.created),
        e.ns.is("hovering", e.hovering)
      ]),
      onMousemove: e.hoverItem,
      onClick: Ze(e.selectOptionClick, ["stop"])
    }, [
      ee(e.$slots, "default", {
        item: e.item,
        index: e.index,
        disabled: e.disabled
      }, () => [
        W("span", null, ke(e.getLabel(e.item)), 1)
      ])
    ], 46, ["id", "aria-selected", "aria-disabled", "onMousemove", "onClick"]);
  }
  var pW = /* @__PURE__ */ Ne(dW, [["render", fW], ["__file", "option-item.vue"]]), Oy = Number.isNaN || function(t) {
    return typeof t == "number" && t !== t;
  };
  function vW(e, t) {
    return !!(e === t || Oy(e) && Oy(t));
  }
  function hW(e, t) {
    if (e.length !== t.length)
      return !1;
    for (var n = 0; n < e.length; n++)
      if (!vW(e[n], t[n]))
        return !1;
    return !0;
  }
  function mW(e, t) {
    t === void 0 && (t = hW);
    var n = null;
    function o() {
      for (var l = [], a = 0; a < arguments.length; a++)
        l[a] = arguments[a];
      if (n && n.lastThis === this && t(l, n.lastArgs))
        return n.lastResult;
      var r = e.apply(this, l);
      return n = {
        lastResult: r,
        lastArgs: l,
        lastThis: this
      }, r;
    }
    return o.clear = function() {
      n = null;
    }, o;
  }
  const qE = () => {
    const t = dt().proxy.$props;
    return S(() => {
      const n = (o, l, a) => ({});
      return t.perfMode ? Nd(n) : mW(n);
    });
  }, Fp = 50, Gc = "itemRendered", Xc = "scroll", Br = "forward", Jc = "backward", To = "auto", Yd = "smart", xi = "start", dl = "center", Pi = "end", fs = "horizontal", tm = "vertical", gW = "ltr", Yr = "rtl", Ri = "negative", nm = "positive-ascending", om = "positive-descending", bW = {
    [fs]: "left",
    [tm]: "top"
  }, yW = 20, wW = {
    [fs]: "deltaX",
    [tm]: "deltaY"
  }, GE = ({ atEndEdge: e, atStartEdge: t, layout: n }, o) => {
    let l, a = 0;
    const r = (u) => u < 0 && t.value || u > 0 && e.value;
    return {
      hasReachedEdge: r,
      onWheel: (u) => {
        Yl(l);
        const c = u[wW[n.value]];
        r(a) && r(a + c) || (a += c, vh() || u.preventDefault(), l = Ul(() => {
          o(a), a = 0;
        }));
      }
    };
  }, zp = tl({
    type: X([Number, Function]),
    required: !0
  }), Hp = tl({
    type: Number
  }), Kp = tl({
    type: Number,
    default: 2
  }), CW = tl({
    type: String,
    values: ["ltr", "rtl"],
    default: "ltr"
  }), Wp = tl({
    type: Number,
    default: 0
  }), Zc = tl({
    type: Number,
    required: !0
  }), XE = tl({
    type: String,
    values: ["horizontal", "vertical"],
    default: tm
  }), JE = Te({
    className: {
      type: String,
      default: ""
    },
    containerElement: {
      type: X([String, Object]),
      default: "div"
    },
    data: {
      type: X(Array),
      default: () => en([])
    },
    direction: CW,
    height: {
      type: [String, Number],
      required: !0
    },
    innerElement: {
      type: [String, Object],
      default: "div"
    },
    innerProps: {
      type: X(Object),
      default: () => ({})
    },
    style: {
      type: X([Object, String, Array])
    },
    useIsScrolling: Boolean,
    width: {
      type: [Number, String],
      required: !1
    },
    perfMode: {
      type: Boolean,
      default: !0
    },
    scrollbarAlwaysOn: Boolean
  }), ZE = Te({
    cache: Kp,
    estimatedItemSize: Hp,
    layout: XE,
    initScrollOffset: Wp,
    total: Zc,
    itemSize: zp,
    ...JE
  }), jp = {
    type: Number,
    default: 6
  }, QE = { type: Number, default: 0 }, ek = { type: Number, default: 2 }, rr = Te({
    columnCache: Kp,
    columnWidth: zp,
    estimatedColumnWidth: Hp,
    estimatedRowHeight: Hp,
    initScrollLeft: Wp,
    initScrollTop: Wp,
    itemKey: {
      type: X(Function),
      default: ({
        columnIndex: e,
        rowIndex: t
      }) => `${t}:${e}`
    },
    rowCache: Kp,
    rowHeight: zp,
    totalColumn: Zc,
    totalRow: Zc,
    hScrollbarSize: jp,
    vScrollbarSize: jp,
    scrollbarStartGap: QE,
    scrollbarEndGap: ek,
    role: String,
    ...JE
  }), tk = Te({
    alwaysOn: Boolean,
    class: String,
    layout: XE,
    total: Zc,
    ratio: {
      type: Number,
      required: !0
    },
    clientSize: {
      type: Number,
      required: !0
    },
    scrollFrom: {
      type: Number,
      required: !0
    },
    scrollbarSize: jp,
    startGap: QE,
    endGap: ek,
    visible: Boolean
  }), Ga = (e, t) => e < t ? Br : Jc, Di = (e) => e === gW || e === Yr || e === fs, Iy = (e) => e === Yr;
  let Mr = null;
  function Qc(e = !1) {
    if (Mr === null || e) {
      const t = document.createElement("div"), n = t.style;
      n.width = "50px", n.height = "50px", n.overflow = "scroll", n.direction = "rtl";
      const o = document.createElement("div"), l = o.style;
      return l.width = "100px", l.height = "100px", t.appendChild(o), document.body.appendChild(t), t.scrollLeft > 0 ? Mr = om : (t.scrollLeft = 1, t.scrollLeft === 0 ? Mr = Ri : Mr = nm), document.body.removeChild(t), Mr;
    }
    return Mr;
  }
  function SW({ move: e, size: t, bar: n }, o) {
    const l = {}, a = `translate${n.axis}(${e}px)`;
    return l[n.size] = t, l.transform = a, o === "horizontal" ? l.height = "100%" : l.width = "100%", l;
  }
  const Up = /* @__PURE__ */ U({
    name: "ElVirtualScrollBar",
    props: tk,
    emits: ["scroll", "start-move", "stop-move"],
    setup(e, { emit: t }) {
      const n = S(() => e.startGap + e.endGap), o = he("virtual-scrollbar"), l = he("scrollbar"), a = A(), r = A();
      let i = null, u = null;
      const c = Rt({
        isDragging: !1,
        traveled: 0
      }), d = S(() => $C[e.layout]), f = S(() => e.clientSize - s(n)), v = S(() => ({
        position: "absolute",
        width: `${fs === e.layout ? f.value : e.scrollbarSize}px`,
        height: `${fs === e.layout ? e.scrollbarSize : f.value}px`,
        [bW[e.layout]]: "2px",
        right: "2px",
        bottom: "2px",
        borderRadius: "4px"
      })), p = S(() => {
        const k = e.ratio;
        if (k >= 100)
          return Number.POSITIVE_INFINITY;
        if (k >= 50)
          return k * f.value / 100;
        const T = f.value / 3;
        return Math.floor(Math.min(Math.max(k * f.value / 100, yW), T));
      }), m = S(() => {
        if (!Number.isFinite(p.value))
          return {
            display: "none"
          };
        const k = `${p.value}px`;
        return SW({
          bar: d.value,
          size: k,
          move: c.traveled
        }, e.layout);
      }), h = S(() => Math.ceil(e.clientSize - p.value - s(n))), g = () => {
        window.addEventListener("mousemove", y), window.addEventListener("mouseup", w);
        const k = s(r);
        k && (u = document.onselectstart, document.onselectstart = () => !1, k.addEventListener("touchmove", y, { passive: !0 }), k.addEventListener("touchend", w));
      }, b = () => {
        window.removeEventListener("mousemove", y), window.removeEventListener("mouseup", w), document.onselectstart = u, u = null;
        const k = s(r);
        k && (k.removeEventListener("touchmove", y), k.removeEventListener("touchend", w));
      }, C = (k) => {
        k.stopImmediatePropagation(), !(k.ctrlKey || [1, 2].includes(k.button)) && (c.isDragging = !0, c[d.value.axis] = k.currentTarget[d.value.offset] - (k[d.value.client] - k.currentTarget.getBoundingClientRect()[d.value.direction]), t("start-move"), g());
      }, w = () => {
        c.isDragging = !1, c[d.value.axis] = 0, t("stop-move"), b();
      }, y = (k) => {
        const { isDragging: T } = c;
        if (!T || !r.value || !a.value)
          return;
        const x = c[d.value.axis];
        if (!x)
          return;
        Yl(i);
        const I = (a.value.getBoundingClientRect()[d.value.direction] - k[d.value.client]) * -1, P = r.value[d.value.offset] - x, O = I - P;
        i = Ul(() => {
          c.traveled = Math.max(0, Math.min(O, h.value)), t("scroll", O, h.value);
        });
      }, E = (k) => {
        const T = Math.abs(k.target.getBoundingClientRect()[d.value.direction] - k[d.value.client]), x = r.value[d.value.offset] / 2, I = T - x;
        c.traveled = Math.max(0, Math.min(I, h.value)), t("scroll", I, h.value);
      };
      return de(() => e.scrollFrom, (k) => {
        c.isDragging || (c.traveled = Math.ceil(k * h.value));
      }), Bt(() => {
        b();
      }), () => qe("div", {
        role: "presentation",
        ref: a,
        class: [
          o.b(),
          e.class,
          (e.alwaysOn || c.isDragging) && "always-on"
        ],
        style: v.value,
        onMousedown: Ze(E, ["stop", "prevent"]),
        onTouchstartPrevent: C
      }, qe("div", {
        ref: r,
        class: l.e("thumb"),
        style: m.value,
        onMousedown: C
      }, []));
    }
  }), nk = ({
    name: e,
    getOffset: t,
    getItemSize: n,
    getItemOffset: o,
    getEstimatedTotalSize: l,
    getStartIndexForOffset: a,
    getStopIndexForStartIndex: r,
    initCache: i,
    clearCache: u,
    validateProps: c
  }) => /* @__PURE__ */ U({
    name: e ?? "ElVirtualList",
    props: ZE,
    emits: [Gc, Xc],
    setup(d, { emit: f, expose: v }) {
      c(d);
      const p = dt(), m = he("vl"), h = A(i(d, p)), g = qE(), b = A(), C = A(), w = A(), y = A({
        isScrolling: !1,
        scrollDir: "forward",
        scrollOffset: je(d.initScrollOffset) ? d.initScrollOffset : 0,
        updateRequested: !1,
        isScrollbarDragging: !1,
        scrollbarAlwaysOn: d.scrollbarAlwaysOn
      }), E = S(() => {
        const { total: K, cache: Z } = d, { isScrolling: J, scrollDir: ie, scrollOffset: ue } = s(y);
        if (K === 0)
          return [0, 0, 0, 0];
        const re = a(d, ue, s(h)), se = r(d, re, ue, s(h)), ne = !J || ie === Jc ? Math.max(1, Z) : 1, le = !J || ie === Br ? Math.max(1, Z) : 1;
        return [
          Math.max(0, re - ne),
          Math.max(0, Math.min(K - 1, se + le)),
          re,
          se
        ];
      }), k = S(() => l(d, s(h))), T = S(() => Di(d.layout)), x = S(() => [
        {
          position: "relative",
          [`overflow-${T.value ? "x" : "y"}`]: "scroll",
          WebkitOverflowScrolling: "touch",
          willChange: "transform"
        },
        {
          direction: d.direction,
          height: je(d.height) ? `${d.height}px` : d.height,
          width: je(d.width) ? `${d.width}px` : d.width
        },
        d.style
      ]), I = S(() => {
        const K = s(k), Z = s(T);
        return {
          height: Z ? "100%" : `${K}px`,
          pointerEvents: s(y).isScrolling ? "none" : void 0,
          width: Z ? `${K}px` : "100%"
        };
      }), P = S(() => T.value ? d.width : d.height), { onWheel: O } = GE({
        atStartEdge: S(() => y.value.scrollOffset <= 0),
        atEndEdge: S(() => y.value.scrollOffset >= k.value),
        layout: S(() => d.layout)
      }, (K) => {
        var Z, J;
        (J = (Z = w.value).onMouseUp) == null || J.call(Z), R(Math.min(y.value.scrollOffset + K, k.value - P.value));
      });
      Dt(b, "wheel", O, {
        passive: !1
      });
      const N = () => {
        const { total: K } = d;
        if (K > 0) {
          const [ue, re, se, ne] = s(E);
          f(Gc, ue, re, se, ne);
        }
        const { scrollDir: Z, scrollOffset: J, updateRequested: ie } = s(y);
        f(Xc, Z, J, ie);
      }, z = (K) => {
        const { clientHeight: Z, scrollHeight: J, scrollTop: ie } = K.currentTarget, ue = s(y);
        if (ue.scrollOffset === ie)
          return;
        const re = Math.max(0, Math.min(ie, J - Z));
        y.value = {
          ...ue,
          isScrolling: !0,
          scrollDir: Ga(ue.scrollOffset, re),
          scrollOffset: re,
          updateRequested: !1
        }, Re(V);
      }, Y = (K) => {
        const { clientWidth: Z, scrollLeft: J, scrollWidth: ie } = K.currentTarget, ue = s(y);
        if (ue.scrollOffset === J)
          return;
        const { direction: re } = d;
        let se = J;
        if (re === Yr)
          switch (Qc()) {
            case Ri: {
              se = -J;
              break;
            }
            case om: {
              se = ie - Z - J;
              break;
            }
          }
        se = Math.max(0, Math.min(se, ie - Z)), y.value = {
          ...ue,
          isScrolling: !0,
          scrollDir: Ga(ue.scrollOffset, se),
          scrollOffset: se,
          updateRequested: !1
        }, Re(V);
      }, G = (K) => {
        s(T) ? Y(K) : z(K), N();
      }, M = (K, Z) => {
        const J = (k.value - P.value) / Z * K;
        R(Math.min(k.value - P.value, J));
      }, R = (K) => {
        K = Math.max(K, 0), K !== s(y).scrollOffset && (y.value = {
          ...s(y),
          scrollOffset: K,
          scrollDir: Ga(s(y).scrollOffset, K),
          updateRequested: !0
        }, Re(V));
      }, D = (K, Z = To) => {
        const { scrollOffset: J } = s(y);
        K = Math.max(0, Math.min(K, d.total - 1)), R(t(d, K, Z, J, s(h)));
      }, L = (K) => {
        const { direction: Z, itemSize: J, layout: ie } = d, ue = g.value(u && J, u && ie, u && Z);
        let re;
        if (Ot(ue, String(K)))
          re = ue[K];
        else {
          const se = o(d, K, s(h)), ne = n(d, K, s(h)), le = s(T), Ce = Z === Yr, j = le ? se : 0;
          ue[K] = re = {
            position: "absolute",
            left: Ce ? void 0 : `${j}px`,
            right: Ce ? `${j}px` : void 0,
            top: le ? 0 : `${se}px`,
            height: le ? "100%" : `${ne}px`,
            width: le ? `${ne}px` : "100%"
          };
        }
        return re;
      }, V = () => {
        y.value.isScrolling = !1, Re(() => {
          g.value(-1, null, null);
        });
      }, F = () => {
        const K = b.value;
        K && (K.scrollTop = 0);
      };
      ft(() => {
        if (!xt)
          return;
        const { initScrollOffset: K } = d, Z = s(b);
        je(K) && Z && (s(T) ? Z.scrollLeft = K : Z.scrollTop = K), N();
      }), Qo(() => {
        const { direction: K, layout: Z } = d, { scrollOffset: J, updateRequested: ie } = s(y), ue = s(b);
        if (ie && ue)
          if (Z === fs)
            if (K === Yr)
              switch (Qc()) {
                case Ri: {
                  ue.scrollLeft = -J;
                  break;
                }
                case nm: {
                  ue.scrollLeft = J;
                  break;
                }
                default: {
                  const { clientWidth: re, scrollWidth: se } = ue;
                  ue.scrollLeft = se - re - J;
                  break;
                }
              }
            else
              ue.scrollLeft = J;
          else
            ue.scrollTop = J;
      }), hd(() => {
        s(b).scrollTop = s(y).scrollOffset;
      });
      const H = {
        ns: m,
        clientSize: P,
        estimatedTotalSize: k,
        windowStyle: x,
        windowRef: b,
        innerRef: C,
        innerStyle: I,
        itemsToRender: E,
        scrollbarRef: w,
        states: y,
        getItemStyle: L,
        onScroll: G,
        onScrollbarScroll: M,
        onWheel: O,
        scrollTo: R,
        scrollToItem: D,
        resetScrollTop: F
      };
      return v({
        windowRef: b,
        innerRef: C,
        getItemStyleCache: g,
        scrollTo: R,
        scrollToItem: D,
        resetScrollTop: F,
        states: y
      }), H;
    },
    render(d) {
      var f;
      const {
        $slots: v,
        className: p,
        clientSize: m,
        containerElement: h,
        data: g,
        getItemStyle: b,
        innerElement: C,
        itemsToRender: w,
        innerStyle: y,
        layout: E,
        total: k,
        onScroll: T,
        onScrollbarScroll: x,
        states: I,
        useIsScrolling: P,
        windowStyle: O,
        ns: N
      } = d, [z, Y] = w, G = ct(h), M = ct(C), R = [];
      if (k > 0)
        for (let F = z; F <= Y; F++)
          R.push(qe(We, { key: F }, (f = v.default) == null ? void 0 : f.call(v, {
            data: g,
            index: F,
            isScrolling: P ? I.isScrolling : void 0,
            style: b(F)
          })));
      const D = [
        qe(M, pt(d.innerProps, {
          style: y,
          ref: "innerRef"
        }), Ae(M) ? R : {
          default: () => R
        })
      ], L = qe(Up, {
        ref: "scrollbarRef",
        clientSize: m,
        layout: E,
        onScroll: x,
        ratio: m * 100 / this.estimatedTotalSize,
        scrollFrom: I.scrollOffset / (this.estimatedTotalSize - m),
        total: k,
        alwaysOn: I.scrollbarAlwaysOn
      }), V = qe(G, {
        class: [N.e("window"), p],
        style: O,
        onScroll: T,
        ref: "windowRef",
        key: 0
      }, Ae(G) ? [D] : { default: () => [D] });
      return qe("div", {
        key: 0,
        class: [N.e("wrapper"), I.scrollbarAlwaysOn ? "always-on" : ""]
      }, [V, L]);
    }
  }), ok = nk({
    name: "ElFixedSizeList",
    getItemOffset: ({ itemSize: e }, t) => t * e,
    getItemSize: ({ itemSize: e }) => e,
    getEstimatedTotalSize: ({ total: e, itemSize: t }) => t * e,
    getOffset: ({ height: e, total: t, itemSize: n, layout: o, width: l }, a, r, i) => {
      const u = Di(o) ? l : e;
      typeof process < "u" && process.env.NODE_ENV !== "production" && Ae(u) && Zt("[ElVirtualList]", `
        You should set
          width/height
        to number when your layout is
          horizontal/vertical
      `);
      const c = Math.max(0, t * n - u), d = Math.min(c, a * n), f = Math.max(0, (a + 1) * n - u);
      switch (r === Yd && (i >= f - u && i <= d + u ? r = To : r = dl), r) {
        case xi:
          return d;
        case Pi:
          return f;
        case dl: {
          const v = Math.round(f + (d - f) / 2);
          return v < Math.ceil(u / 2) ? 0 : v > c + Math.floor(u / 2) ? c : v;
        }
        case To:
        default:
          return i >= f && i <= d ? i : i < f ? f : d;
      }
    },
    getStartIndexForOffset: ({ total: e, itemSize: t }, n) => Math.max(0, Math.min(e - 1, Math.floor(n / t))),
    getStopIndexForStartIndex: ({ height: e, total: t, itemSize: n, layout: o, width: l }, a, r) => {
      const i = a * n, u = Di(o) ? l : e, c = Math.ceil((u + r - i) / n);
      return Math.max(0, Math.min(t - 1, a + c - 1));
    },
    initCache() {
    },
    clearCache: !0,
    validateProps() {
    }
  }), EW = "ElDynamicSizeList", Fr = (e, t, n) => {
    const { itemSize: o } = e, { items: l, lastVisitedIndex: a } = n;
    if (t > a) {
      let r = 0;
      if (a >= 0) {
        const i = l[a];
        r = i.offset + i.size;
      }
      for (let i = a + 1; i <= t; i++) {
        const u = o(i);
        l[i] = {
          offset: r,
          size: u
        }, r += u;
      }
      n.lastVisitedIndex = t;
    }
    return l[t];
  }, kW = (e, t, n) => {
    const { items: o, lastVisitedIndex: l } = t;
    return (l > 0 ? o[l].offset : 0) >= n ? lk(e, t, 0, l, n) : _W(e, t, Math.max(0, l), n);
  }, lk = (e, t, n, o, l) => {
    for (; n <= o; ) {
      const a = n + Math.floor((o - n) / 2), r = Fr(e, a, t).offset;
      if (r === l)
        return a;
      r < l ? n = a + 1 : r > l && (o = a - 1);
    }
    return Math.max(0, n - 1);
  }, _W = (e, t, n, o) => {
    const { total: l } = e;
    let a = 1;
    for (; n < l && Fr(e, n, t).offset < o; )
      n += a, a *= 2;
    return lk(e, t, Math.floor(n / 2), Math.min(n, l - 1), o);
  }, My = ({ total: e }, { items: t, estimatedItemSize: n, lastVisitedIndex: o }) => {
    let l = 0;
    if (o >= e && (o = e - 1), o >= 0) {
      const i = t[o];
      l = i.offset + i.size;
    }
    const r = (e - o - 1) * n;
    return l + r;
  }, TW = nk({
    name: "ElDynamicSizeList",
    getItemOffset: (e, t, n) => Fr(e, t, n).offset,
    getItemSize: (e, t, { items: n }) => n[t].size,
    getEstimatedTotalSize: My,
    getOffset: (e, t, n, o, l) => {
      const { height: a, layout: r, width: i } = e, u = Di(r) ? i : a, c = Fr(e, t, l), d = My(e, l), f = Math.max(0, Math.min(d - u, c.offset)), v = Math.max(0, c.offset - u + c.size);
      switch (n === Yd && (o >= v - u && o <= f + u ? n = To : n = dl), n) {
        case xi:
          return f;
        case Pi:
          return v;
        case dl:
          return Math.round(v + (f - v) / 2);
        case To:
        default:
          return o >= v && o <= f ? o : o < v ? v : f;
      }
    },
    getStartIndexForOffset: (e, t, n) => kW(e, n, t),
    getStopIndexForStartIndex: (e, t, n, o) => {
      const { height: l, total: a, layout: r, width: i } = e, u = Di(r) ? i : l, c = Fr(e, t, o), d = n + u;
      let f = c.offset + c.size, v = t;
      for (; v < a - 1 && f < d; )
        v++, f += Fr(e, v, o).size;
      return v;
    },
    initCache({ estimatedItemSize: e = Fp }, t) {
      const n = {
        items: {},
        estimatedItemSize: e,
        lastVisitedIndex: -1
      };
      return n.clearCacheAfterIndex = (o, l = !0) => {
        var a, r;
        n.lastVisitedIndex = Math.min(n.lastVisitedIndex, o - 1), (a = t.exposed) == null || a.getItemStyleCache(-1), l && ((r = t.proxy) == null || r.$forceUpdate());
      }, n;
    },
    clearCache: !1,
    validateProps: ({ itemSize: e }) => {
      typeof process < "u" && process.env.NODE_ENV !== "production" && typeof e != "function" && Zt(EW, `
          itemSize is required as function, but the given value was ${typeof e}
        `);
    }
  }), NW = {
    loading: Boolean,
    data: {
      type: Array,
      required: !0
    },
    hoveringIndex: Number,
    width: Number,
    id: String,
    ariaLabel: String
  };
  var $W = /* @__PURE__ */ U({
    name: "ElSelectDropdown",
    props: NW,
    setup(e, {
      slots: t,
      expose: n
    }) {
      const o = Ve(em), l = he("select"), {
        getLabel: a,
        getValue: r,
        getDisabled: i
      } = fu(o.props), u = A([]), c = A(), d = S(() => e.data.length);
      de(() => d.value, () => {
        var O, N;
        (N = (O = o.tooltipRef.value) == null ? void 0 : O.updatePopper) == null || N.call(O);
      });
      const f = S(() => kt(o.props.estimatedOptionHeight)), v = S(() => f.value ? {
        itemSize: o.props.itemHeight
      } : {
        estimatedSize: o.props.estimatedOptionHeight,
        itemSize: (O) => u.value[O]
      }), p = (O = [], N) => {
        const {
          props: {
            valueKey: z
          }
        } = o;
        return ot(N) ? O && O.some((Y) => Pt(dn(Y, z)) === dn(N, z)) : O.includes(N);
      }, m = (O, N) => {
        if (ot(N)) {
          const {
            valueKey: z
          } = o.props;
          return dn(O, z) === dn(N, z);
        } else
          return O === N;
      }, h = (O, N) => o.props.multiple ? p(O, r(N)) : m(O, r(N)), g = (O, N) => {
        const {
          disabled: z,
          multiple: Y,
          multipleLimit: G
        } = o.props;
        return z || !N && (Y ? G > 0 && O.length >= G : !1);
      }, b = (O) => e.hoveringIndex === O;
      n({
        listRef: c,
        isSized: f,
        isItemDisabled: g,
        isItemHovering: b,
        isItemSelected: h,
        scrollToItem: (O) => {
          const N = c.value;
          N && N.scrollToItem(O);
        },
        resetScrollTop: () => {
          const O = c.value;
          O && O.resetScrollTop();
        }
      });
      const E = (O) => {
        const {
          index: N,
          data: z,
          style: Y
        } = O, G = s(f), {
          itemSize: M,
          estimatedSize: R
        } = s(v), {
          modelValue: D
        } = o.props, {
          onSelect: L,
          onHover: V
        } = o, F = z[N];
        if (F.type === "Group")
          return q(aW, {
            item: F,
            style: Y,
            height: G ? M : R
          }, null);
        const H = h(D, F), K = g(D, H), Z = b(N);
        return q(pW, pt(O, {
          selected: H,
          disabled: i(F) || K,
          created: !!F.created,
          hovering: Z,
          item: F,
          onSelect: L,
          onHover: V
        }), {
          default: (J) => {
            var ie;
            return ((ie = t.default) == null ? void 0 : ie.call(t, J)) || q("span", null, [a(F)]);
          }
        });
      }, {
        onKeyboardNavigate: k,
        onKeyboardSelect: T
      } = o, x = () => {
        k("forward");
      }, I = () => {
        k("backward");
      }, P = (O) => {
        const N = Ht(O), {
          tab: z,
          esc: Y,
          down: G,
          up: M,
          enter: R,
          numpadEnter: D
        } = _e;
        switch ([Y, G, M, R, D].includes(N) && (O.preventDefault(), O.stopPropagation()), N) {
          case z:
          case Y:
            break;
          case G:
            x();
            break;
          case M:
            I();
            break;
          case R:
          case D:
            T();
            break;
        }
      };
      return () => {
        var O, N, z, Y;
        const {
          data: G,
          width: M
        } = e, {
          height: R,
          multiple: D,
          scrollbarAlwaysOn: L
        } = o.props, V = S(() => Lc ? !0 : L), F = s(f) ? ok : TW;
        return q("div", {
          class: [l.b("dropdown"), l.is("multiple", D)],
          style: {
            width: `${M}px`
          }
        }, [(O = t.header) == null ? void 0 : O.call(t), ((N = t.loading) == null ? void 0 : N.call(t)) || ((z = t.empty) == null ? void 0 : z.call(t)) || q(F, pt({
          ref: c
        }, s(v), {
          className: l.be("dropdown", "list"),
          scrollbarAlwaysOn: V.value,
          data: G,
          height: R,
          width: M,
          total: G.length,
          innerElement: "ul",
          innerProps: {
            id: e.id,
            role: "listbox",
            "aria-label": e.ariaLabel,
            "aria-orientation": "vertical"
          },
          onKeydown: P
        }), {
          default: (H) => q(E, H, null)
        }), (Y = t.footer) == null ? void 0 : Y.call(t)]);
      };
    }
  });
  function OW(e, t) {
    const { aliasProps: n, getLabel: o, getValue: l } = fu(e), a = A(0), r = A(), i = S(() => e.allowCreate && e.filterable);
    de(() => e.options, (p) => {
      const m = new Set(p.map((h) => o(h)));
      t.createdOptions = t.createdOptions.filter((h) => !m.has(o(h)));
    });
    function u(p) {
      const m = (h) => o(h) === p;
      return e.options && e.options.some(m) || t.createdOptions.some(m);
    }
    function c(p) {
      i.value && (e.multiple && p.created ? a.value++ : r.value = p);
    }
    function d(p) {
      if (i.value)
        if (p && p.length > 0) {
          if (u(p)) {
            t.createdOptions = t.createdOptions.filter((h) => o(h) !== t.previousQuery);
            return;
          }
          const m = {
            [n.value.value]: p,
            [n.value.label]: p,
            created: !0,
            [n.value.disabled]: !1
          };
          t.createdOptions.length >= a.value ? t.createdOptions[a.value] = m : t.createdOptions.push(m);
        } else if (e.multiple)
          t.createdOptions.length = a.value;
        else {
          const m = r.value;
          t.createdOptions.length = 0, m && m.created && t.createdOptions.push(m);
        }
    }
    function f(p) {
      if (!i.value || !p || !p.created || p.created && e.reserveKeyword && t.inputValue === o(p))
        return;
      const m = t.createdOptions.findIndex((h) => l(h) === l(p));
      ~m && (t.createdOptions.splice(m, 1), a.value--);
    }
    function v() {
      i.value && (t.createdOptions.length = 0, a.value = 0);
    }
    return {
      createNewOption: d,
      removeNewOption: f,
      selectNewOption: c,
      clearAllNewOption: v
    };
  }
  const IW = (e, t) => {
    const { t: n } = _t(), o = he("select"), l = he("input"), { form: a, formItem: r } = Nn(), { inputId: i } = wo(e, {
      formItemContext: r
    }), { aliasProps: u, getLabel: c, getValue: d, getDisabled: f, getOptions: v } = fu(e), { valueOnClear: p, isEmptyValue: m } = nu(e), h = Rt({
      inputValue: "",
      cachedOptions: [],
      createdOptions: [],
      hoveringIndex: -1,
      inputHovering: !1,
      selectionWidth: 0,
      collapseItemWidth: 0,
      previousQuery: null,
      previousValue: void 0,
      selectedLabel: "",
      menuVisibleOnFocus: !1,
      isBeforeHide: !1
    }), g = A(-1), b = A(!1), C = A(), w = A(), y = A(), E = A(), k = A(), T = A(), x = A(), I = A(), P = A(), O = A(), {
      isComposing: N,
      handleCompositionStart: z,
      handleCompositionEnd: Y,
      handleCompositionUpdate: G
    } = ru({
      afterComposition: (Ie) => Gt(Ie)
    }), M = S(() => e.disabled || !!(a != null && a.disabled)), { wrapperRef: R, isFocused: D, handleBlur: L } = la(k, {
      disabled: M,
      afterFocus() {
        e.automaticDropdown && !K.value && (K.value = !0, h.menuVisibleOnFocus = !0);
      },
      beforeBlur(Ie) {
        var at, mt;
        return ((at = y.value) == null ? void 0 : at.isFocusInsideContent(Ie)) || ((mt = E.value) == null ? void 0 : mt.isFocusInsideContent(Ie));
      },
      afterBlur() {
        var Ie;
        K.value = !1, h.menuVisibleOnFocus = !1, e.validateEvent && ((Ie = r == null ? void 0 : r.validate) == null || Ie.call(r, "blur").catch((at) => vt(at)));
      }
    }), V = S(() => be("")), F = S(() => e.loading ? !1 : e.options.length > 0 || h.createdOptions.length > 0), H = A([]), K = A(!1), Z = S(() => {
      var Ie;
      return (Ie = a == null ? void 0 : a.statusIcon) != null ? Ie : !1;
    }), J = S(() => {
      const Ie = H.value.length * e.itemHeight;
      return Ie > e.height ? e.height : Ie;
    }), ie = S(() => e.multiple ? ye(e.modelValue) && e.modelValue.length > 0 : !m(e.modelValue)), ue = S(() => e.clearable && !M.value && ie.value && (D.value || h.inputHovering)), re = S(() => e.remote && e.filterable ? "" : e.suffixIcon), se = S(() => re.value && o.is("reverse", K.value)), ne = S(() => (r == null ? void 0 : r.validateState) || ""), le = S(() => {
      if (ne.value)
        return Dd[ne.value];
    }), Ce = S(() => e.remote ? e.debounce : 0), j = S(() => e.remote && !h.inputValue && !F.value), te = S(() => e.loading ? e.loadingText || n("el.select.loading") : e.filterable && h.inputValue && F.value && H.value.length === 0 ? e.noMatchText || n("el.select.noMatch") : F.value ? null : e.noDataText || n("el.select.noData")), ce = S(() => e.filterable && Fe(e.filterMethod)), ge = S(() => e.filterable && e.remote && Fe(e.remoteMethod)), be = (Ie) => {
      const at = new RegExp(Xh(Ie), "i"), mt = (Et) => ce.value || ge.value ? !0 : Ie ? at.test(c(Et) || "") : !0;
      return e.loading ? [] : [...h.createdOptions, ...e.options].reduce((Et, gn) => {
        const So = v(gn);
        if (ye(So)) {
          const Is = So.filter(mt);
          Is.length > 0 && Et.push({
            label: c(gn),
            type: "Group"
          }, ...Is);
        } else (e.remote || mt(gn)) && Et.push(gn);
        return Et;
      }, []);
    }, Ee = () => {
      H.value = be(h.inputValue);
    }, Oe = S(() => {
      const Ie = /* @__PURE__ */ new Map();
      return V.value.forEach((at, mt) => {
        Ie.set(sn(d(at)), { option: at, index: mt });
      }), Ie;
    }), De = S(() => {
      const Ie = /* @__PURE__ */ new Map();
      return H.value.forEach((at, mt) => {
        Ie.set(sn(d(at)), { option: at, index: mt });
      }), Ie;
    }), we = S(() => H.value.every((Ie) => f(Ie))), me = vn(), Pe = S(() => me.value === "small" ? "small" : "default"), Me = () => {
      var Ie;
      if (je(e.fitInputWidth)) {
        g.value = e.fitInputWidth;
        return;
      }
      const at = ((Ie = C.value) == null ? void 0 : Ie.offsetWidth) || 200;
      !e.fitInputWidth && F.value ? Re(() => {
        g.value = Math.max(at, Be());
      }) : g.value = at;
    }, Be = () => {
      var Ie, at;
      const Et = document.createElement("canvas").getContext("2d"), gn = o.be("dropdown", "item"), Is = (((at = (Ie = I.value) == null ? void 0 : Ie.listRef) == null ? void 0 : at.innerRef) || document).querySelector(`.${gn}`);
      if (Is === null || Et === null)
        return 0;
      const Cu = getComputedStyle(Is), D_ = Number.parseFloat(Cu.paddingLeft) + Number.parseFloat(Cu.paddingRight);
      return Et.font = `bold ${Cu.font.replace(new RegExp(`\\b${Cu.fontWeight}\\b`), "")}`, H.value.reduce((A_, V_) => {
        const L_ = Et.measureText(c(V_));
        return Math.max(L_.width, A_);
      }, 0) + D_;
    }, pe = () => {
      if (!w.value)
        return 0;
      const Ie = window.getComputedStyle(w.value);
      return Number.parseFloat(Ie.gap || "6px");
    }, Le = S(() => {
      const Ie = pe(), at = e.filterable ? Ie + Ud : 0;
      return { maxWidth: `${O.value && e.maxCollapseTags === 1 ? h.selectionWidth - h.collapseItemWidth - Ie - at : h.selectionWidth - at}px` };
    }), Xe = S(() => ({ maxWidth: `${h.selectionWidth}px` })), ut = S(() => ye(e.modelValue) ? e.modelValue.length === 0 && !h.inputValue : e.filterable ? !h.inputValue : !0), Nt = S(() => {
      var Ie;
      const at = (Ie = e.placeholder) != null ? Ie : n("el.select.placeholder");
      return e.multiple || !ie.value ? at : h.selectedLabel;
    }), Ye = S(() => {
      var Ie, at;
      return (at = (Ie = y.value) == null ? void 0 : Ie.popperRef) == null ? void 0 : at.contentRef;
    }), tt = S(() => {
      if (e.multiple) {
        const Ie = e.modelValue.length;
        if (Ie > 0 && De.value.has(e.modelValue[Ie - 1])) {
          const { index: at } = De.value.get(e.modelValue[Ie - 1]);
          return at;
        }
      } else if (!m(e.modelValue) && De.value.has(e.modelValue)) {
        const { index: Ie } = De.value.get(e.modelValue);
        return Ie;
      }
      return -1;
    }), fe = S({
      get() {
        return K.value && (e.loading || !j.value) && (!b.value || !Zn(h.previousQuery));
      },
      set(Ie) {
        K.value = Ie;
      }
    }), He = S(() => e.multiple ? e.collapseTags ? h.cachedOptions.slice(0, e.maxCollapseTags) : h.cachedOptions : []), Qe = S(() => e.multiple ? e.collapseTags ? h.cachedOptions.slice(e.maxCollapseTags) : [] : []), {
      createNewOption: ve,
      removeNewOption: Ke,
      selectNewOption: St,
      clearAllNewOption: Ft
    } = OW(e, h), Se = () => {
      M.value || (h.menuVisibleOnFocus ? h.menuVisibleOnFocus = !1 : K.value = !K.value);
    }, Je = () => {
      h.inputValue.length > 0 && !K.value && (K.value = !0), ve(h.inputValue), Re(() => {
        Yt(h.inputValue);
      });
    }, lt = eu(() => {
      Je(), b.value = !1;
    }, Ce), Yt = (Ie) => {
      h.previousQuery === Ie || N.value || (h.previousQuery = Ie, e.filterable && Fe(e.filterMethod) ? e.filterMethod(Ie) : e.filterable && e.remote && Fe(e.remoteMethod) && e.remoteMethod(Ie), e.defaultFirstOption && (e.filterable || e.remote) && H.value.length ? Re($n) : Re(Tt));
    }, $n = () => {
      const Ie = H.value.filter((Et) => !Et.disabled && Et.type !== "Group"), at = Ie.find((Et) => Et.created), mt = Ie[0];
      h.hoveringIndex = ht(H.value, at || mt);
    }, xe = (Ie) => {
      ln(e.modelValue, Ie) || t(gt, Ie);
    }, wt = (Ie) => {
      t(et, Ie), xe(Ie), h.previousValue = e.multiple ? String(Ie) : Ie, Re(() => {
        if (e.multiple && ye(e.modelValue)) {
          const at = h.cachedOptions.slice(), mt = e.modelValue.map((Et) => ll(Et, at));
          ln(h.cachedOptions, mt) || (h.cachedOptions = mt);
        } else
          Er(!0);
      });
    }, ht = (Ie = [], at) => {
      if (!ot(at))
        return Ie.indexOf(at);
      const mt = e.valueKey;
      let Et = -1;
      return Ie.some((gn, So) => dn(gn, mt) === dn(at, mt) ? (Et = So, !0) : !1), Et;
    }, sn = (Ie) => ot(Ie) ? dn(Ie, e.valueKey) : Ie, Co = () => {
      Me();
    }, uo = () => {
      h.selectionWidth = Number.parseFloat(window.getComputedStyle(w.value).width);
    }, ef = () => {
      h.collapseItemWidth = O.value.getBoundingClientRect().width;
    }, Os = () => {
      var Ie, at;
      (at = (Ie = y.value) == null ? void 0 : Ie.updatePopper) == null || at.call(Ie);
    }, yu = () => {
      var Ie, at;
      (at = (Ie = E.value) == null ? void 0 : Ie.updatePopper) == null || at.call(Ie);
    }, Da = (Ie) => {
      const at = d(Ie);
      if (e.multiple) {
        let mt = e.modelValue.slice();
        const Et = ht(mt, at);
        Et > -1 ? (mt = [
          ...mt.slice(0, Et),
          ...mt.slice(Et + 1)
        ], h.cachedOptions.splice(Et, 1), Ke(Ie)) : (e.multipleLimit <= 0 || mt.length < e.multipleLimit) && (mt = [...mt, at], h.cachedOptions.push(Ie), St(Ie)), wt(mt), Ie.created && Yt(""), e.filterable && !e.reserveKeyword && (h.inputValue = "");
      } else
        h.selectedLabel = c(Ie), !ln(e.modelValue, at) && wt(at), K.value = !1, St(Ie), Ie.created || Ft();
      Ol();
    }, wu = (Ie, at) => {
      let mt = e.modelValue.slice();
      const Et = ht(mt, d(at));
      Et > -1 && !M.value && (mt = [
        ...e.modelValue.slice(0, Et),
        ...e.modelValue.slice(Et + 1)
      ], h.cachedOptions.splice(Et, 1), wt(mt), t("remove-tag", d(at)), Ke(at)), Ie.stopPropagation(), Ol();
    }, Ol = () => {
      var Ie;
      (Ie = k.value) == null || Ie.focus();
    }, tf = () => {
      var Ie;
      if (K.value) {
        K.value = !1, Re(() => {
          var at;
          return (at = k.value) == null ? void 0 : at.blur();
        });
        return;
      }
      (Ie = k.value) == null || Ie.blur();
    }, nf = () => {
      h.inputValue.length > 0 ? h.inputValue = "" : K.value = !1;
    }, of = (Ie) => U1(Ie, (at) => !h.cachedOptions.some((mt) => d(mt) === at && f(mt))), lf = (Ie) => {
      const at = Ht(Ie);
      if (e.multiple && at !== _e.delete && h.inputValue.length === 0) {
        Ie.preventDefault();
        const mt = e.modelValue.slice(), Et = of(mt);
        if (Et < 0)
          return;
        const gn = mt[Et];
        mt.splice(Et, 1);
        const So = h.cachedOptions[Et];
        h.cachedOptions.splice(Et, 1), Ke(So), wt(mt), t("remove-tag", gn);
      }
    }, af = () => {
      let Ie;
      ye(e.modelValue) ? Ie = [] : Ie = p.value, h.selectedLabel = "", K.value = !1, wt(Ie), t("clear"), Ft(), Ol();
    }, Aa = (Ie, at = void 0) => {
      const mt = H.value;
      if (!["forward", "backward"].includes(Ie) || M.value || mt.length <= 0 || we.value || N.value)
        return;
      if (!K.value)
        return Se();
      kt(at) && (at = h.hoveringIndex);
      let Et = -1;
      Ie === "forward" ? (Et = at + 1, Et >= mt.length && (Et = 0)) : Ie === "backward" && (Et = at - 1, (Et < 0 || Et >= mt.length) && (Et = mt.length - 1));
      const gn = mt[Et];
      if (f(gn) || gn.type === "Group")
        return Aa(Ie, Et);
      h.hoveringIndex = Et, Rn(Et);
    }, $e = () => {
      if (K.value)
        ~h.hoveringIndex && H.value[h.hoveringIndex] && Da(H.value[h.hoveringIndex]);
      else return Se();
    }, nt = (Ie) => {
      h.hoveringIndex = Ie ?? -1;
    }, Tt = () => {
      e.multiple ? h.hoveringIndex = H.value.findIndex((Ie) => e.modelValue.some((at) => sn(at) === sn(d(Ie)))) : h.hoveringIndex = H.value.findIndex((Ie) => sn(d(Ie)) === sn(e.modelValue));
    }, Gt = (Ie) => {
      if (h.inputValue = Ie.target.value, e.remote)
        b.value = !0, lt();
      else
        return Je();
    }, an = (Ie) => {
      if (K.value = !1, D.value) {
        const at = new FocusEvent("blur", Ie);
        L(at);
      }
    }, Ln = () => (h.isBeforeHide = !1, Re(() => {
      ~tt.value && Rn(tt.value);
    })), Rn = (Ie) => {
      I.value.scrollToItem(Ie);
    }, ll = (Ie, at) => {
      const mt = sn(Ie);
      if (Oe.value.has(mt)) {
        const { option: Et } = Oe.value.get(mt);
        return Et;
      }
      if (at && at.length) {
        const Et = at.find((gn) => sn(d(gn)) === mt);
        if (Et)
          return Et;
      }
      return {
        [u.value.value]: Ie,
        [u.value.label]: Ie
      };
    }, Il = (Ie) => {
      var at, mt;
      return (mt = (at = Oe.value.get(d(Ie))) == null ? void 0 : at.index) != null ? mt : -1;
    }, Er = (Ie = !1) => {
      if (e.multiple)
        if (e.modelValue.length > 0) {
          const at = h.cachedOptions.slice();
          h.cachedOptions.length = 0, h.previousValue = e.modelValue.toString();
          for (const mt of e.modelValue) {
            const Et = ll(mt, at);
            h.cachedOptions.push(Et);
          }
        } else
          h.cachedOptions = [], h.previousValue = void 0;
      else if (ie.value) {
        h.previousValue = e.modelValue;
        const at = H.value, mt = at.findIndex((Et) => sn(d(Et)) === sn(e.modelValue));
        ~mt ? h.selectedLabel = c(at[mt]) : (!h.selectedLabel || Ie) && (h.selectedLabel = sn(e.modelValue));
      } else
        h.selectedLabel = "", h.previousValue = void 0;
      Ft(), Me();
    };
    return de(() => e.fitInputWidth, () => {
      Me();
    }), de(K, (Ie) => {
      Ie ? (e.persistent || Me(), Yt("")) : (h.inputValue = "", h.previousQuery = null, h.isBeforeHide = !0, ve("")), t("visible-change", Ie);
    }), de(() => e.modelValue, (Ie, at) => {
      var mt;
      (!Ie || ye(Ie) && Ie.length === 0 || e.multiple && !ln(Ie.toString(), h.previousValue) || !e.multiple && sn(Ie) !== sn(h.previousValue)) && Er(!0), !ln(Ie, at) && e.validateEvent && ((mt = r == null ? void 0 : r.validate) == null || mt.call(r, "change").catch((gn) => vt(gn)));
    }, {
      deep: !0
    }), de(() => e.options, () => {
      const Ie = k.value;
      (!Ie || Ie && document.activeElement !== Ie) && Er();
    }, {
      deep: !0,
      flush: "post"
    }), de(() => H.value, () => (Me(), I.value && Re(I.value.resetScrollTop))), to(() => {
      h.isBeforeHide || Ee();
    }), to(() => {
      const { valueKey: Ie, options: at } = e, mt = /* @__PURE__ */ new Map();
      for (const Et of at) {
        const gn = d(Et);
        let So = gn;
        if (ot(So) && (So = dn(gn, Ie)), mt.get(So)) {
          vt("ElSelectV2", "The option values you provided seem to be duplicated, which may cause some problems, please check.");
          break;
        } else
          mt.set(So, !0);
      }
    }), ft(() => {
      Er();
    }), qt(C, Co), qt(w, uo), qt(I, Os), qt(R, Os), qt(P, yu), qt(O, ef), {
      inputId: i,
      collapseTagSize: Pe,
      currentPlaceholder: Nt,
      expanded: K,
      emptyText: te,
      popupHeight: J,
      debounce: Ce,
      allOptions: V,
      allOptionsValueMap: Oe,
      filteredOptions: H,
      iconComponent: re,
      iconReverse: se,
      tagStyle: Le,
      collapseTagStyle: Xe,
      popperSize: g,
      dropdownMenuVisible: fe,
      hasModelValue: ie,
      shouldShowPlaceholder: ut,
      selectDisabled: M,
      selectSize: me,
      needStatusIcon: Z,
      showClearBtn: ue,
      states: h,
      isFocused: D,
      nsSelect: o,
      nsInput: l,
      inputRef: k,
      menuRef: I,
      tagMenuRef: P,
      tooltipRef: y,
      tagTooltipRef: E,
      selectRef: C,
      wrapperRef: R,
      selectionRef: w,
      prefixRef: T,
      suffixRef: x,
      collapseItemRef: O,
      popperRef: Ye,
      validateState: ne,
      validateIcon: le,
      showTagList: He,
      collapseTagList: Qe,
      debouncedOnInputChange: lt,
      deleteTag: wu,
      getLabel: c,
      getValue: d,
      getDisabled: f,
      getValueKey: sn,
      getIndex: Il,
      handleClear: af,
      handleClickOutside: an,
      handleDel: lf,
      handleEsc: nf,
      focus: Ol,
      blur: tf,
      handleMenuEnter: Ln,
      handleResize: Co,
      resetSelectionWidth: uo,
      updateTooltip: Os,
      updateTagTooltip: yu,
      updateOptions: Ee,
      toggleMenu: Se,
      scrollTo: Rn,
      onInput: Gt,
      onKeyboardNavigate: Aa,
      onKeyboardSelect: $e,
      onSelect: Da,
      onHover: nt,
      handleCompositionStart: z,
      handleCompositionEnd: Y,
      handleCompositionUpdate: G
    };
  }, MW = /* @__PURE__ */ U({
    name: "ElSelectV2",
    components: {
      ElSelectMenu: $W,
      ElTag: Wl,
      ElTooltip: Pn,
      ElIcon: ze
    },
    directives: { ClickOutside: Jl },
    props: sW,
    emits: uW,
    setup(e, { emit: t }) {
      const n = S(() => {
        const { modelValue: u, multiple: c } = e, d = c ? [] : void 0;
        return ye(u) ? c ? u : d : c ? d : u;
      }), o = IW(Rt({
        ...wn(e),
        modelValue: n
      }), t), { calculatorRef: l, inputStyle: a } = Uh(), r = xn();
      yt(em, {
        props: Rt({
          ...wn(e),
          height: o.popupHeight,
          modelValue: n
        }),
        expanded: o.expanded,
        tooltipRef: o.tooltipRef,
        contentId: r,
        onSelect: o.onSelect,
        onHover: o.onHover,
        onKeyboardNavigate: o.onKeyboardNavigate,
        onKeyboardSelect: o.onKeyboardSelect
      });
      const i = S(() => e.multiple ? o.states.cachedOptions.map((u) => o.getLabel(u)) : o.states.selectedLabel);
      return {
        ...o,
        modelValue: n,
        selectedLabel: i,
        calculatorRef: l,
        inputStyle: a,
        contentId: r,
        BORDER_HORIZONTAL_WIDTH: BE
      };
    }
  });
  function xW(e, t, n, o, l, a) {
    const r = $t("el-tag"), i = $t("el-tooltip"), u = $t("el-icon"), c = $t("el-select-menu"), d = bd("click-outside");
    return it((_(), B("div", {
      ref: "selectRef",
      class: $([e.nsSelect.b(), e.nsSelect.m(e.selectSize)]),
      onMouseenter: (f) => e.states.inputHovering = !0,
      onMouseleave: (f) => e.states.inputHovering = !1
    }, [
      q(i, {
        ref: "tooltipRef",
        visible: e.dropdownMenuVisible,
        teleported: e.teleported,
        "popper-class": [e.nsSelect.e("popper"), e.popperClass],
        "popper-style": e.popperStyle,
        "gpu-acceleration": !1,
        "stop-popper-mouse-event": !1,
        "popper-options": e.popperOptions,
        "fallback-placements": e.fallbackPlacements,
        effect: e.effect,
        placement: e.placement,
        pure: "",
        transition: `${e.nsSelect.namespace.value}-zoom-in-top`,
        trigger: "click",
        persistent: e.persistent,
        "append-to": e.appendTo,
        "show-arrow": e.showArrow,
        offset: e.offset,
        onBeforeShow: e.handleMenuEnter,
        onHide: (f) => e.states.isBeforeHide = !1
      }, {
        default: Q(() => {
          var f, v;
          return [
            W("div", {
              ref: "wrapperRef",
              class: $([
                e.nsSelect.e("wrapper"),
                e.nsSelect.is("focused", e.isFocused),
                e.nsSelect.is("hovering", e.states.inputHovering),
                e.nsSelect.is("filterable", e.filterable),
                e.nsSelect.is("disabled", e.selectDisabled)
              ]),
              onClick: Ze(e.toggleMenu, ["prevent"])
            }, [
              e.$slots.prefix ? (_(), B("div", {
                key: 0,
                ref: "prefixRef",
                class: $(e.nsSelect.e("prefix"))
              }, [
                ee(e.$slots, "prefix")
              ], 2)) : oe("v-if", !0),
              W("div", {
                ref: "selectionRef",
                class: $([
                  e.nsSelect.e("selection"),
                  e.nsSelect.is("near", e.multiple && !e.$slots.prefix && !!e.modelValue.length)
                ])
              }, [
                e.multiple ? ee(e.$slots, "tag", {
                  key: 0,
                  data: e.states.cachedOptions,
                  deleteTag: e.deleteTag,
                  selectDisabled: e.selectDisabled
                }, () => [
                  (_(!0), B(We, null, bt(e.showTagList, (p) => (_(), B("div", {
                    key: e.getValueKey(e.getValue(p)),
                    class: $(e.nsSelect.e("selected-item"))
                  }, [
                    q(r, {
                      closable: !e.selectDisabled && !e.getDisabled(p),
                      size: e.collapseTagSize,
                      type: e.tagType,
                      effect: e.tagEffect,
                      "disable-transitions": "",
                      style: Ue(e.tagStyle),
                      onClose: (m) => e.deleteTag(m, p)
                    }, {
                      default: Q(() => [
                        W("span", {
                          class: $(e.nsSelect.e("tags-text"))
                        }, [
                          ee(e.$slots, "label", {
                            index: e.getIndex(p),
                            label: e.getLabel(p),
                            value: e.getValue(p)
                          }, () => [
                            Ct(ke(e.getLabel(p)), 1)
                          ])
                        ], 2)
                      ]),
                      _: 2
                    }, 1032, ["closable", "size", "type", "effect", "style", "onClose"])
                  ], 2))), 128)),
                  e.collapseTags && e.modelValue.length > e.maxCollapseTags ? (_(), ae(i, {
                    key: 0,
                    ref: "tagTooltipRef",
                    disabled: e.dropdownMenuVisible || !e.collapseTagsTooltip,
                    "fallback-placements": ["bottom", "top", "right", "left"],
                    effect: e.effect,
                    placement: "bottom",
                    "popper-class": e.popperClass,
                    "popper-style": e.popperStyle,
                    teleported: e.teleported
                  }, {
                    default: Q(() => [
                      W("div", {
                        ref: "collapseItemRef",
                        class: $(e.nsSelect.e("selected-item"))
                      }, [
                        q(r, {
                          closable: !1,
                          size: e.collapseTagSize,
                          type: e.tagType,
                          effect: e.tagEffect,
                          style: Ue(e.collapseTagStyle),
                          "disable-transitions": ""
                        }, {
                          default: Q(() => [
                            W("span", {
                              class: $(e.nsSelect.e("tags-text"))
                            }, " + " + ke(e.modelValue.length - e.maxCollapseTags), 3)
                          ]),
                          _: 1
                        }, 8, ["size", "type", "effect", "style"])
                      ], 2)
                    ]),
                    content: Q(() => [
                      W("div", {
                        ref: "tagMenuRef",
                        class: $(e.nsSelect.e("selection"))
                      }, [
                        (_(!0), B(We, null, bt(e.collapseTagList, (p) => (_(), B("div", {
                          key: e.getValueKey(e.getValue(p)),
                          class: $(e.nsSelect.e("selected-item"))
                        }, [
                          q(r, {
                            class: "in-tooltip",
                            closable: !e.selectDisabled && !e.getDisabled(p),
                            size: e.collapseTagSize,
                            type: e.tagType,
                            effect: e.tagEffect,
                            "disable-transitions": "",
                            onClose: (m) => e.deleteTag(m, p)
                          }, {
                            default: Q(() => [
                              W("span", {
                                class: $(e.nsSelect.e("tags-text"))
                              }, [
                                ee(e.$slots, "label", {
                                  index: e.getIndex(p),
                                  label: e.getLabel(p),
                                  value: e.getValue(p)
                                }, () => [
                                  Ct(ke(e.getLabel(p)), 1)
                                ])
                              ], 2)
                            ]),
                            _: 2
                          }, 1032, ["closable", "size", "type", "effect", "onClose"])
                        ], 2))), 128))
                      ], 2)
                    ]),
                    _: 3
                  }, 8, ["disabled", "effect", "popper-class", "popper-style", "teleported"])) : oe("v-if", !0)
                ]) : oe("v-if", !0),
                W("div", {
                  class: $([
                    e.nsSelect.e("selected-item"),
                    e.nsSelect.e("input-wrapper"),
                    e.nsSelect.is("hidden", !e.filterable || e.selectDisabled)
                  ])
                }, [
                  it(W("input", {
                    id: e.inputId,
                    ref: "inputRef",
                    "onUpdate:modelValue": (p) => e.states.inputValue = p,
                    style: Ue(e.inputStyle),
                    autocomplete: e.autocomplete,
                    tabindex: e.tabindex,
                    "aria-autocomplete": "none",
                    "aria-haspopup": "listbox",
                    autocapitalize: "off",
                    "aria-expanded": e.expanded,
                    "aria-label": e.ariaLabel,
                    class: $([e.nsSelect.e("input"), e.nsSelect.is(e.selectSize)]),
                    disabled: e.selectDisabled,
                    role: "combobox",
                    "aria-controls": e.contentId,
                    "aria-activedescendant": e.states.hoveringIndex >= 0 ? `${e.contentId}-${e.states.hoveringIndex}` : "",
                    readonly: !e.filterable,
                    spellcheck: "false",
                    type: "text",
                    name: e.name,
                    onInput: e.onInput,
                    onCompositionstart: e.handleCompositionStart,
                    onCompositionupdate: e.handleCompositionUpdate,
                    onCompositionend: e.handleCompositionEnd,
                    onKeydown: [
                      on(Ze((p) => e.onKeyboardNavigate("backward"), ["stop", "prevent"]), ["up"]),
                      on(Ze((p) => e.onKeyboardNavigate("forward"), ["stop", "prevent"]), ["down"]),
                      on(Ze(e.onKeyboardSelect, ["stop", "prevent"]), ["enter"]),
                      on(Ze(e.handleEsc, ["stop", "prevent"]), ["esc"]),
                      on(Ze(e.handleDel, ["stop"]), ["delete"])
                    ],
                    onClick: Ze(e.toggleMenu, ["stop"])
                  }, null, 46, ["id", "onUpdate:modelValue", "autocomplete", "tabindex", "aria-expanded", "aria-label", "disabled", "aria-controls", "aria-activedescendant", "readonly", "name", "onInput", "onCompositionstart", "onCompositionupdate", "onCompositionend", "onKeydown", "onClick"]), [
                    [Sd, e.states.inputValue]
                  ]),
                  e.filterable ? (_(), B("span", {
                    key: 0,
                    ref: "calculatorRef",
                    "aria-hidden": "true",
                    class: $(e.nsSelect.e("input-calculator")),
                    textContent: ke(e.states.inputValue)
                  }, null, 10, ["textContent"])) : oe("v-if", !0)
                ], 2),
                e.shouldShowPlaceholder ? (_(), B("div", {
                  key: 1,
                  class: $([
                    e.nsSelect.e("selected-item"),
                    e.nsSelect.e("placeholder"),
                    e.nsSelect.is("transparent", !e.hasModelValue || e.expanded && !e.states.inputValue)
                  ])
                }, [
                  e.hasModelValue ? ee(e.$slots, "label", {
                    key: 0,
                    index: (v = (f = e.allOptionsValueMap.get(e.modelValue)) == null ? void 0 : f.index) != null ? v : -1,
                    label: e.currentPlaceholder,
                    value: e.modelValue
                  }, () => [
                    W("span", null, ke(e.currentPlaceholder), 1)
                  ]) : (_(), B("span", { key: 1 }, ke(e.currentPlaceholder), 1))
                ], 2)) : oe("v-if", !0)
              ], 2),
              W("div", {
                ref: "suffixRef",
                class: $(e.nsSelect.e("suffix"))
              }, [
                e.iconComponent ? it((_(), ae(u, {
                  key: 0,
                  class: $([e.nsSelect.e("caret"), e.nsInput.e("icon"), e.iconReverse])
                }, {
                  default: Q(() => [
                    (_(), ae(ct(e.iconComponent)))
                  ]),
                  _: 1
                }, 8, ["class"])), [
                  [Mt, !e.showClearBtn]
                ]) : oe("v-if", !0),
                e.showClearBtn && e.clearIcon ? (_(), ae(u, {
                  key: 1,
                  class: $([
                    e.nsSelect.e("caret"),
                    e.nsInput.e("icon"),
                    e.nsSelect.e("clear")
                  ]),
                  onClick: Ze(e.handleClear, ["prevent", "stop"])
                }, {
                  default: Q(() => [
                    (_(), ae(ct(e.clearIcon)))
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])) : oe("v-if", !0),
                e.validateState && e.validateIcon && e.needStatusIcon ? (_(), ae(u, {
                  key: 2,
                  class: $([
                    e.nsInput.e("icon"),
                    e.nsInput.e("validateIcon"),
                    e.nsInput.is("loading", e.validateState === "validating")
                  ])
                }, {
                  default: Q(() => [
                    (_(), ae(ct(e.validateIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : oe("v-if", !0)
              ], 2)
            ], 10, ["onClick"])
          ];
        }),
        content: Q(() => [
          q(c, {
            id: e.contentId,
            ref: "menuRef",
            data: e.filteredOptions,
            width: e.popperSize - e.BORDER_HORIZONTAL_WIDTH,
            "hovering-index": e.states.hoveringIndex,
            "scrollbar-always-on": e.scrollbarAlwaysOn,
            "aria-label": e.ariaLabel
          }, io({
            default: Q((f) => [
              ee(e.$slots, "default", Bo(fl(f)))
            ]),
            _: 2
          }, [
            e.$slots.header ? {
              name: "header",
              fn: Q(() => [
                W("div", {
                  class: $(e.nsSelect.be("dropdown", "header")),
                  onClick: Ze(() => {
                  }, ["stop"])
                }, [
                  ee(e.$slots, "header")
                ], 10, ["onClick"])
              ])
            } : void 0,
            e.$slots.loading && e.loading ? {
              name: "loading",
              fn: Q(() => [
                W("div", {
                  class: $(e.nsSelect.be("dropdown", "loading"))
                }, [
                  ee(e.$slots, "loading")
                ], 2)
              ])
            } : e.loading || e.filteredOptions.length === 0 ? {
              name: "empty",
              fn: Q(() => [
                W("div", {
                  class: $(e.nsSelect.be("dropdown", "empty"))
                }, [
                  ee(e.$slots, "empty", {}, () => [
                    W("span", null, ke(e.emptyText), 1)
                  ])
                ], 2)
              ])
            } : void 0,
            e.$slots.footer ? {
              name: "footer",
              fn: Q(() => [
                W("div", {
                  class: $(e.nsSelect.be("dropdown", "footer")),
                  onClick: Ze(() => {
                  }, ["stop"])
                }, [
                  ee(e.$slots, "footer")
                ], 10, ["onClick"])
              ])
            } : void 0
          ]), 1032, ["id", "data", "width", "hovering-index", "scrollbar-always-on", "aria-label"])
        ]),
        _: 3
      }, 8, ["visible", "teleported", "popper-class", "popper-style", "popper-options", "fallback-placements", "effect", "placement", "transition", "persistent", "append-to", "show-arrow", "offset", "onBeforeShow", "onHide"])
    ], 42, ["onMouseenter", "onMouseleave"])), [
      [d, e.handleClickOutside, e.popperRef]
    ]);
  }
  var PW = /* @__PURE__ */ Ne(MW, [["render", xW], ["__file", "select.vue"]]);
  const RW = rt(PW), DW = Te({
    animated: Boolean,
    count: {
      type: Number,
      default: 1
    },
    rows: {
      type: Number,
      default: 3
    },
    loading: {
      type: Boolean,
      default: !0
    },
    throttle: {
      type: X([Number, Object])
    }
  }), AW = Te({
    variant: {
      type: String,
      values: [
        "circle",
        "rect",
        "h1",
        "h3",
        "text",
        "caption",
        "p",
        "image",
        "button"
      ],
      default: "text"
    }
  }), VW = /* @__PURE__ */ U({
    name: "ElSkeletonItem"
  }), LW = /* @__PURE__ */ U({
    ...VW,
    props: AW,
    setup(e) {
      const t = he("skeleton");
      return (n, o) => (_(), B("div", {
        class: $([s(t).e("item"), s(t).e(n.variant)])
      }, [
        n.variant === "image" ? (_(), ae(s(vD), { key: 0 })) : oe("v-if", !0)
      ], 2));
    }
  });
  var ed = /* @__PURE__ */ Ne(LW, [["__file", "skeleton-item.vue"]]);
  const BW = (e, t = 0) => {
    if (t === 0)
      return e;
    const n = ot(t) && !!t.initVal, o = A(n);
    let l = null;
    const a = (i) => {
      if (kt(i)) {
        o.value = e.value;
        return;
      }
      l && clearTimeout(l), l = setTimeout(() => {
        o.value = e.value;
      }, i);
    }, r = (i) => {
      i === "leading" ? je(t) ? a(t) : a(t.leading) : ot(t) ? a(t.trailing) : o.value = !1;
    };
    return ft(() => r("leading")), de(() => e.value, (i) => {
      r(i ? "leading" : "trailing");
    }), o;
  }, FW = /* @__PURE__ */ U({
    name: "ElSkeleton"
  }), zW = /* @__PURE__ */ U({
    ...FW,
    props: DW,
    setup(e, { expose: t }) {
      const n = e, o = he("skeleton"), l = BW(At(n, "loading"), n.throttle);
      return t({
        uiLoading: l
      }), (a, r) => s(l) ? (_(), B("div", pt({
        key: 0,
        class: [s(o).b(), s(o).is("animated", a.animated)]
      }, a.$attrs), [
        (_(!0), B(We, null, bt(a.count, (i) => (_(), B(We, { key: i }, [
          s(l) ? ee(a.$slots, "template", { key: i }, () => [
            q(ed, {
              class: $(s(o).is("first")),
              variant: "p"
            }, null, 8, ["class"]),
            (_(!0), B(We, null, bt(a.rows, (u) => (_(), ae(ed, {
              key: u,
              class: $([
                s(o).e("paragraph"),
                s(o).is("last", u === a.rows && a.rows > 1)
              ]),
              variant: "p"
            }, null, 8, ["class"]))), 128))
          ]) : oe("v-if", !0)
        ], 64))), 128))
      ], 16)) : ee(a.$slots, "default", Bo(pt({ key: 1 }, a.$attrs)));
    }
  });
  var HW = /* @__PURE__ */ Ne(zW, [["__file", "skeleton.vue"]]);
  const KW = rt(HW, {
    SkeletonItem: ed
  }), WW = nn(ed), ak = Symbol("sliderContextKey"), jW = Te({
    modelValue: {
      type: X([Number, Array]),
      default: 0
    },
    id: {
      type: String,
      default: void 0
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1
    },
    showInput: Boolean,
    showInputControls: {
      type: Boolean,
      default: !0
    },
    size: mn,
    inputSize: mn,
    showStops: Boolean,
    showTooltip: {
      type: Boolean,
      default: !0
    },
    formatTooltip: {
      type: X(Function),
      default: void 0
    },
    disabled: Boolean,
    range: Boolean,
    vertical: Boolean,
    height: String,
    rangeStartLabel: {
      type: String,
      default: void 0
    },
    rangeEndLabel: {
      type: String,
      default: void 0
    },
    formatValueText: {
      type: X(Function),
      default: void 0
    },
    tooltipClass: {
      type: String,
      default: void 0
    },
    placement: {
      type: String,
      values: aa,
      default: "top"
    },
    marks: {
      type: X(Object)
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    persistent: {
      type: Boolean,
      default: !0
    },
    ...Yn(["ariaLabel"])
  }), zf = (e) => je(e) || ye(e) && e.every(je), UW = {
    [et]: zf,
    [fn]: zf,
    [gt]: zf
  }, YW = Te({
    modelValue: {
      type: Number,
      default: 0
    },
    vertical: Boolean,
    tooltipClass: String,
    placement: {
      type: String,
      values: aa,
      default: "top"
    }
  }), qW = {
    [et]: (e) => je(e)
  }, GW = (e, t, n) => {
    const o = A(), l = A(!1), a = S(() => t.value instanceof Function), r = S(() => a.value && t.value(e.modelValue) || e.modelValue), i = wl(() => {
      n.value && (l.value = !0);
    }, 50), u = wl(() => {
      n.value && (l.value = !1);
    }, 50);
    return {
      tooltip: o,
      tooltipVisible: l,
      formatValue: r,
      displayTooltip: i,
      hideTooltip: u
    };
  }, XW = (e, t, n) => {
    const {
      disabled: o,
      min: l,
      max: a,
      step: r,
      showTooltip: i,
      persistent: u,
      precision: c,
      sliderSize: d,
      formatTooltip: f,
      emitChange: v,
      resetSize: p,
      updateDragging: m
    } = Ve(ak), { tooltip: h, tooltipVisible: g, formatValue: b, displayTooltip: C, hideTooltip: w } = GW(e, f, i), y = A(), E = S(() => `${(e.modelValue - l.value) / (a.value - l.value) * 100}%`), k = S(() => e.vertical ? { bottom: E.value } : { left: E.value }), T = () => {
      t.hovering = !0, C();
    }, x = () => {
      t.hovering = !1, t.dragging || w();
    }, I = (K) => {
      o.value || (K.preventDefault(), L(K), window.addEventListener("mousemove", V), window.addEventListener("touchmove", V), window.addEventListener("mouseup", F), window.addEventListener("touchend", F), window.addEventListener("contextmenu", F), y.value.focus());
    }, P = (K) => {
      o.value || (t.newPosition = Number.parseFloat(E.value) + K / (a.value - l.value) * 100, H(t.newPosition), v());
    }, O = () => {
      P(-r.value);
    }, N = () => {
      P(r.value);
    }, z = () => {
      P(-r.value * 4);
    }, Y = () => {
      P(r.value * 4);
    }, G = () => {
      o.value || (H(0), v());
    }, M = () => {
      o.value || (H(100), v());
    }, R = (K) => {
      const Z = Ht(K);
      let J = !0;
      switch (Z) {
        case _e.left:
        case _e.down:
          O();
          break;
        case _e.right:
        case _e.up:
          N();
          break;
        case _e.home:
          G();
          break;
        case _e.end:
          M();
          break;
        case _e.pageDown:
          z();
          break;
        case _e.pageUp:
          Y();
          break;
        default:
          J = !1;
          break;
      }
      J && K.preventDefault();
    }, D = (K) => {
      let Z, J;
      return K.type.startsWith("touch") ? (J = K.touches[0].clientY, Z = K.touches[0].clientX) : (J = K.clientY, Z = K.clientX), {
        clientX: Z,
        clientY: J
      };
    }, L = (K) => {
      t.dragging = !0, t.isClick = !0;
      const { clientX: Z, clientY: J } = D(K);
      e.vertical ? t.startY = J : t.startX = Z, t.startPosition = Number.parseFloat(E.value), t.newPosition = t.startPosition;
    }, V = (K) => {
      if (t.dragging) {
        t.isClick = !1, C(), p();
        let Z;
        const { clientX: J, clientY: ie } = D(K);
        e.vertical ? (t.currentY = ie, Z = (t.startY - t.currentY) / d.value * 100) : (t.currentX = J, Z = (t.currentX - t.startX) / d.value * 100), t.newPosition = t.startPosition + Z, H(t.newPosition);
      }
    }, F = () => {
      t.dragging && (setTimeout(() => {
        t.dragging = !1, t.hovering || w(), t.isClick || H(t.newPosition), v();
      }, 0), window.removeEventListener("mousemove", V), window.removeEventListener("touchmove", V), window.removeEventListener("mouseup", F), window.removeEventListener("touchend", F), window.removeEventListener("contextmenu", F));
    }, H = async (K) => {
      if (K === null || Number.isNaN(+K))
        return;
      K = Od(K, 0, 100);
      const Z = Math.floor((a.value - l.value) / r.value), J = Z * r.value / (a.value - l.value) * 100, ie = J + (100 - J) / 2;
      let ue;
      if (K < J) {
        const re = J / Z, se = Math.round(K / re);
        ue = l.value + se * r.value;
      } else K < ie ? ue = l.value + Z * r.value : ue = a.value;
      ue = Number.parseFloat(ue.toFixed(c.value)), ue !== e.modelValue && n(et, ue), !t.dragging && e.modelValue !== t.oldValue && (t.oldValue = e.modelValue), await Re(), t.dragging && C(), h.value.updatePopper();
    };
    return de(() => t.dragging, (K) => {
      m(K);
    }), Dt(y, "touchstart", I, { passive: !1 }), {
      disabled: o,
      button: y,
      tooltip: h,
      tooltipVisible: g,
      showTooltip: i,
      persistent: u,
      wrapperStyle: k,
      formatValue: b,
      handleMouseEnter: T,
      handleMouseLeave: x,
      onButtonDown: I,
      onKeyDown: R,
      setPosition: H
    };
  }, JW = /* @__PURE__ */ U({
    name: "ElSliderButton"
  }), ZW = /* @__PURE__ */ U({
    ...JW,
    props: YW,
    emits: qW,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = he("slider"), a = Rt({
        hovering: !1,
        dragging: !1,
        isClick: !1,
        startX: 0,
        currentX: 0,
        startY: 0,
        currentY: 0,
        startPosition: 0,
        newPosition: 0,
        oldValue: o.modelValue
      }), r = S(() => d.value ? f.value : !1), {
        disabled: i,
        button: u,
        tooltip: c,
        showTooltip: d,
        persistent: f,
        tooltipVisible: v,
        wrapperStyle: p,
        formatValue: m,
        handleMouseEnter: h,
        handleMouseLeave: g,
        onButtonDown: b,
        onKeyDown: C,
        setPosition: w
      } = XW(o, a, n), { hovering: y, dragging: E } = wn(a);
      return t({
        onButtonDown: b,
        onKeyDown: C,
        setPosition: w,
        hovering: y,
        dragging: E
      }), (k, T) => (_(), B("div", {
        ref_key: "button",
        ref: u,
        class: $([s(l).e("button-wrapper"), { hover: s(y), dragging: s(E) }]),
        style: Ue(s(p)),
        tabindex: s(i) ? void 0 : 0,
        onMouseenter: s(h),
        onMouseleave: s(g),
        onMousedown: s(b),
        onFocus: s(h),
        onBlur: s(g),
        onKeydown: s(C)
      }, [
        q(s(Pn), {
          ref_key: "tooltip",
          ref: c,
          visible: s(v),
          placement: k.placement,
          "fallback-placements": ["top", "bottom", "right", "left"],
          "stop-popper-mouse-event": !1,
          "popper-class": k.tooltipClass,
          disabled: !s(d),
          persistent: s(r)
        }, {
          content: Q(() => [
            W("span", null, ke(s(m)), 1)
          ]),
          default: Q(() => [
            W("div", {
              class: $([s(l).e("button"), { hover: s(y), dragging: s(E) }])
            }, null, 2)
          ]),
          _: 1
        }, 8, ["visible", "placement", "popper-class", "disabled", "persistent"])
      ], 46, ["tabindex", "onMouseenter", "onMouseleave", "onMousedown", "onFocus", "onBlur", "onKeydown"]));
    }
  });
  var xy = /* @__PURE__ */ Ne(ZW, [["__file", "button.vue"]]);
  const QW = Te({
    mark: {
      type: X([String, Object]),
      default: void 0
    }
  });
  var ej = /* @__PURE__ */ U({
    name: "ElSliderMarker",
    props: QW,
    setup(e) {
      const t = he("slider"), n = S(() => Ae(e.mark) ? e.mark : e.mark.label), o = S(() => Ae(e.mark) ? void 0 : e.mark.style);
      return () => qe("div", {
        class: t.e("marks-text"),
        style: o.value
      }, n.value);
    }
  });
  const tj = (e, t, n) => {
    const { form: o, formItem: l } = Nn(), a = Ut(), r = A(), i = A(), u = {
      firstButton: r,
      secondButton: i
    }, c = S(() => e.disabled || (o == null ? void 0 : o.disabled) || !1), d = S(() => Math.min(t.firstValue, t.secondValue)), f = S(() => Math.max(t.firstValue, t.secondValue)), v = S(() => e.range ? `${100 * (f.value - d.value) / (e.max - e.min)}%` : `${100 * (t.firstValue - e.min) / (e.max - e.min)}%`), p = S(() => e.range ? `${100 * (d.value - e.min) / (e.max - e.min)}%` : "0%"), m = S(() => e.vertical ? { height: e.height } : {}), h = S(() => e.vertical ? {
      height: v.value,
      bottom: p.value
    } : {
      width: v.value,
      left: p.value
    }), g = () => {
      if (a.value) {
        const N = a.value.getBoundingClientRect();
        t.sliderSize = N[e.vertical ? "height" : "width"];
      }
    }, b = (N) => {
      const z = e.min + N * (e.max - e.min) / 100;
      if (!e.range)
        return r;
      let Y;
      return Math.abs(d.value - z) < Math.abs(f.value - z) ? Y = t.firstValue < t.secondValue ? "firstButton" : "secondButton" : Y = t.firstValue > t.secondValue ? "firstButton" : "secondButton", u[Y];
    }, C = (N) => {
      const z = b(N);
      return z.value.setPosition(N), z;
    }, w = (N) => {
      t.firstValue = N ?? e.min, E(e.range ? [d.value, f.value] : N ?? e.min);
    }, y = (N) => {
      t.secondValue = N, e.range && E([d.value, f.value]);
    }, E = (N) => {
      n(et, N), n(fn, N);
    }, k = async () => {
      await Re(), n(gt, e.range ? [d.value, f.value] : e.modelValue);
    }, T = (N) => {
      var z, Y, G, M, R, D;
      if (c.value || t.dragging)
        return;
      g();
      let L = 0;
      if (e.vertical) {
        const V = (G = (Y = (z = N.touches) == null ? void 0 : z.item(0)) == null ? void 0 : Y.clientY) != null ? G : N.clientY;
        L = (a.value.getBoundingClientRect().bottom - V) / t.sliderSize * 100;
      } else {
        const V = (D = (R = (M = N.touches) == null ? void 0 : M.item(0)) == null ? void 0 : R.clientX) != null ? D : N.clientX, F = a.value.getBoundingClientRect().left;
        L = (V - F) / t.sliderSize * 100;
      }
      if (!(L < 0 || L > 100))
        return C(L);
    };
    return {
      elFormItem: l,
      slider: a,
      firstButton: r,
      secondButton: i,
      sliderDisabled: c,
      minValue: d,
      maxValue: f,
      runwayStyle: m,
      barStyle: h,
      resetSize: g,
      setPosition: C,
      emitChange: k,
      onSliderWrapperPrevent: (N) => {
        var z, Y;
        ((z = u.firstButton.value) != null && z.dragging || (Y = u.secondButton.value) != null && Y.dragging) && N.preventDefault();
      },
      onSliderClick: (N) => {
        T(N) && k();
      },
      onSliderDown: async (N) => {
        const z = T(N);
        z && (await Re(), z.value.onButtonDown(N));
      },
      onSliderMarkerDown: (N) => {
        if (c.value || t.dragging)
          return;
        C(N) && k();
      },
      setFirstValue: w,
      setSecondValue: y
    };
  }, nj = (e, t, n, o) => ({
    stops: S(() => {
      if (!e.showStops || e.min > e.max)
        return [];
      if (e.step === 0)
        return vt("ElSlider", "step should not be 0."), [];
      const r = Math.ceil((e.max - e.min) / e.step), i = 100 * e.step / (e.max - e.min), u = Array.from({ length: r - 1 }).map((c, d) => (d + 1) * i);
      return e.range ? u.filter((c) => c < 100 * (n.value - e.min) / (e.max - e.min) || c > 100 * (o.value - e.min) / (e.max - e.min)) : u.filter((c) => c > 100 * (t.firstValue - e.min) / (e.max - e.min));
    }),
    getStopStyle: (r) => e.vertical ? { bottom: `${r}%` } : { left: `${r}%` }
  }), oj = (e) => S(() => e.marks ? Object.keys(e.marks).map(Number.parseFloat).sort((n, o) => n - o).filter((n) => n <= e.max && n >= e.min).map((n) => ({
    point: n,
    position: (n - e.min) * 100 / (e.max - e.min),
    mark: e.marks[n]
  })) : []), lj = (e, t, n, o, l, a) => {
    const r = (c) => {
      l(et, c), l(fn, c);
    }, i = () => e.range ? ![n.value, o.value].every((c, d) => c === t.oldValue[d]) : e.modelValue !== t.oldValue, u = () => {
      var c, d;
      e.min > e.max && Zt("Slider", "min should not be greater than max.");
      const f = e.modelValue;
      e.range && ye(f) ? f[1] < e.min ? r([e.min, e.min]) : f[0] > e.max ? r([e.max, e.max]) : f[0] < e.min ? r([e.min, f[1]]) : f[1] > e.max ? r([f[0], e.max]) : (t.firstValue = f[0], t.secondValue = f[1], i() && (e.validateEvent && ((c = a == null ? void 0 : a.validate) == null || c.call(a, "change").catch((v) => vt(v))), t.oldValue = f.slice())) : !e.range && je(f) && !Number.isNaN(f) && (f < e.min ? r(e.min) : f > e.max ? r(e.max) : (t.firstValue = f, i() && (e.validateEvent && ((d = a == null ? void 0 : a.validate) == null || d.call(a, "change").catch((v) => vt(v))), t.oldValue = f)));
    };
    u(), de(() => t.dragging, (c) => {
      c || u();
    }), de(() => e.modelValue, (c, d) => {
      t.dragging || ye(c) && ye(d) && c.every((f, v) => f === d[v]) && t.firstValue === c[0] && t.secondValue === c[1] || u();
    }, {
      deep: !0
    }), de(() => [e.min, e.max], () => {
      u();
    });
  }, aj = (e, t, n) => {
    const o = A();
    return ft(async () => {
      e.range ? (ye(e.modelValue) ? (t.firstValue = Math.max(e.min, e.modelValue[0]), t.secondValue = Math.min(e.max, e.modelValue[1])) : (t.firstValue = e.min, t.secondValue = e.max), t.oldValue = [t.firstValue, t.secondValue]) : (!je(e.modelValue) || Number.isNaN(e.modelValue) ? t.firstValue = e.min : t.firstValue = Math.min(e.max, Math.max(e.min, e.modelValue)), t.oldValue = t.firstValue), Dt(window, "resize", n), await Re(), n();
    }), {
      sliderWrapper: o
    };
  }, rj = /* @__PURE__ */ U({
    name: "ElSlider"
  }), sj = /* @__PURE__ */ U({
    ...rj,
    props: jW,
    emits: UW,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = he("slider"), { t: a } = _t(), r = Rt({
        firstValue: 0,
        secondValue: 0,
        oldValue: 0,
        dragging: !1,
        sliderSize: 1
      }), {
        elFormItem: i,
        slider: u,
        firstButton: c,
        secondButton: d,
        sliderDisabled: f,
        minValue: v,
        maxValue: p,
        runwayStyle: m,
        barStyle: h,
        resetSize: g,
        emitChange: b,
        onSliderWrapperPrevent: C,
        onSliderClick: w,
        onSliderDown: y,
        onSliderMarkerDown: E,
        setFirstValue: k,
        setSecondValue: T
      } = tj(o, r, n), { stops: x, getStopStyle: I } = nj(o, r, v, p), { inputId: P, isLabeledByFormItem: O } = wo(o, {
        formItemContext: i
      }), N = vn(), z = S(() => o.inputSize || N.value), Y = S(() => o.ariaLabel || a("el.slider.defaultLabel", {
        min: o.min,
        max: o.max
      })), G = S(() => o.range ? o.rangeStartLabel || a("el.slider.defaultRangeStartLabel") : Y.value), M = S(() => o.formatValueText ? o.formatValueText(K.value) : `${K.value}`), R = S(() => o.rangeEndLabel || a("el.slider.defaultRangeEndLabel")), D = S(() => o.formatValueText ? o.formatValueText(Z.value) : `${Z.value}`), L = S(() => [
        l.b(),
        l.m(N.value),
        l.is("vertical", o.vertical),
        { [l.m("with-input")]: o.showInput }
      ]), V = oj(o);
      lj(o, r, v, p, n, i);
      const F = S(() => {
        const ue = [o.min, o.max, o.step].map((re) => {
          const se = `${re}`.split(".")[1];
          return se ? se.length : 0;
        });
        return Math.max.apply(null, ue);
      }), { sliderWrapper: H } = aj(o, r, g), { firstValue: K, secondValue: Z, sliderSize: J } = wn(r), ie = (ue) => {
        r.dragging = ue;
      };
      return Dt(H, "touchstart", C, {
        passive: !1
      }), Dt(H, "touchmove", C, {
        passive: !1
      }), yt(ak, {
        ...wn(o),
        sliderSize: J,
        disabled: f,
        precision: F,
        emitChange: b,
        resetSize: g,
        updateDragging: ie
      }), t({
        onSliderClick: w
      }), (ue, re) => {
        var se, ne;
        return _(), B("div", {
          id: ue.range ? s(P) : void 0,
          ref_key: "sliderWrapper",
          ref: H,
          class: $(s(L)),
          role: ue.range ? "group" : void 0,
          "aria-label": ue.range && !s(O) ? s(Y) : void 0,
          "aria-labelledby": ue.range && s(O) ? (se = s(i)) == null ? void 0 : se.labelId : void 0
        }, [
          W("div", {
            ref_key: "slider",
            ref: u,
            class: $([
              s(l).e("runway"),
              { "show-input": ue.showInput && !ue.range },
              s(l).is("disabled", s(f))
            ]),
            style: Ue(s(m)),
            onMousedown: s(y),
            onTouchstartPassive: s(y)
          }, [
            W("div", {
              class: $(s(l).e("bar")),
              style: Ue(s(h))
            }, null, 6),
            q(xy, {
              id: ue.range ? void 0 : s(P),
              ref_key: "firstButton",
              ref: c,
              "model-value": s(K),
              vertical: ue.vertical,
              "tooltip-class": ue.tooltipClass,
              placement: ue.placement,
              role: "slider",
              "aria-label": ue.range || !s(O) ? s(G) : void 0,
              "aria-labelledby": !ue.range && s(O) ? (ne = s(i)) == null ? void 0 : ne.labelId : void 0,
              "aria-valuemin": ue.min,
              "aria-valuemax": ue.range ? s(Z) : ue.max,
              "aria-valuenow": s(K),
              "aria-valuetext": s(M),
              "aria-orientation": ue.vertical ? "vertical" : "horizontal",
              "aria-disabled": s(f),
              "onUpdate:modelValue": s(k)
            }, null, 8, ["id", "model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-labelledby", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"]),
            ue.range ? (_(), ae(xy, {
              key: 0,
              ref_key: "secondButton",
              ref: d,
              "model-value": s(Z),
              vertical: ue.vertical,
              "tooltip-class": ue.tooltipClass,
              placement: ue.placement,
              role: "slider",
              "aria-label": s(R),
              "aria-valuemin": s(K),
              "aria-valuemax": ue.max,
              "aria-valuenow": s(Z),
              "aria-valuetext": s(D),
              "aria-orientation": ue.vertical ? "vertical" : "horizontal",
              "aria-disabled": s(f),
              "onUpdate:modelValue": s(T)
            }, null, 8, ["model-value", "vertical", "tooltip-class", "placement", "aria-label", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext", "aria-orientation", "aria-disabled", "onUpdate:modelValue"])) : oe("v-if", !0),
            ue.showStops ? (_(), B("div", { key: 1 }, [
              (_(!0), B(We, null, bt(s(x), (le, Ce) => (_(), B("div", {
                key: Ce,
                class: $(s(l).e("stop")),
                style: Ue(s(I)(le))
              }, null, 6))), 128))
            ])) : oe("v-if", !0),
            s(V).length > 0 ? (_(), B(We, { key: 2 }, [
              W("div", null, [
                (_(!0), B(We, null, bt(s(V), (le, Ce) => (_(), B("div", {
                  key: Ce,
                  style: Ue(s(I)(le.position)),
                  class: $([s(l).e("stop"), s(l).e("marks-stop")])
                }, null, 6))), 128))
              ]),
              W("div", {
                class: $(s(l).e("marks"))
              }, [
                (_(!0), B(We, null, bt(s(V), (le, Ce) => (_(), ae(s(ej), {
                  key: Ce,
                  mark: le.mark,
                  style: Ue(s(I)(le.position)),
                  onMousedown: Ze((j) => s(E)(le.position), ["stop"])
                }, null, 8, ["mark", "style", "onMousedown"]))), 128))
              ], 2)
            ], 64)) : oe("v-if", !0)
          ], 46, ["onMousedown", "onTouchstartPassive"]),
          ue.showInput && !ue.range ? (_(), ae(s(LE), {
            key: 0,
            ref: "input",
            "model-value": s(K),
            class: $(s(l).e("input")),
            step: ue.step,
            disabled: s(f),
            controls: ue.showInputControls,
            min: ue.min,
            max: ue.max,
            precision: s(F),
            size: s(z),
            "onUpdate:modelValue": s(k),
            onChange: s(b)
          }, null, 8, ["model-value", "class", "step", "disabled", "controls", "min", "max", "precision", "size", "onUpdate:modelValue", "onChange"])) : oe("v-if", !0)
        ], 10, ["id", "role", "aria-label", "aria-labelledby"]);
      };
    }
  });
  var ij = /* @__PURE__ */ Ne(sj, [["__file", "slider.vue"]]);
  const uj = rt(ij), cj = Te({
    prefixCls: {
      type: String
    }
  }), Py = /* @__PURE__ */ U({
    name: "ElSpaceItem",
    props: cj,
    setup(e, { slots: t }) {
      const n = he("space"), o = S(() => `${e.prefixCls || n.b()}__item`);
      return () => qe("div", { class: o.value }, ee(t, "default"));
    }
  }), Ry = {
    small: 8,
    default: 12,
    large: 16
  };
  function dj(e) {
    const t = he("space"), n = S(() => [t.b(), t.m(e.direction), e.class]), o = A(0), l = A(0), a = S(() => {
      const i = e.wrap || e.fill ? { flexWrap: "wrap" } : {}, u = {
        alignItems: e.alignment
      }, c = {
        rowGap: `${l.value}px`,
        columnGap: `${o.value}px`
      };
      return [i, u, c, e.style];
    }), r = S(() => e.fill ? { flexGrow: 1, minWidth: `${e.fillRatio}%` } : {});
    return to(() => {
      const { size: i = "small", wrap: u, direction: c, fill: d } = e;
      if (ye(i)) {
        const [f = 0, v = 0] = i;
        o.value = f, l.value = v;
      } else {
        let f;
        je(i) ? f = i : f = Ry[i || "small"] || Ry.small, (u || d) && c === "horizontal" ? o.value = l.value = f : c === "horizontal" ? (o.value = f, l.value = 0) : (l.value = f, o.value = 0);
      }
    }), {
      classes: n,
      containerStyle: a,
      itemStyle: r
    };
  }
  const fj = Te({
    direction: {
      type: String,
      values: ["horizontal", "vertical"],
      default: "horizontal"
    },
    class: {
      type: X([
        String,
        Object,
        Array
      ]),
      default: ""
    },
    style: {
      type: X([String, Array, Object]),
      default: ""
    },
    alignment: {
      type: X(String),
      default: "center"
    },
    prefixCls: {
      type: String
    },
    spacer: {
      type: X([Object, String, Number, Array]),
      default: null,
      validator: (e) => Wt(e) || je(e) || Ae(e)
    },
    wrap: Boolean,
    fill: Boolean,
    fillRatio: {
      type: Number,
      default: 100
    },
    size: {
      type: [String, Array, Number],
      values: Tl,
      validator: (e) => je(e) || ye(e) && e.length === 2 && e.every(je)
    }
  }), pj = /* @__PURE__ */ U({
    name: "ElSpace",
    props: fj,
    setup(e, { slots: t }) {
      const { classes: n, containerStyle: o, itemStyle: l } = dj(e);
      function a(r, i = "", u = []) {
        const { prefixCls: c } = e;
        return r.forEach((d, f) => {
          Tp(d) ? ye(d.children) && d.children.forEach((v, p) => {
            Tp(v) && ye(v.children) ? a(v.children, `${i + p}-`, u) : Wt(v) && (v == null ? void 0 : v.type) === Qt ? u.push(v) : u.push(q(Py, {
              style: l.value,
              prefixCls: c,
              key: `nested-${i + p}`
            }, {
              default: () => [v]
            }, ko.PROPS | ko.STYLE, ["style", "prefixCls"]));
          }) : oL(d) && u.push(q(Py, {
            style: l.value,
            prefixCls: c,
            key: `LoopKey${i + f}`
          }, {
            default: () => [d]
          }, ko.PROPS | ko.STYLE, ["style", "prefixCls"]));
        }), u;
      }
      return () => {
        var r;
        const { spacer: i, direction: u } = e, c = ee(t, "default", { key: 0 }, () => []);
        if (((r = c.children) != null ? r : []).length === 0)
          return null;
        if (ye(c.children)) {
          let d = a(c.children);
          if (i) {
            const f = d.length - 1;
            d = d.reduce((v, p, m) => {
              const h = [...v, p];
              return m !== f && h.push(q("span", {
                style: [
                  l.value,
                  u === "vertical" ? "width: 100%" : null
                ],
                key: m
              }, [
                Wt(i) ? i : Ct(i, ko.TEXT)
              ], ko.STYLE)), h;
            }, []);
          }
          return q("div", {
            class: n.value,
            style: o.value
          }, d, ko.STYLE | ko.CLASS);
        }
        return c.children;
      };
    }
  }), vj = rt(pj), hj = Te({
    decimalSeparator: {
      type: String,
      default: "."
    },
    groupSeparator: {
      type: String,
      default: ","
    },
    precision: {
      type: Number,
      default: 0
    },
    formatter: Function,
    value: {
      type: X([Number, Object]),
      default: 0
    },
    prefix: String,
    suffix: String,
    title: String,
    valueStyle: {
      type: X([String, Object, Array])
    }
  }), mj = /* @__PURE__ */ U({
    name: "ElStatistic"
  }), gj = /* @__PURE__ */ U({
    ...mj,
    props: hj,
    setup(e, { expose: t }) {
      const n = e, o = he("statistic"), l = S(() => {
        const { value: a, formatter: r, precision: i, decimalSeparator: u, groupSeparator: c } = n;
        if (Fe(r))
          return r(a);
        if (!je(a) || Number.isNaN(a))
          return a;
        let [d, f = ""] = String(a).split(".");
        return f = f.padEnd(i, "0").slice(0, i > 0 ? i : 0), d = d.replace(/\B(?=(\d{3})+(?!\d))/g, c), [d, f].join(f ? u : "");
      });
      return t({
        displayValue: l
      }), (a, r) => (_(), B("div", {
        class: $(s(o).b())
      }, [
        a.$slots.title || a.title ? (_(), B("div", {
          key: 0,
          class: $(s(o).e("head"))
        }, [
          ee(a.$slots, "title", {}, () => [
            Ct(ke(a.title), 1)
          ])
        ], 2)) : oe("v-if", !0),
        W("div", {
          class: $(s(o).e("content"))
        }, [
          a.$slots.prefix || a.prefix ? (_(), B("div", {
            key: 0,
            class: $(s(o).e("prefix"))
          }, [
            ee(a.$slots, "prefix", {}, () => [
              W("span", null, ke(a.prefix), 1)
            ])
          ], 2)) : oe("v-if", !0),
          W("span", {
            class: $(s(o).e("number")),
            style: Ue(a.valueStyle)
          }, ke(s(l)), 7),
          a.$slots.suffix || a.suffix ? (_(), B("div", {
            key: 1,
            class: $(s(o).e("suffix"))
          }, [
            ee(a.$slots, "suffix", {}, () => [
              W("span", null, ke(a.suffix), 1)
            ])
          ], 2)) : oe("v-if", !0)
        ], 2)
      ], 2));
    }
  });
  var bj = /* @__PURE__ */ Ne(gj, [["__file", "statistic.vue"]]);
  const rk = rt(bj), yj = Te({
    format: {
      type: String,
      default: "HH:mm:ss"
    },
    prefix: String,
    suffix: String,
    title: String,
    value: {
      type: X([Number, Object]),
      default: 0
    },
    valueStyle: {
      type: X([String, Object, Array])
    }
  }), wj = {
    finish: () => !0,
    [gt]: (e) => je(e)
  }, Cj = [
    ["Y", 1e3 * 60 * 60 * 24 * 365],
    ["M", 1e3 * 60 * 60 * 24 * 30],
    ["D", 1e3 * 60 * 60 * 24],
    ["H", 1e3 * 60 * 60],
    ["m", 1e3 * 60],
    ["s", 1e3],
    ["S", 1]
  ], Dy = (e) => je(e) ? new Date(e).getTime() : e.valueOf(), Ay = (e, t) => {
    let n = e;
    const o = /\[([^\]]*)]/g;
    return Cj.reduce((a, [r, i]) => {
      const u = new RegExp(`${r}+(?![^\\[\\]]*\\])`, "g");
      if (u.test(a)) {
        const c = Math.floor(n / i);
        return n -= c * i, a.replace(u, (d) => String(c).padStart(d.length, "0"));
      }
      return a;
    }, t).replace(o, "$1");
  }, Sj = /* @__PURE__ */ U({
    name: "ElCountdown"
  }), Ej = /* @__PURE__ */ U({
    ...Sj,
    props: yj,
    emits: wj,
    setup(e, { expose: t, emit: n }) {
      const o = e;
      let l;
      const a = A(0), r = S(() => Ay(a.value, o.format)), i = (d) => Ay(d, o.format), u = () => {
        l && (Yl(l), l = void 0);
      }, c = () => {
        const d = Dy(o.value), f = () => {
          let v = d - Date.now();
          n(gt, v), v <= 0 ? (v = 0, u(), n("finish")) : l = Ul(f), a.value = v;
        };
        l = Ul(f);
      };
      return ft(() => {
        a.value = Dy(o.value) - Date.now(), de(() => [o.value, o.format], () => {
          u(), c();
        }, {
          immediate: !0
        });
      }), Bt(() => {
        u();
      }), t({
        displayValue: r
      }), (d, f) => (_(), ae(s(rk), {
        value: a.value,
        title: d.title,
        prefix: d.prefix,
        suffix: d.suffix,
        "value-style": d.valueStyle,
        formatter: i
      }, io({
        _: 2
      }, [
        bt(d.$slots, (v, p) => ({
          name: p,
          fn: Q(() => [
            ee(d.$slots, p)
          ])
        }))
      ]), 1032, ["value", "title", "prefix", "suffix", "value-style"]));
    }
  });
  var kj = /* @__PURE__ */ Ne(Ej, [["__file", "countdown.vue"]]);
  const _j = rt(kj), Tj = Te({
    space: {
      type: [Number, String],
      default: ""
    },
    active: {
      type: Number,
      default: 0
    },
    direction: {
      type: String,
      default: "horizontal",
      values: ["horizontal", "vertical"]
    },
    alignCenter: {
      type: Boolean
    },
    simple: {
      type: Boolean
    },
    finishStatus: {
      type: String,
      values: ["wait", "process", "finish", "error", "success"],
      default: "finish"
    },
    processStatus: {
      type: String,
      values: ["wait", "process", "finish", "error", "success"],
      default: "process"
    }
  }), Nj = {
    [gt]: (e, t) => [e, t].every(je)
  }, sk = "ElSteps", $j = /* @__PURE__ */ U({
    name: "ElSteps"
  }), Oj = /* @__PURE__ */ U({
    ...$j,
    props: Tj,
    emits: Nj,
    setup(e, { emit: t }) {
      const n = e, o = he("steps"), {
        children: l,
        addChild: a,
        removeChild: r,
        ChildrenSorter: i
      } = Fd(dt(), "ElStep");
      return de(l, () => {
        l.value.forEach((u, c) => {
          u.setIndex(c);
        });
      }), yt(sk, { props: n, steps: l, addStep: a, removeStep: r }), de(() => n.active, (u, c) => {
        t(gt, u, c);
      }), (u, c) => (_(), B("div", {
        class: $([s(o).b(), s(o).m(u.simple ? "simple" : u.direction)])
      }, [
        ee(u.$slots, "default"),
        q(s(i))
      ], 2));
    }
  });
  var Ij = /* @__PURE__ */ Ne(Oj, [["__file", "steps.vue"]]);
  const Mj = Te({
    title: {
      type: String,
      default: ""
    },
    icon: {
      type: Lt
    },
    description: {
      type: String,
      default: ""
    },
    status: {
      type: String,
      values: ["", "wait", "process", "finish", "error", "success"],
      default: ""
    }
  }), xj = /* @__PURE__ */ U({
    name: "ElStep"
  }), Pj = /* @__PURE__ */ U({
    ...xj,
    props: Mj,
    setup(e) {
      const t = e, n = he("step"), o = A(-1), l = A({}), a = A(""), r = Ve(sk), i = dt();
      let u = 0, c = 0;
      ft(() => {
        de([
          () => r.props.active,
          () => r.props.processStatus,
          () => r.props.finishStatus
        ], ([x], [I]) => {
          c = I || 0, u = x - c, k(x);
        }, { immediate: !0 });
      });
      const d = S(() => t.status || a.value), f = S(() => {
        const x = r.steps.value[o.value - 1];
        return x ? x.internalStatus.value : "wait";
      }), v = S(() => r.props.alignCenter), p = S(() => r.props.direction === "vertical"), m = S(() => r.props.simple), h = S(() => r.steps.value.length), g = S(() => {
        var x;
        return ((x = r.steps.value[h.value - 1]) == null ? void 0 : x.uid) === i.uid;
      }), b = S(() => m.value ? "" : r.props.space), C = S(() => [
        n.b(),
        n.is(m.value ? "simple" : r.props.direction),
        n.is("flex", g.value && !b.value && !v.value),
        n.is("center", v.value && !p.value && !m.value)
      ]), w = S(() => {
        const x = {
          flexBasis: je(b.value) ? `${b.value}px` : b.value ? b.value : `${100 / (h.value - (v.value ? 0 : 1))}%`
        };
        return p.value || g.value && (x.maxWidth = `${100 / h.value}%`), x;
      }), y = (x) => {
        o.value = x;
      }, E = (x) => {
        const I = x === "wait", O = {
          transitionDelay: `${Math.abs(u) === 1 ? 0 : u > 0 ? (o.value + 1 - c) * 150 : -(o.value + 1 - r.props.active) * 150}ms`
        }, N = x === r.props.processStatus || I ? 0 : 100;
        O.borderWidth = N && !m.value ? "1px" : 0, O[r.props.direction === "vertical" ? "height" : "width"] = `${N}%`, l.value = O;
      }, k = (x) => {
        x > o.value ? a.value = r.props.finishStatus : x === o.value && f.value !== "error" ? a.value = r.props.processStatus : a.value = "wait";
        const I = r.steps.value[o.value - 1];
        I && I.calcProgress(a.value);
      }, T = {
        uid: i.uid,
        getVnode: () => i.vnode,
        currentStatus: d,
        internalStatus: a,
        setIndex: y,
        calcProgress: E
      };
      return r.addStep(T), Bt(() => {
        r.removeStep(T);
      }), (x, I) => (_(), B("div", {
        style: Ue(s(w)),
        class: $(s(C))
      }, [
        oe(" icon & line "),
        W("div", {
          class: $([s(n).e("head"), s(n).is(s(d))])
        }, [
          s(m) ? oe("v-if", !0) : (_(), B("div", {
            key: 0,
            class: $(s(n).e("line"))
          }, [
            W("i", {
              class: $(s(n).e("line-inner")),
              style: Ue(l.value)
            }, null, 6)
          ], 2)),
          W("div", {
            class: $([s(n).e("icon"), s(n).is(x.icon || x.$slots.icon ? "icon" : "text")])
          }, [
            ee(x.$slots, "icon", {}, () => [
              x.icon ? (_(), ae(s(ze), {
                key: 0,
                class: $(s(n).e("icon-inner"))
              }, {
                default: Q(() => [
                  (_(), ae(ct(x.icon)))
                ]),
                _: 1
              }, 8, ["class"])) : s(d) === "success" ? (_(), ae(s(ze), {
                key: 1,
                class: $([s(n).e("icon-inner"), s(n).is("status")])
              }, {
                default: Q(() => [
                  q(s(ou))
                ]),
                _: 1
              }, 8, ["class"])) : s(d) === "error" ? (_(), ae(s(ze), {
                key: 2,
                class: $([s(n).e("icon-inner"), s(n).is("status")])
              }, {
                default: Q(() => [
                  q(s(Oo))
                ]),
                _: 1
              }, 8, ["class"])) : s(m) ? oe("v-if", !0) : (_(), B("div", {
                key: 3,
                class: $(s(n).e("icon-inner"))
              }, ke(o.value + 1), 3))
            ])
          ], 2)
        ], 2),
        oe(" title & description "),
        W("div", {
          class: $(s(n).e("main"))
        }, [
          W("div", {
            class: $([s(n).e("title"), s(n).is(s(d))])
          }, [
            ee(x.$slots, "title", {}, () => [
              Ct(ke(x.title), 1)
            ])
          ], 2),
          s(m) ? (_(), B("div", {
            key: 0,
            class: $(s(n).e("arrow"))
          }, null, 2)) : (_(), B("div", {
            key: 1,
            class: $([s(n).e("description"), s(n).is(s(d))])
          }, [
            ee(x.$slots, "description", {}, () => [
              Ct(ke(x.description), 1)
            ])
          ], 2))
        ], 2)
      ], 6));
    }
  });
  var ik = /* @__PURE__ */ Ne(Pj, [["__file", "item.vue"]]);
  const Rj = rt(Ij, {
    Step: ik
  }), Dj = nn(ik), uk = (e) => ["", ...Tl].includes(e), Aj = Te({
    modelValue: {
      type: [Boolean, String, Number],
      default: !1
    },
    disabled: Boolean,
    loading: Boolean,
    size: {
      type: String,
      validator: uk
    },
    width: {
      type: [String, Number],
      default: ""
    },
    inlinePrompt: Boolean,
    inactiveActionIcon: {
      type: Lt
    },
    activeActionIcon: {
      type: Lt
    },
    activeIcon: {
      type: Lt
    },
    inactiveIcon: {
      type: Lt
    },
    activeText: {
      type: String,
      default: ""
    },
    inactiveText: {
      type: String,
      default: ""
    },
    activeValue: {
      type: [Boolean, String, Number],
      default: !0
    },
    inactiveValue: {
      type: [Boolean, String, Number],
      default: !1
    },
    name: {
      type: String,
      default: ""
    },
    validateEvent: {
      type: Boolean,
      default: !0
    },
    beforeChange: {
      type: X(Function)
    },
    id: String,
    tabindex: {
      type: [String, Number]
    },
    ...Yn(["ariaLabel"])
  }), Vj = {
    [et]: (e) => Vt(e) || Ae(e) || je(e),
    [gt]: (e) => Vt(e) || Ae(e) || je(e),
    [fn]: (e) => Vt(e) || Ae(e) || je(e)
  }, Yp = "ElSwitch", Lj = /* @__PURE__ */ U({
    name: Yp
  }), Bj = /* @__PURE__ */ U({
    ...Lj,
    props: Aj,
    emits: Vj,
    setup(e, { expose: t, emit: n }) {
      const o = e, { formItem: l } = Nn(), a = vn(), r = he("switch"), { inputId: i } = wo(o, {
        formItemContext: l
      }), u = Cn(S(() => o.loading)), c = A(o.modelValue !== !1), d = Ut(), f = S(() => [
        r.b(),
        r.m(a.value),
        r.is("disabled", u.value),
        r.is("checked", g.value)
      ]), v = S(() => [
        r.e("label"),
        r.em("label", "left"),
        r.is("active", !g.value)
      ]), p = S(() => [
        r.e("label"),
        r.em("label", "right"),
        r.is("active", g.value)
      ]), m = S(() => ({
        width: tn(o.width)
      }));
      de(() => o.modelValue, () => {
        c.value = !0;
      });
      const h = S(() => c.value ? o.modelValue : !1), g = S(() => h.value === o.activeValue);
      [o.activeValue, o.inactiveValue].includes(h.value) || (n(et, o.inactiveValue), n(gt, o.inactiveValue), n(fn, o.inactiveValue)), de(g, (y) => {
        var E;
        d.value.checked = y, o.validateEvent && ((E = l == null ? void 0 : l.validate) == null || E.call(l, "change").catch((k) => vt(k)));
      });
      const b = () => {
        const y = g.value ? o.inactiveValue : o.activeValue;
        n(et, y), n(gt, y), n(fn, y), Re(() => {
          d.value.checked = g.value;
        });
      }, C = () => {
        if (u.value)
          return;
        const { beforeChange: y } = o;
        if (!y) {
          b();
          return;
        }
        const E = y();
        [
          _a(E),
          Vt(E)
        ].includes(!0) || Zt(Yp, "beforeChange must return type `Promise<boolean>` or `boolean`"), _a(E) ? E.then((T) => {
          T && b();
        }).catch((T) => {
          vt(Yp, `some error occurred: ${T}`);
        }) : E && b();
      }, w = () => {
        var y, E;
        (E = (y = d.value) == null ? void 0 : y.focus) == null || E.call(y);
      };
      return ft(() => {
        d.value.checked = g.value;
      }), t({
        focus: w,
        checked: g
      }), (y, E) => (_(), B("div", {
        class: $(s(f)),
        onClick: Ze(C, ["prevent"])
      }, [
        W("input", {
          id: s(i),
          ref_key: "input",
          ref: d,
          class: $(s(r).e("input")),
          type: "checkbox",
          role: "switch",
          "aria-checked": s(g),
          "aria-disabled": s(u),
          "aria-label": y.ariaLabel,
          name: y.name,
          "true-value": y.activeValue,
          "false-value": y.inactiveValue,
          disabled: s(u),
          tabindex: y.tabindex,
          onChange: b,
          onKeydown: on(C, ["enter"])
        }, null, 42, ["id", "aria-checked", "aria-disabled", "aria-label", "name", "true-value", "false-value", "disabled", "tabindex", "onKeydown"]),
        !y.inlinePrompt && (y.inactiveIcon || y.inactiveText) ? (_(), B("span", {
          key: 0,
          class: $(s(v))
        }, [
          y.inactiveIcon ? (_(), ae(s(ze), { key: 0 }, {
            default: Q(() => [
              (_(), ae(ct(y.inactiveIcon)))
            ]),
            _: 1
          })) : oe("v-if", !0),
          !y.inactiveIcon && y.inactiveText ? (_(), B("span", {
            key: 1,
            "aria-hidden": s(g)
          }, ke(y.inactiveText), 9, ["aria-hidden"])) : oe("v-if", !0)
        ], 2)) : oe("v-if", !0),
        W("span", {
          class: $(s(r).e("core")),
          style: Ue(s(m))
        }, [
          y.inlinePrompt ? (_(), B("div", {
            key: 0,
            class: $(s(r).e("inner"))
          }, [
            y.activeIcon || y.inactiveIcon ? (_(), ae(s(ze), {
              key: 0,
              class: $(s(r).is("icon"))
            }, {
              default: Q(() => [
                (_(), ae(ct(s(g) ? y.activeIcon : y.inactiveIcon)))
              ]),
              _: 1
            }, 8, ["class"])) : y.activeText || y.inactiveText ? (_(), B("span", {
              key: 1,
              class: $(s(r).is("text")),
              "aria-hidden": !s(g)
            }, ke(s(g) ? y.activeText : y.inactiveText), 11, ["aria-hidden"])) : oe("v-if", !0)
          ], 2)) : oe("v-if", !0),
          W("div", {
            class: $(s(r).e("action"))
          }, [
            y.loading ? (_(), ae(s(ze), {
              key: 0,
              class: $(s(r).is("loading"))
            }, {
              default: Q(() => [
                q(s(Cl))
              ]),
              _: 1
            }, 8, ["class"])) : s(g) ? ee(y.$slots, "active-action", { key: 1 }, () => [
              y.activeActionIcon ? (_(), ae(s(ze), { key: 0 }, {
                default: Q(() => [
                  (_(), ae(ct(y.activeActionIcon)))
                ]),
                _: 1
              })) : oe("v-if", !0)
            ]) : s(g) ? oe("v-if", !0) : ee(y.$slots, "inactive-action", { key: 2 }, () => [
              y.inactiveActionIcon ? (_(), ae(s(ze), { key: 0 }, {
                default: Q(() => [
                  (_(), ae(ct(y.inactiveActionIcon)))
                ]),
                _: 1
              })) : oe("v-if", !0)
            ])
          ], 2)
        ], 6),
        !y.inlinePrompt && (y.activeIcon || y.activeText) ? (_(), B("span", {
          key: 1,
          class: $(s(p))
        }, [
          y.activeIcon ? (_(), ae(s(ze), { key: 0 }, {
            default: Q(() => [
              (_(), ae(ct(y.activeIcon)))
            ]),
            _: 1
          })) : oe("v-if", !0),
          !y.activeIcon && y.activeText ? (_(), B("span", {
            key: 1,
            "aria-hidden": !s(g)
          }, ke(y.activeText), 9, ["aria-hidden"])) : oe("v-if", !0)
        ], 2)) : oe("v-if", !0)
      ], 10, ["onClick"]));
    }
  });
  var Fj = /* @__PURE__ */ Ne(Bj, [["__file", "switch.vue"]]);
  const zj = rt(Fj), Hf = function(e) {
    var t;
    return (t = e.target) == null ? void 0 : t.closest("td");
  }, Hj = function(e, t, n, o, l) {
    if (!t && !o && (!l || ye(l) && !l.length))
      return e;
    Ae(n) ? n = n === "descending" ? -1 : 1 : n = n && n < 0 ? -1 : 1;
    const a = o ? null : function(i, u) {
      return l ? Y1(En(l), (c) => Ae(c) ? dn(i, c) : c(i, u, e)) : (t !== "$key" && ot(i) && "$value" in i && (i = i.$value), [
        ot(i) ? t ? dn(i, t) : null : i
      ]);
    }, r = function(i, u) {
      var c, d, f, v, p, m;
      if (o)
        return o(i.value, u.value);
      for (let h = 0, g = (d = (c = i.key) == null ? void 0 : c.length) != null ? d : 0; h < g; h++) {
        if (((f = i.key) == null ? void 0 : f[h]) < ((v = u.key) == null ? void 0 : v[h]))
          return -1;
        if (((p = i.key) == null ? void 0 : p[h]) > ((m = u.key) == null ? void 0 : m[h]))
          return 1;
      }
      return 0;
    };
    return e.map((i, u) => ({
      value: i,
      index: u,
      key: a ? a(i, u) : null
    })).sort((i, u) => {
      let c = r(i, u);
      return c || (c = i.index - u.index), c * +n;
    }).map((i) => i.value);
  }, ck = function(e, t) {
    let n = null;
    return e.columns.forEach((o) => {
      o.id === t && (n = o);
    }), n;
  }, Kj = function(e, t) {
    let n = null;
    for (let o = 0; o < e.columns.length; o++) {
      const l = e.columns[o];
      if (l.columnKey === t) {
        n = l;
        break;
      }
    }
    return n || Zt("ElTable", `No column matching with column-key: ${t}`), n;
  }, Vy = function(e, t, n) {
    const o = (t.className || "").match(new RegExp(`${n}-table_[^\\s]+`, "gm"));
    return o ? ck(e, o[0]) : null;
  }, An = (e, t) => {
    if (!e)
      throw new Error("Row is required when get row identity");
    if (Ae(t)) {
      if (!t.includes("."))
        return `${e[t]}`;
      const n = t.split(".");
      let o = e;
      for (const l of n)
        o = o[l];
      return `${o}`;
    } else if (Fe(t))
      return t.call(null, e);
    return "";
  }, qr = function(e, t, n = !1, o = "children") {
    const l = e || [], a = {};
    return l.forEach((r, i) => {
      if (a[An(r, t)] = { row: r, index: i }, n) {
        const u = r[o];
        ye(u) && Object.assign(a, qr(u, t, !0, o));
      }
    }), a;
  };
  function Wj(e, t) {
    const n = {};
    let o;
    for (o in e)
      n[o] = e[o];
    for (o in t)
      if (Ot(t, o)) {
        const l = t[o];
        kt(l) || (n[o] = l);
      }
    return n;
  }
  function lm(e) {
    return e === "" || kt(e) || (e = Number.parseInt(e, 10), Number.isNaN(e) && (e = "")), e;
  }
  function dk(e) {
    return e === "" || kt(e) || (e = lm(e), Number.isNaN(e) && (e = 80)), e;
  }
  function jj(e) {
    return je(e) ? e : Ae(e) ? /^\d+(?:px)?$/.test(e) ? Number.parseInt(e, 10) : e : null;
  }
  function Uj(...e) {
    return e.length === 0 ? (t) => t : e.length === 1 ? e[0] : e.reduce((t, n) => (...o) => t(n(...o)));
  }
  function td(e, t, n, o, l, a, r) {
    let i = a ?? 0, u = !1;
    const d = (() => {
      if (!r)
        return e.indexOf(t);
      const h = An(t, r);
      return e.findIndex((g) => An(g, r) === h);
    })(), f = d !== -1, v = l == null ? void 0 : l.call(null, t, i), p = (h) => {
      h === "add" ? e.push(t) : e.splice(d, 1), u = !0;
    }, m = (h) => {
      let g = 0;
      const b = (o == null ? void 0 : o.children) && h[o.children];
      return b && ye(b) && (g += b.length, b.forEach((C) => {
        g += m(C);
      })), g;
    };
    return (!l || v) && (Vt(n) ? n && !f ? p("add") : !n && f && p("remove") : p(f ? "remove" : "add")), !(o != null && o.checkStrictly) && (o != null && o.children) && ye(t[o.children]) && t[o.children].forEach((h) => {
      const g = td(e, h, n ?? !f, o, l, i + 1, r);
      i += m(h) + 1, g && (u = g);
    }), u;
  }
  function Yj(e, t, n = "children", o = "hasChildren", l = !1) {
    const a = (i) => !(ye(i) && i.length);
    function r(i, u, c) {
      t(i, u, c), u.forEach((d) => {
        if (d[o] && l) {
          t(d, null, c + 1);
          return;
        }
        const f = d[n];
        a(f) || r(d, f, c + 1);
      });
    }
    e.forEach((i) => {
      if (i[o] && l) {
        t(i, null, 0);
        return;
      }
      const u = i[n];
      a(u) || r(i, u, 0);
    });
  }
  const qj = (e, t, n, o) => {
    const l = {
      strategy: "fixed",
      ...e.popperOptions
    }, a = Fe(o == null ? void 0 : o.tooltipFormatter) ? o.tooltipFormatter({
      row: n,
      column: o,
      cellValue: ni(n, o.property).value
    }) : void 0;
    return Wt(a) ? {
      slotContent: a,
      content: null,
      ...e,
      popperOptions: l
    } : {
      slotContent: null,
      content: a ?? t,
      ...e,
      popperOptions: l
    };
  };
  let Fn = null;
  function Gj(e, t, n, o, l, a) {
    var r;
    const i = qj(e, t, n, o), u = {
      ...i,
      slotContent: void 0
    };
    if ((Fn == null ? void 0 : Fn.trigger) === l) {
      const m = (r = Fn.vm) == null ? void 0 : r.component;
      q1(m == null ? void 0 : m.props, u), m && i.slotContent && (m.slots.content = () => [i.slotContent]);
      return;
    }
    Fn == null || Fn();
    const c = a == null ? void 0 : a.refs.tableWrapper, d = c == null ? void 0 : c.dataset.prefix, f = q(Pn, {
      virtualTriggering: !0,
      virtualRef: l,
      appendTo: c,
      placement: "top",
      transition: "none",
      offset: 0,
      hideAfter: 0,
      ...u
    }, i.slotContent ? {
      content: () => i.slotContent
    } : void 0);
    f.appContext = { ...a.appContext, ...a };
    const v = document.createElement("div");
    Na(f, v), f.component.exposed.onOpen();
    const p = c == null ? void 0 : c.querySelector(`.${d}-scrollbar__wrap`);
    Fn = () => {
      var m, h;
      (h = (m = f.component) == null ? void 0 : m.exposed) != null && h.onClose && f.component.exposed.onClose(), Na(null, v);
      const g = Fn;
      p == null || p.removeEventListener("scroll", g), g.trigger = void 0, g.vm = void 0, Fn = null;
    }, Fn.trigger = l ?? void 0, Fn.vm = f, p == null || p.addEventListener("scroll", Fn);
  }
  function fk(e) {
    return e.children ? Y1(e.children, fk) : [e];
  }
  function Ly(e, t) {
    return e + t.colSpan;
  }
  const pk = (e, t, n, o) => {
    let l = 0, a = e;
    const r = n.states.columns.value;
    if (o) {
      const u = fk(o[e]);
      l = r.slice(0, r.indexOf(u[0])).reduce(Ly, 0), a = l + u.reduce(Ly, 0) - 1;
    } else
      l = e;
    let i;
    switch (t) {
      case "left":
        a < n.states.fixedLeafColumnsLength.value && (i = "left");
        break;
      case "right":
        l >= r.length - n.states.rightFixedLeafColumnsLength.value && (i = "right");
        break;
      default:
        a < n.states.fixedLeafColumnsLength.value ? i = "left" : l >= r.length - n.states.rightFixedLeafColumnsLength.value && (i = "right");
    }
    return i ? {
      direction: i,
      start: l,
      after: a
    } : {};
  }, am = (e, t, n, o, l, a = 0) => {
    const r = [], { direction: i, start: u, after: c } = pk(t, n, o, l);
    if (i) {
      const d = i === "left";
      r.push(`${e}-fixed-column--${i}`), d && c + a === o.states.fixedLeafColumnsLength.value - 1 ? r.push("is-last-column") : !d && u - a === o.states.columns.value.length - o.states.rightFixedLeafColumnsLength.value && r.push("is-first-column");
    }
    return r;
  };
  function By(e, t) {
    return e + (Zi(t.realWidth) || Number.isNaN(t.realWidth) ? Number(t.width) : t.realWidth);
  }
  const rm = (e, t, n, o) => {
    const {
      direction: l,
      start: a = 0,
      after: r = 0
    } = pk(e, t, n, o);
    if (!l)
      return;
    const i = {}, u = l === "left", c = n.states.columns.value;
    return u ? i.left = c.slice(0, a).reduce(By, 0) : i.right = c.slice(r + 1).reverse().reduce(By, 0), i;
  }, ps = (e, t) => {
    e && (Number.isNaN(e[t]) || (e[t] = `${e[t]}px`));
  };
  function Xj(e) {
    const t = dt(), n = A(!1), o = A([]);
    return {
      updateExpandRows: () => {
        const u = e.data.value || [], c = e.rowKey.value;
        if (n.value)
          o.value = u.slice();
        else if (c) {
          const d = qr(o.value, c);
          o.value = u.reduce((f, v) => {
            const p = An(v, c);
            return d[p] && f.push(v), f;
          }, []);
        } else
          o.value = [];
      },
      toggleRowExpansion: (u, c) => {
        td(o.value, u, c, void 0, void 0, void 0, e.rowKey.value) && t.emit("expand-change", u, o.value.slice());
      },
      setExpandRowKeys: (u) => {
        t.store.assertRowKey();
        const c = e.data.value || [], d = e.rowKey.value, f = qr(c, d);
        o.value = u.reduce((v, p) => {
          const m = f[p];
          return m && v.push(m.row), v;
        }, []);
      },
      isRowExpanded: (u) => {
        const c = e.rowKey.value;
        return c ? !!qr(o.value, c)[An(u, c)] : o.value.includes(u);
      },
      states: {
        expandRows: o,
        defaultExpandAll: n
      }
    };
  }
  function Jj(e) {
    const t = dt(), n = A(null), o = A(null), l = (c) => {
      t.store.assertRowKey(), n.value = c, r(c);
    }, a = () => {
      n.value = null;
    }, r = (c) => {
      var d;
      const { data: f, rowKey: v } = e;
      let p = null;
      v.value && (p = (d = (s(f) || []).find((m) => An(m, v.value) === c)) != null ? d : null), o.value = p ?? null, t.emit("current-change", o.value, null);
    };
    return {
      setCurrentRowKey: l,
      restoreCurrentRowKey: a,
      setCurrentRowByKey: r,
      updateCurrentRow: (c) => {
        const d = o.value;
        if (c && c !== d) {
          o.value = c, t.emit("current-change", o.value, d);
          return;
        }
        !c && d && (o.value = null, t.emit("current-change", null, d));
      },
      updateCurrentRowData: () => {
        const c = e.rowKey.value, d = e.data.value || [], f = o.value;
        if (f && !d.includes(f)) {
          if (c) {
            const v = An(f, c);
            r(v);
          } else
            o.value = null;
          Zi(o.value) && t.emit("current-change", null, f);
        } else n.value && (r(n.value), a());
      },
      states: {
        _currentRowKey: n,
        currentRow: o
      }
    };
  }
  function Zj(e) {
    const t = A([]), n = A({}), o = A(16), l = A(!1), a = A({}), r = A("hasChildren"), i = A("children"), u = A(!1), c = dt(), d = S(() => {
      if (!e.rowKey.value)
        return {};
      const y = e.data.value || [];
      return v(y);
    }), f = S(() => {
      const y = e.rowKey.value, E = Object.keys(a.value), k = {};
      return E.length && E.forEach((T) => {
        if (a.value[T].length) {
          const x = { children: [] };
          a.value[T].forEach((I) => {
            const P = An(I, y);
            x.children.push(P), I[r.value] && !k[P] && (k[P] = { children: [] });
          }), k[T] = x;
        }
      }), k;
    }), v = (y) => {
      const E = e.rowKey.value, k = {};
      return Yj(y, (T, x, I) => {
        const P = An(T, E);
        ye(x) ? k[P] = {
          children: x.map((O) => An(O, E)),
          level: I
        } : l.value && (k[P] = {
          children: [],
          lazy: !0,
          level: I
        });
      }, i.value, r.value, l.value), k;
    }, p = (y = !1, E) => {
      var k, T;
      E || (E = (k = c.store) == null ? void 0 : k.states.defaultExpandAll.value);
      const x = d.value, I = f.value, P = Object.keys(x), O = {};
      if (P.length) {
        const N = s(n), z = [], Y = (M, R) => {
          if (y)
            return t.value ? E || t.value.includes(R) : !!(E || M != null && M.expanded);
          {
            const D = E || t.value && t.value.includes(R);
            return !!(M != null && M.expanded || D);
          }
        };
        P.forEach((M) => {
          const R = N[M], D = { ...x[M] };
          if (D.expanded = Y(R, M), D.lazy) {
            const { loaded: L = !1, loading: V = !1 } = R || {};
            D.loaded = !!L, D.loading = !!V, z.push(M);
          }
          O[M] = D;
        });
        const G = Object.keys(I);
        l.value && G.length && z.length && G.forEach((M) => {
          var R;
          const D = N[M], L = I[M].children;
          if (z.includes(M)) {
            if (((R = O[M].children) == null ? void 0 : R.length) !== 0)
              throw new Error("[ElTable]children must be an empty array.");
            O[M].children = L;
          } else {
            const { loaded: V = !1, loading: F = !1 } = D || {};
            O[M] = {
              lazy: !0,
              loaded: !!V,
              loading: !!F,
              expanded: Y(D, M),
              children: L,
              level: void 0
            };
          }
        });
      }
      n.value = O, (T = c.store) == null || T.updateTableScrollY();
    };
    de(() => t.value, () => {
      p(!0);
    }), de(() => d.value, () => {
      p();
    }), de(() => f.value, () => {
      p();
    });
    const m = (y) => {
      t.value = y, p();
    }, h = (y) => l.value && y && "loaded" in y && !y.loaded, g = (y, E) => {
      c.store.assertRowKey();
      const k = e.rowKey.value, T = An(y, k), x = T && n.value[T];
      if (T && x && "expanded" in x) {
        const I = x.expanded;
        E = kt(E) ? !x.expanded : E, n.value[T].expanded = E, I !== E && c.emit("expand-change", y, E), h(x) && C(y, T, x), c.store.updateTableScrollY();
      }
    }, b = (y) => {
      c.store.assertRowKey();
      const E = e.rowKey.value, k = An(y, E), T = n.value[k];
      h(T) ? C(y, k, T) : g(y, void 0);
    }, C = (y, E, k) => {
      const { load: T } = c.props;
      T && !n.value[E].loaded && (n.value[E].loading = !0, T(y, k, (x) => {
        if (!ye(x))
          throw new TypeError("[ElTable] data must be an array");
        n.value[E].loading = !1, n.value[E].loaded = !0, n.value[E].expanded = !0, x.length && (a.value[E] = x), c.emit("expand-change", y, !0);
      }));
    };
    return {
      loadData: C,
      loadOrToggle: b,
      toggleTreeExpansion: g,
      updateTreeExpandKeys: m,
      updateTreeData: p,
      updateKeyChildren: (y, E) => {
        const { lazy: k, rowKey: T } = c.props;
        if (k) {
          if (!T)
            throw new Error("[Table] rowKey is required in updateKeyChild");
          a.value[y] && (a.value[y] = E);
        }
      },
      normalize: v,
      states: {
        expandRowKeys: t,
        treeData: n,
        indent: o,
        lazy: l,
        lazyTreeNodeMap: a,
        lazyColumnIdentifier: r,
        childrenColumnName: i,
        checkStrictly: u
      }
    };
  }
  const Qj = (e, t) => {
    const n = t.sortingColumn;
    return !n || Ae(n.sortable) ? e : Hj(e, t.sortProp, t.sortOrder, n.sortMethod, n.sortBy);
  }, sc = (e) => {
    const t = [];
    return e.forEach((n) => {
      n.children && n.children.length > 0 ? t.push.apply(t, sc(n.children)) : t.push(n);
    }), t;
  };
  function e9() {
    var e;
    const t = dt(), { size: n } = wn((e = t.proxy) == null ? void 0 : e.$props), o = A(null), l = A([]), a = A([]), r = A(!1), i = A([]), u = A([]), c = A([]), d = A([]), f = A([]), v = A([]), p = A([]), m = A([]), h = [], g = A(0), b = A(0), C = A(0), w = A(!1), y = A([]), E = A(!1), k = A(!1), T = A(null), x = A({}), I = A(null), P = A(null), O = A(null), N = A(null), z = A(null), Y = S(() => o.value ? qr(y.value, o.value) : void 0);
    de(l, () => {
      var Ye;
      t.state && (D(!1), t.props.tableLayout === "auto" && ((Ye = t.refs.tableHeaderRef) == null || Ye.updateFixedColumnStyle()));
    }, {
      deep: !0
    });
    const G = () => {
      if (!o.value)
        throw new Error("[ElTable] prop row-key is required");
    }, M = (Ye) => {
      var tt;
      (tt = Ye.children) == null || tt.forEach((fe) => {
        fe.fixed = Ye.fixed, M(fe);
      });
    }, R = () => {
      i.value.forEach((Ke) => {
        M(Ke);
      }), d.value = i.value.filter((Ke) => [!0, "left"].includes(Ke.fixed));
      const Ye = i.value.find((Ke) => Ke.type === "selection");
      let tt;
      Ye && Ye.fixed !== "right" && !d.value.includes(Ye) && i.value.indexOf(Ye) === 0 && d.value.length && (d.value.unshift(Ye), tt = !0), f.value = i.value.filter((Ke) => Ke.fixed === "right");
      const fe = i.value.filter((Ke) => (tt ? Ke.type !== "selection" : !0) && !Ke.fixed);
      u.value = Array.from(d.value).concat(fe).concat(f.value);
      const He = sc(fe), Qe = sc(d.value), ve = sc(f.value);
      g.value = He.length, b.value = Qe.length, C.value = ve.length, c.value = Array.from(Qe).concat(He).concat(ve), r.value = d.value.length > 0 || f.value.length > 0;
    }, D = (Ye, tt = !1) => {
      Ye && R(), tt ? t.state.doLayout() : t.state.debouncedUpdateLayout();
    }, L = (Ye) => Y.value ? !!Y.value[An(Ye, o.value)] : y.value.includes(Ye), V = () => {
      w.value = !1;
      const Ye = y.value;
      y.value = [], Ye.length && t.emit("selection-change", []);
    }, F = () => {
      var Ye, tt;
      let fe;
      if (o.value) {
        fe = [];
        const He = (tt = (Ye = t == null ? void 0 : t.store) == null ? void 0 : Ye.states) == null ? void 0 : tt.childrenColumnName.value, Qe = qr(l.value, o.value, !0, He);
        for (const ve in Y.value)
          Ot(Y.value, ve) && !Qe[ve] && fe.push(Y.value[ve].row);
      } else
        fe = y.value.filter((He) => !l.value.includes(He));
      if (fe.length) {
        const He = y.value.filter((Qe) => !fe.includes(Qe));
        y.value = He, t.emit("selection-change", He.slice());
      }
    }, H = () => (y.value || []).slice(), K = (Ye, tt, fe = !0, He = !1) => {
      var Qe, ve, Ke, St;
      const Ft = {
        children: (ve = (Qe = t == null ? void 0 : t.store) == null ? void 0 : Qe.states) == null ? void 0 : ve.childrenColumnName.value,
        checkStrictly: (St = (Ke = t == null ? void 0 : t.store) == null ? void 0 : Ke.states) == null ? void 0 : St.checkStrictly.value
      };
      if (td(y.value, Ye, tt, Ft, He ? void 0 : T.value, l.value.indexOf(Ye), o.value)) {
        const Je = (y.value || []).slice();
        fe && t.emit("select", Je, Ye), t.emit("selection-change", Je);
      }
    }, Z = () => {
      var Ye, tt;
      const fe = k.value ? !w.value : !(w.value || y.value.length);
      w.value = fe;
      let He = !1, Qe = 0;
      const ve = (tt = (Ye = t == null ? void 0 : t.store) == null ? void 0 : Ye.states) == null ? void 0 : tt.rowKey.value, { childrenColumnName: Ke } = t.store.states, St = {
        children: Ke.value,
        checkStrictly: !1
      };
      l.value.forEach((Ft, Se) => {
        const Je = Se + Qe;
        td(y.value, Ft, fe, St, T.value, Je, ve) && (He = !0), Qe += ie(An(Ft, ve));
      }), He && t.emit("selection-change", y.value ? y.value.slice() : []), t.emit("select-all", (y.value || []).slice());
    }, J = () => {
      var Ye;
      if (((Ye = l.value) == null ? void 0 : Ye.length) === 0) {
        w.value = !1;
        return;
      }
      const { childrenColumnName: tt } = t.store.states;
      let fe = 0, He = 0;
      const Qe = (Ke) => {
        var St;
        for (const Ft of Ke) {
          const Se = T.value && T.value.call(null, Ft, fe);
          if (L(Ft))
            He++;
          else if (!T.value || Se)
            return !1;
          if (fe++, (St = Ft[tt.value]) != null && St.length && !Qe(Ft[tt.value]))
            return !1;
        }
        return !0;
      }, ve = Qe(l.value || []);
      w.value = He === 0 ? !1 : ve;
    }, ie = (Ye) => {
      var tt;
      if (!t || !t.store)
        return 0;
      const { treeData: fe } = t.store.states;
      let He = 0;
      const Qe = (tt = fe.value[Ye]) == null ? void 0 : tt.children;
      return Qe && (He += Qe.length, Qe.forEach((ve) => {
        He += ie(ve);
      })), He;
    }, ue = (Ye, tt) => {
      const fe = {};
      return En(Ye).forEach((He) => {
        x.value[He.id] = tt, fe[He.columnKey || He.id] = tt;
      }), fe;
    }, re = (Ye, tt, fe) => {
      P.value && P.value !== Ye && (P.value.order = null), P.value = Ye, O.value = tt, N.value = fe;
    }, se = () => {
      let Ye = s(a);
      Object.keys(x.value).forEach((tt) => {
        const fe = x.value[tt];
        if (!fe || fe.length === 0)
          return;
        const He = ck({
          columns: c.value
        }, tt);
        He && He.filterMethod && (Ye = Ye.filter((Qe) => fe.some((ve) => He.filterMethod.call(null, ve, Qe, He))));
      }), I.value = Ye;
    }, ne = () => {
      var Ye;
      l.value = Qj((Ye = I.value) != null ? Ye : [], {
        sortingColumn: P.value,
        sortProp: O.value,
        sortOrder: N.value
      });
    }, le = (Ye = void 0) => {
      Ye != null && Ye.filter || se(), ne();
    }, Ce = (Ye) => {
      const { tableHeaderRef: tt } = t.refs;
      if (!tt)
        return;
      const fe = Object.assign({}, tt.filterPanels), He = Object.keys(fe);
      if (He.length)
        if (Ae(Ye) && (Ye = [Ye]), ye(Ye)) {
          const Qe = Ye.map((ve) => Kj({
            columns: c.value
          }, ve));
          He.forEach((ve) => {
            const Ke = Qe.find((St) => St.id === ve);
            Ke && (Ke.filteredValue = []);
          }), t.store.commit("filterChange", {
            column: Qe,
            values: [],
            silent: !0,
            multi: !0
          });
        } else
          He.forEach((Qe) => {
            const ve = c.value.find((Ke) => Ke.id === Qe);
            ve && (ve.filteredValue = []);
          }), x.value = {}, t.store.commit("filterChange", {
            column: {},
            values: [],
            silent: !0
          });
    }, j = () => {
      P.value && (re(null, null, null), t.store.commit("changeSortCondition", {
        silent: !0
      }));
    }, {
      setExpandRowKeys: te,
      toggleRowExpansion: ce,
      updateExpandRows: ge,
      states: be,
      isRowExpanded: Ee
    } = Xj({
      data: l,
      rowKey: o
    }), {
      updateTreeExpandKeys: Oe,
      toggleTreeExpansion: De,
      updateTreeData: we,
      updateKeyChildren: me,
      loadOrToggle: Pe,
      states: Me
    } = Zj({
      data: l,
      rowKey: o
    }), {
      updateCurrentRowData: Be,
      updateCurrentRow: pe,
      setCurrentRowKey: Le,
      states: Xe
    } = Jj({
      data: l,
      rowKey: o
    });
    return {
      assertRowKey: G,
      updateColumns: R,
      scheduleLayout: D,
      isSelected: L,
      clearSelection: V,
      cleanSelection: F,
      getSelectionRows: H,
      toggleRowSelection: K,
      _toggleAllSelection: Z,
      toggleAllSelection: null,
      updateAllSelected: J,
      updateFilters: ue,
      updateCurrentRow: pe,
      updateSort: re,
      execFilter: se,
      execSort: ne,
      execQuery: le,
      clearFilter: Ce,
      clearSort: j,
      toggleRowExpansion: ce,
      setExpandRowKeysAdapter: (Ye) => {
        te(Ye), Oe(Ye);
      },
      setCurrentRowKey: Le,
      toggleRowExpansionAdapter: (Ye, tt) => {
        c.value.some(({ type: He }) => He === "expand") ? ce(Ye, tt) : De(Ye, tt);
      },
      isRowExpanded: Ee,
      updateExpandRows: ge,
      updateCurrentRowData: Be,
      loadOrToggle: Pe,
      updateTreeData: we,
      updateKeyChildren: me,
      states: {
        tableSize: n,
        rowKey: o,
        data: l,
        _data: a,
        isComplex: r,
        _columns: i,
        originColumns: u,
        columns: c,
        fixedColumns: d,
        rightFixedColumns: f,
        leafColumns: v,
        fixedLeafColumns: p,
        rightFixedLeafColumns: m,
        updateOrderFns: h,
        leafColumnsLength: g,
        fixedLeafColumnsLength: b,
        rightFixedLeafColumnsLength: C,
        isAllSelected: w,
        selection: y,
        reserveSelection: E,
        selectOnIndeterminate: k,
        selectable: T,
        filters: x,
        filteredData: I,
        sortingColumn: P,
        sortProp: O,
        sortOrder: N,
        hoverRow: z,
        ...be,
        ...Me,
        ...Xe
      }
    };
  }
  function qp(e, t) {
    return e.map((n) => {
      var o;
      return n.id === t.id ? t : ((o = n.children) != null && o.length && (n.children = qp(n.children, t)), n);
    });
  }
  function Gp(e) {
    e.forEach((t) => {
      var n, o;
      t.no = (n = t.getColumnIndex) == null ? void 0 : n.call(t), (o = t.children) != null && o.length && Gp(t.children);
    }), e.sort((t, n) => t.no - n.no);
  }
  function t9() {
    const e = dt(), t = e9();
    return {
      ns: he("table"),
      ...t,
      mutations: {
        setData(r, i) {
          const u = s(r._data) !== i;
          r.data.value = i, r._data.value = i, e.store.execQuery(), e.store.updateCurrentRowData(), e.store.updateExpandRows(), e.store.updateTreeData(e.store.states.defaultExpandAll.value), s(r.reserveSelection) ? e.store.assertRowKey() : u ? e.store.clearSelection() : e.store.cleanSelection(), e.store.updateAllSelected(), e.$ready && e.store.scheduleLayout();
        },
        insertColumn(r, i, u, c) {
          var d;
          const f = s(r._columns);
          let v = [];
          u ? (u && !u.children && (u.children = []), (d = u.children) == null || d.push(i), v = qp(f, u)) : (f.push(i), v = f), Gp(v), r._columns.value = v, r.updateOrderFns.push(c), i.type === "selection" && (r.selectable.value = i.selectable, r.reserveSelection.value = i.reserveSelection), e.$ready && (e.store.updateColumns(), e.store.scheduleLayout());
        },
        updateColumnOrder(r, i) {
          var u;
          ((u = i.getColumnIndex) == null ? void 0 : u.call(i)) !== i.no && (Gp(r._columns.value), e.$ready && e.store.updateColumns());
        },
        removeColumn(r, i, u, c) {
          var d;
          const f = s(r._columns) || [];
          if (u)
            (d = u.children) == null || d.splice(u.children.findIndex((p) => p.id === i.id), 1), Re(() => {
              var p;
              ((p = u.children) == null ? void 0 : p.length) === 0 && delete u.children;
            }), r._columns.value = qp(f, u);
          else {
            const p = f.indexOf(i);
            p > -1 && (f.splice(p, 1), r._columns.value = f);
          }
          const v = r.updateOrderFns.indexOf(c);
          v > -1 && r.updateOrderFns.splice(v, 1), e.$ready && (e.store.updateColumns(), e.store.scheduleLayout());
        },
        sort(r, i) {
          const { prop: u, order: c, init: d } = i;
          if (u) {
            const f = s(r.columns).find((v) => v.property === u);
            f && (f.order = c, e.store.updateSort(f, u, c), e.store.commit("changeSortCondition", { init: d }));
          }
        },
        changeSortCondition(r, i) {
          const { sortingColumn: u, sortProp: c, sortOrder: d } = r, f = s(u), v = s(c), p = s(d);
          Zi(p) && (r.sortingColumn.value = null, r.sortProp.value = null);
          const m = { filter: !0 };
          e.store.execQuery(m), (!i || !(i.silent || i.init)) && e.emit("sort-change", {
            column: f,
            prop: v,
            order: p
          }), e.store.updateTableScrollY();
        },
        filterChange(r, i) {
          const { column: u, values: c, silent: d } = i, f = e.store.updateFilters(u, c);
          e.store.execQuery(), d || e.emit("filter-change", f), e.store.updateTableScrollY();
        },
        toggleAllSelection() {
          var r, i;
          (i = (r = e.store).toggleAllSelection) == null || i.call(r);
        },
        rowSelectedChanged(r, i) {
          e.store.toggleRowSelection(i), e.store.updateAllSelected();
        },
        setHoverRow(r, i) {
          r.hoverRow.value = i;
        },
        setCurrentRow(r, i) {
          e.store.updateCurrentRow(i);
        }
      },
      commit: function(r, ...i) {
        const u = e.store.mutations;
        if (u[r])
          u[r].apply(e, [
            e.store.states,
            ...i
          ]);
        else
          throw new Error(`Action not found: ${r}`);
      },
      updateTableScrollY: function() {
        Re(() => e.layout.updateScrollY.apply(e.layout));
      }
    };
  }
  const sm = {
    rowKey: "rowKey",
    defaultExpandAll: "defaultExpandAll",
    selectOnIndeterminate: "selectOnIndeterminate",
    indent: "indent",
    lazy: "lazy",
    data: "data",
    "treeProps.hasChildren": {
      key: "lazyColumnIdentifier",
      default: "hasChildren"
    },
    "treeProps.children": {
      key: "childrenColumnName",
      default: "children"
    },
    "treeProps.checkStrictly": {
      key: "checkStrictly",
      default: !1
    }
  };
  function n9(e, t) {
    if (!e)
      throw new Error("Table is required.");
    const n = t9();
    return n.toggleAllSelection = wl(n._toggleAllSelection, 10), Object.keys(sm).forEach((o) => {
      vk(hk(t, o), o, n);
    }), o9(n, t), n;
  }
  function o9(e, t) {
    Object.keys(sm).forEach((n) => {
      de(() => hk(t, n), (o) => {
        vk(o, n, e);
      });
    });
  }
  function vk(e, t, n) {
    let o = e, l = sm[t];
    ot(l) && (o = o || l.default, l = l.key), n.states[l].value = o;
  }
  function hk(e, t) {
    if (t.includes(".")) {
      const n = t.split(".");
      let o = e;
      return n.forEach((l) => {
        o = o[l];
      }), o;
    } else
      return e[t];
  }
  class l9 {
    constructor(t) {
      this.observers = [], this.table = null, this.store = null, this.columns = [], this.fit = !0, this.showHeader = !0, this.height = A(null), this.scrollX = A(!1), this.scrollY = A(!1), this.bodyWidth = A(null), this.fixedWidth = A(null), this.rightFixedWidth = A(null), this.gutterWidth = 0;
      for (const n in t)
        Ot(t, n) && (Kt(this[n]) ? this[n].value = t[n] : this[n] = t[n]);
      if (!this.table)
        throw new Error("Table is required for Table Layout");
      if (!this.store)
        throw new Error("Store is required for Table Layout");
    }
    updateScrollY() {
      const t = this.height.value;
      if (Zi(t))
        return !1;
      const n = this.table.refs.scrollBarRef;
      if (this.table.vnode.el && (n != null && n.wrapRef)) {
        let o = !0;
        const l = this.scrollY.value;
        return o = n.wrapRef.scrollHeight > n.wrapRef.clientHeight, this.scrollY.value = o, l !== o;
      }
      return !1;
    }
    setHeight(t, n = "height") {
      if (!xt)
        return;
      const o = this.table.vnode.el;
      if (t = jj(t), this.height.value = Number(t), !o && (t || t === 0)) {
        Re(() => this.setHeight(t, n));
        return;
      }
      o && je(t) ? (o.style[n] = `${t}px`, this.updateElsHeight()) : o && Ae(t) && (o.style[n] = t, this.updateElsHeight());
    }
    setMaxHeight(t) {
      this.setHeight(t, "max-height");
    }
    getFlattenColumns() {
      const t = [];
      return this.table.store.states.columns.value.forEach((o) => {
        o.isColumnGroup ? t.push.apply(t, o.columns) : t.push(o);
      }), t;
    }
    updateElsHeight() {
      this.updateScrollY(), this.notifyObservers("scrollable");
    }
    headerDisplayNone(t) {
      if (!t)
        return !0;
      let n = t;
      for (; n.tagName !== "DIV"; ) {
        if (getComputedStyle(n).display === "none")
          return !0;
        n = n.parentElement;
      }
      return !1;
    }
    updateColumnsWidth() {
      var t;
      if (!xt)
        return;
      const n = this.fit, o = (t = this.table.vnode.el) == null ? void 0 : t.clientWidth;
      let l = 0;
      const a = this.getFlattenColumns(), r = a.filter((c) => !je(c.width));
      if (a.forEach((c) => {
        je(c.width) && c.realWidth && (c.realWidth = null);
      }), r.length > 0 && n) {
        if (a.forEach((c) => {
          l += Number(c.width || c.minWidth || 80);
        }), l <= o) {
          this.scrollX.value = !1;
          const c = o - l;
          if (r.length === 1)
            r[0].realWidth = Number(r[0].minWidth || 80) + c;
          else {
            const d = r.reduce((p, m) => p + Number(m.minWidth || 80), 0), f = c / d;
            let v = 0;
            r.forEach((p, m) => {
              if (m === 0)
                return;
              const h = Math.floor(Number(p.minWidth || 80) * f);
              v += h, p.realWidth = Number(p.minWidth || 80) + h;
            }), r[0].realWidth = Number(r[0].minWidth || 80) + c - v;
          }
        } else
          this.scrollX.value = !0, r.forEach((c) => {
            c.realWidth = Number(c.minWidth);
          });
        this.bodyWidth.value = Math.max(l, o), this.table.state.resizeState.value.width = this.bodyWidth.value;
      } else
        a.forEach((c) => {
          !c.width && !c.minWidth ? c.realWidth = 80 : c.realWidth = Number(c.width || c.minWidth), l += c.realWidth;
        }), this.scrollX.value = l > o, this.bodyWidth.value = l;
      const i = this.store.states.fixedColumns.value;
      if (i.length > 0) {
        let c = 0;
        i.forEach((d) => {
          c += Number(d.realWidth || d.width);
        }), this.fixedWidth.value = c;
      }
      const u = this.store.states.rightFixedColumns.value;
      if (u.length > 0) {
        let c = 0;
        u.forEach((d) => {
          c += Number(d.realWidth || d.width);
        }), this.rightFixedWidth.value = c;
      }
      this.notifyObservers("columns");
    }
    addObserver(t) {
      this.observers.push(t);
    }
    removeObserver(t) {
      const n = this.observers.indexOf(t);
      n !== -1 && this.observers.splice(n, 1);
    }
    notifyObservers(t) {
      this.observers.forEach((o) => {
        var l, a;
        switch (t) {
          case "columns":
            (l = o.state) == null || l.onColumnsChange(this);
            break;
          case "scrollable":
            (a = o.state) == null || a.onScrollableChange(this);
            break;
          default:
            throw new Error(`Table Layout don't have event ${t}.`);
        }
      });
    }
  }
  const { CheckboxGroup: a9 } = xo, r9 = /* @__PURE__ */ U({
    name: "ElTableFilterPanel",
    components: {
      ElCheckbox: xo,
      ElCheckboxGroup: a9,
      ElScrollbar: Go,
      ElTooltip: Pn,
      ElIcon: ze,
      ArrowDown: Nl,
      ArrowUp: Pd
    },
    directives: { ClickOutside: Jl },
    props: {
      placement: {
        type: String,
        default: "bottom-start"
      },
      store: {
        type: Object
      },
      column: {
        type: Object
      },
      upDataColumn: {
        type: Function
      },
      appendTo: zt.appendTo
    },
    setup(e) {
      const t = dt(), { t: n } = _t(), o = he("table-filter"), l = t == null ? void 0 : t.parent;
      e.column && !l.filterPanels.value[e.column.id] && (l.filterPanels.value[e.column.id] = t);
      const a = A(!1), r = A(null), i = S(() => e.column && e.column.filters), u = S(() => e.column && e.column.filterClassName ? `${o.b()} ${e.column.filterClassName}` : o.b()), c = S({
        get: () => {
          var E;
          return (((E = e.column) == null ? void 0 : E.filteredValue) || [])[0];
        },
        set: (E) => {
          d.value && (go(E) ? d.value.splice(0, 1) : d.value.splice(0, 1, E));
        }
      }), d = S({
        get() {
          return e.column ? e.column.filteredValue || [] : [];
        },
        set(E) {
          var k;
          e.column && ((k = e.upDataColumn) == null || k.call(e, "filteredValue", E));
        }
      }), f = S(() => e.column ? e.column.filterMultiple : !0), v = (E) => E.value === c.value, p = () => {
        a.value = !1;
      }, m = (E) => {
        E.stopPropagation(), a.value = !a.value;
      }, h = () => {
        a.value = !1;
      }, g = () => {
        w(d.value), p();
      }, b = () => {
        d.value = [], w(d.value), p();
      }, C = (E) => {
        c.value = E, go(E) ? w([]) : w(d.value), p();
      }, w = (E) => {
        var k, T;
        (k = e.store) == null || k.commit("filterChange", {
          column: e.column,
          values: E
        }), (T = e.store) == null || T.updateAllSelected();
      };
      de(a, (E) => {
        var k;
        e.column && ((k = e.upDataColumn) == null || k.call(e, "filterOpened", E));
      }, {
        immediate: !0
      });
      const y = S(() => {
        var E, k;
        return (k = (E = r.value) == null ? void 0 : E.popperRef) == null ? void 0 : k.contentRef;
      });
      return {
        tooltipVisible: a,
        multiple: f,
        filterClassName: u,
        filteredValue: d,
        filterValue: c,
        filters: i,
        handleConfirm: g,
        handleReset: b,
        handleSelect: C,
        isPropAbsent: go,
        isActive: v,
        t: n,
        ns: o,
        showFilterPanel: m,
        hideFilterPanel: h,
        popperPaneRef: y,
        tooltip: r
      };
    }
  });
  function s9(e, t, n, o, l, a) {
    const r = $t("el-checkbox"), i = $t("el-checkbox-group"), u = $t("el-scrollbar"), c = $t("arrow-up"), d = $t("arrow-down"), f = $t("el-icon"), v = $t("el-tooltip"), p = bd("click-outside");
    return _(), ae(v, {
      ref: "tooltip",
      visible: e.tooltipVisible,
      offset: 0,
      placement: e.placement,
      "show-arrow": !1,
      "stop-popper-mouse-event": !1,
      teleported: "",
      effect: "light",
      pure: "",
      "popper-class": e.filterClassName,
      persistent: "",
      "append-to": e.appendTo
    }, {
      content: Q(() => [
        e.multiple ? (_(), B("div", { key: 0 }, [
          W("div", {
            class: $(e.ns.e("content"))
          }, [
            q(u, {
              "wrap-class": e.ns.e("wrap")
            }, {
              default: Q(() => [
                q(i, {
                  modelValue: e.filteredValue,
                  "onUpdate:modelValue": (m) => e.filteredValue = m,
                  class: $(e.ns.e("checkbox-group"))
                }, {
                  default: Q(() => [
                    (_(!0), B(We, null, bt(e.filters, (m) => (_(), ae(r, {
                      key: m.value,
                      value: m.value
                    }, {
                      default: Q(() => [
                        Ct(ke(m.text), 1)
                      ]),
                      _: 2
                    }, 1032, ["value"]))), 128))
                  ]),
                  _: 1
                }, 8, ["modelValue", "onUpdate:modelValue", "class"])
              ]),
              _: 1
            }, 8, ["wrap-class"])
          ], 2),
          W("div", {
            class: $(e.ns.e("bottom"))
          }, [
            W("button", {
              class: $(e.ns.is("disabled", e.filteredValue.length === 0)),
              disabled: e.filteredValue.length === 0,
              type: "button",
              onClick: e.handleConfirm
            }, ke(e.t("el.table.confirmFilter")), 11, ["disabled", "onClick"]),
            W("button", {
              type: "button",
              onClick: e.handleReset
            }, ke(e.t("el.table.resetFilter")), 9, ["onClick"])
          ], 2)
        ])) : (_(), B("ul", {
          key: 1,
          class: $(e.ns.e("list"))
        }, [
          W("li", {
            class: $([
              e.ns.e("list-item"),
              e.ns.is("active", e.isPropAbsent(e.filterValue))
            ]),
            onClick: (m) => e.handleSelect(null)
          }, ke(e.t("el.table.clearFilter")), 11, ["onClick"]),
          (_(!0), B(We, null, bt(e.filters, (m) => (_(), B("li", {
            key: m.value,
            class: $([e.ns.e("list-item"), e.ns.is("active", e.isActive(m))]),
            label: m.value,
            onClick: (h) => e.handleSelect(m.value)
          }, ke(m.text), 11, ["label", "onClick"]))), 128))
        ], 2))
      ]),
      default: Q(() => [
        it((_(), B("span", {
          class: $([
            `${e.ns.namespace.value}-table__column-filter-trigger`,
            `${e.ns.namespace.value}-none-outline`
          ]),
          onClick: e.showFilterPanel
        }, [
          q(f, null, {
            default: Q(() => [
              ee(e.$slots, "filter-icon", {}, () => {
                var m;
                return [
                  (m = e.column) != null && m.filterOpened ? (_(), ae(c, { key: 0 })) : (_(), ae(d, { key: 1 }))
                ];
              })
            ]),
            _: 3
          })
        ], 10, ["onClick"])), [
          [p, e.hideFilterPanel, e.popperPaneRef]
        ])
      ]),
      _: 3
    }, 8, ["visible", "placement", "popper-class", "append-to"]);
  }
  var i9 = /* @__PURE__ */ Ne(r9, [["render", s9], ["__file", "filter-panel.vue"]]);
  function im(e) {
    const t = dt();
    gd(() => {
      n.value.addObserver(t);
    }), ft(() => {
      o(n.value), l(n.value);
    }), Qo(() => {
      o(n.value), l(n.value);
    }), bs(() => {
      n.value.removeObserver(t);
    });
    const n = S(() => {
      const a = e.layout;
      if (!a)
        throw new Error("Can not find table layout.");
      return a;
    }), o = (a) => {
      var r;
      const i = ((r = e.vnode.el) == null ? void 0 : r.querySelectorAll("colgroup > col")) || [];
      if (!i.length)
        return;
      const u = a.getFlattenColumns(), c = {};
      u.forEach((d) => {
        c[d.id] = d;
      });
      for (let d = 0, f = i.length; d < f; d++) {
        const v = i[d], p = v.getAttribute("name"), m = c[p];
        m && v.setAttribute("width", m.realWidth || m.width);
      }
    }, l = (a) => {
      var r, i;
      const u = ((r = e.vnode.el) == null ? void 0 : r.querySelectorAll("colgroup > col[name=gutter]")) || [];
      for (let d = 0, f = u.length; d < f; d++)
        u[d].setAttribute("width", a.scrollY.value ? a.gutterWidth : "0");
      const c = ((i = e.vnode.el) == null ? void 0 : i.querySelectorAll("th.gutter")) || [];
      for (let d = 0, f = c.length; d < f; d++) {
        const v = c[d];
        v.style.width = a.scrollY.value ? `${a.gutterWidth}px` : "0", v.style.display = a.scrollY.value ? "" : "none";
      }
    };
    return {
      tableLayout: n.value,
      onColumnsChange: o,
      onScrollableChange: l
    };
  }
  const ol = Symbol("ElTable");
  function u9(e, t) {
    const n = dt(), o = Ve(ol), l = (h) => {
      h.stopPropagation();
    }, a = (h, g) => {
      !g.filters && g.sortable ? m(h, g, !1) : g.filterable && !g.sortable && l(h), o == null || o.emit("header-click", g, h);
    }, r = (h, g) => {
      o == null || o.emit("header-contextmenu", g, h);
    }, i = A(null), u = A(!1), c = A(), d = (h, g) => {
      var b, C;
      if (xt && !(g.children && g.children.length > 0) && i.value && e.border) {
        u.value = !0;
        const w = o;
        t("set-drag-visible", !0);
        const y = w == null ? void 0 : w.vnode.el, E = y == null ? void 0 : y.getBoundingClientRect().left, k = (C = (b = n == null ? void 0 : n.vnode) == null ? void 0 : b.el) == null ? void 0 : C.querySelector(`th.${g.id}`), T = k.getBoundingClientRect(), x = T.left - E + 30;
        _o(k, "noclick"), c.value = {
          startMouseLeft: h.clientX,
          startLeft: T.right - E,
          startColumnLeft: T.left - E,
          tableLeft: E
        };
        const I = w == null ? void 0 : w.refs.resizeProxy;
        I.style.left = `${c.value.startLeft}px`, document.onselectstart = function() {
          return !1;
        }, document.ondragstart = function() {
          return !1;
        };
        const P = (N) => {
          const z = N.clientX - c.value.startMouseLeft, Y = c.value.startLeft + z;
          I.style.left = `${Math.max(x, Y)}px`;
        }, O = () => {
          if (u.value) {
            const { startColumnLeft: N, startLeft: z } = c.value, G = Number.parseInt(I.style.left, 10) - N;
            g.width = g.realWidth = G, w == null || w.emit("header-dragend", g.width, z - N, g, h), requestAnimationFrame(() => {
              e.store.scheduleLayout(!1, !0);
            }), document.body.style.cursor = "", u.value = !1, i.value = null, c.value = void 0, t("set-drag-visible", !1);
          }
          document.removeEventListener("mousemove", P), document.removeEventListener("mouseup", O), document.onselectstart = null, document.ondragstart = null, setTimeout(() => {
            jn(k, "noclick");
          }, 0);
        };
        document.addEventListener("mousemove", P), document.addEventListener("mouseup", O);
      }
    }, f = (h, g) => {
      var b;
      if (g.children && g.children.length > 0)
        return;
      const C = h.target;
      if (!Qn(C))
        return;
      const w = C == null ? void 0 : C.closest("th");
      if (!(!g || !g.resizable || !w) && !u.value && e.border) {
        const y = w.getBoundingClientRect(), E = document.body.style, k = ((b = w.parentNode) == null ? void 0 : b.lastElementChild) === w, T = e.allowDragLastColumn || !k;
        y.width > 12 && y.right - h.clientX < 8 && T ? (E.cursor = "col-resize", Lo(w, "is-sortable") && (w.style.cursor = "col-resize"), i.value = g) : u.value || (E.cursor = "", Lo(w, "is-sortable") && (w.style.cursor = "pointer"), i.value = null);
      }
    }, v = () => {
      xt && (document.body.style.cursor = "");
    }, p = ({ order: h, sortOrders: g }) => {
      if (h === "")
        return g[0];
      const b = g.indexOf(h || null);
      return g[b > g.length - 2 ? 0 : b + 1];
    }, m = (h, g, b) => {
      var C;
      h.stopPropagation();
      const w = g.order === b ? null : b || p(g), y = (C = h.target) == null ? void 0 : C.closest("th");
      if (y && Lo(y, "noclick")) {
        jn(y, "noclick");
        return;
      }
      if (!g.sortable)
        return;
      const E = h.currentTarget;
      if (["ascending", "descending"].some((P) => Lo(E, P) && !g.sortOrders.includes(P)))
        return;
      const k = e.store.states;
      let T = k.sortProp.value, x;
      const I = k.sortingColumn.value;
      (I !== g || I === g && Zi(I.order)) && (I && (I.order = null), k.sortingColumn.value = g, T = g.property), w ? x = g.order = w : x = g.order = null, k.sortProp.value = T, k.sortOrder.value = x, o == null || o.store.commit("changeSortCondition");
    };
    return {
      handleHeaderClick: a,
      handleHeaderContextMenu: r,
      handleMouseDown: d,
      handleMouseMove: f,
      handleMouseOut: v,
      handleSortClick: m,
      handleFilterClick: l
    };
  }
  function c9(e) {
    const t = Ve(ol), n = he("table");
    return {
      getHeaderRowStyle: (i) => {
        const u = t == null ? void 0 : t.props.headerRowStyle;
        return Fe(u) ? u.call(null, { rowIndex: i }) : u;
      },
      getHeaderRowClass: (i) => {
        const u = [], c = t == null ? void 0 : t.props.headerRowClassName;
        return Ae(c) ? u.push(c) : Fe(c) && u.push(c.call(null, { rowIndex: i })), u.join(" ");
      },
      getHeaderCellStyle: (i, u, c, d) => {
        var f;
        let v = (f = t == null ? void 0 : t.props.headerCellStyle) != null ? f : {};
        Fe(v) && (v = v.call(null, {
          rowIndex: i,
          columnIndex: u,
          row: c,
          column: d
        }));
        const p = rm(u, d.fixed, e.store, c);
        return ps(p, "left"), ps(p, "right"), Object.assign({}, v, p);
      },
      getHeaderCellClass: (i, u, c, d) => {
        const f = am(n.b(), u, d.fixed, e.store, c), v = [
          d.id,
          d.order,
          d.headerAlign,
          d.className,
          d.labelClassName,
          ...f
        ];
        d.children || v.push("is-leaf"), d.sortable && v.push("is-sortable");
        const p = t == null ? void 0 : t.props.headerCellClassName;
        return Ae(p) ? v.push(p) : Fe(p) && v.push(p.call(null, {
          rowIndex: i,
          columnIndex: u,
          row: c,
          column: d
        })), v.push(n.e("cell")), v.filter((m) => !!m).join(" ");
      }
    };
  }
  const mk = (e) => {
    const t = [];
    return e.forEach((n) => {
      n.children ? (t.push(n), t.push.apply(t, mk(n.children))) : t.push(n);
    }), t;
  }, gk = (e) => {
    let t = 1;
    const n = (a, r) => {
      if (r && (a.level = r.level + 1, t < a.level && (t = a.level)), a.children) {
        let i = 0;
        a.children.forEach((u) => {
          n(u, a), i += u.colSpan;
        }), a.colSpan = i;
      } else
        a.colSpan = 1;
    };
    e.forEach((a) => {
      a.level = 1, n(a, void 0);
    });
    const o = [];
    for (let a = 0; a < t; a++)
      o.push([]);
    return mk(e).forEach((a) => {
      a.children ? (a.rowSpan = 1, a.children.forEach((r) => r.isSubColumn = !0)) : a.rowSpan = t - a.level + 1, o[a.level - 1].push(a);
    }), o;
  };
  function d9(e) {
    const t = Ve(ol), n = S(() => gk(e.store.states.originColumns.value));
    return {
      isGroup: S(() => {
        const a = n.value.length > 1;
        return a && t && (t.state.isGroup.value = !0), a;
      }),
      toggleAllSelection: (a) => {
        a.stopPropagation(), t == null || t.store.commit("toggleAllSelection");
      },
      columnRows: n
    };
  }
  var f9 = /* @__PURE__ */ U({
    name: "ElTableHeader",
    components: {
      ElCheckbox: xo
    },
    props: {
      fixed: {
        type: String,
        default: ""
      },
      store: {
        required: !0,
        type: Object
      },
      border: Boolean,
      defaultSort: {
        type: Object,
        default: () => ({
          prop: "",
          order: ""
        })
      },
      appendFilterPanelTo: {
        type: String
      },
      allowDragLastColumn: {
        type: Boolean
      }
    },
    setup(e, { emit: t }) {
      const n = dt(), o = Ve(ol), l = he("table"), a = A({}), { onColumnsChange: r, onScrollableChange: i } = im(o), u = (o == null ? void 0 : o.props.tableLayout) === "auto", c = Rt(/* @__PURE__ */ new Map()), d = A();
      let f;
      const v = () => {
        f = setTimeout(() => {
          c.size > 0 && (c.forEach((O, N) => {
            const z = d.value.querySelector(`.${N.replace(/\s/g, ".")}`);
            if (z) {
              const Y = z.getBoundingClientRect().width;
              O.width = Y || O.width;
            }
          }), c.clear());
        });
      };
      de(c, v), Bt(() => {
        f && (clearTimeout(f), f = void 0);
      }), ft(async () => {
        await Re(), await Re();
        const { prop: O, order: N } = e.defaultSort;
        o == null || o.store.commit("sort", { prop: O, order: N, init: !0 }), v();
      });
      const {
        handleHeaderClick: p,
        handleHeaderContextMenu: m,
        handleMouseDown: h,
        handleMouseMove: g,
        handleMouseOut: b,
        handleSortClick: C,
        handleFilterClick: w
      } = u9(e, t), {
        getHeaderRowStyle: y,
        getHeaderRowClass: E,
        getHeaderCellStyle: k,
        getHeaderCellClass: T
      } = c9(e), { isGroup: x, toggleAllSelection: I, columnRows: P } = d9(e);
      return n.state = {
        onColumnsChange: r,
        onScrollableChange: i
      }, n.filterPanels = a, {
        ns: l,
        filterPanels: a,
        onColumnsChange: r,
        onScrollableChange: i,
        columnRows: P,
        getHeaderRowClass: E,
        getHeaderRowStyle: y,
        getHeaderCellClass: T,
        getHeaderCellStyle: k,
        handleHeaderClick: p,
        handleHeaderContextMenu: m,
        handleMouseDown: h,
        handleMouseMove: g,
        handleMouseOut: b,
        handleSortClick: C,
        handleFilterClick: w,
        isGroup: x,
        toggleAllSelection: I,
        saveIndexSelection: c,
        isTableLayoutAuto: u,
        theadRef: d,
        updateFixedColumnStyle: v
      };
    },
    render() {
      const {
        ns: e,
        isGroup: t,
        columnRows: n,
        getHeaderCellStyle: o,
        getHeaderCellClass: l,
        getHeaderRowClass: a,
        getHeaderRowStyle: r,
        handleHeaderClick: i,
        handleHeaderContextMenu: u,
        handleMouseDown: c,
        handleMouseMove: d,
        handleSortClick: f,
        handleMouseOut: v,
        store: p,
        $parent: m,
        saveIndexSelection: h,
        isTableLayoutAuto: g
      } = this;
      let b = 1;
      return qe("thead", {
        ref: "theadRef",
        class: e.is("group", t)
      }, n.map((C, w) => qe("tr", {
        class: a(w),
        key: w,
        style: r(w)
      }, C.map((y, E) => {
        y.rowSpan > b && (b = y.rowSpan);
        const k = l(w, E, C, y);
        return g && y.fixed && h.set(k, y), qe("th", {
          class: k,
          colspan: y.colSpan,
          key: `${y.id}-thead`,
          rowspan: y.rowSpan,
          style: o(w, E, C, y),
          onClick: (T) => {
            var x;
            (x = T.currentTarget) != null && x.classList.contains("noclick") || i(T, y);
          },
          onContextmenu: (T) => u(T, y),
          onMousedown: (T) => c(T, y),
          onMousemove: (T) => d(T, y),
          onMouseout: v
        }, [
          qe("div", {
            class: [
              "cell",
              y.filteredValue && y.filteredValue.length > 0 ? "highlight" : ""
            ]
          }, [
            y.renderHeader ? y.renderHeader({
              column: y,
              $index: E,
              store: p,
              _self: m
            }) : y.label,
            y.sortable && qe("span", {
              onClick: (T) => f(T, y),
              class: "caret-wrapper"
            }, [
              qe("i", {
                onClick: (T) => f(T, y, "ascending"),
                class: "sort-caret ascending"
              }),
              qe("i", {
                onClick: (T) => f(T, y, "descending"),
                class: "sort-caret descending"
              })
            ]),
            y.filterable && qe(i9, {
              store: p,
              placement: y.filterPlacement || "bottom-start",
              appendTo: m == null ? void 0 : m.appendFilterPanelTo,
              column: y,
              upDataColumn: (T, x) => {
                y[T] = x;
              }
            }, {
              "filter-icon": () => y.renderFilterIcon ? y.renderFilterIcon({
                filterOpened: y.filterOpened
              }) : null
            })
          ])
        ]);
      }))));
    }
  });
  function Kf(e, t, n = 0.03) {
    return e - t > n;
  }
  function p9(e) {
    const t = Ve(ol), n = A(""), o = A(qe("div")), l = (m, h, g) => {
      var b, C, w;
      const y = t, E = Hf(m);
      let k = null;
      const T = (b = y == null ? void 0 : y.vnode.el) == null ? void 0 : b.dataset.prefix;
      E && (k = Vy({
        columns: (w = (C = e.store) == null ? void 0 : C.states.columns.value) != null ? w : []
      }, E, T), k && (y == null || y.emit(`cell-${g}`, h, k, E, m))), y == null || y.emit(`row-${g}`, h, k, m);
    }, a = (m, h) => {
      l(m, h, "dblclick");
    }, r = (m, h) => {
      var g;
      (g = e.store) == null || g.commit("setCurrentRow", h), l(m, h, "click");
    }, i = (m, h) => {
      l(m, h, "contextmenu");
    }, u = wl((m) => {
      var h;
      (h = e.store) == null || h.commit("setHoverRow", m);
    }, 30), c = wl(() => {
      var m;
      (m = e.store) == null || m.commit("setHoverRow", null);
    }, 30), d = (m) => {
      const h = window.getComputedStyle(m, null), g = Number.parseInt(h.paddingLeft, 10) || 0, b = Number.parseInt(h.paddingRight, 10) || 0, C = Number.parseInt(h.paddingTop, 10) || 0, w = Number.parseInt(h.paddingBottom, 10) || 0;
      return {
        left: g,
        right: b,
        top: C,
        bottom: w
      };
    }, f = (m, h, g) => {
      var b;
      let C = (b = h == null ? void 0 : h.target) == null ? void 0 : b.parentNode;
      for (; m > 1 && (C = C == null ? void 0 : C.nextSibling, !(!C || C.nodeName !== "TR")); )
        g(C, "hover-row hover-fixed-row"), m--;
    };
    return {
      handleDoubleClick: a,
      handleClick: r,
      handleContextMenu: i,
      handleMouseEnter: u,
      handleMouseLeave: c,
      handleCellMouseEnter: (m, h, g) => {
        var b, C, w, y, E, k, T, x, I;
        if (!t)
          return;
        const P = t, O = Hf(m), N = (b = P == null ? void 0 : P.vnode.el) == null ? void 0 : b.dataset.prefix;
        let z = null;
        if (O) {
          if (z = Vy({
            columns: (w = (C = e.store) == null ? void 0 : C.states.columns.value) != null ? w : []
          }, O, N), !z)
            return;
          O.rowSpan > 1 && f(O.rowSpan, m, _o);
          const ie = P.hoverState = {
            cell: O,
            column: z,
            row: h
          };
          P == null || P.emit("cell-mouse-enter", ie.row, ie.column, ie.cell, m);
        }
        if (!g) {
          ((y = Fn) == null ? void 0 : y.trigger) === O && ((E = Fn) == null || E());
          return;
        }
        const Y = m.target.querySelector(".cell");
        if (!(Lo(Y, `${N}-tooltip`) && Y.childNodes.length && ((k = Y.textContent) != null && k.trim())))
          return;
        const G = document.createRange();
        G.setStart(Y, 0), G.setEnd(Y, Y.childNodes.length);
        const { width: M, height: R } = G.getBoundingClientRect(), { width: D, height: L } = Y.getBoundingClientRect(), { top: V, left: F, right: H, bottom: K } = d(Y), Z = F + H, J = V + K;
        Kf(M + Z, D) || Kf(R + J, L) || Kf(Y.scrollWidth, D) ? Gj(g, (T = (O == null ? void 0 : O.innerText) || (O == null ? void 0 : O.textContent)) != null ? T : "", h, z, O, P) : ((x = Fn) == null ? void 0 : x.trigger) === O && ((I = Fn) == null || I());
      },
      handleCellMouseLeave: (m) => {
        const h = Hf(m);
        if (!h)
          return;
        h.rowSpan > 1 && f(h.rowSpan, m, jn);
        const g = t == null ? void 0 : t.hoverState;
        t == null || t.emit("cell-mouse-leave", g == null ? void 0 : g.row, g == null ? void 0 : g.column, g == null ? void 0 : g.cell, m);
      },
      tooltipContent: n,
      tooltipTrigger: o
    };
  }
  function v9(e) {
    const t = Ve(ol), n = he("table");
    return {
      getRowStyle: (c, d) => {
        const f = t == null ? void 0 : t.props.rowStyle;
        return Fe(f) ? f.call(null, {
          row: c,
          rowIndex: d
        }) : f || null;
      },
      getRowClass: (c, d, f) => {
        var v;
        const p = [n.e("row")];
        t != null && t.props.highlightCurrentRow && c === ((v = e.store) == null ? void 0 : v.states.currentRow.value) && p.push("current-row"), e.stripe && f % 2 === 1 && p.push(n.em("row", "striped"));
        const m = t == null ? void 0 : t.props.rowClassName;
        return Ae(m) ? p.push(m) : Fe(m) && p.push(m.call(null, {
          row: c,
          rowIndex: d
        })), p;
      },
      getCellStyle: (c, d, f, v) => {
        const p = t == null ? void 0 : t.props.cellStyle;
        let m = p ?? {};
        Fe(p) && (m = p.call(null, {
          rowIndex: c,
          columnIndex: d,
          row: f,
          column: v
        }));
        const h = rm(d, e == null ? void 0 : e.fixed, e.store);
        return ps(h, "left"), ps(h, "right"), Object.assign({}, m, h);
      },
      getCellClass: (c, d, f, v, p) => {
        const m = am(n.b(), d, e == null ? void 0 : e.fixed, e.store, void 0, p), h = [v.id, v.align, v.className, ...m], g = t == null ? void 0 : t.props.cellClassName;
        return Ae(g) ? h.push(g) : Fe(g) && h.push(g.call(null, {
          rowIndex: c,
          columnIndex: d,
          row: f,
          column: v
        })), h.push(n.e("cell")), h.filter((b) => !!b).join(" ");
      },
      getSpan: (c, d, f, v) => {
        let p = 1, m = 1;
        const h = t == null ? void 0 : t.props.spanMethod;
        if (Fe(h)) {
          const g = h({
            row: c,
            column: d,
            rowIndex: f,
            columnIndex: v
          });
          ye(g) ? (p = g[0], m = g[1]) : ot(g) && (p = g.rowspan, m = g.colspan);
        }
        return { rowspan: p, colspan: m };
      },
      getColspanRealWidth: (c, d, f) => {
        if (d < 1)
          return c[f].realWidth;
        const v = c.map(({ realWidth: p, width: m }) => p || m).slice(f, f + d);
        return Number(v.reduce((p, m) => Number(p) + Number(m), -1));
      }
    };
  }
  const h9 = /* @__PURE__ */ U({
    name: "TableTdWrapper"
  }), m9 = /* @__PURE__ */ U({
    ...h9,
    props: {
      colspan: {
        type: Number,
        default: 1
      },
      rowspan: {
        type: Number,
        default: 1
      }
    },
    setup(e) {
      return (t, n) => (_(), B("td", {
        colspan: e.colspan,
        rowspan: e.rowspan
      }, [
        ee(t.$slots, "default")
      ], 8, ["colspan", "rowspan"]));
    }
  });
  var g9 = /* @__PURE__ */ Ne(m9, [["__file", "td-wrapper.vue"]]);
  function b9(e) {
    const t = Ve(ol), n = he("table"), {
      handleDoubleClick: o,
      handleClick: l,
      handleContextMenu: a,
      handleMouseEnter: r,
      handleMouseLeave: i,
      handleCellMouseEnter: u,
      handleCellMouseLeave: c,
      tooltipContent: d,
      tooltipTrigger: f
    } = p9(e), {
      getRowStyle: v,
      getRowClass: p,
      getCellStyle: m,
      getCellClass: h,
      getSpan: g,
      getColspanRealWidth: b
    } = v9(e);
    let C = -1;
    const w = S(() => {
      var x;
      return (x = e.store) == null ? void 0 : x.states.columns.value.findIndex(({ type: I }) => I === "default");
    }), y = (x, I) => {
      var P;
      const O = (P = t == null ? void 0 : t.props) == null ? void 0 : P.rowKey;
      return O ? An(x, O) : I;
    }, E = (x, I, P, O = !1) => {
      const { tooltipEffect: N, tooltipOptions: z, store: Y } = e, { indent: G, columns: M } = Y.states, R = [];
      let D = !0;
      return P && (R.push(n.em("row", `level-${P.level}`)), D = !!P.display), I === 0 && (C = -1), e.stripe && D && C++, R.push(...p(x, I, C)), qe("tr", {
        style: [D ? null : { display: "none" }, v(x, I)],
        class: R,
        key: y(x, I),
        onDblclick: (V) => o(V, x),
        onClick: (V) => l(V, x),
        onContextmenu: (V) => a(V, x),
        onMouseenter: () => r(I),
        onMouseleave: i
      }, M.value.map((V, F) => {
        const { rowspan: H, colspan: K } = g(x, V, I, F);
        if (!H || !K)
          return null;
        const Z = Object.assign({}, V);
        Z.realWidth = b(M.value, K, F);
        const J = {
          store: Y,
          _self: e.context || t,
          column: Z,
          row: x,
          $index: I,
          cellIndex: F,
          expanded: O
        };
        F === w.value && P && (J.treeNode = {
          indent: P.level && P.level * G.value,
          level: P.level
        }, Vt(P.expanded) && (J.treeNode.expanded = P.expanded, "loading" in P && (J.treeNode.loading = P.loading), "noLazyChildren" in P && (J.treeNode.noLazyChildren = P.noLazyChildren)));
        const ie = `${y(x, I)},${F}`, ue = Z.columnKey || Z.rawColumnKey || "", re = V.showOverflowTooltip && q1({
          effect: N
        }, z, V.showOverflowTooltip);
        return qe(g9, {
          style: m(I, F, x, V),
          class: h(I, F, x, V, K - 1),
          key: `${ue}${ie}`,
          rowspan: H,
          colspan: K,
          onMouseenter: (se) => u(se, x, re),
          onMouseleave: c
        }, {
          default: () => k(F, V, J)
        });
      }));
    }, k = (x, I, P) => I.renderCell(P);
    return {
      wrappedRowRender: (x, I) => {
        const P = e.store, { isRowExpanded: O, assertRowKey: N } = P, { treeData: z, lazyTreeNodeMap: Y, childrenColumnName: G, rowKey: M } = P.states, R = P.states.columns.value;
        if (R.some(({ type: L }) => L === "expand")) {
          const L = O(x), V = E(x, I, void 0, L), F = t == null ? void 0 : t.renderExpanded;
          if (!F)
            return console.error("[Element Error]renderExpanded is required."), V;
          const H = [[V]];
          return (t.props.preserveExpandedContent || L) && H[0].push(qe("tr", {
            key: `expanded-row__${V.key}`,
            style: { display: L ? "" : "none" }
          }, [
            qe("td", {
              colspan: R.length,
              class: `${n.e("cell")} ${n.e("expanded-cell")}`
            }, [F({ row: x, $index: I, store: P, expanded: L })])
          ])), H;
        } else if (Object.keys(z.value).length) {
          N();
          const L = An(x, M.value);
          let V = z.value[L], F = null;
          V && (F = {
            expanded: V.expanded,
            level: V.level,
            display: !0,
            noLazyChildren: void 0,
            loading: void 0
          }, Vt(V.lazy) && (F && Vt(V.loaded) && V.loaded && (F.noLazyChildren = !(V.children && V.children.length)), F.loading = V.loading));
          const H = [E(x, I, F ?? void 0)];
          if (V) {
            let K = 0;
            const Z = (ie, ue) => {
              ie && ie.length && ue && ie.forEach((re) => {
                const se = {
                  display: ue.display && ue.expanded,
                  level: ue.level + 1,
                  expanded: !1,
                  noLazyChildren: !1,
                  loading: !1
                }, ne = An(re, M.value);
                if (go(ne))
                  throw new Error("For nested data item, row-key is required.");
                if (V = { ...z.value[ne] }, V && (se.expanded = V.expanded, V.level = V.level || se.level, V.display = !!(V.expanded && se.display), Vt(V.lazy) && (Vt(V.loaded) && V.loaded && (se.noLazyChildren = !(V.children && V.children.length)), se.loading = V.loading)), K++, H.push(E(re, I + K, se)), V) {
                  const le = Y.value[ne] || re[G.value];
                  Z(le, V);
                }
              });
            };
            V.display = !0;
            const J = Y.value[L] || x[G.value];
            Z(J, V);
          }
          return H;
        } else
          return E(x, I, void 0);
      },
      tooltipContent: d,
      tooltipTrigger: f
    };
  }
  const y9 = {
    store: {
      required: !0,
      type: Object
    },
    stripe: Boolean,
    tooltipEffect: String,
    tooltipOptions: {
      type: Object
    },
    context: {
      default: () => ({}),
      type: Object
    },
    rowClassName: [String, Function],
    rowStyle: [Object, Function],
    fixed: {
      type: String,
      default: ""
    },
    highlight: Boolean
  };
  var w9 = /* @__PURE__ */ U({
    name: "ElTableBody",
    props: y9,
    setup(e) {
      var t;
      const n = dt(), o = Ve(ol), l = he("table"), { wrappedRowRender: a, tooltipContent: r, tooltipTrigger: i } = b9(e), { onColumnsChange: u, onScrollableChange: c } = im(o), d = [];
      return de((t = e.store) == null ? void 0 : t.states.hoverRow, (f, v) => {
        var p, m;
        const h = n == null ? void 0 : n.vnode.el, g = Array.from((h == null ? void 0 : h.children) || []).filter((w) => w == null ? void 0 : w.classList.contains(`${l.e("row")}`));
        let b = f;
        const C = (p = g[b]) == null ? void 0 : p.childNodes;
        if (C != null && C.length) {
          let w = 0;
          Array.from(C).reduce((E, k, T) => {
            var x, I;
            return ((x = C[T]) == null ? void 0 : x.colSpan) > 1 && (w = (I = C[T]) == null ? void 0 : I.colSpan), k.nodeName !== "TD" && w === 0 && E.push(T), w > 0 && w--, E;
          }, []).forEach((E) => {
            var k;
            for (b = f; b > 0; ) {
              const T = (k = g[b - 1]) == null ? void 0 : k.childNodes;
              if (T[E] && T[E].nodeName === "TD" && T[E].rowSpan > 1) {
                _o(T[E], "hover-cell"), d.push(T[E]);
                break;
              }
              b--;
            }
          });
        } else
          d.forEach((w) => jn(w, "hover-cell")), d.length = 0;
        !((m = e.store) != null && m.states.isComplex.value) || !xt || Ul(() => {
          const w = g[v], y = g[f];
          w && !w.classList.contains("hover-fixed-row") && jn(w, "hover-row"), y && _o(y, "hover-row");
        });
      }), bs(() => {
        var f;
        (f = Fn) == null || f();
      }), {
        ns: l,
        onColumnsChange: u,
        onScrollableChange: c,
        wrappedRowRender: a,
        tooltipContent: r,
        tooltipTrigger: i
      };
    },
    render() {
      const { wrappedRowRender: e, store: t } = this, n = (t == null ? void 0 : t.states.data.value) || [];
      return qe("tbody", { tabIndex: -1 }, [
        n.reduce((o, l) => o.concat(e(l, o.length)), [])
      ]);
    }
  });
  function C9() {
    const e = Ve(ol), t = e == null ? void 0 : e.store, n = S(() => {
      var i;
      return (i = t == null ? void 0 : t.states.fixedLeafColumnsLength.value) != null ? i : 0;
    }), o = S(() => {
      var i;
      return (i = t == null ? void 0 : t.states.rightFixedColumns.value.length) != null ? i : 0;
    }), l = S(() => {
      var i;
      return (i = t == null ? void 0 : t.states.columns.value.length) != null ? i : 0;
    }), a = S(() => {
      var i;
      return (i = t == null ? void 0 : t.states.fixedColumns.value.length) != null ? i : 0;
    }), r = S(() => {
      var i;
      return (i = t == null ? void 0 : t.states.rightFixedColumns.value.length) != null ? i : 0;
    });
    return {
      leftFixedLeafCount: n,
      rightFixedLeafCount: o,
      columnsCount: l,
      leftFixedCount: a,
      rightFixedCount: r,
      columns: S(() => {
        var i;
        return (i = t == null ? void 0 : t.states.columns.value) != null ? i : [];
      })
    };
  }
  function S9(e) {
    const { columns: t } = C9(), n = he("table");
    return {
      getCellClasses: (a, r) => {
        const i = a[r], u = [
          n.e("cell"),
          i.id,
          i.align,
          i.labelClassName,
          ...am(n.b(), r, i.fixed, e.store)
        ];
        return i.className && u.push(i.className), i.children || u.push(n.is("leaf")), u;
      },
      getCellStyles: (a, r) => {
        const i = rm(r, a.fixed, e.store);
        return ps(i, "left"), ps(i, "right"), i;
      },
      columns: t
    };
  }
  var E9 = /* @__PURE__ */ U({
    name: "ElTableFooter",
    props: {
      fixed: {
        type: String,
        default: ""
      },
      store: {
        required: !0,
        type: Object
      },
      summaryMethod: Function,
      sumText: String,
      border: Boolean,
      defaultSort: {
        type: Object,
        default: () => ({
          prop: "",
          order: ""
        })
      }
    },
    setup(e) {
      const t = Ve(ol), n = he("table"), { getCellClasses: o, getCellStyles: l, columns: a } = S9(e), { onScrollableChange: r, onColumnsChange: i } = im(t);
      return {
        ns: n,
        onScrollableChange: r,
        onColumnsChange: i,
        getCellClasses: o,
        getCellStyles: l,
        columns: a
      };
    },
    render() {
      const { columns: e, getCellStyles: t, getCellClasses: n, summaryMethod: o, sumText: l } = this, a = this.store.states.data.value;
      let r = [];
      return o ? r = o({
        columns: e,
        data: a
      }) : e.forEach((i, u) => {
        if (u === 0) {
          r[u] = l;
          return;
        }
        const c = a.map((p) => Number(p[i.property])), d = [];
        let f = !0;
        c.forEach((p) => {
          if (!Number.isNaN(+p)) {
            f = !1;
            const m = `${p}`.split(".")[1];
            d.push(m ? m.length : 0);
          }
        });
        const v = Math.max.apply(null, d);
        f ? r[u] = "" : r[u] = c.reduce((p, m) => {
          const h = Number(m);
          return Number.isNaN(+h) ? p : Number.parseFloat((p + m).toFixed(Math.min(v, 20)));
        }, 0);
      }), qe(qe("tfoot", [
        qe("tr", {}, [
          ...e.map((i, u) => qe("td", {
            key: u,
            colspan: i.colSpan,
            rowspan: i.rowSpan,
            class: n(e, u),
            style: t(i, u)
          }, [
            qe("div", {
              class: ["cell", i.labelClassName]
            }, [r[u]])
          ]))
        ])
      ]));
    }
  });
  function k9(e) {
    return {
      setCurrentRow: (f) => {
        e.commit("setCurrentRow", f);
      },
      getSelectionRows: () => e.getSelectionRows(),
      toggleRowSelection: (f, v, p = !0) => {
        e.toggleRowSelection(f, v, !1, p), e.updateAllSelected();
      },
      clearSelection: () => {
        e.clearSelection();
      },
      clearFilter: (f) => {
        e.clearFilter(f);
      },
      toggleAllSelection: () => {
        e.commit("toggleAllSelection");
      },
      toggleRowExpansion: (f, v) => {
        e.toggleRowExpansionAdapter(f, v);
      },
      clearSort: () => {
        e.clearSort();
      },
      sort: (f, v) => {
        e.commit("sort", { prop: f, order: v });
      },
      updateKeyChildren: (f, v) => {
        e.updateKeyChildren(f, v);
      }
    };
  }
  function _9(e, t, n, o) {
    const l = A(!1), a = A(null), r = A(!1), i = (R) => {
      r.value = R;
    }, u = A({
      width: null,
      height: null,
      headerHeight: null
    }), c = A(!1), d = {
      display: "inline-block",
      verticalAlign: "middle"
    }, f = A(), v = A(0), p = A(0), m = A(0), h = A(0), g = A(0);
    to(() => {
      var R;
      t.setHeight((R = e.height) != null ? R : null);
    }), to(() => {
      var R;
      t.setMaxHeight((R = e.maxHeight) != null ? R : null);
    }), de(() => [e.currentRowKey, n.states.rowKey], ([R, D]) => {
      !s(D) || !s(R) || n.setCurrentRowKey(`${R}`);
    }, {
      immediate: !0
    }), de(() => e.data, (R) => {
      o.store.commit("setData", R);
    }, {
      immediate: !0,
      deep: !0
    }), to(() => {
      e.expandRowKeys && n.setExpandRowKeysAdapter(e.expandRowKeys);
    });
    const b = () => {
      o.store.commit("setHoverRow", null), o.hoverState && (o.hoverState = null);
    }, C = (R, D) => {
      const { pixelX: L, pixelY: V } = D;
      Math.abs(L) >= Math.abs(V) && (o.refs.bodyWrapper.scrollLeft += D.pixelX / 5);
    }, w = S(() => e.height || e.maxHeight || n.states.fixedColumns.value.length > 0 || n.states.rightFixedColumns.value.length > 0), y = S(() => ({
      width: t.bodyWidth.value ? `${t.bodyWidth.value}px` : ""
    })), E = () => {
      w.value && t.updateElsHeight(), t.updateColumnsWidth(), !(typeof window > "u") && requestAnimationFrame(I);
    };
    ft(async () => {
      await Re(), n.updateColumns(), P(), requestAnimationFrame(E);
      const R = o.vnode.el, D = o.refs.headerWrapper;
      e.flexible && R && R.parentElement && (R.parentElement.style.minWidth = "0"), u.value = {
        width: f.value = R.offsetWidth,
        height: R.offsetHeight,
        headerHeight: e.showHeader && D ? D.offsetHeight : null
      }, n.states.columns.value.forEach((L) => {
        L.filteredValue && L.filteredValue.length && o.store.commit("filterChange", {
          column: L,
          values: L.filteredValue,
          silent: !0
        });
      }), o.$ready = !0;
    });
    const k = (R, D) => {
      if (!R)
        return;
      const L = Array.from(R.classList).filter((V) => !V.startsWith("is-scrolling-"));
      L.push(t.scrollX.value ? D : "is-scrolling-none"), R.className = L.join(" ");
    }, T = (R) => {
      const { tableWrapper: D } = o.refs;
      k(D, R);
    }, x = (R) => {
      const { tableWrapper: D } = o.refs;
      return !!(D && D.classList.contains(R));
    }, I = function() {
      if (!o.refs.scrollBarRef)
        return;
      if (!t.scrollX.value) {
        const Z = "is-scrolling-none";
        x(Z) || T(Z);
        return;
      }
      const R = o.refs.scrollBarRef.wrapRef;
      if (!R)
        return;
      const { scrollLeft: D, offsetWidth: L, scrollWidth: V } = R, { headerWrapper: F, footerWrapper: H } = o.refs;
      F && (F.scrollLeft = D), H && (H.scrollLeft = D);
      const K = V - L - 1;
      D >= K ? T("is-scrolling-right") : T(D === 0 ? "is-scrolling-left" : "is-scrolling-middle");
    }, P = () => {
      o.refs.scrollBarRef && (o.refs.scrollBarRef.wrapRef && Dt(o.refs.scrollBarRef.wrapRef, "scroll", I, {
        passive: !0
      }), e.fit ? qt(o.vnode.el, O) : Dt(window, "resize", O), qt(o.refs.bodyWrapper, () => {
        var R, D;
        O(), (D = (R = o.refs) == null ? void 0 : R.scrollBarRef) == null || D.update();
      }));
    }, O = () => {
      var R, D, L, V;
      const F = o.vnode.el;
      if (!o.$ready || !F)
        return;
      let H = !1;
      const {
        width: K,
        height: Z,
        headerHeight: J
      } = u.value, ie = f.value = F.offsetWidth;
      K !== ie && (H = !0);
      const ue = F.offsetHeight;
      (e.height || w.value) && Z !== ue && (H = !0);
      const re = e.tableLayout === "fixed" ? o.refs.headerWrapper : (R = o.refs.tableHeaderRef) == null ? void 0 : R.$el;
      e.showHeader && (re == null ? void 0 : re.offsetHeight) !== J && (H = !0), v.value = ((D = o.refs.tableWrapper) == null ? void 0 : D.scrollHeight) || 0, m.value = (re == null ? void 0 : re.scrollHeight) || 0, h.value = ((L = o.refs.footerWrapper) == null ? void 0 : L.offsetHeight) || 0, g.value = ((V = o.refs.appendWrapper) == null ? void 0 : V.offsetHeight) || 0, p.value = v.value - m.value - h.value - g.value, H && (u.value = {
        width: ie,
        height: ue,
        headerHeight: e.showHeader && (re == null ? void 0 : re.offsetHeight) || 0
      }, E());
    }, N = vn(), z = S(() => {
      const { bodyWidth: R, scrollY: D, gutterWidth: L } = t;
      return R.value ? `${R.value - (D.value ? L : 0)}px` : "";
    }), Y = S(() => e.maxHeight ? "fixed" : e.tableLayout), G = S(() => {
      if (e.data && e.data.length)
        return;
      let R = "100%";
      e.height && p.value && (R = `${p.value}px`);
      const D = f.value;
      return {
        width: D ? `${D}px` : "",
        height: R
      };
    }), M = S(() => e.height ? {
      height: "100%"
    } : e.maxHeight ? Number.isNaN(Number(e.maxHeight)) ? {
      maxHeight: `calc(${e.maxHeight} - ${m.value + h.value}px)`
    } : {
      maxHeight: `${+e.maxHeight - m.value - h.value}px`
    } : {});
    return {
      isHidden: l,
      renderExpanded: a,
      setDragVisible: i,
      isGroup: c,
      handleMouseLeave: b,
      handleHeaderFooterMousewheel: C,
      tableSize: N,
      emptyBlockStyle: G,
      resizeProxyVisible: r,
      bodyWidth: z,
      resizeState: u,
      doLayout: E,
      tableBodyStyles: y,
      tableLayout: Y,
      scrollbarViewStyle: d,
      scrollbarStyle: M
    };
  }
  function T9(e) {
    const t = A(), n = () => {
      const l = e.vnode.el.querySelector(".hidden-columns"), a = { childList: !0, subtree: !0 }, r = e.store.states.updateOrderFns;
      t.value = new MutationObserver(() => {
        r.forEach((i) => i());
      }), t.value.observe(l, a);
    };
    ft(() => {
      n();
    }), bs(() => {
      var o;
      (o = t.value) == null || o.disconnect();
    });
  }
  var N9 = {
    data: {
      type: Array,
      default: () => []
    },
    size: mn,
    width: [String, Number],
    height: [String, Number],
    maxHeight: [String, Number],
    fit: {
      type: Boolean,
      default: !0
    },
    stripe: Boolean,
    border: Boolean,
    rowKey: [String, Function],
    showHeader: {
      type: Boolean,
      default: !0
    },
    showSummary: Boolean,
    sumText: String,
    summaryMethod: Function,
    rowClassName: [String, Function],
    rowStyle: [Object, Function],
    cellClassName: [String, Function],
    cellStyle: [Object, Function],
    headerRowClassName: [String, Function],
    headerRowStyle: [Object, Function],
    headerCellClassName: [String, Function],
    headerCellStyle: [Object, Function],
    highlightCurrentRow: Boolean,
    currentRowKey: [String, Number],
    emptyText: String,
    expandRowKeys: Array,
    defaultExpandAll: Boolean,
    defaultSort: Object,
    tooltipEffect: String,
    tooltipOptions: Object,
    spanMethod: Function,
    selectOnIndeterminate: {
      type: Boolean,
      default: !0
    },
    indent: {
      type: Number,
      default: 16
    },
    treeProps: {
      type: Object,
      default: () => ({
        hasChildren: "hasChildren",
        children: "children",
        checkStrictly: !1
      })
    },
    lazy: Boolean,
    load: Function,
    style: {
      type: Object,
      default: () => ({})
    },
    className: {
      type: String,
      default: ""
    },
    tableLayout: {
      type: String,
      default: "fixed"
    },
    scrollbarAlwaysOn: Boolean,
    flexible: Boolean,
    showOverflowTooltip: [Boolean, Object],
    tooltipFormatter: Function,
    appendFilterPanelTo: String,
    scrollbarTabindex: {
      type: [Number, String],
      default: void 0
    },
    allowDragLastColumn: {
      type: Boolean,
      default: !0
    },
    preserveExpandedContent: Boolean,
    nativeScrollbar: Boolean
  };
  function bk(e) {
    const t = e.tableLayout === "auto";
    let n = e.columns || [];
    t && n.every(({ width: l }) => kt(l)) && (n = []);
    const o = (l) => {
      const a = {
        key: `${e.tableLayout}_${l.id}`,
        style: {},
        name: void 0
      };
      return t ? a.style = {
        width: `${l.width}px`
      } : a.name = l.id, a;
    };
    return qe("colgroup", {}, n.map((l) => qe("col", o(l))));
  }
  bk.props = ["columns", "tableLayout"];
  const $9 = () => {
    const e = A(), t = (a, r) => {
      const i = e.value;
      i && i.scrollTo(a, r);
    }, n = (a, r) => {
      const i = e.value;
      i && je(r) && ["Top", "Left"].includes(a) && i[`setScroll${a}`](r);
    };
    return {
      scrollBarRef: e,
      scrollTo: t,
      setScrollTop: (a) => n("Top", a),
      setScrollLeft: (a) => n("Left", a)
    };
  };
  var Fy = !1, ja, Xp, Jp, ic, uc, yk, cc, Zp, Qp, ev, wk, tv, nv, Ck, Sk;
  function ao() {
    if (!Fy) {
      Fy = !0;
      var e = navigator.userAgent, t = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(e), n = /(Mac OS X)|(Windows)|(Linux)/.exec(e);
      if (tv = /\b(iPhone|iP[ao]d)/.exec(e), nv = /\b(iP[ao]d)/.exec(e), ev = /Android/i.exec(e), Ck = /FBAN\/\w+;/i.exec(e), Sk = /Mobile/i.exec(e), wk = !!/Win64/.exec(e), t) {
        ja = t[1] ? parseFloat(t[1]) : t[5] ? parseFloat(t[5]) : NaN, ja && document && document.documentMode && (ja = document.documentMode);
        var o = /(?:Trident\/(\d+.\d+))/.exec(e);
        yk = o ? parseFloat(o[1]) + 4 : ja, Xp = t[2] ? parseFloat(t[2]) : NaN, Jp = t[3] ? parseFloat(t[3]) : NaN, ic = t[4] ? parseFloat(t[4]) : NaN, ic ? (t = /(?:Chrome\/(\d+\.\d+))/.exec(e), uc = t && t[1] ? parseFloat(t[1]) : NaN) : uc = NaN;
      } else ja = Xp = Jp = uc = ic = NaN;
      if (n) {
        if (n[1]) {
          var l = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(e);
          cc = l ? parseFloat(l[1].replace("_", ".")) : !0;
        } else cc = !1;
        Zp = !!n[2], Qp = !!n[3];
      } else cc = Zp = Qp = !1;
    }
  }
  var ov = { ie: function() {
    return ao() || ja;
  }, ieCompatibilityMode: function() {
    return ao() || yk > ja;
  }, ie64: function() {
    return ov.ie() && wk;
  }, firefox: function() {
    return ao() || Xp;
  }, opera: function() {
    return ao() || Jp;
  }, webkit: function() {
    return ao() || ic;
  }, safari: function() {
    return ov.webkit();
  }, chrome: function() {
    return ao() || uc;
  }, windows: function() {
    return ao() || Zp;
  }, osx: function() {
    return ao() || cc;
  }, linux: function() {
    return ao() || Qp;
  }, iphone: function() {
    return ao() || tv;
  }, mobile: function() {
    return ao() || tv || nv || ev || Sk;
  }, nativeApp: function() {
    return ao() || Ck;
  }, android: function() {
    return ao() || ev;
  }, ipad: function() {
    return ao() || nv;
  } }, O9 = ov, I9 = !!(typeof window < "u" && window.document && window.document.createElement), M9 = { canUseDOM: I9 }, Ek = M9, kk;
  Ek.canUseDOM && (kk = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature("", "") !== !0);
  function x9(e, t) {
    if (!Ek.canUseDOM || t && !("addEventListener" in document)) return !1;
    var n = "on" + e, o = n in document;
    if (!o) {
      var l = document.createElement("div");
      l.setAttribute(n, "return;"), o = typeof l[n] == "function";
    }
    return !o && kk && e === "wheel" && (o = document.implementation.hasFeature("Events.wheel", "3.0")), o;
  }
  var P9 = x9, zy = 10, Hy = 40, Ky = 800;
  function _k(e) {
    var t = 0, n = 0, o = 0, l = 0;
    return "detail" in e && (n = e.detail), "wheelDelta" in e && (n = -e.wheelDelta / 120), "wheelDeltaY" in e && (n = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = n, n = 0), o = t * zy, l = n * zy, "deltaY" in e && (l = e.deltaY), "deltaX" in e && (o = e.deltaX), (o || l) && e.deltaMode && (e.deltaMode == 1 ? (o *= Hy, l *= Hy) : (o *= Ky, l *= Ky)), o && !t && (t = o < 1 ? -1 : 1), l && !n && (n = l < 1 ? -1 : 1), { spinX: t, spinY: n, pixelX: o, pixelY: l };
  }
  _k.getEventType = function() {
    return O9.firefox() ? "DOMMouseScroll" : P9("wheel") ? "wheel" : "mousewheel";
  };
  var R9 = _k;
  /**
  * Checks if an event is supported in the current execution environment.
  *
  * NOTE: This will not work correctly for non-generic events such as `change`,
  * `reset`, `load`, `error`, and `select`.
  *
  * Borrows from Modernizr.
  *
  * @param {string} eventNameSuffix Event name, e.g. "click".
  * @param {?boolean} capture Check if the capture phase is supported.
  * @return {boolean} True if the event is supported.
  * @internal
  * @license Modernizr 3.0.0pre (Custom Build) | MIT
  */
  const dc = "_Mousewheel", Wy = function(e, t) {
    if (e && e.addEventListener) {
      Tk(e);
      const n = function(o) {
        const l = R9(o);
        t && Reflect.apply(t, this, [o, l]);
      };
      e[dc] = { wheelHandler: n }, e.addEventListener("wheel", n, { passive: !0 });
    }
  }, Tk = (e) => {
    var t;
    (t = e[dc]) != null && t.wheelHandler && (e.removeEventListener("wheel", e[dc].wheelHandler), e[dc] = null);
  }, D9 = {
    beforeMount(e, t) {
      Wy(e, t.value);
    },
    unmounted(e) {
      Tk(e);
    },
    updated(e, t) {
      t.value !== t.oldValue && Wy(e, t.value);
    }
  };
  let A9 = 1;
  const V9 = /* @__PURE__ */ U({
    name: "ElTable",
    directives: {
      Mousewheel: D9
    },
    components: {
      TableHeader: f9,
      TableBody: w9,
      TableFooter: E9,
      ElScrollbar: Go,
      hColgroup: bk
    },
    props: N9,
    emits: [
      "select",
      "select-all",
      "selection-change",
      "cell-mouse-enter",
      "cell-mouse-leave",
      "cell-contextmenu",
      "cell-click",
      "cell-dblclick",
      "row-click",
      "row-contextmenu",
      "row-dblclick",
      "header-click",
      "header-contextmenu",
      "sort-change",
      "filter-change",
      "current-change",
      "header-dragend",
      "expand-change",
      "scroll"
    ],
    setup(e) {
      const { t } = _t(), n = he("table"), o = dt();
      yt(ol, o);
      const l = n9(o, e);
      o.store = l;
      const a = new l9({
        store: o.store,
        table: o,
        fit: e.fit,
        showHeader: e.showHeader
      });
      o.layout = a;
      const r = S(() => (l.states.data.value || []).length === 0), {
        setCurrentRow: i,
        getSelectionRows: u,
        toggleRowSelection: c,
        clearSelection: d,
        clearFilter: f,
        toggleAllSelection: v,
        toggleRowExpansion: p,
        clearSort: m,
        sort: h,
        updateKeyChildren: g
      } = k9(l), {
        isHidden: b,
        renderExpanded: C,
        setDragVisible: w,
        isGroup: y,
        handleMouseLeave: E,
        handleHeaderFooterMousewheel: k,
        tableSize: T,
        emptyBlockStyle: x,
        resizeProxyVisible: I,
        bodyWidth: P,
        resizeState: O,
        doLayout: N,
        tableBodyStyles: z,
        tableLayout: Y,
        scrollbarViewStyle: G,
        scrollbarStyle: M
      } = _9(e, a, l, o), { scrollBarRef: R, scrollTo: D, setScrollLeft: L, setScrollTop: V } = $9(), F = wl(N, 50), H = `${n.namespace.value}-table_${A9++}`;
      o.tableId = H, o.state = {
        isGroup: y,
        resizeState: O,
        doLayout: N,
        debouncedUpdateLayout: F
      };
      const K = S(() => {
        var ie;
        return (ie = e.sumText) != null ? ie : t("el.table.sumText");
      }), Z = S(() => {
        var ie;
        return (ie = e.emptyText) != null ? ie : t("el.table.emptyText");
      }), J = S(() => gk(l.states.originColumns.value)[0]);
      return T9(o), Bt(() => {
        F.cancel();
      }), {
        ns: n,
        layout: a,
        store: l,
        columns: J,
        handleHeaderFooterMousewheel: k,
        handleMouseLeave: E,
        tableId: H,
        tableSize: T,
        isHidden: b,
        isEmpty: r,
        renderExpanded: C,
        resizeProxyVisible: I,
        resizeState: O,
        isGroup: y,
        bodyWidth: P,
        tableBodyStyles: z,
        emptyBlockStyle: x,
        debouncedUpdateLayout: F,
        setCurrentRow: i,
        getSelectionRows: u,
        toggleRowSelection: c,
        clearSelection: d,
        clearFilter: f,
        toggleAllSelection: v,
        toggleRowExpansion: p,
        clearSort: m,
        doLayout: N,
        sort: h,
        updateKeyChildren: g,
        t,
        setDragVisible: w,
        context: o,
        computedSumText: K,
        computedEmptyText: Z,
        tableLayout: Y,
        scrollbarViewStyle: G,
        scrollbarStyle: M,
        scrollBarRef: R,
        scrollTo: D,
        setScrollLeft: L,
        setScrollTop: V,
        allowDragLastColumn: e.allowDragLastColumn
      };
    }
  });
  function L9(e, t, n, o, l, a) {
    const r = $t("hColgroup"), i = $t("table-header"), u = $t("table-body"), c = $t("table-footer"), d = $t("el-scrollbar"), f = bd("mousewheel");
    return _(), B("div", {
      ref: "tableWrapper",
      class: $([
        {
          [e.ns.m("fit")]: e.fit,
          [e.ns.m("striped")]: e.stripe,
          [e.ns.m("border")]: e.border || e.isGroup,
          [e.ns.m("hidden")]: e.isHidden,
          [e.ns.m("group")]: e.isGroup,
          [e.ns.m("fluid-height")]: e.maxHeight,
          [e.ns.m("scrollable-x")]: e.layout.scrollX.value,
          [e.ns.m("scrollable-y")]: e.layout.scrollY.value,
          [e.ns.m("enable-row-hover")]: !e.store.states.isComplex.value,
          [e.ns.m("enable-row-transition")]: (e.store.states.data.value || []).length !== 0 && (e.store.states.data.value || []).length < 100,
          "has-footer": e.showSummary
        },
        e.ns.m(e.tableSize),
        e.className,
        e.ns.b(),
        e.ns.m(`layout-${e.tableLayout}`)
      ]),
      style: Ue(e.style),
      "data-prefix": e.ns.namespace.value,
      onMouseleave: e.handleMouseLeave
    }, [
      W("div", {
        class: $(e.ns.e("inner-wrapper"))
      }, [
        W("div", {
          ref: "hiddenColumns",
          class: "hidden-columns"
        }, [
          ee(e.$slots, "default")
        ], 512),
        e.showHeader && e.tableLayout === "fixed" ? it((_(), B("div", {
          key: 0,
          ref: "headerWrapper",
          class: $(e.ns.e("header-wrapper"))
        }, [
          W("table", {
            ref: "tableHeader",
            class: $(e.ns.e("header")),
            style: Ue(e.tableBodyStyles),
            border: "0",
            cellpadding: "0",
            cellspacing: "0"
          }, [
            q(r, {
              columns: e.store.states.columns.value,
              "table-layout": e.tableLayout
            }, null, 8, ["columns", "table-layout"]),
            q(i, {
              ref: "tableHeaderRef",
              border: e.border,
              "default-sort": e.defaultSort,
              store: e.store,
              "append-filter-panel-to": e.appendFilterPanelTo,
              "allow-drag-last-column": e.allowDragLastColumn,
              onSetDragVisible: e.setDragVisible
            }, null, 8, ["border", "default-sort", "store", "append-filter-panel-to", "allow-drag-last-column", "onSetDragVisible"])
          ], 6)
        ], 2)), [
          [f, e.handleHeaderFooterMousewheel]
        ]) : oe("v-if", !0),
        W("div", {
          ref: "bodyWrapper",
          class: $(e.ns.e("body-wrapper"))
        }, [
          q(d, {
            ref: "scrollBarRef",
            "view-style": e.scrollbarViewStyle,
            "wrap-style": e.scrollbarStyle,
            always: e.scrollbarAlwaysOn,
            tabindex: e.scrollbarTabindex,
            native: e.nativeScrollbar,
            onScroll: (v) => e.$emit("scroll", v)
          }, {
            default: Q(() => [
              W("table", {
                ref: "tableBody",
                class: $(e.ns.e("body")),
                cellspacing: "0",
                cellpadding: "0",
                border: "0",
                style: Ue({
                  width: e.bodyWidth,
                  tableLayout: e.tableLayout
                })
              }, [
                q(r, {
                  columns: e.store.states.columns.value,
                  "table-layout": e.tableLayout
                }, null, 8, ["columns", "table-layout"]),
                e.showHeader && e.tableLayout === "auto" ? (_(), ae(i, {
                  key: 0,
                  ref: "tableHeaderRef",
                  class: $(e.ns.e("body-header")),
                  border: e.border,
                  "default-sort": e.defaultSort,
                  store: e.store,
                  "append-filter-panel-to": e.appendFilterPanelTo,
                  onSetDragVisible: e.setDragVisible
                }, null, 8, ["class", "border", "default-sort", "store", "append-filter-panel-to", "onSetDragVisible"])) : oe("v-if", !0),
                q(u, {
                  context: e.context,
                  highlight: e.highlightCurrentRow,
                  "row-class-name": e.rowClassName,
                  "tooltip-effect": e.tooltipEffect,
                  "tooltip-options": e.tooltipOptions,
                  "row-style": e.rowStyle,
                  store: e.store,
                  stripe: e.stripe
                }, null, 8, ["context", "highlight", "row-class-name", "tooltip-effect", "tooltip-options", "row-style", "store", "stripe"]),
                e.showSummary && e.tableLayout === "auto" ? (_(), ae(c, {
                  key: 1,
                  class: $(e.ns.e("body-footer")),
                  border: e.border,
                  "default-sort": e.defaultSort,
                  store: e.store,
                  "sum-text": e.computedSumText,
                  "summary-method": e.summaryMethod
                }, null, 8, ["class", "border", "default-sort", "store", "sum-text", "summary-method"])) : oe("v-if", !0)
              ], 6),
              e.isEmpty ? (_(), B("div", {
                key: 0,
                ref: "emptyBlock",
                style: Ue(e.emptyBlockStyle),
                class: $(e.ns.e("empty-block"))
              }, [
                W("span", {
                  class: $(e.ns.e("empty-text"))
                }, [
                  ee(e.$slots, "empty", {}, () => [
                    Ct(ke(e.computedEmptyText), 1)
                  ])
                ], 2)
              ], 6)) : oe("v-if", !0),
              e.$slots.append ? (_(), B("div", {
                key: 1,
                ref: "appendWrapper",
                class: $(e.ns.e("append-wrapper"))
              }, [
                ee(e.$slots, "append")
              ], 2)) : oe("v-if", !0)
            ]),
            _: 3
          }, 8, ["view-style", "wrap-style", "always", "tabindex", "native", "onScroll"])
        ], 2),
        e.showSummary && e.tableLayout === "fixed" ? it((_(), B("div", {
          key: 1,
          ref: "footerWrapper",
          class: $(e.ns.e("footer-wrapper"))
        }, [
          W("table", {
            class: $(e.ns.e("footer")),
            cellspacing: "0",
            cellpadding: "0",
            border: "0",
            style: Ue(e.tableBodyStyles)
          }, [
            q(r, {
              columns: e.store.states.columns.value,
              "table-layout": e.tableLayout
            }, null, 8, ["columns", "table-layout"]),
            q(c, {
              border: e.border,
              "default-sort": e.defaultSort,
              store: e.store,
              "sum-text": e.computedSumText,
              "summary-method": e.summaryMethod
            }, null, 8, ["border", "default-sort", "store", "sum-text", "summary-method"])
          ], 6)
        ], 2)), [
          [Mt, !e.isEmpty],
          [f, e.handleHeaderFooterMousewheel]
        ]) : oe("v-if", !0),
        e.border || e.isGroup ? (_(), B("div", {
          key: 2,
          class: $(e.ns.e("border-left-patch"))
        }, null, 2)) : oe("v-if", !0)
      ], 2),
      it(W("div", {
        ref: "resizeProxy",
        class: $(e.ns.e("column-resize-proxy"))
      }, null, 2), [
        [Mt, e.resizeProxyVisible]
      ])
    ], 46, ["data-prefix", "onMouseleave"]);
  }
  var B9 = /* @__PURE__ */ Ne(V9, [["render", L9], ["__file", "table.vue"]]);
  const F9 = {
    selection: "table-column--selection",
    expand: "table__expand-column"
  }, z9 = {
    default: {
      order: ""
    },
    selection: {
      width: 48,
      minWidth: 48,
      realWidth: 48,
      order: ""
    },
    expand: {
      width: 48,
      minWidth: 48,
      realWidth: 48,
      order: ""
    },
    index: {
      width: 48,
      minWidth: 48,
      realWidth: 48,
      order: ""
    }
  }, H9 = (e) => F9[e] || "", K9 = {
    selection: {
      renderHeader({
        store: e,
        column: t
      }) {
        var n;
        function o() {
          return e.states.data.value && e.states.data.value.length === 0;
        }
        return qe(xo, {
          disabled: o(),
          size: e.states.tableSize.value,
          indeterminate: e.states.selection.value.length > 0 && !e.states.isAllSelected.value,
          "onUpdate:modelValue": (n = e.toggleAllSelection) != null ? n : void 0,
          modelValue: e.states.isAllSelected.value,
          ariaLabel: t.label
        });
      },
      renderCell({
        row: e,
        column: t,
        store: n,
        $index: o
      }) {
        return qe(xo, {
          disabled: t.selectable ? !t.selectable.call(null, e, o) : !1,
          size: n.states.tableSize.value,
          onChange: () => {
            n.commit("rowSelectedChanged", e);
          },
          onClick: (l) => l.stopPropagation(),
          modelValue: n.isSelected(e),
          ariaLabel: t.label
        });
      },
      sortable: !1,
      resizable: !1
    },
    index: {
      renderHeader({
        column: e
      }) {
        return e.label || "#";
      },
      renderCell({
        column: e,
        $index: t
      }) {
        let n = t + 1;
        const o = e.index;
        return je(o) ? n = t + o : Fe(o) && (n = o(t)), qe("div", {}, [n]);
      },
      sortable: !1
    },
    expand: {
      renderHeader({
        column: e
      }) {
        return e.label || "";
      },
      renderCell({
        column: e,
        row: t,
        store: n,
        expanded: o
      }) {
        const { ns: l } = n, a = [l.e("expand-icon")];
        return !e.renderExpand && o && a.push(l.em("expand-icon", "expanded")), qe("div", {
          class: a,
          onClick: function(i) {
            i.stopPropagation(), n.toggleRowExpansion(t);
          }
        }, {
          default: () => e.renderExpand ? [
            e.renderExpand({
              expanded: o
            })
          ] : [
            qe(ze, null, {
              default: () => [qe(Un)]
            })
          ]
        });
      },
      sortable: !1,
      resizable: !1
    }
  };
  function W9({
    row: e,
    column: t,
    $index: n
  }) {
    var o;
    const l = t.property, a = l && ni(e, l).value;
    return t && t.formatter ? t.formatter(e, t, a, n) : ((o = a == null ? void 0 : a.toString) == null ? void 0 : o.call(a)) || "";
  }
  function j9({
    row: e,
    treeNode: t,
    store: n
  }, o = !1) {
    const { ns: l } = n;
    if (!t)
      return o ? [
        qe("span", {
          class: l.e("placeholder")
        })
      ] : null;
    const a = [], r = function(i) {
      i.stopPropagation(), !t.loading && n.loadOrToggle(e);
    };
    if (t.indent && a.push(qe("span", {
      class: l.e("indent"),
      style: { "padding-left": `${t.indent}px` }
    })), Vt(t.expanded) && !t.noLazyChildren) {
      const i = [
        l.e("expand-icon"),
        t.expanded ? l.em("expand-icon", "expanded") : ""
      ];
      let u = Un;
      t.loading && (u = Cl), a.push(qe("div", {
        class: i,
        onClick: r
      }, {
        default: () => [
          qe(ze, { class: l.is("loading", t.loading) }, {
            default: () => [qe(u)]
          })
        ]
      }));
    } else
      a.push(qe("span", {
        class: l.e("placeholder")
      }));
    return a;
  }
  function jy(e, t) {
    return e.reduce((n, o) => (n[o] = o, n), t);
  }
  function U9(e, t) {
    const n = dt();
    return {
      registerComplexWatchers: () => {
        const a = ["fixed"], r = {
          realWidth: "width",
          realMinWidth: "minWidth"
        }, i = jy(a, r);
        Object.keys(i).forEach((u) => {
          const c = r[u];
          Ot(t, c) && de(() => t[c], (d) => {
            let f = d;
            c === "width" && u === "realWidth" && (f = lm(d)), c === "minWidth" && u === "realMinWidth" && (f = dk(d)), n.columnConfig.value[c] = f, n.columnConfig.value[u] = f;
            const v = c === "fixed";
            e.value.store.scheduleLayout(v);
          });
        });
      },
      registerNormalWatchers: () => {
        const a = [
          "label",
          "filters",
          "filterMultiple",
          "filteredValue",
          "sortable",
          "index",
          "formatter",
          "className",
          "labelClassName",
          "filterClassName",
          "showOverflowTooltip",
          "tooltipFormatter",
          "resizable"
        ], r = ["showOverflowTooltip"], i = {
          property: "prop",
          align: "realAlign",
          headerAlign: "realHeaderAlign"
        }, u = jy(a, i);
        Object.keys(u).forEach((c) => {
          const d = i[c];
          Ot(t, d) && de(() => t[d], (f) => {
            n.columnConfig.value[c] = f;
          });
        }), r.forEach((c) => {
          Ot(e.value.props, c) && de(() => e.value.props[c], (d) => {
            n.columnConfig.value[c] = d;
          });
        });
      }
    };
  }
  function Y9(e, t, n) {
    const o = dt(), l = A(""), a = A(!1), r = A(), i = A(), u = he("table");
    to(() => {
      r.value = e.align ? `is-${e.align}` : null, r.value;
    }), to(() => {
      i.value = e.headerAlign ? `is-${e.headerAlign}` : r.value, i.value;
    });
    const c = S(() => {
      let y = o.vnode.vParent || o.parent;
      for (; y && !y.tableId && !y.columnId; )
        y = y.vnode.vParent || y.parent;
      return y;
    }), d = S(() => {
      const { store: y } = o.parent;
      if (!y)
        return !1;
      const { treeData: E } = y.states, k = E.value;
      return k && Object.keys(k).length > 0;
    }), f = A(lm(e.width)), v = A(dk(e.minWidth)), p = (y) => (f.value && (y.width = f.value), v.value && (y.minWidth = v.value), !f.value && v.value && (y.width = void 0), y.minWidth || (y.minWidth = 80), y.realWidth = Number(kt(y.width) ? y.minWidth : y.width), y), m = (y) => {
      const E = y.type, k = K9[E] || {};
      Object.keys(k).forEach((x) => {
        const I = k[x];
        x !== "className" && !kt(I) && (y[x] = I);
      });
      const T = H9(E);
      if (T) {
        const x = `${s(u.namespace)}-${T}`;
        y.className = y.className ? `${y.className} ${x}` : x;
      }
      return y;
    }, h = (y) => {
      ye(y) ? y.forEach((k) => E(k)) : E(y);
      function E(k) {
        var T;
        ((T = k == null ? void 0 : k.type) == null ? void 0 : T.name) === "ElTableColumn" && (k.vParent = o);
      }
    };
    return {
      columnId: l,
      realAlign: r,
      isSubColumn: a,
      realHeaderAlign: i,
      columnOrTableParent: c,
      setColumnWidth: p,
      setColumnForcedProps: m,
      setColumnRenders: (y) => {
        e.renderHeader ? vt("TableColumn", "Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.") : y.type !== "selection" && (y.renderHeader = (k) => (o.columnConfig.value.label, ee(t, "header", k, () => [y.label]))), t["filter-icon"] && (y.renderFilterIcon = (k) => ee(t, "filter-icon", k)), t.expand && (y.renderExpand = (k) => ee(t, "expand", k));
        let E = y.renderCell;
        return y.type === "expand" ? (y.renderCell = (k) => qe("div", {
          class: "cell"
        }, [E(k)]), n.value.renderExpanded = (k) => t.default ? t.default(k) : t.default) : (E = E || W9, y.renderCell = (k) => {
          let T = null;
          if (t.default) {
            const z = t.default(k);
            T = z.some((Y) => Y.type !== Qt) ? z : E(k);
          } else
            T = E(k);
          const { columns: x } = n.value.store.states, I = x.value.findIndex((z) => z.type === "default"), P = d.value && k.cellIndex === I, O = j9(k, P), N = {
            class: "cell",
            style: {}
          };
          return y.showOverflowTooltip && (N.class = `${N.class} ${s(u.namespace)}-tooltip`, N.style = {
            width: `${(k.column.realWidth || Number(k.column.width)) - 1}px`
          }), h(T), qe("div", N, [O, T]);
        }), y;
      },
      getPropsData: (...y) => y.reduce((E, k) => (ye(k) && k.forEach((T) => {
        E[T] = e[T];
      }), E), {}),
      getColumnElIndex: (y, E) => Array.prototype.indexOf.call(y, E),
      updateColumnOrder: () => {
        n.value.store.commit("updateColumnOrder", o.columnConfig.value);
      }
    };
  }
  var q9 = {
    type: {
      type: String,
      default: "default"
    },
    label: String,
    className: String,
    labelClassName: String,
    property: String,
    prop: String,
    width: {
      type: [String, Number],
      default: ""
    },
    minWidth: {
      type: [String, Number],
      default: ""
    },
    renderHeader: Function,
    sortable: {
      type: [Boolean, String],
      default: !1
    },
    sortMethod: Function,
    sortBy: [String, Function, Array],
    resizable: {
      type: Boolean,
      default: !0
    },
    columnKey: String,
    align: String,
    headerAlign: String,
    showOverflowTooltip: {
      type: [Boolean, Object],
      default: void 0
    },
    tooltipFormatter: Function,
    fixed: [Boolean, String],
    formatter: Function,
    selectable: Function,
    reserveSelection: Boolean,
    filterMethod: Function,
    filteredValue: Array,
    filters: Array,
    filterPlacement: String,
    filterMultiple: {
      type: Boolean,
      default: !0
    },
    filterClassName: String,
    index: [Number, Function],
    sortOrders: {
      type: Array,
      default: () => ["ascending", "descending", null],
      validator: (e) => e.every((t) => ["ascending", "descending", null].includes(t))
    }
  };
  let G9 = 1;
  var Nk = /* @__PURE__ */ U({
    name: "ElTableColumn",
    components: {
      ElCheckbox: xo
    },
    props: q9,
    setup(e, { slots: t }) {
      const n = dt(), o = A({}), l = S(() => {
        let w = n.parent;
        for (; w && !w.tableId; )
          w = w.parent;
        return w;
      }), { registerNormalWatchers: a, registerComplexWatchers: r } = U9(l, e), {
        columnId: i,
        isSubColumn: u,
        realHeaderAlign: c,
        columnOrTableParent: d,
        setColumnWidth: f,
        setColumnForcedProps: v,
        setColumnRenders: p,
        getPropsData: m,
        getColumnElIndex: h,
        realAlign: g,
        updateColumnOrder: b
      } = Y9(e, t, l), C = d.value;
      i.value = `${"tableId" in C && C.tableId || "columnId" in C && C.columnId}_column_${G9++}`, gd(() => {
        u.value = l.value !== C;
        const w = e.type || "default", y = e.sortable === "" ? !0 : e.sortable, E = w === "selection" ? !1 : kt(e.showOverflowTooltip) ? C.props.showOverflowTooltip : e.showOverflowTooltip, k = kt(e.tooltipFormatter) ? C.props.tooltipFormatter : e.tooltipFormatter, T = {
          ...z9[w],
          id: i.value,
          type: w,
          property: e.prop || e.property,
          align: g,
          headerAlign: c,
          showOverflowTooltip: E,
          tooltipFormatter: k,
          filterable: e.filters || e.filterMethod,
          filteredValue: [],
          filterPlacement: "",
          filterClassName: "",
          isColumnGroup: !1,
          isSubColumn: !1,
          filterOpened: !1,
          sortable: y,
          index: e.index,
          rawColumnKey: n.vnode.key
        };
        let N = m([
          "columnKey",
          "label",
          "className",
          "labelClassName",
          "type",
          "renderHeader",
          "formatter",
          "fixed",
          "resizable"
        ], ["sortMethod", "sortBy", "sortOrders"], ["selectable", "reserveSelection"], [
          "filterMethod",
          "filters",
          "filterMultiple",
          "filterOpened",
          "filteredValue",
          "filterPlacement",
          "filterClassName"
        ]);
        N = Wj(T, N), N = Uj(p, f, v)(N), o.value = N, a(), r();
      }), ft(() => {
        var w, y;
        const E = d.value, k = u.value ? (w = E.vnode.el) == null ? void 0 : w.children : (y = E.refs.hiddenColumns) == null ? void 0 : y.children, T = () => h(k || [], n.vnode.el);
        o.value.getColumnIndex = T, T() > -1 && l.value.store.commit("insertColumn", o.value, u.value ? "columnConfig" in E && E.columnConfig.value : null, b);
      }), Bt(() => {
        const w = o.value.getColumnIndex;
        (w ? w() : -1) > -1 && l.value.store.commit("removeColumn", o.value, u.value ? "columnConfig" in C && C.columnConfig.value : null, b);
      }), n.columnId = i.value, n.columnConfig = o;
    },
    render() {
      var e, t, n;
      try {
        const o = (t = (e = this.$slots).default) == null ? void 0 : t.call(e, {
          row: {},
          column: {},
          $index: -1
        }), l = [];
        if (ye(o))
          for (const r of o)
            ((n = r.type) == null ? void 0 : n.name) === "ElTableColumn" || r.shapeFlag & 2 ? l.push(r) : r.type === We && ye(r.children) && r.children.forEach((i) => {
              (i == null ? void 0 : i.patchFlag) !== 1024 && !Ae(i == null ? void 0 : i.children) && l.push(i);
            });
        return qe("div", l);
      } catch {
        return qe("div", []);
      }
    }
  });
  const X9 = rt(B9, {
    TableColumn: Nk
  }), J9 = nn(Nk);
  var Ai = /* @__PURE__ */ ((e) => (e.ASC = "asc", e.DESC = "desc", e))(Ai || {}), Vi = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.CENTER = "center", e.RIGHT = "right", e))(Vi || {}), $k = /* @__PURE__ */ ((e) => (e.LEFT = "left", e.RIGHT = "right", e))($k || {});
  const lv = {
    asc: "desc",
    desc: "asc"
    /* ASC */
  }, Li = Symbol("placeholder"), Z9 = (e, t, n) => {
    var o;
    const l = {
      flexGrow: 0,
      flexShrink: 0,
      ...n ? {} : {
        flexGrow: e.flexGrow || 0,
        flexShrink: e.flexShrink || 1
      }
    };
    n || (l.flexShrink = 1);
    const a = {
      ...(o = e.style) != null ? o : {},
      ...l,
      flexBasis: "auto",
      width: e.width
    };
    return t || (e.maxWidth && (a.maxWidth = e.maxWidth), e.minWidth && (a.minWidth = e.minWidth)), a;
  };
  function Q9(e, t, n) {
    const o = S(() => s(t).map((g, b) => {
      var C, w;
      return {
        ...g,
        key: (w = (C = g.key) != null ? C : g.dataKey) != null ? w : b
      };
    })), l = S(() => s(o).filter((g) => !g.hidden)), a = S(() => s(l).filter((g) => g.fixed === "left" || g.fixed === !0)), r = S(() => s(l).filter((g) => g.fixed === "right")), i = S(() => s(l).filter((g) => !g.fixed)), u = S(() => {
      const g = [];
      return s(a).forEach((b) => {
        g.push({
          ...b,
          placeholderSign: Li
        });
      }), s(i).forEach((b) => {
        g.push(b);
      }), s(r).forEach((b) => {
        g.push({
          ...b,
          placeholderSign: Li
        });
      }), g;
    }), c = S(() => s(a).length || s(r).length), d = S(() => s(o).reduce((g, b) => (g[b.key] = Z9(b, s(n), e.fixed), g), {})), f = S(() => s(l).reduce((g, b) => g + b.width, 0)), v = (g) => s(o).find((b) => b.key === g), p = (g) => s(d)[g], m = (g, b) => {
      g.width = b;
    };
    function h(g) {
      var b;
      const { key: C } = g.currentTarget.dataset;
      if (!C)
        return;
      const { sortState: w, sortBy: y } = e;
      let E = Ai.ASC;
      ot(w) ? E = lv[w[C]] : E = lv[y.order], (b = e.onColumnSort) == null || b.call(e, { column: v(C), key: C, order: E });
    }
    return {
      columns: o,
      columnsStyles: d,
      columnsTotalWidth: f,
      fixedColumnsOnLeft: a,
      fixedColumnsOnRight: r,
      hasFixedColumns: c,
      mainColumns: u,
      normalColumns: i,
      visibleColumns: l,
      getColumn: v,
      getColumnStyle: p,
      updateColumnWidth: m,
      onColumnSorted: h
    };
  }
  const e7 = (e, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: o,
    onMaybeEndReached: l
  }) => {
    const a = A({ scrollLeft: 0, scrollTop: 0 });
    function r(p) {
      var m, h, g;
      const { scrollTop: b } = p;
      (m = t.value) == null || m.scrollTo(p), (h = n.value) == null || h.scrollToTop(b), (g = o.value) == null || g.scrollToTop(b);
    }
    function i(p) {
      a.value = p, r(p);
    }
    function u(p) {
      a.value.scrollTop = p, r(s(a));
    }
    function c(p) {
      var m, h;
      a.value.scrollLeft = p, (h = (m = t.value) == null ? void 0 : m.scrollTo) == null || h.call(m, s(a));
    }
    function d(p) {
      var m;
      i(p), (m = e.onScroll) == null || m.call(e, p);
    }
    function f({ scrollTop: p }) {
      const { scrollTop: m } = s(a);
      p !== m && u(p);
    }
    function v(p, m = "auto") {
      var h;
      (h = t.value) == null || h.scrollToRow(p, m);
    }
    return de(() => s(a).scrollTop, (p, m) => {
      p > m && l();
    }), {
      scrollPos: a,
      scrollTo: i,
      scrollToLeft: c,
      scrollToTop: u,
      scrollToRow: v,
      onScroll: d,
      onVerticalScroll: f
    };
  }, t7 = (e, {
    mainTableRef: t,
    leftTableRef: n,
    rightTableRef: o,
    tableInstance: l,
    ns: a,
    isScrolling: r
  }) => {
    const i = dt(), { emit: u } = i, c = Ut(!1), d = A(e.defaultExpandedRowKeys || []), f = A(-1), v = Ut(null), p = A({}), m = A({}), h = Ut({}), g = Ut({}), b = Ut({}), C = S(() => je(e.estimatedRowHeight));
    function w(P) {
      var O;
      (O = e.onRowsRendered) == null || O.call(e, P), P.rowCacheEnd > s(f) && (f.value = P.rowCacheEnd);
    }
    function y({ hovered: P, rowKey: O }) {
      if (r.value)
        return;
      l.vnode.el.querySelectorAll(`[rowkey="${String(O)}"]`).forEach((Y) => {
        P ? Y.classList.add(a.is("hovered")) : Y.classList.remove(a.is("hovered"));
      });
    }
    function E({
      expanded: P,
      rowData: O,
      rowIndex: N,
      rowKey: z
    }) {
      var Y, G;
      const M = [...s(d)], R = M.indexOf(z);
      P ? R === -1 && M.push(z) : R > -1 && M.splice(R, 1), d.value = M, u("update:expandedRowKeys", M), (Y = e.onRowExpand) == null || Y.call(e, {
        expanded: P,
        rowData: O,
        rowIndex: N,
        rowKey: z
      }), (G = e.onExpandedRowsChange) == null || G.call(e, M), l.vnode.el.querySelector(`.${a.is("hovered")}[rowkey="${String(z)}"]`) && Re(() => y({ hovered: !0, rowKey: z }));
    }
    const k = wl(() => {
      var P, O, N, z;
      c.value = !0, p.value = { ...s(p), ...s(m) }, T(s(v), !1), m.value = {}, v.value = null, (P = t.value) == null || P.forceUpdate(), (O = n.value) == null || O.forceUpdate(), (N = o.value) == null || N.forceUpdate(), (z = i.proxy) == null || z.$forceUpdate(), c.value = !1;
    }, 0);
    function T(P, O = !1) {
      s(C) && [t, n, o].forEach((N) => {
        const z = s(N);
        z && z.resetAfterRowIndex(P, O);
      });
    }
    function x(P, O, N) {
      const z = s(v);
      (z === null || z > N) && (v.value = N), m.value[P] = O;
    }
    function I({ rowKey: P, height: O, rowIndex: N }, z) {
      z ? z === $k.RIGHT ? b.value[P] = O : h.value[P] = O : g.value[P] = O;
      const Y = Math.max(...[h, b, g].map((G) => G.value[P] || 0));
      s(p)[P] !== Y && (x(P, Y, N), k());
    }
    return {
      expandedRowKeys: d,
      lastRenderedRowIndex: f,
      isDynamic: C,
      isResetting: c,
      rowHeights: p,
      resetAfterIndex: T,
      onRowExpanded: E,
      onRowHovered: y,
      onRowsRendered: w,
      onRowHeightChange: I
    };
  }, n7 = (e, { expandedRowKeys: t, lastRenderedRowIndex: n, resetAfterIndex: o }) => {
    const l = A({}), a = S(() => {
      const i = {}, { data: u, rowKey: c } = e, d = s(t);
      if (!d || !d.length)
        return u;
      const f = [], v = /* @__PURE__ */ new Set();
      d.forEach((m) => v.add(m));
      let p = u.slice();
      for (p.forEach((m) => i[m[c]] = 0); p.length > 0; ) {
        const m = p.shift();
        f.push(m), v.has(m[c]) && ye(m.children) && m.children.length > 0 && (p = [...m.children, ...p], m.children.forEach((h) => i[h[c]] = i[m[c]] + 1));
      }
      return l.value = i, f;
    }), r = S(() => {
      const { data: i, expandColumnKey: u } = e;
      return u ? s(a) : i;
    });
    return de(r, (i, u) => {
      i !== u && (n.value = -1, o(0, !0));
    }), {
      data: r,
      depthMap: l
    };
  }, o7 = (e, t) => e + t, fc = (e) => ye(e) ? e.reduce(o7, 0) : e, pr = (e, t, n = {}) => Fe(e) ? e(t) : e ?? n, wa = (e) => (["width", "maxWidth", "minWidth", "height"].forEach((t) => {
    e[t] = tn(e[t]);
  }), e), Ok = (e) => Wt(e) ? (t) => qe(e, t) : e, l7 = (e, {
    columnsTotalWidth: t,
    rowsHeight: n,
    fixedColumnsOnLeft: o,
    fixedColumnsOnRight: l
  }) => {
    const a = S(() => {
      const { fixed: b, width: C, vScrollbarSize: w } = e, y = C - w;
      return b ? Math.max(Math.round(s(t)), y) : y;
    }), r = S(() => {
      const { height: b = 0, maxHeight: C = 0, footerHeight: w, hScrollbarSize: y } = e;
      if (C > 0) {
        const E = s(v), k = s(n), x = s(f) + E + k + y;
        return Math.min(x, C - w);
      }
      return b - w;
    }), i = S(() => {
      const { maxHeight: b } = e, C = s(r);
      if (je(b) && b > 0)
        return C;
      const w = s(n) + s(f) + s(v);
      return Math.min(C, w);
    }), u = (b) => b.width, c = S(() => fc(s(o).map(u))), d = S(() => fc(s(l).map(u))), f = S(() => fc(e.headerHeight)), v = S(() => {
      var b;
      return (((b = e.fixedData) == null ? void 0 : b.length) || 0) * e.rowHeight;
    }), p = S(() => s(r) - s(f) - s(v)), m = S(() => {
      const { style: b = {}, height: C, width: w } = e;
      return wa({
        ...b,
        height: C,
        width: w
      });
    }), h = S(() => wa({ height: e.footerHeight })), g = S(() => ({
      top: tn(s(f)),
      bottom: tn(e.footerHeight),
      width: tn(e.width)
    }));
    return {
      bodyWidth: a,
      fixedTableHeight: i,
      mainTableHeight: r,
      leftTableWidth: c,
      rightTableWidth: d,
      windowHeight: p,
      footerHeight: h,
      emptyStyle: g,
      rootStyle: m,
      headerHeight: f
    };
  };
  function a7(e) {
    const t = A(), n = A(), o = A(), {
      columns: l,
      columnsStyles: a,
      columnsTotalWidth: r,
      fixedColumnsOnLeft: i,
      fixedColumnsOnRight: u,
      hasFixedColumns: c,
      mainColumns: d,
      onColumnSorted: f
    } = Q9(e, At(e, "columns"), At(e, "fixed")), {
      scrollTo: v,
      scrollToLeft: p,
      scrollToTop: m,
      scrollToRow: h,
      onScroll: g,
      onVerticalScroll: b,
      scrollPos: C
    } = e7(e, {
      mainTableRef: t,
      leftTableRef: n,
      rightTableRef: o,
      onMaybeEndReached: j
    }), w = he("table-v2"), y = dt(), E = Ut(!1), {
      expandedRowKeys: k,
      lastRenderedRowIndex: T,
      isDynamic: x,
      isResetting: I,
      rowHeights: P,
      resetAfterIndex: O,
      onRowExpanded: N,
      onRowHeightChange: z,
      onRowHovered: Y,
      onRowsRendered: G
    } = t7(e, {
      mainTableRef: t,
      leftTableRef: n,
      rightTableRef: o,
      tableInstance: y,
      ns: w,
      isScrolling: E
    }), { data: M, depthMap: R } = n7(e, {
      expandedRowKeys: k,
      lastRenderedRowIndex: T,
      resetAfterIndex: O
    }), D = S(() => {
      const { estimatedRowHeight: te, rowHeight: ce } = e, ge = s(M);
      return je(te) ? Object.values(s(P)).reduce((be, Ee) => be + Ee, 0) : ge.length * ce;
    }), {
      bodyWidth: L,
      fixedTableHeight: V,
      mainTableHeight: F,
      leftTableWidth: H,
      rightTableWidth: K,
      windowHeight: Z,
      footerHeight: J,
      emptyStyle: ie,
      rootStyle: ue,
      headerHeight: re
    } = l7(e, {
      columnsTotalWidth: r,
      fixedColumnsOnLeft: i,
      fixedColumnsOnRight: u,
      rowsHeight: D
    }), se = A(), ne = S(() => {
      const te = s(M).length === 0;
      return ye(e.fixedData) ? e.fixedData.length === 0 && te : te;
    });
    function le(te) {
      const { estimatedRowHeight: ce, rowHeight: ge, rowKey: be } = e;
      return ce ? s(P)[s(M)[te][be]] || ce : ge;
    }
    const Ce = A(!1);
    function j() {
      const { onEndReached: te } = e;
      if (!te)
        return;
      const { scrollTop: ce } = s(C), ge = s(D), be = s(Z), Ee = ge - (ce + be) + e.hScrollbarSize;
      !Ce.value && s(T) >= 0 && ge <= ce + s(F) - s(re) ? (Ce.value = !0, te(Ee)) : Ce.value = !1;
    }
    return de(() => s(D), () => Ce.value = !1), de(() => e.expandedRowKeys, (te) => k.value = te, {
      deep: !0
    }), {
      columns: l,
      containerRef: se,
      mainTableRef: t,
      leftTableRef: n,
      rightTableRef: o,
      isDynamic: x,
      isResetting: I,
      isScrolling: E,
      hasFixedColumns: c,
      columnsStyles: a,
      columnsTotalWidth: r,
      data: M,
      expandedRowKeys: k,
      depthMap: R,
      fixedColumnsOnLeft: i,
      fixedColumnsOnRight: u,
      mainColumns: d,
      bodyWidth: L,
      emptyStyle: ie,
      rootStyle: ue,
      footerHeight: J,
      mainTableHeight: F,
      fixedTableHeight: V,
      leftTableWidth: H,
      rightTableWidth: K,
      showEmpty: ne,
      getRowHeight: le,
      onColumnSorted: f,
      onRowHovered: Y,
      onRowExpanded: N,
      onRowsRendered: G,
      onRowHeightChange: z,
      scrollTo: v,
      scrollToLeft: p,
      scrollToTop: m,
      scrollToRow: h,
      onScroll: g,
      onVerticalScroll: b
    };
  }
  const um = Symbol("tableV2"), Ik = "tableV2GridScrollLeft", Mk = String, vu = {
    type: X(Array),
    required: !0
  }, cm = {
    type: X(Array)
  }, xk = {
    ...cm,
    required: !0
  }, r7 = String, Uy = {
    type: X(Array),
    default: () => en([])
  }, Ua = {
    type: Number,
    required: !0
  }, Pk = {
    type: X([String, Number, Symbol]),
    default: "id"
  }, Yy = {
    type: X(Object)
  }, Xa = Te({
    class: String,
    columns: vu,
    columnsStyles: {
      type: X(Object),
      required: !0
    },
    depth: Number,
    expandColumnKey: r7,
    estimatedRowHeight: {
      ...rr.estimatedRowHeight,
      default: void 0
    },
    isScrolling: Boolean,
    onRowExpand: {
      type: X(Function)
    },
    onRowHover: {
      type: X(Function)
    },
    onRowHeightChange: {
      type: X(Function)
    },
    rowData: {
      type: X(Object),
      required: !0
    },
    rowEventHandlers: {
      type: X(Object)
    },
    rowIndex: {
      type: Number,
      required: !0
    },
    rowKey: Pk,
    style: {
      type: X(Object)
    }
  }), Wf = {
    type: Number,
    required: !0
  }, dm = Te({
    class: String,
    columns: vu,
    fixedHeaderData: {
      type: X(Array)
    },
    headerData: {
      type: X(Array),
      required: !0
    },
    headerHeight: {
      type: X([Number, Array]),
      default: 50
    },
    rowWidth: Wf,
    rowHeight: {
      type: Number,
      default: 50
    },
    height: Wf,
    width: Wf
  }), pc = Te({
    columns: vu,
    data: xk,
    fixedData: cm,
    estimatedRowHeight: Xa.estimatedRowHeight,
    width: Ua,
    height: Ua,
    headerWidth: Ua,
    headerHeight: dm.headerHeight,
    bodyWidth: Ua,
    rowHeight: Ua,
    cache: ZE.cache,
    useIsScrolling: Boolean,
    scrollbarAlwaysOn: rr.scrollbarAlwaysOn,
    scrollbarStartGap: rr.scrollbarStartGap,
    scrollbarEndGap: rr.scrollbarEndGap,
    class: Mk,
    style: Yy,
    containerStyle: Yy,
    getRowHeight: {
      type: X(Function),
      required: !0
    },
    rowKey: Xa.rowKey,
    onRowsRendered: {
      type: X(Function)
    },
    onScroll: {
      type: X(Function)
    }
  }), s7 = Te({
    cache: pc.cache,
    estimatedRowHeight: Xa.estimatedRowHeight,
    rowKey: Pk,
    headerClass: {
      type: X([
        String,
        Function
      ])
    },
    headerProps: {
      type: X([
        Object,
        Function
      ])
    },
    headerCellProps: {
      type: X([
        Object,
        Function
      ])
    },
    headerHeight: dm.headerHeight,
    footerHeight: {
      type: Number,
      default: 0
    },
    rowClass: {
      type: X([String, Function])
    },
    rowProps: {
      type: X([Object, Function])
    },
    rowHeight: {
      type: Number,
      default: 50
    },
    cellProps: {
      type: X([
        Object,
        Function
      ])
    },
    columns: vu,
    data: xk,
    dataGetter: {
      type: X(Function)
    },
    fixedData: cm,
    expandColumnKey: Xa.expandColumnKey,
    expandedRowKeys: Uy,
    defaultExpandedRowKeys: Uy,
    class: Mk,
    fixed: Boolean,
    style: {
      type: X(Object)
    },
    width: Ua,
    height: Ua,
    maxHeight: Number,
    useIsScrolling: Boolean,
    indentSize: {
      type: Number,
      default: 12
    },
    iconSize: {
      type: Number,
      default: 12
    },
    hScrollbarSize: rr.hScrollbarSize,
    vScrollbarSize: rr.vScrollbarSize,
    scrollbarAlwaysOn: tk.alwaysOn,
    sortBy: {
      type: X(Object),
      default: () => ({})
    },
    sortState: {
      type: X(Object),
      default: void 0
    },
    onColumnSort: {
      type: X(Function)
    },
    onExpandedRowsChange: {
      type: X(Function)
    },
    onEndReached: {
      type: X(Function)
    },
    onRowExpand: Xa.onRowExpand,
    onScroll: pc.onScroll,
    onRowsRendered: pc.onRowsRendered,
    rowEventHandlers: Xa.rowEventHandlers
  }), i7 = "ElTableV2Header", u7 = /* @__PURE__ */ U({
    name: i7,
    props: dm,
    setup(e, {
      slots: t,
      expose: n
    }) {
      const o = he("table-v2"), l = Ve(Ik), a = A(), r = S(() => wa({
        width: e.width,
        height: e.height
      })), i = S(() => wa({
        width: e.rowWidth,
        height: e.height
      })), u = S(() => En(s(e.headerHeight))), c = (v) => {
        const p = s(a);
        Re(() => {
          p != null && p.scroll && p.scroll({
            left: v
          });
        });
      }, d = () => {
        const v = o.e("fixed-header-row"), {
          columns: p,
          fixedHeaderData: m,
          rowHeight: h
        } = e;
        return m == null ? void 0 : m.map((g, b) => {
          var C;
          const w = wa({
            height: h,
            width: "100%"
          });
          return (C = t.fixed) == null ? void 0 : C.call(t, {
            class: v,
            columns: p,
            rowData: g,
            rowIndex: -(b + 1),
            style: w
          });
        });
      }, f = () => {
        const v = o.e("dynamic-header-row"), {
          columns: p
        } = e;
        return s(u).map((m, h) => {
          var g;
          const b = wa({
            width: "100%",
            height: m
          });
          return (g = t.dynamic) == null ? void 0 : g.call(t, {
            class: v,
            columns: p,
            headerIndex: h,
            style: b
          });
        });
      };
      return Qo(() => {
        l != null && l.value && c(l.value);
      }), n({
        scrollToLeft: c
      }), () => {
        if (!(e.height <= 0))
          return q("div", {
            ref: a,
            class: e.class,
            style: s(r),
            role: "rowgroup"
          }, [q("div", {
            style: s(i),
            class: o.e("header")
          }, [f(), d()])]);
      };
    }
  });
  var c7 = u7;
  const d7 = ({ atXEndEdge: e, atXStartEdge: t, atYEndEdge: n, atYStartEdge: o }, l) => {
    let a = null, r = 0, i = 0;
    const u = (d, f) => {
      const v = d <= 0 && t.value || d >= 0 && e.value, p = f <= 0 && o.value || f >= 0 && n.value;
      return v && p;
    };
    return {
      hasReachedEdge: u,
      onWheel: (d) => {
        Yl(a);
        let f = d.deltaX, v = d.deltaY;
        Math.abs(f) > Math.abs(v) ? v = 0 : f = 0, d.shiftKey && v !== 0 && (f = v, v = 0), !(u(r, i) && u(r + f, i + v)) && (r += f, i += v, d.preventDefault(), a = Ul(() => {
          l(r, i), r = 0, i = 0;
        }));
      }
    };
  }, f7 = (e, t, n, o, l, a, r) => {
    const i = A(0), u = A(0);
    let c, d = 0, f = 0;
    const v = (m) => {
      Yl(c), i.value = m.touches[0].clientX, u.value = m.touches[0].clientY, d = 0, f = 0;
    }, p = (m) => {
      m.preventDefault(), Yl(c), d += i.value - m.touches[0].clientX, f += u.value - m.touches[0].clientY, i.value = m.touches[0].clientX, u.value = m.touches[0].clientY, c = Ul(() => {
        const h = o.value - s(a), g = l.value - s(r), b = Math.min(t.value.scrollLeft + d, h), C = Math.min(t.value.scrollTop + f, g);
        n({
          scrollLeft: b,
          scrollTop: C
        }), d = 0, f = 0;
      });
    };
    return Dt(e, "touchstart", v, {
      passive: !0
    }), Dt(e, "touchmove", p, {
      passive: !1
    }), {
      touchStartX: i,
      touchStartY: u,
      handleTouchStart: v,
      handleTouchMove: p
    };
  }, Rk = ({
    name: e,
    clearCache: t,
    getColumnPosition: n,
    getColumnStartIndexForOffset: o,
    getColumnStopIndexForStartIndex: l,
    getEstimatedTotalHeight: a,
    getEstimatedTotalWidth: r,
    getColumnOffset: i,
    getRowOffset: u,
    getRowPosition: c,
    getRowStartIndexForOffset: d,
    getRowStopIndexForStartIndex: f,
    initCache: v,
    injectToInstance: p,
    validateProps: m
  }) => /* @__PURE__ */ U({
    name: e ?? "ElVirtualList",
    props: rr,
    emits: [Gc, Xc],
    setup(h, { emit: g, expose: b, slots: C }) {
      const w = he("vl");
      m(h);
      const y = dt(), E = A(v(h, y));
      p == null || p(y, E);
      const k = A(), T = A(), x = A(), I = A(), P = A({
        isScrolling: !1,
        scrollLeft: je(h.initScrollLeft) ? h.initScrollLeft : 0,
        scrollTop: je(h.initScrollTop) ? h.initScrollTop : 0,
        updateRequested: !1,
        xAxisScrollDir: Br,
        yAxisScrollDir: Br
      }), O = qE(), N = S(() => Number.parseInt(`${h.height}`, 10)), z = S(() => Number.parseInt(`${h.width}`, 10)), Y = S(() => {
        const { totalColumn: we, totalRow: me, columnCache: Pe } = h, { isScrolling: Me, xAxisScrollDir: Be, scrollLeft: pe } = s(P);
        if (we === 0 || me === 0)
          return [0, 0, 0, 0];
        const Le = o(h, pe, s(E)), Xe = l(h, Le, pe, s(E)), ut = !Me || Be === Jc ? Math.max(1, Pe) : 1, Nt = !Me || Be === Br ? Math.max(1, Pe) : 1;
        return [
          Math.max(0, Le - ut),
          Math.max(0, Math.min(we - 1, Xe + Nt)),
          Le,
          Xe
        ];
      }), G = S(() => {
        const { totalColumn: we, totalRow: me, rowCache: Pe } = h, { isScrolling: Me, yAxisScrollDir: Be, scrollTop: pe } = s(P);
        if (we === 0 || me === 0)
          return [0, 0, 0, 0];
        const Le = d(h, pe, s(E)), Xe = f(h, Le, pe, s(E)), ut = !Me || Be === Jc ? Math.max(1, Pe) : 1, Nt = !Me || Be === Br ? Math.max(1, Pe) : 1;
        return [
          Math.max(0, Le - ut),
          Math.max(0, Math.min(me - 1, Xe + Nt)),
          Le,
          Xe
        ];
      }), M = S(() => a(h, s(E))), R = S(() => r(h, s(E))), D = S(() => {
        var we;
        return [
          {
            position: "relative",
            overflow: "hidden",
            WebkitOverflowScrolling: "touch",
            willChange: "transform"
          },
          {
            direction: h.direction,
            height: je(h.height) ? `${h.height}px` : h.height,
            width: je(h.width) ? `${h.width}px` : h.width
          },
          (we = h.style) != null ? we : {}
        ];
      }), L = S(() => {
        const we = `${s(R)}px`;
        return {
          height: `${s(M)}px`,
          pointerEvents: s(P).isScrolling ? "none" : void 0,
          width: we
        };
      }), V = () => {
        const { totalColumn: we, totalRow: me } = h;
        if (we > 0 && me > 0) {
          const [
            Xe,
            ut,
            Nt,
            Ye
          ] = s(Y), [tt, fe, He, Qe] = s(G);
          g(Gc, {
            columnCacheStart: Xe,
            columnCacheEnd: ut,
            rowCacheStart: tt,
            rowCacheEnd: fe,
            columnVisibleStart: Nt,
            columnVisibleEnd: Ye,
            rowVisibleStart: He,
            rowVisibleEnd: Qe
          });
        }
        const {
          scrollLeft: Pe,
          scrollTop: Me,
          updateRequested: Be,
          xAxisScrollDir: pe,
          yAxisScrollDir: Le
        } = s(P);
        g(Xc, {
          xAxisScrollDir: pe,
          scrollLeft: Pe,
          yAxisScrollDir: Le,
          scrollTop: Me,
          updateRequested: Be
        });
      }, F = (we) => {
        const {
          clientHeight: me,
          clientWidth: Pe,
          scrollHeight: Me,
          scrollLeft: Be,
          scrollTop: pe,
          scrollWidth: Le
        } = we.currentTarget, Xe = s(P);
        if (Xe.scrollTop === pe && Xe.scrollLeft === Be)
          return;
        let ut = Be;
        if (Iy(h.direction))
          switch (Qc()) {
            case Ri:
              ut = -Be;
              break;
            case om:
              ut = Le - Pe - Be;
              break;
          }
        P.value = {
          ...Xe,
          isScrolling: !0,
          scrollLeft: ut,
          scrollTop: Math.max(0, Math.min(pe, Me - me)),
          updateRequested: !0,
          xAxisScrollDir: Ga(Xe.scrollLeft, ut),
          yAxisScrollDir: Ga(Xe.scrollTop, pe)
        }, Re(() => Ce()), j(), V();
      }, H = (we, me) => {
        const Pe = s(N), Me = (M.value - Pe) / me * we;
        J({
          scrollTop: Math.min(M.value - Pe, Me)
        });
      }, K = (we, me) => {
        const Pe = s(z), Me = (R.value - Pe) / me * we;
        J({
          scrollLeft: Math.min(R.value - Pe, Me)
        });
      }, { onWheel: Z } = d7({
        atXStartEdge: S(() => P.value.scrollLeft <= 0),
        atXEndEdge: S(() => P.value.scrollLeft >= R.value - s(z)),
        atYStartEdge: S(() => P.value.scrollTop <= 0),
        atYEndEdge: S(() => P.value.scrollTop >= M.value - s(N))
      }, (we, me) => {
        var Pe, Me, Be, pe;
        (Me = (Pe = T.value) == null ? void 0 : Pe.onMouseUp) == null || Me.call(Pe), (pe = (Be = x.value) == null ? void 0 : Be.onMouseUp) == null || pe.call(Be);
        const Le = s(z), Xe = s(N);
        J({
          scrollLeft: Math.min(P.value.scrollLeft + we, R.value - Le),
          scrollTop: Math.min(P.value.scrollTop + me, M.value - Xe)
        });
      });
      Dt(k, "wheel", Z, {
        passive: !1
      });
      const J = ({
        scrollLeft: we = P.value.scrollLeft,
        scrollTop: me = P.value.scrollTop
      }) => {
        we = Math.max(we, 0), me = Math.max(me, 0);
        const Pe = s(P);
        me === Pe.scrollTop && we === Pe.scrollLeft || (P.value = {
          ...Pe,
          xAxisScrollDir: Ga(Pe.scrollLeft, we),
          yAxisScrollDir: Ga(Pe.scrollTop, me),
          scrollLeft: we,
          scrollTop: me,
          updateRequested: !0
        }, Re(() => Ce()), j(), V());
      }, { touchStartX: ie, touchStartY: ue, handleTouchStart: re, handleTouchMove: se } = f7(k, P, J, R, M, z, N), ne = (we = 0, me = 0, Pe = To) => {
        const Me = s(P);
        me = Math.max(0, Math.min(me, h.totalColumn - 1)), we = Math.max(0, Math.min(we, h.totalRow - 1));
        const Be = fC(w.namespace.value), pe = s(E), Le = a(h, pe), Xe = r(h, pe);
        J({
          scrollLeft: i(h, me, Pe, Me.scrollLeft, pe, Xe > h.width ? Be : 0),
          scrollTop: u(h, we, Pe, Me.scrollTop, pe, Le > h.height ? Be : 0)
        });
      }, le = (we, me) => {
        const { columnWidth: Pe, direction: Me, rowHeight: Be } = h, pe = O.value(t && Pe, t && Be, t && Me), Le = `${we},${me}`;
        if (Ot(pe, Le))
          return pe[Le];
        {
          const [, Xe] = n(h, me, s(E)), ut = s(E), Nt = Iy(Me), [Ye, tt] = c(h, we, ut), [fe] = n(h, me, ut);
          return pe[Le] = {
            position: "absolute",
            left: Nt ? void 0 : `${Xe}px`,
            right: Nt ? `${Xe}px` : void 0,
            top: `${tt}px`,
            height: `${Ye}px`,
            width: `${fe}px`
          }, pe[Le];
        }
      }, Ce = () => {
        P.value.isScrolling = !1, Re(() => {
          O.value(-1, null, null);
        });
      };
      ft(() => {
        if (!xt)
          return;
        const { initScrollLeft: we, initScrollTop: me } = h, Pe = s(k);
        Pe && (je(we) && (Pe.scrollLeft = we), je(me) && (Pe.scrollTop = me)), V();
      });
      const j = () => {
        const { direction: we } = h, { scrollLeft: me, scrollTop: Pe, updateRequested: Me } = s(P), Be = s(k);
        if (Me && Be) {
          if (we === Yr)
            switch (Qc()) {
              case Ri: {
                Be.scrollLeft = -me;
                break;
              }
              case nm: {
                Be.scrollLeft = me;
                break;
              }
              default: {
                const { clientWidth: pe, scrollWidth: Le } = Be;
                Be.scrollLeft = Le - pe - me;
                break;
              }
            }
          else
            Be.scrollLeft = Math.max(0, me);
          Be.scrollTop = Math.max(0, Pe);
        }
      }, { resetAfterColumnIndex: te, resetAfterRowIndex: ce, resetAfter: ge } = y.proxy;
      b({
        windowRef: k,
        innerRef: I,
        getItemStyleCache: O,
        touchStartX: ie,
        touchStartY: ue,
        handleTouchStart: re,
        handleTouchMove: se,
        scrollTo: J,
        scrollToItem: ne,
        states: P,
        resetAfterColumnIndex: te,
        resetAfterRowIndex: ce,
        resetAfter: ge
      });
      const be = () => {
        const {
          scrollbarAlwaysOn: we,
          scrollbarStartGap: me,
          scrollbarEndGap: Pe,
          totalColumn: Me,
          totalRow: Be
        } = h, pe = s(z), Le = s(N), Xe = s(R), ut = s(M), { scrollLeft: Nt, scrollTop: Ye } = s(P), tt = qe(Up, {
          ref: T,
          alwaysOn: we,
          startGap: me,
          endGap: Pe,
          class: w.e("horizontal"),
          clientSize: pe,
          layout: "horizontal",
          onScroll: K,
          ratio: pe * 100 / Xe,
          scrollFrom: Nt / (Xe - pe),
          total: Be,
          visible: !0
        }), fe = qe(Up, {
          ref: x,
          alwaysOn: we,
          startGap: me,
          endGap: Pe,
          class: w.e("vertical"),
          clientSize: Le,
          layout: "vertical",
          onScroll: H,
          ratio: Le * 100 / ut,
          scrollFrom: Ye / (ut - Le),
          total: Me,
          visible: !0
        });
        return {
          horizontalScrollbar: tt,
          verticalScrollbar: fe
        };
      }, Ee = () => {
        var we;
        const [me, Pe] = s(Y), [Me, Be] = s(G), { data: pe, totalColumn: Le, totalRow: Xe, useIsScrolling: ut, itemKey: Nt } = h, Ye = [];
        if (Xe > 0 && Le > 0)
          for (let tt = Me; tt <= Be; tt++)
            for (let fe = me; fe <= Pe; fe++) {
              const He = Nt({ columnIndex: fe, data: pe, rowIndex: tt });
              Ye.push(qe(We, { key: He }, (we = C.default) == null ? void 0 : we.call(C, {
                columnIndex: fe,
                data: pe,
                isScrolling: ut ? s(P).isScrolling : void 0,
                style: le(tt, fe),
                rowIndex: tt
              })));
            }
        return Ye;
      }, Oe = () => {
        const we = ct(h.innerElement), me = Ee();
        return [
          qe(we, pt(h.innerProps, {
            style: s(L),
            ref: I
          }), Ae(we) ? me : {
            default: () => me
          })
        ];
      };
      return () => {
        const we = ct(h.containerElement), { horizontalScrollbar: me, verticalScrollbar: Pe } = be(), Me = Oe();
        return qe("div", {
          key: 0,
          class: w.e("wrapper"),
          role: h.role
        }, [
          qe(we, {
            class: h.className,
            style: s(D),
            onScroll: F,
            ref: k
          }, Ae(we) ? Me : { default: () => Me }),
          me,
          Pe
        ]);
      };
    }
  }), { max: nd, min: Dk, floor: Ak } = Math, qy = "ElDynamicSizeGrid", p7 = {
    column: "columnWidth",
    row: "rowHeight"
  }, av = {
    column: "lastVisitedColumnIndex",
    row: "lastVisitedRowIndex"
  }, Vl = (e, t, n, o) => {
    const [l, a, r] = [
      n[o],
      e[p7[o]],
      n[av[o]]
    ];
    if (t > r) {
      let i = 0;
      if (r >= 0) {
        const u = l[r];
        i = u.offset + u.size;
      }
      for (let u = r + 1; u <= t; u++) {
        const c = a(u);
        l[u] = {
          offset: i,
          size: c
        }, i += c;
      }
      n[av[o]] = t;
    }
    return l[t];
  }, Vk = (e, t, n, o, l, a) => {
    for (; n <= o; ) {
      const r = n + Ak((o - n) / 2), i = Vl(e, r, t, a).offset;
      if (i === l)
        return r;
      i < l ? n = r + 1 : o = r - 1;
    }
    return nd(0, n - 1);
  }, v7 = (e, t, n, o, l) => {
    const a = l === "column" ? e.totalColumn : e.totalRow;
    let r = 1;
    for (; n < a && Vl(e, n, t, l).offset < o; )
      n += r, r *= 2;
    return Vk(e, t, Ak(n / 2), Dk(n, a - 1), o, l);
  }, Gy = (e, t, n, o) => {
    const [l, a] = [
      t[o],
      t[av[o]]
    ];
    return (a > 0 ? l[a].offset : 0) >= n ? Vk(e, t, 0, a, n, o) : v7(e, t, nd(0, a), n, o);
  }, Lk = ({ totalRow: e }, { estimatedRowHeight: t, lastVisitedRowIndex: n, row: o }) => {
    let l = 0;
    if (n >= e && (n = e - 1), n >= 0) {
      const i = o[n];
      l = i.offset + i.size;
    }
    const r = (e - n - 1) * t;
    return l + r;
  }, Bk = ({ totalColumn: e }, { column: t, estimatedColumnWidth: n, lastVisitedColumnIndex: o }) => {
    let l = 0;
    if (o > e && (o = e - 1), o >= 0) {
      const i = t[o];
      l = i.offset + i.size;
    }
    const r = (e - o - 1) * n;
    return l + r;
  }, h7 = {
    column: Bk,
    row: Lk
  }, Xy = (e, t, n, o, l, a, r) => {
    const [i, u] = [
      a === "row" ? e.height : e.width,
      h7[a]
    ], c = Vl(e, t, l, a), d = u(e, l), f = nd(0, Dk(d - i, c.offset)), v = nd(0, c.offset - i + r + c.size);
    switch (n === Yd && (o >= v - i && o <= f + i ? n = To : n = dl), n) {
      case xi:
        return f;
      case Pi:
        return v;
      case dl:
        return Math.round(v + (f - v) / 2);
      case To:
      default:
        return o >= v && o <= f ? o : v > f || o < v ? v : f;
    }
  }, m7 = Rk({
    name: "ElDynamicSizeGrid",
    getColumnPosition: (e, t, n) => {
      const o = Vl(e, t, n, "column");
      return [o.size, o.offset];
    },
    getRowPosition: (e, t, n) => {
      const o = Vl(e, t, n, "row");
      return [o.size, o.offset];
    },
    getColumnOffset: (e, t, n, o, l, a) => Xy(e, t, n, o, l, "column", a),
    getRowOffset: (e, t, n, o, l, a) => Xy(e, t, n, o, l, "row", a),
    getColumnStartIndexForOffset: (e, t, n) => Gy(e, n, t, "column"),
    getColumnStopIndexForStartIndex: (e, t, n, o) => {
      const l = Vl(e, t, o, "column"), a = n + e.width;
      let r = l.offset + l.size, i = t;
      for (; i < e.totalColumn - 1 && r < a; )
        i++, r += Vl(e, t, o, "column").size;
      return i;
    },
    getEstimatedTotalHeight: Lk,
    getEstimatedTotalWidth: Bk,
    getRowStartIndexForOffset: (e, t, n) => Gy(e, n, t, "row"),
    getRowStopIndexForStartIndex: (e, t, n, o) => {
      const { totalRow: l, height: a } = e, r = Vl(e, t, o, "row"), i = n + a;
      let u = r.size + r.offset, c = t;
      for (; c < l - 1 && u < i; )
        c++, u += Vl(e, c, o, "row").size;
      return c;
    },
    injectToInstance: (e, t) => {
      const n = ({ columnIndex: a, rowIndex: r }, i) => {
        var u, c;
        i = kt(i) ? !0 : i, je(a) && (t.value.lastVisitedColumnIndex = Math.min(t.value.lastVisitedColumnIndex, a - 1)), je(r) && (t.value.lastVisitedRowIndex = Math.min(t.value.lastVisitedRowIndex, r - 1)), (u = e.exposed) == null || u.getItemStyleCache.value(-1, null, null), i && ((c = e.proxy) == null || c.$forceUpdate());
      }, o = (a, r) => {
        n({
          columnIndex: a
        }, r);
      }, l = (a, r) => {
        n({
          rowIndex: a
        }, r);
      };
      Object.assign(e.proxy, {
        resetAfterColumnIndex: o,
        resetAfterRowIndex: l,
        resetAfter: n
      });
    },
    initCache: ({
      estimatedColumnWidth: e = Fp,
      estimatedRowHeight: t = Fp
    }) => ({
      column: {},
      estimatedColumnWidth: e,
      estimatedRowHeight: t,
      lastVisitedColumnIndex: -1,
      lastVisitedRowIndex: -1,
      row: {}
    }),
    clearCache: !1,
    validateProps: ({ columnWidth: e, rowHeight: t }) => {
      typeof process < "u" && process.env.NODE_ENV !== "production" && (Fe(e) || Zt(qy, `
          "columnWidth" must be passed as function,
            instead ${typeof e} was given.
        `), Fe(t) || Zt(qy, `
          "rowHeight" must be passed as function,
            instead ${typeof t} was given.
        `));
    }
  }), Jy = "ElFixedSizeGrid", g7 = Rk({
    name: "ElFixedSizeGrid",
    getColumnPosition: ({ columnWidth: e }, t) => [
      e,
      t * e
    ],
    getRowPosition: ({ rowHeight: e }, t) => [
      e,
      t * e
    ],
    getEstimatedTotalHeight: ({ totalRow: e, rowHeight: t }) => t * e,
    getEstimatedTotalWidth: ({ totalColumn: e, columnWidth: t }) => t * e,
    getColumnOffset: ({ totalColumn: e, columnWidth: t, width: n }, o, l, a, r, i) => {
      n = Number(n);
      const u = Math.max(0, e * t - n), c = Math.min(u, o * t), d = Math.max(0, o * t - n + i + t);
      switch (l === "smart" && (a >= d - n && a <= c + n ? l = To : l = dl), l) {
        case xi:
          return c;
        case Pi:
          return d;
        case dl: {
          const f = Math.round(d + (c - d) / 2);
          return f < Math.ceil(n / 2) ? 0 : f > u + Math.floor(n / 2) ? u : f;
        }
        case To:
        default:
          return a >= d && a <= c ? a : d > c || a < d ? d : c;
      }
    },
    getRowOffset: ({ rowHeight: e, height: t, totalRow: n }, o, l, a, r, i) => {
      t = Number(t);
      const u = Math.max(0, n * e - t), c = Math.min(u, o * e), d = Math.max(0, o * e - t + i + e);
      switch (l === Yd && (a >= d - t && a <= c + t ? l = To : l = dl), l) {
        case xi:
          return c;
        case Pi:
          return d;
        case dl: {
          const f = Math.round(d + (c - d) / 2);
          return f < Math.ceil(t / 2) ? 0 : f > u + Math.floor(t / 2) ? u : f;
        }
        case To:
        default:
          return a >= d && a <= c ? a : d > c || a < d ? d : c;
      }
    },
    getColumnStartIndexForOffset: ({ columnWidth: e, totalColumn: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e))),
    getColumnStopIndexForStartIndex: ({ columnWidth: e, totalColumn: t, width: n }, o, l) => {
      const a = o * e, r = Math.ceil((n + l - a) / e);
      return Math.max(0, Math.min(t - 1, o + r - 1));
    },
    getRowStartIndexForOffset: ({ rowHeight: e, totalRow: t }, n) => Math.max(0, Math.min(t - 1, Math.floor(n / e))),
    getRowStopIndexForStartIndex: ({ rowHeight: e, totalRow: t, height: n }, o, l) => {
      const a = o * e, r = Math.ceil((n + l - a) / e);
      return Math.max(0, Math.min(t - 1, o + r - 1));
    },
    initCache: () => {
    },
    clearCache: !0,
    validateProps: ({ columnWidth: e, rowHeight: t }) => {
      typeof process < "u" && process.env.NODE_ENV !== "production" && (je(e) || Zt(Jy, `
          "columnWidth" must be passed as number,
            instead ${typeof e} was given.
        `), je(t) || Zt(Jy, `
          "columnWidth" must be passed as number,
            instead ${typeof t} was given.
        `));
    }
  }), b7 = "ElTableV2Grid", y7 = (e) => {
    const t = A(), n = A(), o = A(0), l = S(() => {
      const {
        data: g,
        rowHeight: b,
        estimatedRowHeight: C
      } = e;
      if (!C)
        return g.length * b;
    }), a = S(() => {
      const {
        fixedData: g,
        rowHeight: b
      } = e;
      return ((g == null ? void 0 : g.length) || 0) * b;
    }), r = S(() => fc(e.headerHeight)), i = S(() => {
      const {
        height: g
      } = e;
      return Math.max(0, g - s(r) - s(a));
    }), u = S(() => s(r) + s(a) > 0), c = ({
      data: g,
      rowIndex: b
    }) => g[b][e.rowKey];
    function d({
      rowCacheStart: g,
      rowCacheEnd: b,
      rowVisibleStart: C,
      rowVisibleEnd: w
    }) {
      var y;
      (y = e.onRowsRendered) == null || y.call(e, {
        rowCacheStart: g,
        rowCacheEnd: b,
        rowVisibleStart: C,
        rowVisibleEnd: w
      });
    }
    function f(g, b) {
      var C;
      (C = n.value) == null || C.resetAfterRowIndex(g, b);
    }
    function v(g, b) {
      const C = s(t), w = s(n);
      ot(g) ? (C == null || C.scrollToLeft(g.scrollLeft), o.value = g.scrollLeft, w == null || w.scrollTo(g)) : (C == null || C.scrollToLeft(g), o.value = g, w == null || w.scrollTo({
        scrollLeft: g,
        scrollTop: b
      }));
    }
    function p(g) {
      var b;
      (b = s(n)) == null || b.scrollTo({
        scrollTop: g
      });
    }
    function m(g, b) {
      var C;
      (C = s(n)) == null || C.scrollToItem(g, 1, b);
    }
    function h() {
      var g, b;
      (g = s(n)) == null || g.$forceUpdate(), (b = s(t)) == null || b.$forceUpdate();
    }
    return de(() => e.bodyWidth, () => {
      var g;
      je(e.estimatedRowHeight) && ((g = n.value) == null || g.resetAfter({
        columnIndex: 0
      }, !1));
    }), {
      bodyRef: n,
      forceUpdate: h,
      fixedRowHeight: a,
      gridHeight: i,
      hasHeader: u,
      headerHeight: r,
      headerRef: t,
      totalHeight: l,
      itemKey: c,
      onItemRendered: d,
      resetAfterRowIndex: f,
      scrollTo: v,
      scrollToTop: p,
      scrollToRow: m,
      scrollLeft: o
    };
  }, w7 = /* @__PURE__ */ U({
    name: b7,
    props: pc,
    setup(e, {
      slots: t,
      expose: n
    }) {
      const {
        ns: o
      } = Ve(um), {
        bodyRef: l,
        fixedRowHeight: a,
        gridHeight: r,
        hasHeader: i,
        headerRef: u,
        headerHeight: c,
        totalHeight: d,
        forceUpdate: f,
        itemKey: v,
        onItemRendered: p,
        resetAfterRowIndex: m,
        scrollTo: h,
        scrollToTop: g,
        scrollToRow: b,
        scrollLeft: C
      } = y7(e);
      yt(Ik, C), hd(async () => {
        var y;
        await Re();
        const E = (y = l.value) == null ? void 0 : y.states.scrollTop;
        E && g(Math.round(E) + 1);
      }), n({
        forceUpdate: f,
        totalHeight: d,
        scrollTo: h,
        scrollToTop: g,
        scrollToRow: b,
        resetAfterRowIndex: m
      });
      const w = () => e.bodyWidth;
      return () => {
        const {
          cache: y,
          columns: E,
          data: k,
          fixedData: T,
          useIsScrolling: x,
          scrollbarAlwaysOn: I,
          scrollbarEndGap: P,
          scrollbarStartGap: O,
          style: N,
          rowHeight: z,
          bodyWidth: Y,
          estimatedRowHeight: G,
          headerWidth: M,
          height: R,
          width: D,
          getRowHeight: L,
          onScroll: V
        } = e, F = je(G), H = F ? m7 : g7, K = s(c);
        return q("div", {
          role: "table",
          class: [o.e("table"), e.class],
          style: N
        }, [q(H, {
          ref: l,
          data: k,
          useIsScrolling: x,
          itemKey: v,
          columnCache: 0,
          columnWidth: F ? w : Y,
          totalColumn: 1,
          totalRow: k.length,
          rowCache: y,
          rowHeight: F ? L : z,
          width: D,
          height: s(r),
          class: o.e("body"),
          role: "rowgroup",
          scrollbarStartGap: O,
          scrollbarEndGap: P,
          scrollbarAlwaysOn: I,
          onScroll: V,
          onItemRendered: p,
          perfMode: !1
        }, {
          default: (Z) => {
            var J;
            const ie = k[Z.rowIndex];
            return (J = t.row) == null ? void 0 : J.call(t, {
              ...Z,
              columns: E,
              rowData: ie
            });
          }
        }), s(i) && q(c7, {
          ref: u,
          class: o.e("header-wrapper"),
          columns: E,
          headerData: k,
          headerHeight: e.headerHeight,
          fixedHeaderData: T,
          rowWidth: M,
          rowHeight: z,
          width: D,
          height: Math.min(K + s(a), R)
        }, {
          dynamic: t.header,
          fixed: t.row
        })]);
      };
    }
  });
  var fm = w7;
  function C7(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Wt(e);
  }
  const S7 = (e, {
    slots: t
  }) => {
    const {
      mainTableRef: n,
      ...o
    } = e;
    return q(fm, pt({
      ref: n
    }, o), C7(t) ? t : {
      default: () => [t]
    });
  };
  var E7 = S7;
  function k7(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Wt(e);
  }
  const _7 = (e, {
    slots: t
  }) => {
    if (!e.columns.length)
      return;
    const {
      leftTableRef: n,
      ...o
    } = e;
    return q(fm, pt({
      ref: n
    }, o), k7(t) ? t : {
      default: () => [t]
    });
  };
  var T7 = _7;
  function N7(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Wt(e);
  }
  const $7 = (e, {
    slots: t
  }) => {
    if (!e.columns.length)
      return;
    const {
      rightTableRef: n,
      ...o
    } = e;
    return q(fm, pt({
      ref: n
    }, o), N7(t) ? t : {
      default: () => [t]
    });
  };
  var O7 = $7;
  const I7 = (e) => {
    const {
      isScrolling: t
    } = Ve(um), n = A(!1), o = A(), l = S(() => je(e.estimatedRowHeight) && e.rowIndex >= 0), a = (u = !1) => {
      const c = s(o);
      if (!c)
        return;
      const {
        columns: d,
        onRowHeightChange: f,
        rowKey: v,
        rowIndex: p,
        style: m
      } = e, {
        height: h
      } = c.getBoundingClientRect();
      n.value = !0, Re(() => {
        if (u || h !== Number.parseInt(m.height)) {
          const g = d[0], b = (g == null ? void 0 : g.placeholderSign) === Li;
          f == null || f({
            rowKey: v,
            height: h,
            rowIndex: p
          }, g && !b && g.fixed);
        }
      });
    }, r = S(() => {
      const {
        rowData: u,
        rowIndex: c,
        rowKey: d,
        onRowHover: f
      } = e, v = e.rowEventHandlers || {}, p = {};
      return Object.entries(v).forEach(([m, h]) => {
        Fe(h) && (p[m] = (g) => {
          h({
            event: g,
            rowData: u,
            rowIndex: c,
            rowKey: d
          });
        });
      }), f && [{
        name: "onMouseleave",
        hovered: !1
      }, {
        name: "onMouseenter",
        hovered: !0
      }].forEach(({
        name: m,
        hovered: h
      }) => {
        const g = p[m];
        p[m] = (b) => {
          f({
            event: b,
            hovered: h,
            rowData: u,
            rowIndex: c,
            rowKey: d
          }), g == null || g(b);
        };
      }), p;
    }), i = (u) => {
      const {
        onRowExpand: c,
        rowData: d,
        rowIndex: f,
        rowKey: v
      } = e;
      c == null || c({
        expanded: u,
        rowData: d,
        rowIndex: f,
        rowKey: v
      });
    };
    return ft(() => {
      s(l) && a(!0);
    }), {
      isScrolling: t,
      measurable: l,
      measured: n,
      rowRef: o,
      eventHandlers: r,
      onExpand: i
    };
  }, M7 = "ElTableV2TableRow", x7 = /* @__PURE__ */ U({
    name: M7,
    props: Xa,
    setup(e, {
      expose: t,
      slots: n,
      attrs: o
    }) {
      const {
        eventHandlers: l,
        isScrolling: a,
        measurable: r,
        measured: i,
        rowRef: u,
        onExpand: c
      } = I7(e);
      return t({
        onExpand: c
      }), () => {
        const {
          columns: d,
          columnsStyles: f,
          expandColumnKey: v,
          depth: p,
          rowData: m,
          rowIndex: h,
          style: g
        } = e;
        let b = d.map((C, w) => {
          const y = ye(m.children) && m.children.length > 0 && C.key === v;
          return n.cell({
            column: C,
            columns: d,
            columnIndex: w,
            depth: p,
            style: f[C.key],
            rowData: m,
            rowIndex: h,
            isScrolling: s(a),
            expandIconProps: y ? {
              rowData: m,
              rowIndex: h,
              onExpand: c
            } : void 0
          });
        });
        if (n.row && (b = n.row({
          cells: b.map((C) => ye(C) && C.length === 1 ? C[0] : C),
          style: g,
          columns: d,
          depth: p,
          rowData: m,
          rowIndex: h,
          isScrolling: s(a)
        })), s(r)) {
          const {
            height: C,
            ...w
          } = g || {}, y = s(i);
          return q("div", pt({
            ref: u,
            class: e.class,
            style: y ? g : w,
            role: "row"
          }, o, s(l)), [b]);
        }
        return q("div", pt(o, {
          ref: u,
          class: e.class,
          style: g,
          role: "row"
        }, s(l)), [b]);
      };
    }
  });
  var P7 = x7;
  function R7(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Wt(e);
  }
  const D7 = (e, {
    slots: t
  }) => {
    const {
      columns: n,
      columnsStyles: o,
      depthMap: l,
      expandColumnKey: a,
      expandedRowKeys: r,
      estimatedRowHeight: i,
      hasFixedColumns: u,
      rowData: c,
      rowIndex: d,
      style: f,
      isScrolling: v,
      rowProps: p,
      rowClass: m,
      rowKey: h,
      rowEventHandlers: g,
      ns: b,
      onRowHovered: C,
      onRowExpanded: w
    } = e, y = pr(m, {
      columns: n,
      rowData: c,
      rowIndex: d
    }, ""), E = pr(p, {
      columns: n,
      rowData: c,
      rowIndex: d
    }), k = c[h], T = l[k] || 0, x = !!a, I = d < 0, P = [b.e("row"), y, b.is("expanded", x && r.includes(k)), b.is("fixed", !T && I), b.is("customized", !!t.row), {
      [b.e(`row-depth-${T}`)]: x && d >= 0
    }], O = u ? C : void 0, N = {
      ...E,
      columns: n,
      columnsStyles: o,
      class: P,
      depth: T,
      expandColumnKey: a,
      estimatedRowHeight: I ? void 0 : i,
      isScrolling: v,
      rowIndex: d,
      rowData: c,
      rowKey: k,
      rowEventHandlers: g,
      style: f
    };
    return q(P7, pt(N, {
      onRowExpand: w,
      onMouseenter: (G) => {
        O == null || O({
          hovered: !0,
          rowKey: k,
          event: G,
          rowData: c,
          rowIndex: d
        });
      },
      onMouseleave: (G) => {
        O == null || O({
          hovered: !1,
          rowKey: k,
          event: G,
          rowData: c,
          rowIndex: d
        });
      },
      rowkey: k
    }), R7(t) ? t : {
      default: () => [t]
    });
  };
  var A7 = D7;
  const pm = (e, {
    slots: t
  }) => {
    var n;
    const {
      cellData: o,
      style: l
    } = e, a = ((n = o == null ? void 0 : o.toString) == null ? void 0 : n.call(o)) || "", r = ee(t, "default", e, () => [a]);
    return q("div", {
      class: e.class,
      title: a,
      style: l
    }, [r]);
  };
  pm.displayName = "ElTableV2Cell";
  pm.inheritAttrs = !1;
  var V7 = pm;
  const L7 = (e) => {
    const {
      expanded: t,
      expandable: n,
      onExpand: o,
      style: l,
      size: a
    } = e, r = {
      onClick: n ? () => o(!t) : void 0,
      class: e.class
    };
    return q(ze, pt(r, {
      size: a,
      style: l
    }), {
      default: () => [q(Un, null, null)]
    });
  };
  var B7 = L7;
  const Fk = ({
    columns: e,
    column: t,
    columnIndex: n,
    depth: o,
    expandIconProps: l,
    isScrolling: a,
    rowData: r,
    rowIndex: i,
    style: u,
    expandedRowKeys: c,
    ns: d,
    cellProps: f,
    expandColumnKey: v,
    indentSize: p,
    iconSize: m,
    rowKey: h
  }, {
    slots: g
  }) => {
    const b = wa(u);
    if (t.placeholderSign === Li)
      return q("div", {
        class: d.em("row-cell", "placeholder"),
        style: b
      }, null);
    const {
      cellRenderer: C,
      dataKey: w,
      dataGetter: y
    } = t, E = Fe(y) ? y({
      columns: e,
      column: t,
      columnIndex: n,
      rowData: r,
      rowIndex: i
    }) : dn(r, w ?? ""), k = pr(f, {
      cellData: E,
      columns: e,
      column: t,
      columnIndex: n,
      rowIndex: i,
      rowData: r
    }), T = {
      class: d.e("cell-text"),
      columns: e,
      column: t,
      columnIndex: n,
      cellData: E,
      isScrolling: a,
      rowData: r,
      rowIndex: i
    }, x = Ok(C), I = x ? x(T) : ee(g, "default", T, () => [q(V7, T, null)]), P = [d.e("row-cell"), t.class, t.align === Vi.CENTER && d.is("align-center"), t.align === Vi.RIGHT && d.is("align-right")], O = i >= 0 && v && t.key === v, N = i >= 0 && c.includes(r[h]);
    let z;
    const Y = `margin-inline-start: ${o * p}px;`;
    return O && (ot(l) ? z = q(B7, pt(l, {
      class: [d.e("expand-icon"), d.is("expanded", N)],
      size: m,
      expanded: N,
      style: Y,
      expandable: !0
    }), null) : z = q("div", {
      style: [Y, `width: ${m}px; height: ${m}px;`].join(" ")
    }, null)), q("div", pt({
      class: P,
      style: b
    }, k, {
      role: "cell"
    }), [z, I]);
  };
  Fk.inheritAttrs = !1;
  var Zy = Fk;
  const F7 = Te({
    class: String,
    columns: vu,
    columnsStyles: {
      type: X(Object),
      required: !0
    },
    headerIndex: Number,
    style: { type: X(Object) }
  }), z7 = /* @__PURE__ */ U({
    name: "ElTableV2HeaderRow",
    props: F7,
    setup(e, {
      slots: t
    }) {
      return () => {
        const {
          columns: n,
          columnsStyles: o,
          headerIndex: l,
          style: a
        } = e;
        let r = n.map((i, u) => t.cell({
          columns: n,
          column: i,
          columnIndex: u,
          headerIndex: l,
          style: o[i.key]
        }));
        return t.header && (r = t.header({
          cells: r.map((i) => ye(i) && i.length === 1 ? i[0] : i),
          columns: n,
          headerIndex: l
        })), q("div", {
          class: e.class,
          style: a,
          role: "row"
        }, [r]);
      };
    }
  });
  var H7 = z7;
  function K7(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Wt(e);
  }
  const W7 = ({
    columns: e,
    columnsStyles: t,
    headerIndex: n,
    style: o,
    headerClass: l,
    headerProps: a,
    ns: r
  }, {
    slots: i
  }) => {
    const u = {
      columns: e,
      headerIndex: n
    }, c = [r.e("header-row"), pr(l, u, ""), r.is("customized", !!i.header)], d = {
      ...pr(a, u),
      columnsStyles: t,
      class: c,
      columns: e,
      headerIndex: n,
      style: o
    };
    return q(H7, d, K7(i) ? i : {
      default: () => [i]
    });
  };
  var j7 = W7;
  const vm = (e, {
    slots: t
  }) => ee(t, "default", e, () => {
    var n, o;
    return [q("div", {
      class: e.class,
      title: (n = e.column) == null ? void 0 : n.title
    }, [(o = e.column) == null ? void 0 : o.title])];
  });
  vm.displayName = "ElTableV2HeaderCell";
  vm.inheritAttrs = !1;
  var U7 = vm;
  const Y7 = (e) => {
    const {
      sortOrder: t
    } = e;
    return q(ze, {
      size: 14,
      class: e.class
    }, {
      default: () => [t === Ai.ASC ? q(OD, null, null) : q(ND, null, null)]
    });
  };
  var q7 = Y7;
  const G7 = (e, {
    slots: t
  }) => {
    const {
      column: n,
      ns: o,
      style: l,
      onColumnSorted: a
    } = e, r = wa(l);
    if (n.placeholderSign === Li)
      return q("div", {
        class: o.em("header-row-cell", "placeholder"),
        style: r
      }, null);
    const {
      headerCellRenderer: i,
      headerClass: u,
      sortable: c
    } = n, d = {
      ...e,
      class: o.e("header-cell-text")
    }, f = Ok(i), v = f ? f(d) : ee(t, "default", d, () => [q(U7, d, null)]), {
      sortBy: p,
      sortState: m,
      headerCellProps: h
    } = e;
    let g, b;
    if (m) {
      const y = m[n.key];
      g = !!lv[y], b = g ? y : Ai.ASC;
    } else
      g = n.key === p.key, b = g ? p.order : Ai.ASC;
    const C = [o.e("header-cell"), pr(u, e, ""), n.align === Vi.CENTER && o.is("align-center"), n.align === Vi.RIGHT && o.is("align-right"), c && o.is("sortable")], w = {
      ...pr(h, e),
      onClick: n.sortable ? a : void 0,
      class: C,
      style: r,
      "data-key": n.key
    };
    return q("div", pt(w, {
      role: "columnheader"
    }), [v, c && q(q7, {
      class: [o.e("sort-icon"), g && o.is("sorting")],
      sortOrder: b
    }, null)]);
  };
  var Qy = G7;
  const zk = (e, {
    slots: t
  }) => {
    var n;
    return q("div", {
      class: e.class,
      style: e.style
    }, [(n = t.default) == null ? void 0 : n.call(t)]);
  };
  zk.displayName = "ElTableV2Footer";
  var X7 = zk;
  const Hk = (e, {
    slots: t
  }) => {
    const n = ee(t, "default", {}, () => [q(PE, null, null)]);
    return q("div", {
      class: e.class,
      style: e.style
    }, [n]);
  };
  Hk.displayName = "ElTableV2Empty";
  var J7 = Hk;
  const Kk = (e, {
    slots: t
  }) => {
    var n;
    return q("div", {
      class: e.class,
      style: e.style
    }, [(n = t.default) == null ? void 0 : n.call(t)]);
  };
  Kk.displayName = "ElTableV2Overlay";
  var Z7 = Kk;
  function Fs(e) {
    return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !Wt(e);
  }
  const Q7 = "ElTableV2", eU = /* @__PURE__ */ U({
    name: Q7,
    props: s7,
    setup(e, {
      slots: t,
      expose: n
    }) {
      const o = he("table-v2"), {
        columnsStyles: l,
        fixedColumnsOnLeft: a,
        fixedColumnsOnRight: r,
        mainColumns: i,
        mainTableHeight: u,
        fixedTableHeight: c,
        leftTableWidth: d,
        rightTableWidth: f,
        data: v,
        depthMap: p,
        expandedRowKeys: m,
        hasFixedColumns: h,
        mainTableRef: g,
        leftTableRef: b,
        rightTableRef: C,
        isDynamic: w,
        isResetting: y,
        isScrolling: E,
        bodyWidth: k,
        emptyStyle: T,
        rootStyle: x,
        footerHeight: I,
        showEmpty: P,
        scrollTo: O,
        scrollToLeft: N,
        scrollToTop: z,
        scrollToRow: Y,
        getRowHeight: G,
        onColumnSorted: M,
        onRowHeightChange: R,
        onRowHovered: D,
        onRowExpanded: L,
        onRowsRendered: V,
        onScroll: F,
        onVerticalScroll: H
      } = a7(e);
      return n({
        scrollTo: O,
        scrollToLeft: N,
        scrollToTop: z,
        scrollToRow: Y
      }), yt(um, {
        ns: o,
        isResetting: y,
        isScrolling: E
      }), () => {
        const {
          cache: K,
          cellProps: Z,
          estimatedRowHeight: J,
          expandColumnKey: ie,
          fixedData: ue,
          headerHeight: re,
          headerClass: se,
          headerProps: ne,
          headerCellProps: le,
          sortBy: Ce,
          sortState: j,
          rowHeight: te,
          rowClass: ce,
          rowEventHandlers: ge,
          rowKey: be,
          rowProps: Ee,
          scrollbarAlwaysOn: Oe,
          indentSize: De,
          iconSize: we,
          useIsScrolling: me,
          vScrollbarSize: Pe,
          width: Me
        } = e, Be = s(v), pe = {
          cache: K,
          class: o.e("main"),
          columns: s(i),
          data: Be,
          fixedData: ue,
          estimatedRowHeight: J,
          bodyWidth: s(k),
          headerHeight: re,
          headerWidth: s(k),
          height: s(u),
          mainTableRef: g,
          rowKey: be,
          rowHeight: te,
          scrollbarAlwaysOn: Oe,
          scrollbarStartGap: 2,
          scrollbarEndGap: Pe,
          useIsScrolling: me,
          width: Me,
          getRowHeight: G,
          onRowsRendered: V,
          onScroll: F
        }, Le = s(d), Xe = s(c), ut = {
          cache: K,
          class: o.e("left"),
          columns: s(a),
          data: Be,
          fixedData: ue,
          estimatedRowHeight: J,
          leftTableRef: b,
          rowHeight: te,
          bodyWidth: Le,
          headerWidth: Le,
          headerHeight: re,
          height: Xe,
          rowKey: be,
          scrollbarAlwaysOn: Oe,
          scrollbarStartGap: 2,
          scrollbarEndGap: Pe,
          useIsScrolling: me,
          width: Le,
          getRowHeight: G,
          onScroll: H
        }, Nt = s(f), Ye = {
          cache: K,
          class: o.e("right"),
          columns: s(r),
          data: Be,
          fixedData: ue,
          estimatedRowHeight: J,
          rightTableRef: C,
          rowHeight: te,
          bodyWidth: Nt,
          headerWidth: Nt,
          headerHeight: re,
          height: Xe,
          rowKey: be,
          scrollbarAlwaysOn: Oe,
          scrollbarStartGap: 2,
          scrollbarEndGap: Pe,
          width: Nt,
          style: `${o.cssVarName("table-scrollbar-size")}: ${Pe}px`,
          useIsScrolling: me,
          getRowHeight: G,
          onScroll: H
        }, tt = s(l), fe = {
          ns: o,
          depthMap: s(p),
          columnsStyles: tt,
          expandColumnKey: ie,
          expandedRowKeys: s(m),
          estimatedRowHeight: J,
          hasFixedColumns: s(h),
          rowProps: Ee,
          rowClass: ce,
          rowKey: be,
          rowEventHandlers: ge,
          onRowHovered: D,
          onRowExpanded: L,
          onRowHeightChange: R
        }, He = {
          cellProps: Z,
          expandColumnKey: ie,
          indentSize: De,
          iconSize: we,
          rowKey: be,
          expandedRowKeys: s(m),
          ns: o
        }, Qe = {
          ns: o,
          headerClass: se,
          headerProps: ne,
          columnsStyles: tt
        }, ve = {
          ns: o,
          sortBy: Ce,
          sortState: j,
          headerCellProps: le,
          onColumnSorted: M
        }, Ke = {
          row: (Se) => q(A7, pt(Se, fe), {
            row: t.row,
            cell: (Je) => {
              let lt;
              return t.cell ? q(Zy, pt(Je, He, {
                style: tt[Je.column.key]
              }), Fs(lt = t.cell(Je)) ? lt : {
                default: () => [lt]
              }) : q(Zy, pt(Je, He, {
                style: tt[Je.column.key]
              }), null);
            }
          }),
          header: (Se) => q(j7, pt(Se, Qe), {
            header: t.header,
            cell: (Je) => {
              let lt;
              return t["header-cell"] ? q(Qy, pt(Je, ve, {
                style: tt[Je.column.key]
              }), Fs(lt = t["header-cell"](Je)) ? lt : {
                default: () => [lt]
              }) : q(Qy, pt(Je, ve, {
                style: tt[Je.column.key]
              }), null);
            }
          })
        }, St = [e.class, o.b(), o.e("root"), o.is("dynamic", s(w))], Ft = {
          class: o.e("footer"),
          style: s(I)
        };
        return q("div", {
          class: St,
          style: s(x)
        }, [q(E7, pe, Fs(Ke) ? Ke : {
          default: () => [Ke]
        }), q(T7, ut, Fs(Ke) ? Ke : {
          default: () => [Ke]
        }), q(O7, Ye, Fs(Ke) ? Ke : {
          default: () => [Ke]
        }), t.footer && q(X7, Ft, {
          default: t.footer
        }), s(P) && q(J7, {
          class: o.e("empty"),
          style: s(T)
        }, {
          default: t.empty
        }), t.overlay && q(Z7, {
          class: o.e("overlay")
        }, {
          default: t.overlay
        })]);
      };
    }
  });
  var tU = eU;
  const nU = Te({
    disableWidth: Boolean,
    disableHeight: Boolean,
    onResize: {
      type: X(Function)
    }
  }), oU = (e) => {
    const t = A(), n = A(0), o = A(0);
    let l;
    return ft(() => {
      l = qt(t, ([a]) => {
        const { width: r, height: i } = a.contentRect, { paddingLeft: u, paddingRight: c, paddingTop: d, paddingBottom: f } = getComputedStyle(a.target), v = Number.parseInt(u) || 0, p = Number.parseInt(c) || 0, m = Number.parseInt(d) || 0, h = Number.parseInt(f) || 0;
        n.value = r - v - p, o.value = i - m - h;
      }).stop;
    }), Bt(() => {
      l == null || l();
    }), de([n, o], ([a, r]) => {
      var i;
      (i = e.onResize) == null || i.call(e, {
        width: a,
        height: r
      });
    }), {
      sizer: t,
      width: n,
      height: o
    };
  }, lU = /* @__PURE__ */ U({
    name: "ElAutoResizer",
    props: nU,
    setup(e, {
      slots: t
    }) {
      const n = he("auto-resizer"), {
        height: o,
        width: l,
        sizer: a
      } = oU(e), r = {
        width: "100%",
        height: "100%"
      };
      return () => {
        var i;
        return q("div", {
          ref: a,
          class: n.b(),
          style: r
        }, [(i = t.default) == null ? void 0 : i.call(t, {
          height: o.value,
          width: l.value
        })]);
      };
    }
  });
  var aU = lU;
  const rU = rt(tU), sU = rt(aU), qd = Symbol("tabsRootContextKey"), iU = Te({
    tabs: {
      type: X(Array),
      default: () => en([])
    },
    tabRefs: {
      type: X(Object),
      default: () => en({})
    }
  }), Wk = "ElTabBar", uU = /* @__PURE__ */ U({
    name: Wk
  }), cU = /* @__PURE__ */ U({
    ...uU,
    props: iU,
    setup(e, { expose: t }) {
      const n = e, o = Ve(qd);
      o || Zt(Wk, "<el-tabs><el-tab-bar /></el-tabs>");
      const l = he("tabs"), a = A(), r = A(), i = () => {
        let v = 0, p = 0;
        const m = ["top", "bottom"].includes(o.props.tabPosition) ? "width" : "height", h = m === "width" ? "x" : "y", g = h === "x" ? "left" : "top";
        return n.tabs.every((b) => {
          if (kt(b.paneName))
            return !1;
          const C = n.tabRefs[b.paneName];
          if (!C)
            return !1;
          if (!b.active)
            return !0;
          v = C[`offset${ba(g)}`], p = C[`client${ba(m)}`];
          const w = window.getComputedStyle(C);
          return m === "width" && (p -= Number.parseFloat(w.paddingLeft) + Number.parseFloat(w.paddingRight), v += Number.parseFloat(w.paddingLeft)), !1;
        }), {
          [m]: `${p}px`,
          transform: `translate${ba(h)}(${v}px)`
        };
      }, u = () => r.value = i(), c = [], d = () => {
        c.forEach((v) => v.stop()), c.length = 0, Object.values(n.tabRefs).forEach((v) => {
          c.push(qt(v, u));
        });
      };
      de(() => n.tabs, async () => {
        await Re(), u(), d();
      }, { immediate: !0 });
      const f = qt(a, () => u());
      return Bt(() => {
        c.forEach((v) => v.stop()), c.length = 0, f.stop();
      }), t({
        ref: a,
        update: u
      }), (v, p) => (_(), B("div", {
        ref_key: "barRef",
        ref: a,
        class: $([s(l).e("active-bar"), s(l).is(s(o).props.tabPosition)]),
        style: Ue(r.value)
      }, null, 6));
    }
  });
  var dU = /* @__PURE__ */ Ne(cU, [["__file", "tab-bar.vue"]]);
  const fU = Te({
    panes: {
      type: X(Array),
      default: () => en([])
    },
    currentName: {
      type: [String, Number],
      default: ""
    },
    editable: Boolean,
    type: {
      type: String,
      values: ["card", "border-card", ""],
      default: ""
    },
    stretch: Boolean,
    tabindex: {
      type: [String, Number],
      default: void 0
    }
  }), pU = {
    tabClick: (e, t, n) => n instanceof Event,
    tabRemove: (e, t) => t instanceof Event
  }, e0 = "ElTabNav", vU = /* @__PURE__ */ U({
    name: e0,
    props: fU,
    emits: pU,
    setup(e, {
      expose: t,
      emit: n
    }) {
      const o = Ve(qd);
      o || Zt(e0, "<el-tabs><tab-nav /></el-tabs>");
      const l = he("tabs"), a = UP(), r = aR(), i = A(), u = A(), c = A(), d = A({}), f = A(), v = A(!1), p = A(0), m = A(!1), h = A(!0), g = Ut(), b = S(() => ["top", "bottom"].includes(o.props.tabPosition)), C = S(() => b.value ? "width" : "height"), w = S(() => ({
        transform: `translate${C.value === "width" ? "X" : "Y"}(-${p.value}px)`
      })), {
        width: y,
        height: E
      } = bp(i), {
        width: k,
        height: T
      } = bp(u, {
        width: 0,
        height: 0
      }, {
        box: "border-box"
      }), x = S(() => b.value ? y.value : E.value), I = S(() => b.value ? k.value : T.value), {
        onWheel: P
      } = GE({
        atStartEdge: S(() => p.value <= 0),
        atEndEdge: S(() => I.value - p.value <= x.value),
        layout: S(() => b.value ? "horizontal" : "vertical")
      }, (V) => {
        p.value = Od(p.value + V, 0, I.value - x.value);
      }), O = () => {
        if (!i.value)
          return;
        const V = i.value[`offset${ba(C.value)}`], F = p.value;
        if (!F)
          return;
        const H = F > V ? F - V : 0;
        p.value = H;
      }, N = () => {
        if (!i.value || !u.value)
          return;
        const V = u.value[`offset${ba(C.value)}`], F = i.value[`offset${ba(C.value)}`], H = p.value;
        if (V - H <= F)
          return;
        const K = V - H > F * 2 ? H + F : V - F;
        p.value = K;
      }, z = async () => {
        const V = u.value;
        if (!v.value || !c.value || !i.value || !V)
          return;
        await Re();
        const F = d.value[e.currentName];
        if (!F)
          return;
        const H = i.value, K = F.getBoundingClientRect(), Z = H.getBoundingClientRect(), J = b.value ? V.offsetWidth - Z.width : V.offsetHeight - Z.height, ie = p.value;
        let ue = ie;
        b.value ? (K.left < Z.left && (ue = ie - (Z.left - K.left)), K.right > Z.right && (ue = ie + K.right - Z.right)) : (K.top < Z.top && (ue = ie - (Z.top - K.top)), K.bottom > Z.bottom && (ue = ie + (K.bottom - Z.bottom))), ue = Math.max(ue, 0), p.value = Math.min(ue, J);
      }, Y = () => {
        var V;
        if (!u.value || !i.value)
          return;
        e.stretch && ((V = f.value) == null || V.update());
        const F = u.value[`offset${ba(C.value)}`], H = i.value[`offset${ba(C.value)}`], K = p.value;
        H < F ? (v.value = v.value || {}, v.value.prev = K, v.value.next = K + H < F, F - K < H && (p.value = F - H)) : (v.value = !1, K > 0 && (p.value = 0));
      }, G = (V) => {
        const F = Ht(V);
        let H = 0;
        switch (F) {
          case _e.left:
          case _e.up:
            H = -1;
            break;
          case _e.right:
          case _e.down:
            H = 1;
            break;
          default:
            return;
        }
        const K = Array.from(V.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)"));
        let J = K.indexOf(V.target) + H;
        J < 0 ? J = K.length - 1 : J >= K.length && (J = 0), K[J].focus({
          preventScroll: !0
        }), K[J].click(), M();
      }, M = () => {
        h.value && (m.value = !0);
      }, R = () => m.value = !1, D = (V, F) => {
        d.value[F] = V;
      }, L = async () => {
        await Re();
        const V = d.value[e.currentName];
        V == null || V.focus({
          preventScroll: !0
        });
      };
      return de(a, (V) => {
        V === "hidden" ? h.value = !1 : V === "visible" && setTimeout(() => h.value = !0, 50);
      }), de(r, (V) => {
        V ? setTimeout(() => h.value = !0, 50) : h.value = !1;
      }), qt(c, Y), ft(() => setTimeout(() => z(), 0)), Qo(() => Y()), t({
        scrollToActiveTab: z,
        removeFocus: R,
        focusActiveTab: L,
        tabListRef: u,
        tabBarRef: f,
        scheduleRender: () => ju(g)
      }), () => {
        const V = v.value ? [q("span", {
          class: [l.e("nav-prev"), l.is("disabled", !v.value.prev)],
          onClick: O
        }, [q(ze, null, {
          default: () => [q(ql, null, null)]
        })]), q("span", {
          class: [l.e("nav-next"), l.is("disabled", !v.value.next)],
          onClick: N
        }, [q(ze, null, {
          default: () => [q(Un, null, null)]
        })])] : null, F = e.panes.map((H, K) => {
          var Z, J, ie, ue, re;
          const se = H.uid, ne = H.props.disabled, le = (J = (Z = H.props.name) != null ? Z : H.index) != null ? J : `${K}`, Ce = !ne && (H.isClosable || H.props.closable !== !1 && e.editable);
          H.index = `${K}`;
          const j = Ce ? q(ze, {
            class: "is-icon-close",
            onClick: (ge) => n("tabRemove", H, ge)
          }, {
            default: () => [q(Oo, null, null)]
          }) : null, te = ((ue = (ie = H.slots).label) == null ? void 0 : ue.call(ie)) || H.props.label, ce = !ne && H.active ? (re = e.tabindex) != null ? re : o.props.tabindex : -1;
          return q("div", {
            ref: (ge) => D(ge, le),
            class: [l.e("item"), l.is(o.props.tabPosition), l.is("active", H.active), l.is("disabled", ne), l.is("closable", Ce), l.is("focus", m.value)],
            id: `tab-${le}`,
            key: `tab-${se}`,
            "aria-controls": `pane-${le}`,
            role: "tab",
            "aria-selected": H.active,
            tabindex: ce,
            onFocus: () => M(),
            onBlur: () => R(),
            onClick: (ge) => {
              R(), n("tabClick", H, le, ge);
            },
            onKeydown: (ge) => {
              const be = Ht(ge);
              Ce && (be === _e.delete || be === _e.backspace) && n("tabRemove", H, ge);
            }
          }, [te, j]);
        });
        return g.value, q("div", {
          ref: c,
          class: [l.e("nav-wrap"), l.is("scrollable", !!v.value), l.is(o.props.tabPosition)]
        }, [V, q("div", {
          class: l.e("nav-scroll"),
          ref: i
        }, [e.panes.length > 0 ? q("div", {
          class: [l.e("nav"), l.is(o.props.tabPosition), l.is("stretch", e.stretch && ["top", "bottom"].includes(o.props.tabPosition))],
          ref: u,
          style: w.value,
          role: "tablist",
          onKeydown: G,
          onWheel: P
        }, [e.type ? null : q(dU, {
          ref: f,
          tabs: [...e.panes],
          tabRefs: d.value
        }, null), F]) : null])]);
      };
    }
  }), hU = Te({
    type: {
      type: String,
      values: ["card", "border-card", ""],
      default: ""
    },
    closable: Boolean,
    addable: Boolean,
    modelValue: {
      type: [String, Number]
    },
    editable: Boolean,
    tabPosition: {
      type: String,
      values: ["top", "right", "bottom", "left"],
      default: "top"
    },
    beforeLeave: {
      type: X(Function),
      default: () => !0
    },
    stretch: Boolean,
    tabindex: {
      type: [String, Number],
      default: 0
    }
  }), jf = (e) => Ae(e) || je(e), mU = {
    [et]: (e) => jf(e),
    tabClick: (e, t) => t instanceof Event,
    tabChange: (e) => jf(e),
    edit: (e, t) => ["remove", "add"].includes(t),
    tabRemove: (e) => jf(e),
    tabAdd: () => !0
  }, gU = /* @__PURE__ */ U({
    name: "ElTabs",
    props: hU,
    emits: mU,
    setup(e, {
      emit: t,
      slots: n,
      expose: o
    }) {
      var l;
      const a = he("tabs"), r = S(() => ["left", "right"].includes(e.tabPosition)), {
        children: i,
        addChild: u,
        removeChild: c,
        ChildrenSorter: d
      } = Fd(dt(), "ElTabPane"), f = A(), v = A((l = e.modelValue) != null ? l : "0"), p = async (w, y = !1) => {
        var E, k, T, x;
        if (!(v.value === w || kt(w)))
          try {
            let I;
            if (e.beforeLeave) {
              const P = e.beforeLeave(w, v.value);
              I = P instanceof Promise ? await P : P;
            } else
              I = !0;
            if (I !== !1) {
              const P = (E = i.value.find((O) => O.paneName === v.value)) == null ? void 0 : E.isFocusInsidePane();
              v.value = w, y && (t(et, w), t("tabChange", w)), (T = (k = f.value) == null ? void 0 : k.removeFocus) == null || T.call(k), P && ((x = f.value) == null || x.focusActiveTab());
            }
          } catch {
          }
      }, m = (w, y, E) => {
        w.props.disabled || (t("tabClick", w, E), p(y, !0));
      }, h = (w, y) => {
        w.props.disabled || kt(w.props.name) || (y.stopPropagation(), t("edit", w.props.name, "remove"), t("tabRemove", w.props.name));
      }, g = () => {
        t("edit", void 0, "add"), t("tabAdd");
      }, b = (w) => {
        const y = Ht(w);
        [_e.enter, _e.numpadEnter].includes(y) && g();
      }, C = (w) => {
        const y = w.el.firstChild, E = ["bottom", "right"].includes(e.tabPosition) ? w.children[0].el : w.children[1].el;
        y !== E && y.before(E);
      };
      return de(() => e.modelValue, (w) => p(w)), de(v, async () => {
        var w;
        await Re(), (w = f.value) == null || w.scrollToActiveTab();
      }), yt(qd, {
        props: e,
        currentName: v,
        registerPane: u,
        unregisterPane: c,
        nav$: f
      }), o({
        currentName: v,
        get tabNavRef() {
          return Md(f.value, ["scheduleRender"]);
        }
      }), () => {
        const w = n["add-icon"], y = e.editable || e.addable ? q("div", {
          class: [a.e("new-tab"), r.value && a.e("new-tab-vertical")],
          tabindex: e.tabindex,
          onClick: g,
          onKeydown: b
        }, [w ? ee(n, "add-icon") : q(ze, {
          class: a.is("icon-plus")
        }, {
          default: () => [q(yC, null, null)]
        })]) : null, E = () => q(vU, {
          ref: f,
          currentName: v.value,
          editable: e.editable,
          type: e.type,
          panes: i.value,
          stretch: e.stretch,
          onTabClick: m,
          onTabRemove: h
        }, null), k = q("div", {
          class: [a.e("header"), r.value && a.e("header-vertical"), a.is(e.tabPosition)]
        }, [q(d, null, {
          default: E,
          $stable: !0
        }), y]), T = q("div", {
          class: a.e("content")
        }, [ee(n, "default")]);
        return q("div", {
          class: [a.b(), a.m(e.tabPosition), {
            [a.m("card")]: e.type === "card",
            [a.m("border-card")]: e.type === "border-card"
          }],
          onVnodeMounted: C,
          onVnodeUpdated: C
        }, [T, k]);
      };
    }
  });
  var bU = gU;
  const yU = Te({
    label: {
      type: String,
      default: ""
    },
    name: {
      type: [String, Number]
    },
    closable: {
      type: Boolean,
      default: void 0
    },
    disabled: Boolean,
    lazy: Boolean
  }), jk = "ElTabPane", wU = /* @__PURE__ */ U({
    name: jk
  }), CU = /* @__PURE__ */ U({
    ...wU,
    props: yU,
    setup(e) {
      const t = e, n = dt(), o = hn(), l = Ve(qd);
      l || Zt(jk, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
      const a = he("tab-pane"), r = A(), i = A(), u = S(() => {
        var h;
        return (h = t.closable) != null ? h : l.props.closable;
      }), c = Vc(() => {
        var h;
        return l.currentName.value === ((h = t.name) != null ? h : i.value);
      }), d = A(c.value), f = S(() => {
        var h;
        return (h = t.name) != null ? h : i.value;
      }), v = Vc(() => !t.lazy || d.value || c.value), p = () => {
        var h;
        return (h = r.value) == null ? void 0 : h.contains(document.activeElement);
      };
      de(c, (h) => {
        h && (d.value = !0);
      });
      const m = Rt({
        uid: n.uid,
        getVnode: () => n.vnode,
        slots: o,
        props: t,
        paneName: f,
        active: c,
        index: i,
        isClosable: u,
        isFocusInsidePane: p
      });
      return l.registerPane(m), Bt(() => {
        l.unregisterPane(m);
      }), Pv(() => {
        var h;
        o.label && ((h = l.nav$.value) == null || h.scheduleRender());
      }), (h, g) => s(v) ? it((_(), B("div", {
        key: 0,
        id: `pane-${s(f)}`,
        ref_key: "paneRef",
        ref: r,
        class: $(s(a).b()),
        role: "tabpanel",
        "aria-hidden": !s(c),
        "aria-labelledby": `tab-${s(f)}`
      }, [
        ee(h.$slots, "default")
      ], 10, ["id", "aria-hidden", "aria-labelledby"])), [
        [Mt, s(c)]
      ]) : oe("v-if", !0);
    }
  });
  var Uk = /* @__PURE__ */ Ne(CU, [["__file", "tab-pane.vue"]]);
  const SU = rt(bU, {
    TabPane: Uk
  }), EU = nn(Uk), kU = Te({
    type: {
      type: String,
      values: ["primary", "success", "info", "warning", "danger", ""],
      default: ""
    },
    size: {
      type: String,
      values: Tl,
      default: ""
    },
    truncated: Boolean,
    lineClamp: {
      type: [String, Number]
    },
    tag: {
      type: String,
      default: "span"
    }
  }), _U = /* @__PURE__ */ U({
    name: "ElText"
  }), TU = /* @__PURE__ */ U({
    ..._U,
    props: kU,
    setup(e) {
      const t = e, n = A(), o = vn(), l = he("text"), a = S(() => [
        l.b(),
        l.m(t.type),
        l.m(o.value),
        l.is("truncated", t.truncated),
        l.is("line-clamp", !kt(t.lineClamp))
      ]), r = () => {
        var i, u, c, d, f, v, p;
        if (ea().title)
          return;
        let h = !1;
        const g = ((i = n.value) == null ? void 0 : i.textContent) || "";
        if (t.truncated) {
          const b = (u = n.value) == null ? void 0 : u.offsetWidth, C = (c = n.value) == null ? void 0 : c.scrollWidth;
          b && C && C > b && (h = !0);
        } else if (!kt(t.lineClamp)) {
          const b = (d = n.value) == null ? void 0 : d.offsetHeight, C = (f = n.value) == null ? void 0 : f.scrollHeight;
          b && C && C > b && (h = !0);
        }
        h ? (v = n.value) == null || v.setAttribute("title", g) : (p = n.value) == null || p.removeAttribute("title");
      };
      return ft(r), Qo(r), (i, u) => (_(), ae(ct(i.tag), {
        ref_key: "textRef",
        ref: n,
        class: $(s(a)),
        style: Ue({ "-webkit-line-clamp": i.lineClamp })
      }, {
        default: Q(() => [
          ee(i.$slots, "default")
        ]),
        _: 3
      }, 8, ["class", "style"]));
    }
  });
  var NU = /* @__PURE__ */ Ne(TU, [["__file", "text.vue"]]);
  const hm = rt(NU), $U = Te({
    format: {
      type: String,
      default: "HH:mm"
    },
    modelValue: {
      type: X(String)
    },
    disabled: Boolean,
    editable: {
      type: Boolean,
      default: !0
    },
    effect: {
      type: X(String),
      default: "light"
    },
    clearable: {
      type: Boolean,
      default: !0
    },
    size: mn,
    placeholder: String,
    start: {
      type: String,
      default: "09:00"
    },
    end: {
      type: String,
      default: "18:00"
    },
    step: {
      type: String,
      default: "00:30"
    },
    minTime: {
      type: X(String)
    },
    maxTime: {
      type: X(String)
    },
    includeEndTime: Boolean,
    name: String,
    prefixIcon: {
      type: X([String, Object]),
      default: () => bC
    },
    clearIcon: {
      type: X([String, Object]),
      default: () => oa
    },
    popperClass: {
      type: String,
      default: ""
    },
    popperStyle: {
      type: X([String, Object])
    },
    ...Cr
  }), Fl = (e) => {
    const t = (e || "").split(":");
    if (t.length >= 2) {
      let n = Number.parseInt(t[0], 10);
      const o = Number.parseInt(t[1], 10), l = e.toUpperCase();
      return l.includes("AM") && n === 12 ? n = 0 : l.includes("PM") && n !== 12 && (n += 12), {
        hours: n,
        minutes: o
      };
    }
    return null;
  }, Uf = (e, t) => {
    const n = Fl(e);
    if (!n)
      return -1;
    const o = Fl(t);
    if (!o)
      return -1;
    const l = n.minutes + n.hours * 60, a = o.minutes + o.hours * 60;
    return l === a ? 0 : l > a ? 1 : -1;
  }, t0 = (e) => `${e}`.padStart(2, "0"), Ar = (e) => `${t0(e.hours)}:${t0(e.minutes)}`, OU = (e, t) => {
    const n = Fl(e);
    if (!n)
      return "";
    const o = Fl(t);
    if (!o)
      return "";
    const l = {
      hours: n.hours,
      minutes: n.minutes
    };
    return l.minutes += o.minutes, l.hours += o.hours, l.hours += Math.floor(l.minutes / 60), l.minutes = l.minutes % 60, Ar(l);
  }, IU = /* @__PURE__ */ U({
    name: "ElTimeSelect"
  }), MU = /* @__PURE__ */ U({
    ...IU,
    props: $U,
    emits: [gt, "blur", "focus", "clear", et],
    setup(e, { expose: t }) {
      const n = e;
      st.extend(Mh);
      const { Option: o } = fr, l = he("input"), a = A(), r = Cn(), { lang: i } = _t(), u = S(() => n.modelValue), c = S(() => {
        const b = Fl(n.start);
        return b ? Ar(b) : null;
      }), d = S(() => {
        const b = Fl(n.end);
        return b ? Ar(b) : null;
      }), f = S(() => {
        const b = Fl(n.step);
        return b ? Ar(b) : null;
      }), v = S(() => {
        const b = Fl(n.minTime || "");
        return b ? Ar(b) : null;
      }), p = S(() => {
        const b = Fl(n.maxTime || "");
        return b ? Ar(b) : null;
      }), m = S(() => {
        var b;
        const C = [], w = (y, E) => {
          C.push({
            value: y,
            disabled: Uf(E, v.value || "-1:-1") <= 0 || Uf(E, p.value || "100:100") >= 0
          });
        };
        if (n.start && n.end && n.step) {
          let y = c.value, E;
          for (; y && d.value && Uf(y, d.value) <= 0; )
            E = st(y, "HH:mm").locale(i.value).format(n.format), w(E, y), y = OU(y, f.value);
          if (n.includeEndTime && d.value && ((b = C[C.length - 1]) == null ? void 0 : b.value) !== d.value) {
            const k = st(d.value, "HH:mm").locale(i.value).format(n.format);
            w(k, d.value);
          }
        }
        return C;
      });
      return t({
        blur: () => {
          var b, C;
          (C = (b = a.value) == null ? void 0 : b.blur) == null || C.call(b);
        },
        focus: () => {
          var b, C;
          (C = (b = a.value) == null ? void 0 : b.focus) == null || C.call(b);
        }
      }), (b, C) => (_(), ae(s(fr), {
        ref_key: "select",
        ref: a,
        "model-value": s(u),
        disabled: s(r),
        clearable: b.clearable,
        "clear-icon": b.clearIcon,
        size: b.size,
        effect: b.effect,
        placeholder: b.placeholder,
        "default-first-option": "",
        filterable: b.editable,
        "empty-values": b.emptyValues,
        "value-on-clear": b.valueOnClear,
        "popper-class": b.popperClass,
        "popper-style": b.popperStyle,
        "onUpdate:modelValue": (w) => b.$emit(s(et), w),
        onChange: (w) => b.$emit(s(gt), w),
        onBlur: (w) => b.$emit("blur", w),
        onFocus: (w) => b.$emit("focus", w),
        onClear: () => b.$emit("clear")
      }, {
        prefix: Q(() => [
          b.prefixIcon ? (_(), ae(s(ze), {
            key: 0,
            class: $(s(l).e("prefix-icon"))
          }, {
            default: Q(() => [
              (_(), ae(ct(b.prefixIcon)))
            ]),
            _: 1
          }, 8, ["class"])) : oe("v-if", !0)
        ]),
        default: Q(() => [
          (_(!0), B(We, null, bt(s(m), (w) => (_(), ae(s(o), {
            key: w.value,
            label: w.value,
            value: w.value,
            disabled: w.disabled
          }, null, 8, ["label", "value", "disabled"]))), 128))
        ]),
        _: 1
      }, 8, ["model-value", "disabled", "clearable", "clear-icon", "size", "effect", "placeholder", "filterable", "empty-values", "value-on-clear", "popper-class", "popper-style", "onUpdate:modelValue", "onChange", "onBlur", "onFocus", "onClear"]));
    }
  });
  var xU = /* @__PURE__ */ Ne(MU, [["__file", "time-select.vue"]]);
  const PU = rt(xU), RU = "timeline", DU = /* @__PURE__ */ U({
    name: "ElTimeline",
    setup(e, { slots: t }) {
      const n = he("timeline");
      return yt(RU, t), () => qe("ul", { class: [n.b()] }, [ee(t, "default")]);
    }
  }), AU = Te({
    timestamp: {
      type: String,
      default: ""
    },
    hideTimestamp: Boolean,
    center: Boolean,
    placement: {
      type: String,
      values: ["top", "bottom"],
      default: "bottom"
    },
    type: {
      type: String,
      values: ["primary", "success", "warning", "danger", "info"],
      default: ""
    },
    color: {
      type: String,
      default: ""
    },
    size: {
      type: String,
      values: ["normal", "large"],
      default: "normal"
    },
    icon: {
      type: Lt
    },
    hollow: Boolean
  }), VU = /* @__PURE__ */ U({
    name: "ElTimelineItem"
  }), LU = /* @__PURE__ */ U({
    ...VU,
    props: AU,
    setup(e) {
      const t = e, n = he("timeline-item"), o = S(() => [
        n.e("node"),
        n.em("node", t.size || ""),
        n.em("node", t.type || ""),
        n.is("hollow", t.hollow)
      ]);
      return (l, a) => (_(), B("li", {
        class: $([s(n).b(), { [s(n).e("center")]: l.center }])
      }, [
        W("div", {
          class: $(s(n).e("tail"))
        }, null, 2),
        l.$slots.dot ? oe("v-if", !0) : (_(), B("div", {
          key: 0,
          class: $(s(o)),
          style: Ue({
            backgroundColor: l.color
          })
        }, [
          l.icon ? (_(), ae(s(ze), {
            key: 0,
            class: $(s(n).e("icon"))
          }, {
            default: Q(() => [
              (_(), ae(ct(l.icon)))
            ]),
            _: 1
          }, 8, ["class"])) : oe("v-if", !0)
        ], 6)),
        l.$slots.dot ? (_(), B("div", {
          key: 1,
          class: $(s(n).e("dot"))
        }, [
          ee(l.$slots, "dot")
        ], 2)) : oe("v-if", !0),
        W("div", {
          class: $(s(n).e("wrapper"))
        }, [
          !l.hideTimestamp && l.placement === "top" ? (_(), B("div", {
            key: 0,
            class: $([s(n).e("timestamp"), s(n).is("top")])
          }, ke(l.timestamp), 3)) : oe("v-if", !0),
          W("div", {
            class: $(s(n).e("content"))
          }, [
            ee(l.$slots, "default")
          ], 2),
          !l.hideTimestamp && l.placement === "bottom" ? (_(), B("div", {
            key: 1,
            class: $([s(n).e("timestamp"), s(n).is("bottom")])
          }, ke(l.timestamp), 3)) : oe("v-if", !0)
        ], 2)
      ], 2));
    }
  });
  var Yk = /* @__PURE__ */ Ne(LU, [["__file", "timeline-item.vue"]]);
  const BU = rt(DU, {
    TimelineItem: Yk
  }), FU = nn(Yk), qk = "left-check-change", Gk = "right-check-change", Vr = Te({
    data: {
      type: X(Array),
      default: () => []
    },
    titles: {
      type: X(Array),
      default: () => []
    },
    buttonTexts: {
      type: X(Array),
      default: () => []
    },
    filterPlaceholder: String,
    filterMethod: {
      type: X(Function)
    },
    leftDefaultChecked: {
      type: X(Array),
      default: () => []
    },
    rightDefaultChecked: {
      type: X(Array),
      default: () => []
    },
    renderContent: {
      type: X(Function)
    },
    modelValue: {
      type: X(Array),
      default: () => []
    },
    format: {
      type: X(Object),
      default: () => ({})
    },
    filterable: Boolean,
    props: {
      type: X(Object),
      default: () => en({
        label: "label",
        key: "key",
        disabled: "disabled"
      })
    },
    targetOrder: {
      type: String,
      values: ["original", "push", "unshift"],
      default: "original"
    },
    validateEvent: {
      type: Boolean,
      default: !0
    }
  }), rv = (e, t) => [e, t].every(ye) || ye(e) && cn(t), zU = {
    [gt]: (e, t, n) => [e, n].every(ye) && ["left", "right"].includes(t),
    [et]: (e) => ye(e),
    [qk]: rv,
    [Gk]: rv
  }, sv = "checked-change", HU = Te({
    data: Vr.data,
    optionRender: {
      type: X(Function)
    },
    placeholder: String,
    title: String,
    filterable: Boolean,
    format: Vr.format,
    filterMethod: Vr.filterMethod,
    defaultChecked: Vr.leftDefaultChecked,
    props: Vr.props
  }), KU = {
    [sv]: rv
  }, hu = (e) => {
    const t = {
      label: "label",
      key: "key",
      disabled: "disabled"
    };
    return S(() => ({
      ...t,
      ...e.props
    }));
  }, WU = (e, t, n) => {
    const o = hu(e), l = S(() => e.data.filter((d) => Fe(e.filterMethod) ? e.filterMethod(t.query, d) : String(d[o.value.label] || d[o.value.key]).toLowerCase().includes(t.query.toLowerCase()))), a = S(() => l.value.filter((d) => !d[o.value.disabled])), r = S(() => {
      const d = t.checked.length, f = e.data.length, { noChecked: v, hasChecked: p } = e.format;
      return v && p ? d > 0 ? p.replace(/\${checked}/g, d.toString()).replace(/\${total}/g, f.toString()) : v.replace(/\${total}/g, f.toString()) : `${d}/${f}`;
    }), i = S(() => {
      const d = t.checked.length;
      return d > 0 && d < a.value.length;
    }), u = () => {
      const d = a.value.map((f) => f[o.value.key]);
      t.allChecked = d.length > 0 && d.every((f) => t.checked.includes(f));
    }, c = (d) => {
      t.checked = d ? a.value.map((f) => f[o.value.key]) : [];
    };
    return de(() => t.checked, (d, f) => {
      if (u(), t.checkChangeByUser) {
        const v = d.concat(f).filter((p) => !d.includes(p) || !f.includes(p));
        n(sv, d, v);
      } else
        n(sv, d), t.checkChangeByUser = !0;
    }), de(a, () => {
      u();
    }), de(() => e.data, () => {
      const d = [], f = l.value.map((v) => v[o.value.key]);
      t.checked.forEach((v) => {
        f.includes(v) && d.push(v);
      }), t.checkChangeByUser = !1, t.checked = d;
    }), de(() => e.defaultChecked, (d, f) => {
      if (f && d.length === f.length && d.every((m) => f.includes(m)))
        return;
      const v = [], p = a.value.map((m) => m[o.value.key]);
      d.forEach((m) => {
        p.includes(m) && v.push(m);
      }), t.checkChangeByUser = !1, t.checked = v;
    }, {
      immediate: !0
    }), {
      filteredData: l,
      checkableData: a,
      checkedSummary: r,
      isIndeterminate: i,
      updateAllChecked: u,
      handleAllCheckedChange: c
    };
  }, jU = /* @__PURE__ */ U({
    name: "ElTransferPanel"
  }), UU = /* @__PURE__ */ U({
    ...jU,
    props: HU,
    emits: KU,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = hn(), a = ({ option: w }) => w, { t: r } = _t(), i = he("transfer"), u = Rt({
        checked: [],
        allChecked: !1,
        query: "",
        checkChangeByUser: !0
      }), c = hu(o), {
        filteredData: d,
        checkedSummary: f,
        isIndeterminate: v,
        handleAllCheckedChange: p
      } = WU(o, u, n), m = S(() => !Zn(u.query) && Zn(d.value)), h = S(() => !Zn(l.default()[0].children)), { checked: g, allChecked: b, query: C } = wn(u);
      return t({
        query: C
      }), (w, y) => (_(), B("div", {
        class: $(s(i).b("panel"))
      }, [
        W("p", {
          class: $(s(i).be("panel", "header"))
        }, [
          q(s(xo), {
            modelValue: s(b),
            "onUpdate:modelValue": (E) => Kt(b) ? b.value = E : null,
            indeterminate: s(v),
            "validate-event": !1,
            onChange: s(p)
          }, {
            default: Q(() => [
              Ct(ke(w.title) + " ", 1),
              W("span", null, ke(s(f)), 1)
            ]),
            _: 1
          }, 8, ["modelValue", "onUpdate:modelValue", "indeterminate", "onChange"])
        ], 2),
        W("div", {
          class: $([s(i).be("panel", "body"), s(i).is("with-footer", s(h))])
        }, [
          w.filterable ? (_(), ae(s(Wn), {
            key: 0,
            modelValue: s(C),
            "onUpdate:modelValue": (E) => Kt(C) ? C.value = E : null,
            class: $(s(i).be("panel", "filter")),
            size: "default",
            placeholder: w.placeholder,
            "prefix-icon": s(_D),
            clearable: "",
            "validate-event": !1
          }, null, 8, ["modelValue", "onUpdate:modelValue", "class", "placeholder", "prefix-icon"])) : oe("v-if", !0),
          it(q(s(TS), {
            modelValue: s(g),
            "onUpdate:modelValue": (E) => Kt(g) ? g.value = E : null,
            "validate-event": !1,
            class: $([s(i).is("filterable", w.filterable), s(i).be("panel", "list")])
          }, {
            default: Q(() => [
              (_(!0), B(We, null, bt(s(d), (E) => (_(), ae(s(xo), {
                key: E[s(c).key],
                class: $(s(i).be("panel", "item")),
                value: E[s(c).key],
                disabled: E[s(c).disabled],
                "validate-event": !1
              }, {
                default: Q(() => {
                  var k;
                  return [
                    q(a, {
                      option: (k = w.optionRender) == null ? void 0 : k.call(w, E)
                    }, null, 8, ["option"])
                  ];
                }),
                _: 2
              }, 1032, ["class", "value", "disabled"]))), 128))
            ]),
            _: 1
          }, 8, ["modelValue", "onUpdate:modelValue", "class"]), [
            [Mt, !s(m) && !s(Zn)(w.data)]
          ]),
          it(W("div", {
            class: $(s(i).be("panel", "empty"))
          }, [
            ee(w.$slots, "empty", {}, () => [
              Ct(ke(s(m) ? s(r)("el.transfer.noMatch") : s(r)("el.transfer.noData")), 1)
            ])
          ], 2), [
            [Mt, s(m) || s(Zn)(w.data)]
          ])
        ], 2),
        s(h) ? (_(), B("p", {
          key: 0,
          class: $(s(i).be("panel", "footer"))
        }, [
          ee(w.$slots, "default")
        ], 2)) : oe("v-if", !0)
      ], 2));
    }
  });
  var n0 = /* @__PURE__ */ Ne(UU, [["__file", "transfer-panel.vue"]]);
  const YU = (e) => {
    const t = hu(e), n = S(() => e.data.reduce((a, r) => (a[r[t.value.key]] = r) && a, {})), o = S(() => e.data.filter((a) => !e.modelValue.includes(a[t.value.key]))), l = S(() => e.targetOrder === "original" ? e.data.filter((a) => e.modelValue.includes(a[t.value.key])) : e.modelValue.reduce((a, r) => {
      const i = n.value[r];
      return i && a.push(i), a;
    }, []));
    return {
      sourceData: o,
      targetData: l
    };
  }, qU = (e, t, n) => {
    const o = hu(e), l = (i, u, c) => {
      n(et, i), n(gt, i, u, c);
    };
    return {
      addToLeft: () => {
        const i = e.modelValue.slice();
        t.rightChecked.forEach((u) => {
          const c = i.indexOf(u);
          c > -1 && i.splice(c, 1);
        }), l(i, "left", t.rightChecked);
      },
      addToRight: () => {
        let i = e.modelValue.slice();
        const u = e.data.filter((c) => {
          const d = c[o.value.key];
          return t.leftChecked.includes(d) && !e.modelValue.includes(d);
        }).map((c) => c[o.value.key]);
        i = e.targetOrder === "unshift" ? u.concat(i) : i.concat(u), e.targetOrder === "original" && (i = e.data.filter((c) => i.includes(c[o.value.key])).map((c) => c[o.value.key])), l(i, "right", t.leftChecked);
      }
    };
  }, GU = (e, t) => ({
    onSourceCheckedChange: (l, a) => {
      e.leftChecked = l, a && t(qk, l, a);
    },
    onTargetCheckedChange: (l, a) => {
      e.rightChecked = l, a && t(Gk, l, a);
    }
  }), XU = /* @__PURE__ */ U({
    name: "ElTransfer"
  }), JU = /* @__PURE__ */ U({
    ...XU,
    props: Vr,
    emits: zU,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = hn(), { t: a } = _t(), r = he("transfer"), { formItem: i } = Nn(), u = Rt({
        leftChecked: [],
        rightChecked: []
      }), c = hu(o), { sourceData: d, targetData: f } = YU(o), { onSourceCheckedChange: v, onTargetCheckedChange: p } = GU(u, n), { addToLeft: m, addToRight: h } = qU(o, u, n), g = A(), b = A(), C = (x) => {
        switch (x) {
          case "left":
            g.value.query = "";
            break;
          case "right":
            b.value.query = "";
            break;
        }
      }, w = S(() => o.buttonTexts.length === 2), y = S(() => o.titles[0] || a("el.transfer.titles.0")), E = S(() => o.titles[1] || a("el.transfer.titles.1")), k = S(() => o.filterPlaceholder || a("el.transfer.filterPlaceholder"));
      de(() => o.modelValue, () => {
        var x;
        o.validateEvent && ((x = i == null ? void 0 : i.validate) == null || x.call(i, "change").catch((I) => vt(I)));
      });
      const T = S(() => (x) => {
        var I;
        if (o.renderContent)
          return o.renderContent(qe, x);
        const P = (((I = l.default) == null ? void 0 : I.call(l, { option: x })) || []).filter((O) => O.type !== Qt);
        return P.length ? P : qe("span", x[c.value.label] || x[c.value.key]);
      });
      return t({
        clearQuery: C,
        leftPanel: g,
        rightPanel: b
      }), (x, I) => (_(), B("div", {
        class: $(s(r).b())
      }, [
        q(n0, {
          ref_key: "leftPanel",
          ref: g,
          data: s(d),
          "option-render": s(T),
          placeholder: s(k),
          title: s(y),
          filterable: x.filterable,
          format: x.format,
          "filter-method": x.filterMethod,
          "default-checked": x.leftDefaultChecked,
          props: o.props,
          onCheckedChange: s(v)
        }, {
          empty: Q(() => [
            ee(x.$slots, "left-empty")
          ]),
          default: Q(() => [
            ee(x.$slots, "left-footer")
          ]),
          _: 3
        }, 8, ["data", "option-render", "placeholder", "title", "filterable", "format", "filter-method", "default-checked", "props", "onCheckedChange"]),
        W("div", {
          class: $(s(r).e("buttons"))
        }, [
          q(s(_n), {
            type: "primary",
            class: $([s(r).e("button"), s(r).is("with-texts", s(w))]),
            disabled: s(Zn)(u.rightChecked),
            onClick: s(m)
          }, {
            default: Q(() => [
              q(s(ze), null, {
                default: Q(() => [
                  q(s(ql))
                ]),
                _: 1
              }),
              s(kt)(x.buttonTexts[0]) ? oe("v-if", !0) : (_(), B("span", { key: 0 }, ke(x.buttonTexts[0]), 1))
            ]),
            _: 1
          }, 8, ["class", "disabled", "onClick"]),
          q(s(_n), {
            type: "primary",
            class: $([s(r).e("button"), s(r).is("with-texts", s(w))]),
            disabled: s(Zn)(u.leftChecked),
            onClick: s(h)
          }, {
            default: Q(() => [
              s(kt)(x.buttonTexts[1]) ? oe("v-if", !0) : (_(), B("span", { key: 0 }, ke(x.buttonTexts[1]), 1)),
              q(s(ze), null, {
                default: Q(() => [
                  q(s(Un))
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["class", "disabled", "onClick"])
        ], 2),
        q(n0, {
          ref_key: "rightPanel",
          ref: b,
          data: s(f),
          "option-render": s(T),
          placeholder: s(k),
          filterable: x.filterable,
          format: x.format,
          "filter-method": x.filterMethod,
          title: s(E),
          "default-checked": x.rightDefaultChecked,
          props: o.props,
          onCheckedChange: s(p)
        }, {
          empty: Q(() => [
            ee(x.$slots, "right-empty")
          ]),
          default: Q(() => [
            ee(x.$slots, "right-footer")
          ]),
          _: 3
        }, 8, ["data", "option-render", "placeholder", "filterable", "format", "filter-method", "title", "default-checked", "props", "onCheckedChange"])
      ], 2));
    }
  });
  var ZU = /* @__PURE__ */ Ne(JU, [["__file", "transfer.vue"]]);
  const QU = rt(ZU), Gr = "$treeNodeId", o0 = function(e, t) {
    !t || t[Gr] || Object.defineProperty(t, Gr, {
      value: e.id,
      enumerable: !1,
      configurable: !1,
      writable: !1
    });
  }, mm = (e, t) => t == null ? void 0 : t[e || Gr], iv = (e, t, n) => {
    const o = e.value.currentNode;
    n();
    const l = e.value.currentNode;
    o !== l && t("current-change", l ? l.data : null, l);
  }, uv = (e) => {
    let t = !0, n = !0, o = !0;
    for (let l = 0, a = e.length; l < a; l++) {
      const r = e[l];
      (r.checked !== !0 || r.indeterminate) && (t = !1, r.disabled || (o = !1)), (r.checked !== !1 || r.indeterminate) && (n = !1);
    }
    return { all: t, none: n, allWithoutDisable: o, half: !t && !n };
  }, Ws = function(e) {
    if (e.childNodes.length === 0 || e.loading)
      return;
    const { all: t, none: n, half: o } = uv(e.childNodes);
    t ? (e.checked = !0, e.indeterminate = !1) : o ? (e.checked = !1, e.indeterminate = !0) : n && (e.checked = !1, e.indeterminate = !1);
    const l = e.parent;
    !l || l.level === 0 || e.store.checkStrictly || Ws(l);
  }, zu = function(e, t) {
    const n = e.store.props, o = e.data || {}, l = n[t];
    if (Fe(l))
      return l(o, e);
    if (Ae(l))
      return o[l];
    if (kt(l)) {
      const a = o[t];
      return kt(a) ? "" : a;
    }
  }, cv = function(e, t) {
    e.forEach((n) => {
      n.canFocus = t, cv(n.childNodes, t);
    });
  };
  let eY = 0, dv = class vc {
    constructor(t) {
      this.isLeafByUser = void 0, this.isLeaf = void 0, this.id = eY++, this.text = null, this.checked = !1, this.indeterminate = !1, this.data = null, this.expanded = !1, this.parent = null, this.visible = !0, this.isCurrent = !1, this.canFocus = !1;
      for (const n in t)
        Ot(t, n) && (this[n] = t[n]);
      this.level = 0, this.loaded = !1, this.childNodes = [], this.loading = !1, this.parent && (this.level = this.parent.level + 1);
    }
    initialize() {
      var t;
      const n = this.store;
      if (!n)
        throw new Error("[Node]store is required!");
      n.registerNode(this);
      const o = n.props;
      if (o && typeof o.isLeaf < "u") {
        const r = zu(this, "isLeaf");
        Vt(r) && (this.isLeafByUser = r);
      }
      if (n.lazy !== !0 && this.data ? (this.setData(this.data), n.defaultExpandAll && (this.expanded = !0, this.canFocus = !0)) : this.level > 0 && n.lazy && n.defaultExpandAll && !this.isLeafByUser && this.expand(), ye(this.data) || o0(this, this.data), !this.data)
        return;
      const l = n.defaultExpandedKeys, a = n.key;
      a && !cn(this.key) && l && l.includes(this.key) && this.expand(null, n.autoExpandParent), a && n.currentNodeKey !== void 0 && this.key === n.currentNodeKey && (n.currentNode && (n.currentNode.isCurrent = !1), n.currentNode = this, n.currentNode.isCurrent = !0), n.lazy && n._initDefaultCheckedNode(this), this.updateLeafState(), (this.level === 1 || ((t = this.parent) == null ? void 0 : t.expanded) === !0) && (this.canFocus = !0);
    }
    setData(t) {
      ye(t) || o0(this, t), this.data = t, this.childNodes = [];
      let n;
      this.level === 0 && ye(this.data) ? n = this.data : n = zu(this, "children") || [];
      for (let o = 0, l = n.length; o < l; o++)
        this.insertChild({ data: n[o] });
    }
    get label() {
      return zu(this, "label");
    }
    get key() {
      const t = this.store.key;
      return this.data ? this.data[t] : null;
    }
    get disabled() {
      return zu(this, "disabled");
    }
    get nextSibling() {
      const t = this.parent;
      if (t) {
        const n = t.childNodes.indexOf(this);
        if (n > -1)
          return t.childNodes[n + 1];
      }
      return null;
    }
    get previousSibling() {
      const t = this.parent;
      if (t) {
        const n = t.childNodes.indexOf(this);
        if (n > -1)
          return n > 0 ? t.childNodes[n - 1] : null;
      }
      return null;
    }
    contains(t, n = !0) {
      return (this.childNodes || []).some((o) => o === t || n && o.contains(t));
    }
    remove() {
      const t = this.parent;
      t && t.removeChild(this);
    }
    insertChild(t, n, o) {
      if (!t)
        throw new Error("InsertChild error: child is required.");
      if (!(t instanceof vc)) {
        if (!o) {
          const l = this.getChildren(!0);
          l != null && l.includes(t.data) || (kt(n) || n < 0 ? l == null || l.push(t.data) : l == null || l.splice(n, 0, t.data));
        }
        Object.assign(t, {
          parent: this,
          store: this.store
        }), t = Rt(new vc(t)), t instanceof vc && t.initialize();
      }
      t.level = this.level + 1, kt(n) || n < 0 ? this.childNodes.push(t) : this.childNodes.splice(n, 0, t), this.updateLeafState();
    }
    insertBefore(t, n) {
      let o;
      n && (o = this.childNodes.indexOf(n)), this.insertChild(t, o);
    }
    insertAfter(t, n) {
      let o;
      n && (o = this.childNodes.indexOf(n), o !== -1 && (o += 1)), this.insertChild(t, o);
    }
    removeChild(t) {
      const n = this.getChildren() || [], o = n.indexOf(t.data);
      o > -1 && n.splice(o, 1);
      const l = this.childNodes.indexOf(t);
      l > -1 && (this.store && this.store.deregisterNode(t), t.parent = null, this.childNodes.splice(l, 1)), this.updateLeafState();
    }
    removeChildByData(t) {
      const n = this.childNodes.find((o) => o.data === t);
      n && this.removeChild(n);
    }
    expand(t, n) {
      const o = () => {
        if (n) {
          let l = this.parent;
          for (; l && l.level > 0; )
            l.expanded = !0, l = l.parent;
        }
        this.expanded = !0, t && t(), cv(this.childNodes, !0);
      };
      this.shouldLoadData() ? this.loadData((l) => {
        ye(l) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || Ws(this), o());
      }) : o();
    }
    doCreateChildren(t, n = {}) {
      t.forEach((o) => {
        this.insertChild(Object.assign({ data: o }, n), void 0, !0);
      });
    }
    collapse() {
      this.expanded = !1, cv(this.childNodes, !1);
    }
    shouldLoadData() {
      return !!(this.store.lazy === !0 && this.store.load && !this.loaded);
    }
    updateLeafState() {
      if (this.store.lazy === !0 && this.loaded !== !0 && typeof this.isLeafByUser < "u") {
        this.isLeaf = this.isLeafByUser;
        return;
      }
      const t = this.childNodes;
      if (!this.store.lazy || this.store.lazy === !0 && this.loaded === !0) {
        this.isLeaf = !t || t.length === 0;
        return;
      }
      this.isLeaf = !1;
    }
    setChecked(t, n, o, l) {
      if (this.indeterminate = t === "half", this.checked = t === !0, this.store.checkStrictly)
        return;
      if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
        const { all: r, allWithoutDisable: i } = uv(this.childNodes);
        !this.isLeaf && !r && i && (this.checked = !1, t = !1);
        const u = () => {
          if (n) {
            const c = this.childNodes;
            for (let v = 0, p = c.length; v < p; v++) {
              const m = c[v];
              l = l || t !== !1;
              const h = m.disabled ? m.checked : l;
              m.setChecked(h, n, !0, l);
            }
            const { half: d, all: f } = uv(c);
            f || (this.checked = f, this.indeterminate = d);
          }
        };
        if (this.shouldLoadData()) {
          this.loadData(() => {
            u(), Ws(this);
          }, {
            checked: t !== !1
          });
          return;
        } else
          u();
      }
      const a = this.parent;
      !a || a.level === 0 || o || Ws(a);
    }
    getChildren(t = !1) {
      if (this.level === 0)
        return this.data;
      const n = this.data;
      if (!n)
        return null;
      const o = this.store.props;
      let l = "children";
      return o && (l = o.children || "children"), kt(n[l]) && (n[l] = null), t && !n[l] && (n[l] = []), n[l];
    }
    updateChildren() {
      const t = this.getChildren() || [], n = this.childNodes.map((a) => a.data), o = {}, l = [];
      t.forEach((a, r) => {
        const i = a[Gr];
        !!i && n.some((c) => (c == null ? void 0 : c[Gr]) === i) ? o[i] = { index: r, data: a } : l.push({ index: r, data: a });
      }), this.store.lazy || n.forEach((a) => {
        o[a == null ? void 0 : a[Gr]] || this.removeChildByData(a);
      }), l.forEach(({ index: a, data: r }) => {
        this.insertChild({ data: r }, a);
      }), this.updateLeafState();
    }
    loadData(t, n = {}) {
      if (this.store.lazy === !0 && this.store.load && !this.loaded && (!this.loading || Object.keys(n).length)) {
        this.loading = !0;
        const o = (a) => {
          this.childNodes = [], this.doCreateChildren(a, n), this.loaded = !0, this.loading = !1, this.updateLeafState(), t && t.call(this, a);
        }, l = () => {
          this.loading = !1;
        };
        this.store.load(this, o, l);
      } else
        t && t.call(this);
    }
    eachNode(t) {
      const n = [this];
      for (; n.length; ) {
        const o = n.shift();
        n.unshift(...o.childNodes), t(o);
      }
    }
    reInitChecked() {
      this.store.checkStrictly || Ws(this);
    }
  };
  class tY {
    constructor(t) {
      this.lazy = !1, this.checkStrictly = !1, this.autoExpandParent = !1, this.defaultExpandAll = !1, this.checkDescendants = !1, this.currentNode = null, this.currentNodeKey = null;
      for (const n in t)
        Ot(t, n) && (this[n] = t[n]);
      this.nodesMap = {};
    }
    initialize() {
      if (this.root = new dv({
        data: this.data,
        store: this
      }), this.root.initialize(), this.lazy && this.load) {
        const t = this.load;
        t(this.root, (n) => {
          this.root.doCreateChildren(n), this._initDefaultCheckedNodes();
        }, It);
      } else
        this._initDefaultCheckedNodes();
    }
    filter(t) {
      const n = this.filterNodeMethod, o = this.lazy, l = async function(a) {
        const r = a.root ? a.root.childNodes : a.childNodes;
        for (const [i, u] of r.entries())
          u.visible = !!(n != null && n.call(u, t, u.data, u)), i % 80 === 0 && i > 0 && await Re(), await l(u);
        if (!a.visible && r.length) {
          let i = !0;
          i = !r.some((u) => u.visible), a.root ? a.root.visible = i === !1 : a.visible = i === !1;
        }
        t && a.visible && !a.isLeaf && (!o || a.loaded) && a.expand();
      };
      l(this);
    }
    setData(t) {
      t !== this.root.data ? (this.nodesMap = {}, this.root.setData(t), this._initDefaultCheckedNodes(), this.setCurrentNodeKey(this.currentNodeKey)) : this.root.updateChildren();
    }
    getNode(t) {
      if (t instanceof dv)
        return t;
      const n = ot(t) ? mm(this.key, t) : t;
      return this.nodesMap[n] || null;
    }
    insertBefore(t, n) {
      var o;
      const l = this.getNode(n);
      (o = l.parent) == null || o.insertBefore({ data: t }, l);
    }
    insertAfter(t, n) {
      var o;
      const l = this.getNode(n);
      (o = l.parent) == null || o.insertAfter({ data: t }, l);
    }
    remove(t) {
      const n = this.getNode(t);
      n && n.parent && (n === this.currentNode && (this.currentNode = null), n.parent.removeChild(n));
    }
    append(t, n) {
      const o = go(n) ? this.root : this.getNode(n);
      o && o.insertChild({ data: t });
    }
    _initDefaultCheckedNodes() {
      const t = this.defaultCheckedKeys || [], n = this.nodesMap;
      t.forEach((o) => {
        const l = n[o];
        l && l.setChecked(!0, !this.checkStrictly);
      });
    }
    _initDefaultCheckedNode(t) {
      const n = this.defaultCheckedKeys || [];
      !cn(t.key) && n.includes(t.key) && t.setChecked(!0, !this.checkStrictly);
    }
    setDefaultCheckedKey(t) {
      t !== this.defaultCheckedKeys && (this.defaultCheckedKeys = t, this._initDefaultCheckedNodes());
    }
    registerNode(t) {
      const n = this.key;
      if (!(!t || !t.data))
        if (!n)
          this.nodesMap[t.id] = t;
        else {
          const o = t.key;
          cn(o) || (this.nodesMap[o] = t);
        }
    }
    deregisterNode(t) {
      !this.key || !t || !t.data || (t.childNodes.forEach((o) => {
        this.deregisterNode(o);
      }), delete this.nodesMap[t.key]);
    }
    getCheckedNodes(t = !1, n = !1) {
      const o = [], l = function(a) {
        (a.root ? a.root.childNodes : a.childNodes).forEach((i) => {
          (i.checked || n && i.indeterminate) && (!t || t && i.isLeaf) && o.push(i.data), l(i);
        });
      };
      return l(this), o;
    }
    getCheckedKeys(t = !1) {
      return this.getCheckedNodes(t).map((n) => (n || {})[this.key]);
    }
    getHalfCheckedNodes() {
      const t = [], n = function(o) {
        (o.root ? o.root.childNodes : o.childNodes).forEach((a) => {
          a.indeterminate && t.push(a.data), n(a);
        });
      };
      return n(this), t;
    }
    getHalfCheckedKeys() {
      return this.getHalfCheckedNodes().map((t) => (t || {})[this.key]);
    }
    _getAllNodes() {
      const t = [], n = this.nodesMap;
      for (const o in n)
        Ot(n, o) && t.push(n[o]);
      return t;
    }
    updateChildren(t, n) {
      const o = this.nodesMap[t];
      if (!o)
        return;
      const l = o.childNodes;
      for (let a = l.length - 1; a >= 0; a--) {
        const r = l[a];
        this.remove(r.data);
      }
      for (let a = 0, r = n.length; a < r; a++) {
        const i = n[a];
        this.append(i, o.data);
      }
    }
    _setCheckedKeys(t, n = !1, o) {
      const l = this._getAllNodes().sort((u, c) => u.level - c.level), a = /* @__PURE__ */ Object.create(null), r = Object.keys(o);
      l.forEach((u) => u.setChecked(!1, !1));
      const i = (u) => {
        u.childNodes.forEach((c) => {
          var d;
          a[c.data[t]] = !0, (d = c.childNodes) != null && d.length && i(c);
        });
      };
      for (let u = 0, c = l.length; u < c; u++) {
        const d = l[u], f = d.data[t].toString();
        if (!r.includes(f)) {
          d.checked && !a[f] && d.setChecked(!1, !1);
          continue;
        }
        if (d.childNodes.length && i(d), d.isLeaf || this.checkStrictly) {
          d.setChecked(!0, !1);
          continue;
        }
        if (d.setChecked(!0, !0), n) {
          d.setChecked(!1, !1);
          const p = function(m) {
            m.childNodes.forEach((g) => {
              g.isLeaf || g.setChecked(!1, !1), p(g);
            });
          };
          p(d);
        }
      }
    }
    setCheckedNodes(t, n = !1) {
      const o = this.key, l = {};
      t.forEach((a) => {
        l[(a || {})[o]] = !0;
      }), this._setCheckedKeys(o, n, l);
    }
    setCheckedKeys(t, n = !1) {
      this.defaultCheckedKeys = t;
      const o = this.key, l = {};
      t.forEach((a) => {
        l[a] = !0;
      }), this._setCheckedKeys(o, n, l);
    }
    setDefaultExpandedKeys(t) {
      t = t || [], this.defaultExpandedKeys = t, t.forEach((n) => {
        const o = this.getNode(n);
        o && o.expand(null, this.autoExpandParent);
      });
    }
    setChecked(t, n, o) {
      const l = this.getNode(t);
      l && l.setChecked(!!n, o);
    }
    getCurrentNode() {
      return this.currentNode;
    }
    setCurrentNode(t) {
      const n = this.currentNode;
      n && (n.isCurrent = !1), this.currentNode = t, this.currentNode.isCurrent = !0;
    }
    setUserCurrentNode(t, n = !0) {
      var o;
      const l = t[this.key], a = this.nodesMap[l];
      this.setCurrentNode(a), n && this.currentNode && this.currentNode.level > 1 && ((o = this.currentNode.parent) == null || o.expand(null, !0));
    }
    setCurrentNodeKey(t, n = !0) {
      var o;
      if (this.currentNodeKey = t, go(t)) {
        this.currentNode && (this.currentNode.isCurrent = !1), this.currentNode = null;
        return;
      }
      const l = this.getNode(t);
      l && (this.setCurrentNode(l), n && this.currentNode && this.currentNode.level > 1 && ((o = this.currentNode.parent) == null || o.expand(null, !0)));
    }
  }
  const gm = "RootTree", Xk = "NodeInstance", l0 = "TreeNodeMap", nY = /* @__PURE__ */ U({
    name: "ElTreeNodeContent",
    props: {
      node: {
        type: Object,
        required: !0
      },
      renderContent: Function
    },
    setup(e) {
      const t = he("tree"), n = Ve(Xk), o = Ve(gm);
      return () => {
        const l = e.node, { data: a, store: r } = l;
        return e.renderContent ? e.renderContent(qe, { _self: n, node: l, data: a, store: r }) : ee(o.ctx.slots, "default", { node: l, data: a }, () => [
          qe(hm, { tag: "span", truncated: !0, class: t.be("node", "label") }, () => [l.label])
        ]);
      };
    }
  });
  var oY = /* @__PURE__ */ Ne(nY, [["__file", "tree-node-content.vue"]]);
  function Jk(e) {
    const t = Ve(l0, null), n = {
      treeNodeExpand: (o) => {
        var l;
        e.node !== o && ((l = e.node) == null || l.collapse());
      },
      children: []
    };
    return t && t.children.push(n), yt(l0, n), {
      broadcastExpanded: (o) => {
        if (e.accordion)
          for (const l of n.children)
            l.treeNodeExpand(o);
      }
    };
  }
  const Zk = Symbol("dragEvents");
  function lY({
    props: e,
    ctx: t,
    el$: n,
    dropIndicator$: o,
    store: l
  }) {
    const a = he("tree"), r = A({
      showDropIndicator: !1,
      draggingNode: null,
      dropNode: null,
      allowDrop: !0,
      dropType: null
    });
    return yt(Zk, {
      treeNodeDragStart: ({ event: d, treeNode: f }) => {
        if (d.dataTransfer) {
          if (Fe(e.allowDrag) && !e.allowDrag(f.node))
            return d.preventDefault(), !1;
          d.dataTransfer.effectAllowed = "move";
          try {
            d.dataTransfer.setData("text/plain", "");
          } catch {
          }
          r.value.draggingNode = f, t.emit("node-drag-start", f.node, d);
        }
      },
      treeNodeDragOver: ({ event: d, treeNode: f }) => {
        if (!d.dataTransfer)
          return;
        const v = f, p = r.value.dropNode;
        p && p.node.id !== v.node.id && jn(p.$el, a.is("drop-inner"));
        const m = r.value.draggingNode;
        if (!m || !v)
          return;
        let h = !0, g = !0, b = !0, C = !0;
        Fe(e.allowDrop) && (h = e.allowDrop(m.node, v.node, "prev"), C = g = e.allowDrop(m.node, v.node, "inner"), b = e.allowDrop(m.node, v.node, "next")), d.dataTransfer.dropEffect = g || h || b ? "move" : "none", (h || g || b) && (p == null ? void 0 : p.node.id) !== v.node.id && (p && t.emit("node-drag-leave", m.node, p.node, d), t.emit("node-drag-enter", m.node, v.node, d)), h || g || b ? r.value.dropNode = v : r.value.dropNode = null, v.node.nextSibling === m.node && (b = !1), v.node.previousSibling === m.node && (h = !1), v.node.contains(m.node, !1) && (g = !1), (m.node === v.node || m.node.contains(v.node)) && (h = !1, g = !1, b = !1);
        const w = v.$el, y = w.querySelector(`.${a.be("node", "content")}`).getBoundingClientRect(), E = n.value.getBoundingClientRect(), k = n.value.scrollTop;
        let T;
        const x = h ? g ? 0.25 : b ? 0.45 : 1 : Number.NEGATIVE_INFINITY, I = b ? g ? 0.75 : h ? 0.55 : 0 : Number.POSITIVE_INFINITY;
        let P = -9999;
        const O = d.clientY - y.top;
        O < y.height * x ? T = "before" : O > y.height * I ? T = "after" : g ? T = "inner" : T = "none";
        const N = w.querySelector(`.${a.be("node", "expand-icon")}`).getBoundingClientRect(), z = o.value;
        T === "before" ? P = N.top - E.top + k : T === "after" && (P = N.bottom - E.top + k), z.style.top = `${P}px`, z.style.left = `${N.right - E.left}px`, T === "inner" ? _o(w, a.is("drop-inner")) : jn(w, a.is("drop-inner")), r.value.showDropIndicator = T === "before" || T === "after", r.value.allowDrop = r.value.showDropIndicator || C, r.value.dropType = T, t.emit("node-drag-over", m.node, v.node, d);
      },
      treeNodeDragEnd: (d) => {
        var f, v;
        const { draggingNode: p, dropType: m, dropNode: h } = r.value;
        if (d.preventDefault(), d.dataTransfer && (d.dataTransfer.dropEffect = "move"), p != null && p.node.data && h) {
          const g = { data: p.node.data };
          m !== "none" && p.node.remove(), m === "before" ? (f = h.node.parent) == null || f.insertBefore(g, h.node) : m === "after" ? (v = h.node.parent) == null || v.insertAfter(g, h.node) : m === "inner" && h.node.insertChild(g), m !== "none" && (l.value.registerNode(g), l.value.key && p.node.eachNode((b) => {
            var C;
            (C = l.value.nodesMap[b.data[l.value.key]]) == null || C.setChecked(b.checked, !l.value.checkStrictly);
          })), jn(h.$el, a.is("drop-inner")), t.emit("node-drag-end", p.node, h.node, m, d), m !== "none" && t.emit("node-drop", p.node, h.node, m, d);
        }
        p && !h && t.emit("node-drag-end", p.node, null, m, d), r.value.showDropIndicator = !1, r.value.draggingNode = null, r.value.dropNode = null, r.value.allowDrop = !0;
      }
    }), {
      dragState: r
    };
  }
  const aY = /* @__PURE__ */ U({
    name: "ElTreeNode",
    components: {
      ElCollapseTransition: Hd,
      ElCheckbox: xo,
      NodeContent: oY,
      ElIcon: ze,
      Loading: Cl
    },
    props: {
      node: {
        type: dv,
        default: () => ({})
      },
      props: {
        type: Object,
        default: () => ({})
      },
      accordion: Boolean,
      renderContent: Function,
      renderAfterExpand: Boolean,
      showCheckbox: Boolean
    },
    emits: ["node-expand"],
    setup(e, t) {
      const n = he("tree"), { broadcastExpanded: o } = Jk(e), l = Ve(gm), a = A(!1), r = A(!1), i = A(), u = A(), c = A(), d = Ve(Zk), f = dt();
      yt(Xk, f), l || vt("Tree", "Can not find node's tree."), e.node.expanded && (a.value = !0, r.value = !0);
      const v = l.props.props.children || "children";
      de(() => {
        var I;
        const P = (I = e.node.data) == null ? void 0 : I[v];
        return P && [...P];
      }, () => {
        e.node.updateChildren();
      }), de(() => e.node.indeterminate, (I) => {
        h(e.node.checked, I);
      }), de(() => e.node.checked, (I) => {
        h(I, e.node.indeterminate);
      }), de(() => e.node.childNodes.length, () => e.node.reInitChecked()), de(() => e.node.expanded, (I) => {
        Re(() => a.value = I), I && (r.value = !0);
      });
      const p = (I) => mm(l.props.nodeKey, I.data), m = (I) => {
        const P = e.props.class;
        if (!P)
          return {};
        let O;
        if (Fe(P)) {
          const { data: N } = I;
          O = P(N, I);
        } else
          O = P;
        return Ae(O) ? { [O]: !0 } : O;
      }, h = (I, P) => {
        (i.value !== I || u.value !== P) && l.ctx.emit("check-change", e.node.data, I, P), i.value = I, u.value = P;
      }, g = (I) => {
        iv(l.store, l.ctx.emit, () => {
          var P;
          if ((P = l == null ? void 0 : l.props) == null ? void 0 : P.nodeKey) {
            const N = p(e.node);
            l.store.value.setCurrentNodeKey(N);
          } else
            l.store.value.setCurrentNode(e.node);
        }), l.currentNode.value = e.node, l.props.expandOnClickNode && C(), (l.props.checkOnClickNode || e.node.isLeaf && l.props.checkOnClickLeaf && e.showCheckbox) && !e.node.disabled && w(!e.node.checked), l.ctx.emit("node-click", e.node.data, e.node, f, I);
      }, b = (I) => {
        var P;
        (P = l.instance.vnode.props) != null && P.onNodeContextmenu && (I.stopPropagation(), I.preventDefault()), l.ctx.emit("node-contextmenu", I, e.node.data, e.node, f);
      }, C = () => {
        e.node.isLeaf || (a.value ? (l.ctx.emit("node-collapse", e.node.data, e.node, f), e.node.collapse()) : e.node.expand(() => {
          t.emit("node-expand", e.node.data, e.node, f);
        }));
      }, w = (I) => {
        e.node.setChecked(I, !(l != null && l.props.checkStrictly)), Re(() => {
          const P = l.store.value;
          l.ctx.emit("check", e.node.data, {
            checkedNodes: P.getCheckedNodes(),
            checkedKeys: P.getCheckedKeys(),
            halfCheckedNodes: P.getHalfCheckedNodes(),
            halfCheckedKeys: P.getHalfCheckedKeys()
          });
        });
      };
      return {
        ns: n,
        node$: c,
        tree: l,
        expanded: a,
        childNodeRendered: r,
        oldChecked: i,
        oldIndeterminate: u,
        getNodeKey: p,
        getNodeClass: m,
        handleSelectChange: h,
        handleClick: g,
        handleContextMenu: b,
        handleExpandIconClick: C,
        handleCheckChange: w,
        handleChildNodeExpand: (I, P, O) => {
          o(P), l.ctx.emit("node-expand", I, P, O);
        },
        handleDragStart: (I) => {
          l.props.draggable && d.treeNodeDragStart({ event: I, treeNode: e });
        },
        handleDragOver: (I) => {
          I.preventDefault(), l.props.draggable && d.treeNodeDragOver({
            event: I,
            treeNode: { $el: c.value, node: e.node }
          });
        },
        handleDrop: (I) => {
          I.preventDefault();
        },
        handleDragEnd: (I) => {
          l.props.draggable && d.treeNodeDragEnd(I);
        },
        CaretRight: gC
      };
    }
  });
  function rY(e, t, n, o, l, a) {
    const r = $t("el-icon"), i = $t("el-checkbox"), u = $t("loading"), c = $t("node-content"), d = $t("el-tree-node"), f = $t("el-collapse-transition");
    return it((_(), B("div", {
      ref: "node$",
      class: $([
        e.ns.b("node"),
        e.ns.is("expanded", e.expanded),
        e.ns.is("current", e.node.isCurrent),
        e.ns.is("hidden", !e.node.visible),
        e.ns.is("focusable", !e.node.disabled),
        e.ns.is("checked", !e.node.disabled && e.node.checked),
        e.getNodeClass(e.node)
      ]),
      role: "treeitem",
      tabindex: "-1",
      "aria-expanded": e.expanded,
      "aria-disabled": e.node.disabled,
      "aria-checked": e.node.checked,
      draggable: e.tree.props.draggable,
      "data-key": e.getNodeKey(e.node),
      onClick: Ze(e.handleClick, ["stop"]),
      onContextmenu: e.handleContextMenu,
      onDragstart: Ze(e.handleDragStart, ["stop"]),
      onDragover: Ze(e.handleDragOver, ["stop"]),
      onDragend: Ze(e.handleDragEnd, ["stop"]),
      onDrop: Ze(e.handleDrop, ["stop"])
    }, [
      W("div", {
        class: $(e.ns.be("node", "content")),
        style: Ue({ paddingLeft: (e.node.level - 1) * e.tree.props.indent + "px" })
      }, [
        e.tree.props.icon || e.CaretRight ? (_(), ae(r, {
          key: 0,
          class: $([
            e.ns.be("node", "expand-icon"),
            e.ns.is("leaf", e.node.isLeaf),
            {
              expanded: !e.node.isLeaf && e.expanded
            }
          ]),
          onClick: Ze(e.handleExpandIconClick, ["stop"])
        }, {
          default: Q(() => [
            (_(), ae(ct(e.tree.props.icon || e.CaretRight)))
          ]),
          _: 1
        }, 8, ["class", "onClick"])) : oe("v-if", !0),
        e.showCheckbox ? (_(), ae(i, {
          key: 1,
          "model-value": e.node.checked,
          indeterminate: e.node.indeterminate,
          disabled: !!e.node.disabled,
          onClick: Ze(() => {
          }, ["stop"]),
          onChange: e.handleCheckChange
        }, null, 8, ["model-value", "indeterminate", "disabled", "onClick", "onChange"])) : oe("v-if", !0),
        e.node.loading ? (_(), ae(r, {
          key: 2,
          class: $([e.ns.be("node", "loading-icon"), e.ns.is("loading")])
        }, {
          default: Q(() => [
            q(u)
          ]),
          _: 1
        }, 8, ["class"])) : oe("v-if", !0),
        q(c, {
          node: e.node,
          "render-content": e.renderContent
        }, null, 8, ["node", "render-content"])
      ], 6),
      q(f, null, {
        default: Q(() => [
          !e.renderAfterExpand || e.childNodeRendered ? it((_(), B("div", {
            key: 0,
            class: $(e.ns.be("node", "children")),
            role: "group",
            "aria-expanded": e.expanded,
            onClick: Ze(() => {
            }, ["stop"])
          }, [
            (_(!0), B(We, null, bt(e.node.childNodes, (v) => (_(), ae(d, {
              key: e.getNodeKey(v),
              "render-content": e.renderContent,
              "render-after-expand": e.renderAfterExpand,
              "show-checkbox": e.showCheckbox,
              node: v,
              accordion: e.accordion,
              props: e.props,
              onNodeExpand: e.handleChildNodeExpand
            }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))), 128))
          ], 10, ["aria-expanded", "onClick"])), [
            [Mt, e.expanded]
          ]) : oe("v-if", !0)
        ]),
        _: 1
      })
    ], 42, ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key", "onClick", "onContextmenu", "onDragstart", "onDragover", "onDragend", "onDrop"])), [
      [Mt, e.node.visible]
    ]);
  }
  var sY = /* @__PURE__ */ Ne(aY, [["render", rY], ["__file", "tree-node.vue"]]);
  function iY({ el$: e }, t) {
    const n = he("tree");
    ft(() => {
      a();
    }), Qo(() => {
      Array.from(e.value.querySelectorAll("input[type=checkbox]")).forEach((i) => {
        i.setAttribute("tabindex", "-1");
      });
    });
    function o(r, i) {
      var u, c;
      const d = t.value.getNode(r[i].dataset.key);
      return d.canFocus && d.visible && (((u = d.parent) == null ? void 0 : u.expanded) || ((c = d.parent) == null ? void 0 : c.level) === 0);
    }
    Dt(e, "keydown", (r) => {
      const i = r.target;
      if (!i.className.includes(n.b("node")))
        return;
      const u = Ht(r), c = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`)), d = c.indexOf(i);
      let f;
      if ([_e.up, _e.down].includes(u)) {
        if (r.preventDefault(), u === _e.up) {
          f = d === -1 ? 0 : d !== 0 ? d - 1 : c.length - 1;
          const p = f;
          for (; !o(c, f); ) {
            if (f--, f === p) {
              f = -1;
              break;
            }
            f < 0 && (f = c.length - 1);
          }
        } else {
          f = d === -1 ? 0 : d < c.length - 1 ? d + 1 : 0;
          const p = f;
          for (; !o(c, f); ) {
            if (f++, f === p) {
              f = -1;
              break;
            }
            f >= c.length && (f = 0);
          }
        }
        f !== -1 && c[f].focus();
      }
      [_e.left, _e.right].includes(u) && (r.preventDefault(), i.click());
      const v = i.querySelector('[type="checkbox"]');
      [_e.enter, _e.numpadEnter, _e.space].includes(u) && v && (r.preventDefault(), v.click());
    });
    const a = () => {
      var r;
      if (!e.value)
        return;
      const i = Array.from(e.value.querySelectorAll(`.${n.is("focusable")}[role=treeitem]`));
      Array.from(e.value.querySelectorAll("input[type=checkbox]")).forEach((d) => {
        d.setAttribute("tabindex", "-1");
      });
      const c = e.value.querySelectorAll(`.${n.is("checked")}[role=treeitem]`);
      if (c.length) {
        c[0].setAttribute("tabindex", "0");
        return;
      }
      (r = i[0]) == null || r.setAttribute("tabindex", "0");
    };
  }
  const uY = {
    "check-change": (e, t, n) => e && Vt(t) && Vt(n),
    "current-change": (e, t) => !0,
    "node-click": (e, t, n, o) => e && t && o instanceof Event,
    "node-contextmenu": (e, t, n, o) => e instanceof Event && t && n,
    "node-collapse": (e, t, n) => e && t,
    "node-expand": (e, t, n) => e && t,
    check: (e, t) => e && t,
    "node-drag-start": (e, t) => e && t,
    "node-drag-end": (e, t, n, o) => e && o,
    "node-drop": (e, t, n, o) => e && t && o,
    "node-drag-leave": (e, t, n) => e && t && n,
    "node-drag-enter": (e, t, n) => e && t && n,
    "node-drag-over": (e, t, n) => e && t && n
  }, cY = /* @__PURE__ */ U({
    name: "ElTree",
    components: { ElTreeNode: sY },
    props: {
      data: {
        type: X(Array),
        default: () => []
      },
      emptyText: {
        type: String
      },
      renderAfterExpand: {
        type: Boolean,
        default: !0
      },
      nodeKey: String,
      checkStrictly: Boolean,
      defaultExpandAll: Boolean,
      expandOnClickNode: {
        type: Boolean,
        default: !0
      },
      checkOnClickNode: Boolean,
      checkOnClickLeaf: {
        type: Boolean,
        default: !0
      },
      checkDescendants: Boolean,
      autoExpandParent: {
        type: Boolean,
        default: !0
      },
      defaultCheckedKeys: Array,
      defaultExpandedKeys: Array,
      currentNodeKey: [String, Number],
      renderContent: {
        type: X(Function)
      },
      showCheckbox: Boolean,
      draggable: Boolean,
      allowDrag: {
        type: X(Function)
      },
      allowDrop: {
        type: X(Function)
      },
      props: {
        type: Object,
        default: () => ({
          children: "children",
          label: "label",
          disabled: "disabled"
        })
      },
      lazy: Boolean,
      highlightCurrent: Boolean,
      load: Function,
      filterNodeMethod: Function,
      accordion: Boolean,
      indent: {
        type: Number,
        default: 18
      },
      icon: {
        type: Lt
      }
    },
    emits: uY,
    setup(e, t) {
      const { t: n } = _t(), o = he("tree"), l = A(new tY({
        key: e.nodeKey,
        data: e.data,
        lazy: e.lazy,
        props: e.props,
        load: e.load,
        currentNodeKey: e.currentNodeKey,
        checkStrictly: e.checkStrictly,
        checkDescendants: e.checkDescendants,
        defaultCheckedKeys: e.defaultCheckedKeys,
        defaultExpandedKeys: e.defaultExpandedKeys,
        autoExpandParent: e.autoExpandParent,
        defaultExpandAll: e.defaultExpandAll,
        filterNodeMethod: e.filterNodeMethod
      }));
      l.value.initialize();
      const a = A(l.value.root), r = A(null), i = A(null), u = A(null), { broadcastExpanded: c } = Jk(e), { dragState: d } = lY({
        props: e,
        ctx: t,
        el$: i,
        dropIndicator$: u,
        store: l
      });
      iY({ el$: i }, l);
      const f = dt(), v = S(() => {
        let V = f == null ? void 0 : f.parent;
        for (; V; ) {
          if (V.type.name === "ElTreeSelect")
            return !0;
          V = V.parent;
        }
        return !1;
      }), p = S(() => {
        const { childNodes: V } = a.value;
        return (!V || V.length === 0 || V.every(({ visible: F }) => !F)) && !v.value;
      });
      de(() => e.currentNodeKey, (V) => {
        l.value.setCurrentNodeKey(V ?? null);
      }), de(() => e.defaultCheckedKeys, (V, F) => {
        ln(V, F) || l.value.setDefaultCheckedKey(V ?? []);
      }), de(() => e.defaultExpandedKeys, (V) => {
        l.value.setDefaultExpandedKeys(V ?? []);
      }), de(() => e.data, (V) => {
        l.value.setData(V);
      }, { deep: !0 }), de(() => e.checkStrictly, (V) => {
        l.value.checkStrictly = V;
      });
      const m = (V) => {
        if (!e.filterNodeMethod)
          throw new Error("[Tree] filterNodeMethod is required when filter");
        l.value.filter(V);
      }, h = (V) => mm(e.nodeKey, V.data), g = (V) => {
        if (!e.nodeKey)
          throw new Error(`[Tree] nodeKey is required in ${V}`);
      }, b = (V) => {
        g("getNodePath");
        const F = l.value.getNode(V);
        if (!F)
          return [];
        const H = [F.data];
        let K = F.parent;
        for (; K && K !== a.value; )
          H.push(K.data), K = K.parent;
        return H.reverse();
      }, C = (V, F) => l.value.getCheckedNodes(V, F), w = (V) => l.value.getCheckedKeys(V), y = () => {
        const V = l.value.getCurrentNode();
        return V ? V.data : null;
      }, E = () => {
        g("getCurrentKey");
        const V = y();
        return V ? V[e.nodeKey] : null;
      }, k = (V, F) => {
        g("setCheckedNodes"), l.value.setCheckedNodes(V, F);
      }, T = (V, F) => {
        g("setCheckedKeys"), l.value.setCheckedKeys(V, F);
      }, x = (V, F, H) => {
        l.value.setChecked(V, F, H);
      }, I = () => l.value.getHalfCheckedNodes(), P = () => l.value.getHalfCheckedKeys(), O = (V, F = !0) => {
        g("setCurrentNode"), iv(l, t.emit, () => {
          c(V), l.value.setUserCurrentNode(V, F);
        });
      }, N = (V = null, F = !0) => {
        g("setCurrentKey"), iv(l, t.emit, () => {
          c(), l.value.setCurrentNodeKey(V, F);
        });
      }, z = (V) => l.value.getNode(V), Y = (V) => {
        l.value.remove(V);
      }, G = (V, F) => {
        l.value.append(V, F);
      }, M = (V, F) => {
        l.value.insertBefore(V, F);
      }, R = (V, F) => {
        l.value.insertAfter(V, F);
      }, D = (V, F, H) => {
        c(F), t.emit("node-expand", V, F, H);
      }, L = (V, F) => {
        g("updateKeyChild"), l.value.updateChildren(V, F);
      };
      return yt(gm, {
        ctx: t,
        props: e,
        store: l,
        root: a,
        currentNode: r,
        instance: f
      }), yt(Sl, void 0), {
        ns: o,
        store: l,
        root: a,
        currentNode: r,
        dragState: d,
        el$: i,
        dropIndicator$: u,
        isEmpty: p,
        filter: m,
        getNodeKey: h,
        getNodePath: b,
        getCheckedNodes: C,
        getCheckedKeys: w,
        getCurrentNode: y,
        getCurrentKey: E,
        setCheckedNodes: k,
        setCheckedKeys: T,
        setChecked: x,
        getHalfCheckedNodes: I,
        getHalfCheckedKeys: P,
        setCurrentNode: O,
        setCurrentKey: N,
        t: n,
        getNode: z,
        remove: Y,
        append: G,
        insertBefore: M,
        insertAfter: R,
        handleNodeExpand: D,
        updateKeyChildren: L
      };
    }
  });
  function dY(e, t, n, o, l, a) {
    const r = $t("el-tree-node");
    return _(), B("div", {
      ref: "el$",
      class: $([
        e.ns.b(),
        e.ns.is("dragging", !!e.dragState.draggingNode),
        e.ns.is("drop-not-allow", !e.dragState.allowDrop),
        e.ns.is("drop-inner", e.dragState.dropType === "inner"),
        { [e.ns.m("highlight-current")]: e.highlightCurrent }
      ]),
      role: "tree"
    }, [
      (_(!0), B(We, null, bt(e.root.childNodes, (i) => (_(), ae(r, {
        key: e.getNodeKey(i),
        node: i,
        props: e.props,
        accordion: e.accordion,
        "render-after-expand": e.renderAfterExpand,
        "show-checkbox": e.showCheckbox,
        "render-content": e.renderContent,
        onNodeExpand: e.handleNodeExpand
      }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))), 128)),
      e.isEmpty ? (_(), B("div", {
        key: 0,
        class: $(e.ns.e("empty-block"))
      }, [
        ee(e.$slots, "empty", {}, () => {
          var i;
          return [
            W("span", {
              class: $(e.ns.e("empty-text"))
            }, ke((i = e.emptyText) != null ? i : e.t("el.tree.emptyText")), 3)
          ];
        })
      ], 2)) : oe("v-if", !0),
      it(W("div", {
        ref: "dropIndicator$",
        class: $(e.ns.e("drop-indicator"))
      }, null, 2), [
        [Mt, e.dragState.showDropIndicator]
      ])
    ], 2);
  }
  var fY = /* @__PURE__ */ Ne(cY, [["render", dY], ["__file", "tree.vue"]]);
  const od = rt(fY), pY = (e, { attrs: t, emit: n }, {
    select: o,
    tree: l,
    key: a
  }) => {
    const r = he("tree-select");
    de(() => e.data, () => {
      e.filterable && Re(() => {
        var c, d;
        (d = l.value) == null || d.filter((c = o.value) == null ? void 0 : c.states.inputValue);
      });
    }, { flush: "post" });
    const i = (c) => {
      var d;
      const f = c.at(-1);
      if (f.expanded && f.childNodes.at(-1))
        i([f.childNodes.at(-1)]);
      else {
        const v = (d = l.value.el$) == null ? void 0 : d.querySelector(`[data-key="${c.at(-1).key}"]`);
        v == null || v.focus({ preventScroll: !0 });
        return;
      }
    };
    return ft(() => {
      Dt(() => {
        var c;
        return (c = o.value) == null ? void 0 : c.$el;
      }, "keydown", async (c) => {
        const d = Ht(c), { dropdownMenuVisible: f } = o.value;
        [_e.down, _e.up].includes(d) && f && (await Re(), setTimeout(() => {
          var v, p, m;
          if (_e.up === d) {
            const h = l.value.store.root.childNodes;
            i(h);
            return;
          }
          (m = (p = (v = o.value.optionsArray[o.value.states.hoveringIndex].$el) == null ? void 0 : v.parentNode) == null ? void 0 : p.parentNode) == null || m.focus({ preventScroll: !0 });
        }));
      }, {
        capture: !0
      });
    }), {
      ...jl(wn(e), Object.keys(fr.props)),
      ...t,
      class: S(() => t.class),
      style: S(() => t.style),
      "onUpdate:modelValue": (c) => n(et, c),
      valueKey: a,
      popperClass: S(() => {
        const c = [r.e("popper")];
        return e.popperClass && c.push(e.popperClass), c.join(" ");
      }),
      filterMethod: (c = "") => {
        var d;
        e.filterMethod ? e.filterMethod(c) : e.remoteMethod ? e.remoteMethod(c) : (d = l.value) == null || d.filter(c);
      }
    };
  }, vY = /* @__PURE__ */ U({
    extends: qc,
    setup(e, t) {
      const n = qc.setup(e, t);
      delete n.selectOptionClick;
      const o = dt().proxy;
      return Re(() => {
        n.select.states.cachedOptions.get(o.value) || n.select.onOptionCreate(o);
      }), de(() => t.attrs.visible, (l) => {
        Re(() => {
          n.states.visible = l;
        });
      }, {
        immediate: !0
      }), n;
    },
    methods: {
      selectOptionClick() {
        this.$el.parentElement.click();
      }
    }
  });
  function fv(e) {
    return e || e === 0;
  }
  function bm(e) {
    return ye(e) && e.length;
  }
  function xr(e) {
    return ye(e) ? e : fv(e) ? [e] : [];
  }
  function hc(e, t, n, o, l) {
    for (let a = 0; a < e.length; a++) {
      const r = e[a];
      if (t(r, a, e, l))
        return o ? o(r, a, e, l) : r;
      {
        const i = n(r);
        if (bm(i)) {
          const u = hc(i, t, n, o, r);
          if (u)
            return u;
        }
      }
    }
  }
  function mc(e, t, n, o) {
    for (let l = 0; l < e.length; l++) {
      const a = e[l];
      t(a, l, e, o);
      const r = n(a);
      bm(r) && mc(r, t, n, a);
    }
  }
  const hY = (e, { attrs: t, slots: n, emit: o }, {
    select: l,
    tree: a,
    key: r
  }) => {
    de([() => e.modelValue, a], () => {
      e.showCheckbox && Re(() => {
        const v = a.value;
        v && !ln(v.getCheckedKeys(), xr(e.modelValue)) && v.setCheckedKeys(xr(e.modelValue));
      });
    }, {
      immediate: !0,
      deep: !0
    });
    const i = S(() => ({
      value: r.value,
      label: "label",
      children: "children",
      disabled: "disabled",
      isLeaf: "isLeaf",
      ...e.props
    })), u = (v, p) => {
      var m;
      const h = i.value[v];
      return Fe(h) ? h(p, (m = a.value) == null ? void 0 : m.getNode(u("value", p))) : p[h];
    }, c = xr(e.modelValue).map((v) => hc(e.data || [], (p) => u("value", p) === v, (p) => u("children", p), (p, m, h, g) => g && u("value", g))).filter((v) => fv(v)), d = S(() => {
      if (!e.renderAfterExpand && !e.lazy)
        return [];
      const v = [];
      return mc(e.data.concat(e.cacheData), (p) => {
        const m = u("value", p);
        v.push({
          value: m,
          currentLabel: u("label", p),
          isDisabled: u("disabled", p)
        });
      }, (p) => u("children", p)), v;
    }), f = () => {
      var v;
      return (v = a.value) == null ? void 0 : v.getCheckedKeys().filter((p) => {
        var m;
        const h = (m = a.value) == null ? void 0 : m.getNode(p);
        return !cn(h) && Zn(h.childNodes);
      });
    };
    return {
      ...jl(wn(e), Object.keys(od.props)),
      ...t,
      nodeKey: r,
      expandOnClickNode: S(() => !e.checkStrictly && e.expandOnClickNode),
      defaultExpandedKeys: S(() => e.defaultExpandedKeys ? e.defaultExpandedKeys.concat(c) : c),
      renderContent: (v, { node: p, data: m, store: h }) => v(vY, {
        value: u("value", m),
        label: u("label", m),
        disabled: u("disabled", m),
        visible: p.visible
      }, e.renderContent ? () => e.renderContent(v, { node: p, data: m, store: h }) : n.default ? () => n.default({ node: p, data: m, store: h }) : void 0),
      filterNodeMethod: (v, p, m) => e.filterNodeMethod ? e.filterNodeMethod(v, p, m) : v ? new RegExp(Xh(v), "i").test(u("label", p) || "") : !0,
      onNodeClick: (v, p, m) => {
        var h, g, b;
        if ((h = t.onNodeClick) == null || h.call(t, v, p, m), !(e.showCheckbox && e.checkOnClickNode))
          if (!e.showCheckbox && (e.checkStrictly || p.isLeaf)) {
            if (!u("disabled", v)) {
              const C = (g = l.value) == null ? void 0 : g.states.options.get(u("value", v));
              (b = l.value) == null || b.handleOptionSelect(C);
            }
          } else e.expandOnClickNode && m.proxy.handleExpandIconClick();
      },
      onCheck: (v, p) => {
        var m;
        if (!e.showCheckbox)
          return;
        const h = u("value", v), g = {};
        mc([a.value.store.root], (y) => g[y.key] = y, (y) => y.childNodes);
        const b = p.checkedKeys, C = e.multiple ? xr(e.modelValue).filter((y) => !(y in g) && !b.includes(y)) : [], w = C.concat(b);
        if (e.checkStrictly)
          o(et, e.multiple ? w : w.includes(h) ? h : void 0);
        else if (e.multiple) {
          const y = f();
          o(et, C.concat(y));
        } else {
          const y = hc([v], (T) => !bm(u("children", T)) && !u("disabled", T), (T) => u("children", T)), E = y ? u("value", y) : void 0, k = fv(e.modelValue) && !!hc([v], (T) => u("value", T) === e.modelValue, (T) => u("children", T));
          o(et, E === e.modelValue || k ? void 0 : E);
        }
        Re(() => {
          var y;
          const E = xr(e.modelValue);
          a.value.setCheckedKeys(E), (y = t.onCheck) == null || y.call(t, v, {
            checkedKeys: a.value.getCheckedKeys(),
            checkedNodes: a.value.getCheckedNodes(),
            halfCheckedKeys: a.value.getHalfCheckedKeys(),
            halfCheckedNodes: a.value.getHalfCheckedNodes()
          });
        }), (m = l.value) == null || m.focus();
      },
      onNodeExpand: (v, p, m) => {
        var h;
        (h = t.onNodeExpand) == null || h.call(t, v, p, m), Re(() => {
          if (!e.checkStrictly && e.lazy && e.multiple && p.checked) {
            const g = {}, b = a.value.getCheckedKeys();
            mc([a.value.store.root], (y) => g[y.key] = y, (y) => y.childNodes);
            const C = xr(e.modelValue).filter((y) => !(y in g) && !b.includes(y)), w = f();
            o(et, C.concat(w));
          }
        });
      },
      cacheOptions: d
    };
  };
  var mY = /* @__PURE__ */ U({
    props: {
      data: {
        type: Array,
        default: () => []
      }
    },
    setup(e) {
      const t = Ve(pu);
      return de(() => e.data, () => {
        var n;
        e.data.forEach((l) => {
          t.states.cachedOptions.has(l.value) || t.states.cachedOptions.set(l.value, l);
        });
        const o = ((n = t.selectRef) == null ? void 0 : n.querySelectorAll("input")) || [];
        xt && !Array.from(o).includes(document.activeElement) && t.setSelected();
      }, { flush: "post", immediate: !0 }), () => {
      };
    }
  });
  const gY = /* @__PURE__ */ U({
    name: "ElTreeSelect",
    inheritAttrs: !1,
    props: {
      ...fr.props,
      ...od.props,
      cacheData: {
        type: Array,
        default: () => []
      }
    },
    setup(e, t) {
      const { slots: n, expose: o } = t, l = A(), a = A(), r = S(() => e.nodeKey || e.valueKey || "value"), i = pY(e, t, { select: l, tree: a, key: r }), { cacheOptions: u, ...c } = hY(e, t, {
        select: l,
        tree: a,
        key: r
      }), d = Rt({});
      return o(d), ft(() => {
        Object.assign(d, {
          ...jl(a.value, [
            "filter",
            "updateKeyChildren",
            "getCheckedNodes",
            "setCheckedNodes",
            "getCheckedKeys",
            "setCheckedKeys",
            "setChecked",
            "getHalfCheckedNodes",
            "getHalfCheckedKeys",
            "getCurrentKey",
            "getCurrentNode",
            "setCurrentKey",
            "setCurrentNode",
            "getNode",
            "remove",
            "append",
            "insertBefore",
            "insertAfter"
          ]),
          ...jl(l.value, ["focus", "blur", "selectedLabel"]),
          treeRef: a.value,
          selectRef: l.value
        });
      }), () => qe(fr, Rt({
        ...i,
        ref: (f) => l.value = f
      }), {
        ...n,
        default: () => [
          qe(mY, { data: u.value }),
          qe(od, Rt({
            ...c,
            ref: (f) => a.value = f
          }))
        ]
      });
    }
  });
  var bY = /* @__PURE__ */ Ne(gY, [["__file", "tree-select.vue"]]);
  const yY = rt(bY), ym = Symbol(), wY = {
    key: -1,
    level: -1,
    data: {}
  };
  var js = /* @__PURE__ */ ((e) => (e.KEY = "id", e.LABEL = "label", e.CHILDREN = "children", e.DISABLED = "disabled", e.CLASS = "", e))(js || {}), pv = /* @__PURE__ */ ((e) => (e.ADD = "add", e.DELETE = "delete", e))(pv || {});
  const Qk = {
    type: Number,
    default: 26
  }, CY = Te({
    data: {
      type: X(Array),
      default: () => en([])
    },
    emptyText: {
      type: String
    },
    height: {
      type: Number,
      default: 200
    },
    props: {
      type: X(Object),
      default: () => en({
        children: "children",
        label: "label",
        disabled: "disabled",
        value: "id",
        class: ""
        /* CLASS */
      })
    },
    highlightCurrent: Boolean,
    showCheckbox: Boolean,
    defaultCheckedKeys: {
      type: X(Array),
      default: () => en([])
    },
    checkStrictly: Boolean,
    defaultExpandedKeys: {
      type: X(Array),
      default: () => en([])
    },
    indent: {
      type: Number,
      default: 16
    },
    itemSize: Qk,
    icon: {
      type: Lt
    },
    expandOnClickNode: {
      type: Boolean,
      default: !0
    },
    checkOnClickNode: Boolean,
    checkOnClickLeaf: {
      type: Boolean,
      default: !0
    },
    currentNodeKey: {
      type: X([String, Number])
    },
    accordion: Boolean,
    filterMethod: {
      type: X(Function)
    },
    perfMode: {
      type: Boolean,
      default: !0
    },
    scrollbarAlwaysOn: Boolean
  }), SY = Te({
    node: {
      type: X(Object),
      default: () => en(wY)
    },
    expanded: Boolean,
    checked: Boolean,
    indeterminate: Boolean,
    showCheckbox: Boolean,
    disabled: Boolean,
    current: Boolean,
    hiddenExpandIcon: Boolean,
    itemSize: Qk
  }), EY = Te({
    node: {
      type: X(Object),
      required: !0
    }
  }), e_ = "node-click", t_ = "node-drop", n_ = "node-expand", o_ = "node-collapse", l_ = "current-change", a_ = "check", r_ = "check-change", s_ = "node-contextmenu", kY = {
    [e_]: (e, t, n) => e && t && n,
    [t_]: (e, t, n) => e && t && n,
    [n_]: (e, t) => e && t,
    [o_]: (e, t) => e && t,
    [l_]: (e, t) => e && t,
    [a_]: (e, t) => e && t,
    [r_]: (e, t) => e && Vt(t),
    [s_]: (e, t, n) => e && t && n
  }, _Y = {
    click: (e, t) => !!(e && t),
    drop: (e, t) => !!(e && t),
    toggle: (e) => !!e,
    check: (e, t) => e && Vt(t)
  };
  function TY(e, t) {
    const n = A(/* @__PURE__ */ new Set()), o = A(/* @__PURE__ */ new Set()), { emit: l } = dt();
    de([() => t.value, () => e.defaultCheckedKeys], () => Re(() => {
      C(e.defaultCheckedKeys);
    }), {
      immediate: !0
    });
    const a = () => {
      if (!t.value || !e.showCheckbox || e.checkStrictly)
        return;
      const { levelTreeNodeMap: w, maxLevel: y } = t.value, E = n.value, k = /* @__PURE__ */ new Set();
      for (let T = y; T >= 1; --T) {
        const x = w.get(T);
        x && x.forEach((I) => {
          const P = I.children;
          let O = !I.isLeaf || I.disabled || E.has(I.key);
          if (P) {
            let N = !0, z = !1;
            for (const Y of P) {
              const G = Y.key;
              if (Y.isEffectivelyChecked || (O = !1), E.has(G))
                z = !0;
              else if (k.has(G)) {
                N = !1, z = !0;
                break;
              } else
                N = !1;
            }
            N ? E.add(I.key) : z ? (k.add(I.key), E.delete(I.key)) : (E.delete(I.key), k.delete(I.key));
          }
          I.isEffectivelyChecked = O;
        });
      }
      o.value = k;
    }, r = (w) => n.value.has(w.key), i = (w) => o.value.has(w.key), u = (w, y, E = !0, k = !0) => {
      const T = n.value, x = w.children;
      !e.checkStrictly && E && (x != null && x.length) && (y = x.some((P) => !P.isEffectivelyChecked));
      const I = (P, O) => {
        T[O ? pv.ADD : pv.DELETE](P.key);
        const N = P.children;
        !e.checkStrictly && N && N.forEach((z) => {
          (!z.disabled || z.children) && I(z, O);
        });
      };
      I(w, y), k && a(), E && c(w, y);
    }, c = (w, y) => {
      const { checkedNodes: E, checkedKeys: k } = m(), { halfCheckedNodes: T, halfCheckedKeys: x } = h();
      l(a_, w.data, {
        checkedKeys: k,
        checkedNodes: E,
        halfCheckedKeys: x,
        halfCheckedNodes: T
      }), l(r_, w.data, y);
    };
    function d(w = !1) {
      return m(w).checkedKeys;
    }
    function f(w = !1) {
      return m(w).checkedNodes;
    }
    function v() {
      return h().halfCheckedKeys;
    }
    function p() {
      return h().halfCheckedNodes;
    }
    function m(w = !1) {
      const y = [], E = [];
      if (t != null && t.value && e.showCheckbox) {
        const { treeNodeMap: k } = t.value;
        n.value.forEach((T) => {
          const x = k.get(T);
          x && (!w || w && x.isLeaf) && (E.push(T), y.push(x.data));
        });
      }
      return {
        checkedKeys: E,
        checkedNodes: y
      };
    }
    function h() {
      const w = [], y = [];
      if (t != null && t.value && e.showCheckbox) {
        const { treeNodeMap: E } = t.value;
        o.value.forEach((k) => {
          const T = E.get(k);
          T && (y.push(k), w.push(T.data));
        });
      }
      return {
        halfCheckedNodes: w,
        halfCheckedKeys: y
      };
    }
    function g(w) {
      n.value.clear(), o.value.clear(), Re(() => {
        C(w);
      });
    }
    function b(w, y) {
      if (t != null && t.value && e.showCheckbox) {
        const E = t.value.treeNodeMap.get(w);
        E && u(E, y, !1);
      }
    }
    function C(w) {
      if (t != null && t.value) {
        const { treeNodeMap: y } = t.value;
        if (e.showCheckbox && y && (w == null ? void 0 : w.length) > 0) {
          for (const E of w) {
            const k = y.get(E);
            k && !r(k) && u(k, !0, !1, !1);
          }
          a();
        }
      }
    }
    return {
      updateCheckedKeys: a,
      toggleCheckbox: u,
      isChecked: r,
      isIndeterminate: i,
      getCheckedKeys: d,
      getCheckedNodes: f,
      getHalfCheckedKeys: v,
      getHalfCheckedNodes: p,
      setChecked: b,
      setCheckedKeys: g
    };
  }
  function NY(e, t) {
    const n = A(/* @__PURE__ */ new Set([])), o = A(/* @__PURE__ */ new Set([])), l = S(() => Fe(e.filterMethod));
    function a(i) {
      var u;
      if (!l.value)
        return;
      const c = /* @__PURE__ */ new Set(), d = o.value, f = n.value, v = [], p = ((u = t.value) == null ? void 0 : u.treeNodes) || [], m = e.filterMethod;
      f.clear();
      function h(g) {
        g.forEach((b) => {
          v.push(b), m != null && m(i, b.data, b) ? v.forEach((w) => {
            c.add(w.key), w.expanded = !0;
          }) : (b.expanded = !1, b.isLeaf && f.add(b.key));
          const C = b.children;
          if (C && h(C), !b.isLeaf) {
            if (!c.has(b.key))
              f.add(b.key);
            else if (C) {
              let w = !0;
              for (const y of C)
                if (!f.has(y.key)) {
                  w = !1;
                  break;
                }
              w ? d.add(b.key) : d.delete(b.key);
            }
          }
          v.pop();
        });
      }
      return h(p), c;
    }
    function r(i) {
      return o.value.has(i.key);
    }
    return {
      hiddenExpandIconKeySet: o,
      hiddenNodeKeySet: n,
      doFilter: a,
      isForceHiddenExpandIcon: r
    };
  }
  function $Y(e, t) {
    const n = A(/* @__PURE__ */ new Set()), o = A(), l = Ut(), a = A(), {
      isIndeterminate: r,
      isChecked: i,
      toggleCheckbox: u,
      getCheckedKeys: c,
      getCheckedNodes: d,
      getHalfCheckedKeys: f,
      getHalfCheckedNodes: v,
      setChecked: p,
      setCheckedKeys: m
    } = TY(e, l), { doFilter: h, hiddenNodeKeySet: g, isForceHiddenExpandIcon: b } = NY(e, l), C = S(() => {
      var le;
      return ((le = e.props) == null ? void 0 : le.value) || js.KEY;
    }), w = S(() => {
      var le;
      return ((le = e.props) == null ? void 0 : le.children) || js.CHILDREN;
    }), y = S(() => {
      var le;
      return ((le = e.props) == null ? void 0 : le.disabled) || js.DISABLED;
    }), E = S(() => {
      var le;
      return ((le = e.props) == null ? void 0 : le.label) || js.LABEL;
    }), k = S(() => {
      var le;
      const Ce = n.value, j = g.value, te = [], ce = ((le = l.value) == null ? void 0 : le.treeNodes) || [], ge = [];
      for (let be = ce.length - 1; be >= 0; --be)
        ge.push(ce[be]);
      for (; ge.length; ) {
        const be = ge.pop();
        if (!j.has(be.key) && (te.push(be), be.children && Ce.has(be.key)))
          for (let Ee = be.children.length - 1; Ee >= 0; --Ee)
            ge.push(be.children[Ee]);
      }
      return te;
    }), T = S(() => k.value.length > 0);
    function x(le) {
      const Ce = /* @__PURE__ */ new Map(), j = /* @__PURE__ */ new Map();
      let te = 1;
      function ce(be, Ee = 1, Oe = void 0) {
        var De;
        const we = [];
        for (const me of be) {
          const Pe = O(me), Me = {
            level: Ee,
            key: Pe,
            data: me
          };
          Me.label = z(me), Me.parent = Oe;
          const Be = P(me);
          Me.disabled = N(me), Me.isLeaf = !Be || Be.length === 0, Me.expanded = n.value.has(Pe), Be && Be.length && (Me.children = ce(Be, Ee + 1, Me)), we.push(Me), Ce.set(Pe, Me), j.has(Ee) || j.set(Ee, []), (De = j.get(Ee)) == null || De.push(Me);
        }
        return Ee > te && (te = Ee), we;
      }
      const ge = ce(le);
      return {
        treeNodeMap: Ce,
        levelTreeNodeMap: j,
        maxLevel: te,
        treeNodes: ge
      };
    }
    function I(le) {
      const Ce = h(le);
      Ce && (n.value = Ce);
    }
    function P(le) {
      return le[w.value];
    }
    function O(le) {
      return le ? le[C.value] : "";
    }
    function N(le) {
      return le[y.value];
    }
    function z(le) {
      return le[E.value];
    }
    function Y(le) {
      n.value.has(le.key) ? F(le) : V(le);
    }
    function G(le) {
      const Ce = /* @__PURE__ */ new Set(), j = l.value.treeNodeMap;
      n.value.forEach((te) => {
        const ce = j.get(te);
        n.value.delete(ce.key), ce.expanded = !1;
      }), le.forEach((te) => {
        let ce = j.get(te);
        for (; ce && !Ce.has(ce.key); )
          Ce.add(ce.key), ce.expanded = !0, ce = ce.parent;
      }), n.value = Ce;
    }
    function M(le, Ce) {
      t(e_, le.data, le, Ce), D(le), e.expandOnClickNode && Y(le), e.showCheckbox && (e.checkOnClickNode || le.isLeaf && e.checkOnClickLeaf) && !le.disabled && u(le, !i(le), !0);
    }
    function R(le, Ce) {
      t(t_, le.data, le, Ce);
    }
    function D(le) {
      K(le) || (o.value = le.key, t(l_, le.data, le));
    }
    function L(le, Ce) {
      u(le, Ce);
    }
    function V(le) {
      const Ce = n.value;
      if (l.value && e.accordion) {
        const { treeNodeMap: te } = l.value;
        Ce.forEach((ce) => {
          const ge = te.get(ce);
          le && le.level === (ge == null ? void 0 : ge.level) && (Ce.delete(ce), ge.expanded = !1);
        });
      }
      Ce.add(le.key);
      const j = re(le.key);
      j && (j.expanded = !0, t(n_, j.data, j));
    }
    function F(le) {
      n.value.delete(le.key);
      const Ce = re(le.key);
      Ce && (Ce.expanded = !1, t(o_, Ce.data, Ce));
    }
    function H(le) {
      return !!le.disabled;
    }
    function K(le) {
      const Ce = o.value;
      return Ce !== void 0 && Ce === le.key;
    }
    function Z() {
      var le, Ce;
      if (o.value)
        return (Ce = (le = l.value) == null ? void 0 : le.treeNodeMap.get(o.value)) == null ? void 0 : Ce.data;
    }
    function J() {
      return o.value;
    }
    function ie(le) {
      o.value = le;
    }
    function ue(le) {
      l.value = x(le);
    }
    function re(le) {
      var Ce;
      const j = ot(le) ? O(le) : le;
      return (Ce = l.value) == null ? void 0 : Ce.treeNodeMap.get(j);
    }
    function se(le, Ce = "auto") {
      const j = re(le);
      j && a.value && a.value.scrollToItem(k.value.indexOf(j), Ce);
    }
    function ne(le) {
      var Ce;
      (Ce = a.value) == null || Ce.scrollTo(le);
    }
    return de(() => e.currentNodeKey, (le) => {
      o.value = le;
    }, {
      immediate: !0
    }), de(() => e.defaultExpandedKeys, (le) => {
      n.value = new Set(le);
    }, {
      immediate: !0
    }), de(() => e.data, (le) => {
      ue(le);
    }, {
      immediate: !0
    }), {
      tree: l,
      flattenTree: k,
      isNotEmpty: T,
      listRef: a,
      getKey: O,
      getChildren: P,
      toggleExpand: Y,
      toggleCheckbox: u,
      isChecked: i,
      isIndeterminate: r,
      isDisabled: H,
      isCurrent: K,
      isForceHiddenExpandIcon: b,
      handleNodeClick: M,
      handleNodeDrop: R,
      handleNodeCheck: L,
      getCurrentNode: Z,
      getCurrentKey: J,
      setCurrentKey: ie,
      getCheckedKeys: c,
      getCheckedNodes: d,
      getHalfCheckedKeys: f,
      getHalfCheckedNodes: v,
      setChecked: p,
      setCheckedKeys: m,
      filter: I,
      setData: ue,
      getNode: re,
      expandNode: V,
      collapseNode: F,
      setExpandedKeys: G,
      scrollToNode: se,
      scrollTo: ne
    };
  }
  var OY = /* @__PURE__ */ U({
    name: "ElTreeNodeContent",
    props: EY,
    setup(e) {
      const t = Ve(ym), n = he("tree");
      return () => {
        const o = e.node, { data: l } = o;
        return t != null && t.ctx.slots.default ? t.ctx.slots.default({ node: o, data: l }) : qe(hm, { tag: "span", truncated: !0, class: n.be("node", "label") }, () => [o == null ? void 0 : o.label]);
      };
    }
  });
  const IY = /* @__PURE__ */ U({
    name: "ElTreeNode"
  }), MY = /* @__PURE__ */ U({
    ...IY,
    props: SY,
    emits: _Y,
    setup(e, { emit: t }) {
      const n = e, o = Ve(ym), l = he("tree"), a = S(() => {
        var p;
        return (p = o == null ? void 0 : o.props.indent) != null ? p : 16;
      }), r = S(() => {
        var p;
        return (p = o == null ? void 0 : o.props.icon) != null ? p : gC;
      }), i = (p) => {
        const m = o == null ? void 0 : o.props.props.class;
        if (!m)
          return {};
        let h;
        if (Fe(m)) {
          const { data: g } = p;
          h = m(g, p);
        } else
          h = m;
        return Ae(h) ? { [h]: !0 } : h;
      }, u = (p) => {
        t("click", n.node, p);
      }, c = (p) => {
        t("drop", n.node, p);
      }, d = () => {
        t("toggle", n.node);
      }, f = (p) => {
        t("check", n.node, p);
      }, v = (p) => {
        var m, h, g, b;
        (g = (h = (m = o == null ? void 0 : o.instance) == null ? void 0 : m.vnode) == null ? void 0 : h.props) != null && g.onNodeContextmenu && (p.stopPropagation(), p.preventDefault()), o == null || o.ctx.emit(s_, p, (b = n.node) == null ? void 0 : b.data, n.node);
      };
      return (p, m) => {
        var h, g, b;
        return _(), B("div", {
          ref: "node$",
          class: $([
            s(l).b("node"),
            s(l).is("expanded", p.expanded),
            s(l).is("current", p.current),
            s(l).is("focusable", !p.disabled),
            s(l).is("checked", !p.disabled && p.checked),
            i(p.node)
          ]),
          role: "treeitem",
          tabindex: "-1",
          "aria-expanded": p.expanded,
          "aria-disabled": p.disabled,
          "aria-checked": p.checked,
          "data-key": (h = p.node) == null ? void 0 : h.key,
          onClick: Ze(u, ["stop"]),
          onContextmenu: v,
          onDragover: Ze(() => {
          }, ["prevent"]),
          onDragenter: Ze(() => {
          }, ["prevent"]),
          onDrop: Ze(c, ["stop"])
        }, [
          W("div", {
            class: $(s(l).be("node", "content")),
            style: Ue({
              paddingLeft: `${(p.node.level - 1) * s(a)}px`,
              height: p.itemSize + "px"
            })
          }, [
            s(r) ? (_(), ae(s(ze), {
              key: 0,
              class: $([
                s(l).is("leaf", !!((g = p.node) != null && g.isLeaf)),
                s(l).is("hidden", p.hiddenExpandIcon),
                {
                  expanded: !((b = p.node) != null && b.isLeaf) && p.expanded
                },
                s(l).be("node", "expand-icon")
              ]),
              onClick: Ze(d, ["stop"])
            }, {
              default: Q(() => [
                (_(), ae(ct(s(r))))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : oe("v-if", !0),
            p.showCheckbox ? (_(), ae(s(xo), {
              key: 1,
              "model-value": p.checked,
              indeterminate: p.indeterminate,
              disabled: p.disabled,
              onChange: f,
              onClick: Ze(() => {
              }, ["stop"])
            }, null, 8, ["model-value", "indeterminate", "disabled", "onClick"])) : oe("v-if", !0),
            q(s(OY), {
              node: { ...p.node, expanded: p.expanded }
            }, null, 8, ["node"])
          ], 6)
        ], 42, ["aria-expanded", "aria-disabled", "aria-checked", "data-key", "onClick", "onDragover", "onDragenter", "onDrop"]);
      };
    }
  });
  var xY = /* @__PURE__ */ Ne(MY, [["__file", "tree-node.vue"]]);
  const PY = /* @__PURE__ */ U({
    name: "ElTreeV2"
  }), RY = /* @__PURE__ */ U({
    ...PY,
    props: CY,
    emits: kY,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = hn(), a = S(() => o.itemSize);
      yt(ym, {
        ctx: {
          emit: n,
          slots: l
        },
        props: o,
        instance: dt()
      }), yt(Sl, void 0);
      const { t: r } = _t(), i = he("tree"), {
        flattenTree: u,
        isNotEmpty: c,
        listRef: d,
        toggleExpand: f,
        isIndeterminate: v,
        isChecked: p,
        isDisabled: m,
        isCurrent: h,
        isForceHiddenExpandIcon: g,
        handleNodeClick: b,
        handleNodeDrop: C,
        handleNodeCheck: w,
        toggleCheckbox: y,
        getCurrentNode: E,
        getCurrentKey: k,
        setCurrentKey: T,
        getCheckedKeys: x,
        getCheckedNodes: I,
        getHalfCheckedKeys: P,
        getHalfCheckedNodes: O,
        setChecked: N,
        setCheckedKeys: z,
        filter: Y,
        setData: G,
        getNode: M,
        expandNode: R,
        collapseNode: D,
        setExpandedKeys: L,
        scrollToNode: V,
        scrollTo: F
      } = $Y(o, n);
      return t({
        toggleCheckbox: y,
        getCurrentNode: E,
        getCurrentKey: k,
        setCurrentKey: T,
        getCheckedKeys: x,
        getCheckedNodes: I,
        getHalfCheckedKeys: P,
        getHalfCheckedNodes: O,
        setChecked: N,
        setCheckedKeys: z,
        filter: Y,
        setData: G,
        getNode: M,
        expandNode: R,
        collapseNode: D,
        setExpandedKeys: L,
        scrollToNode: V,
        scrollTo: F
      }), (H, K) => (_(), B("div", {
        class: $([s(i).b(), { [s(i).m("highlight-current")]: H.highlightCurrent }]),
        role: "tree"
      }, [
        s(c) ? (_(), ae(s(ok), {
          key: 0,
          ref_key: "listRef",
          ref: d,
          "class-name": s(i).b("virtual-list"),
          data: s(u),
          total: s(u).length,
          height: H.height,
          "item-size": s(a),
          "perf-mode": H.perfMode,
          "scrollbar-always-on": H.scrollbarAlwaysOn
        }, {
          default: Q(({ data: Z, index: J, style: ie }) => [
            (_(), ae(xY, {
              key: Z[J].key,
              style: Ue(ie),
              node: Z[J],
              expanded: Z[J].expanded,
              "show-checkbox": H.showCheckbox,
              checked: s(p)(Z[J]),
              indeterminate: s(v)(Z[J]),
              "item-size": s(a),
              disabled: s(m)(Z[J]),
              current: s(h)(Z[J]),
              "hidden-expand-icon": s(g)(Z[J]),
              onClick: s(b),
              onToggle: s(f),
              onCheck: s(w),
              onDrop: s(C)
            }, null, 8, ["style", "node", "expanded", "show-checkbox", "checked", "indeterminate", "item-size", "disabled", "current", "hidden-expand-icon", "onClick", "onToggle", "onCheck", "onDrop"]))
          ]),
          _: 1
        }, 8, ["class-name", "data", "total", "height", "item-size", "perf-mode", "scrollbar-always-on"])) : (_(), B("div", {
          key: 1,
          class: $(s(i).e("empty-block"))
        }, [
          ee(H.$slots, "empty", {}, () => {
            var Z;
            return [
              W("span", {
                class: $(s(i).e("empty-text"))
              }, ke((Z = H.emptyText) != null ? Z : s(r)("el.tree.emptyText")), 3)
            ];
          })
        ], 2))
      ], 2));
    }
  });
  var DY = /* @__PURE__ */ Ne(RY, [["__file", "tree.vue"]]);
  const AY = rt(DY), i_ = Symbol("uploadContextKey"), VY = "ElUpload";
  class LY extends Error {
    constructor(t, n, o, l) {
      super(t), this.name = "UploadAjaxError", this.status = n, this.method = o, this.url = l;
    }
  }
  function a0(e, t, n) {
    let o;
    return n.response ? o = `${n.response.error || n.response}` : n.responseText ? o = `${n.responseText}` : o = `fail to ${t.method} ${e} ${n.status}`, new LY(o, n.status, t.method, e);
  }
  function BY(e) {
    const t = e.responseText || e.response;
    if (!t)
      return t;
    try {
      return JSON.parse(t);
    } catch {
      return t;
    }
  }
  const FY = (e) => {
    typeof XMLHttpRequest > "u" && Zt(VY, "XMLHttpRequest is undefined");
    const t = new XMLHttpRequest(), n = e.action;
    t.upload && t.upload.addEventListener("progress", (a) => {
      const r = a;
      r.percent = a.total > 0 ? a.loaded / a.total * 100 : 0, e.onProgress(r);
    });
    const o = new FormData();
    if (e.data)
      for (const [a, r] of Object.entries(e.data))
        ye(r) && r.length ? o.append(a, ...r) : o.append(a, r);
    o.append(e.filename, e.file, e.file.name), t.addEventListener("error", () => {
      e.onError(a0(n, e, t));
    }), t.addEventListener("load", () => {
      if (t.status < 200 || t.status >= 300)
        return e.onError(a0(n, e, t));
      e.onSuccess(BY(t));
    }), t.open(e.method, n, !0), e.withCredentials && "withCredentials" in t && (t.withCredentials = !0);
    const l = e.headers || {};
    if (l instanceof Headers)
      l.forEach((a, r) => t.setRequestHeader(r, a));
    else
      for (const [a, r] of Object.entries(l))
        cn(r) || t.setRequestHeader(a, String(r));
    return t.send(o), t;
  }, u_ = ["text", "picture", "picture-card"];
  let zY = 1;
  const vv = () => Date.now() + zY++, c_ = Te({
    action: {
      type: String,
      default: "#"
    },
    headers: {
      type: X(Object)
    },
    method: {
      type: String,
      default: "post"
    },
    data: {
      type: X([Object, Function, Promise]),
      default: () => en({})
    },
    multiple: Boolean,
    name: {
      type: String,
      default: "file"
    },
    drag: Boolean,
    withCredentials: Boolean,
    showFileList: {
      type: Boolean,
      default: !0
    },
    accept: {
      type: String,
      default: ""
    },
    fileList: {
      type: X(Array),
      default: () => en([])
    },
    autoUpload: {
      type: Boolean,
      default: !0
    },
    listType: {
      type: String,
      values: u_,
      default: "text"
    },
    httpRequest: {
      type: X(Function),
      default: FY
    },
    disabled: Boolean,
    limit: Number
  }), HY = Te({
    ...c_,
    beforeUpload: {
      type: X(Function),
      default: It
    },
    beforeRemove: {
      type: X(Function)
    },
    onRemove: {
      type: X(Function),
      default: It
    },
    onChange: {
      type: X(Function),
      default: It
    },
    onPreview: {
      type: X(Function),
      default: It
    },
    onSuccess: {
      type: X(Function),
      default: It
    },
    onProgress: {
      type: X(Function),
      default: It
    },
    onError: {
      type: X(Function),
      default: It
    },
    onExceed: {
      type: X(Function),
      default: It
    },
    crossorigin: {
      type: X(String)
    }
  }), KY = Te({
    files: {
      type: X(Array),
      default: () => en([])
    },
    disabled: Boolean,
    handlePreview: {
      type: X(Function),
      default: It
    },
    listType: {
      type: String,
      values: u_,
      default: "text"
    },
    crossorigin: {
      type: X(String)
    }
  }), WY = {
    remove: (e) => !!e
  }, jY = /* @__PURE__ */ U({
    name: "ElUploadList"
  }), UY = /* @__PURE__ */ U({
    ...jY,
    props: KY,
    emits: WY,
    setup(e, { emit: t }) {
      const n = e, { t: o } = _t(), l = he("upload"), a = he("icon"), r = he("list"), i = Cn(), u = A(!1), c = S(() => [
        l.b("list"),
        l.bm("list", n.listType),
        l.is("disabled", n.disabled)
      ]), d = (f) => {
        t("remove", f);
      };
      return (f, v) => (_(), ae(e1, {
        tag: "ul",
        class: $(s(c)),
        name: s(r).b()
      }, {
        default: Q(() => [
          (_(!0), B(We, null, bt(f.files, (p, m) => (_(), B("li", {
            key: p.uid || p.name,
            class: $([
              s(l).be("list", "item"),
              s(l).is(p.status),
              { focusing: u.value }
            ]),
            tabindex: s(i) ? void 0 : 0,
            "aria-disabled": s(i),
            role: "button",
            onKeydown: on((h) => !s(i) && d(p), ["delete"]),
            onFocus: (h) => u.value = !0,
            onBlur: (h) => u.value = !1,
            onClick: (h) => u.value = !1
          }, [
            ee(f.$slots, "default", {
              file: p,
              index: m
            }, () => [
              f.listType === "picture" || p.status !== "uploading" && f.listType === "picture-card" ? (_(), B("img", {
                key: 0,
                class: $(s(l).be("list", "item-thumbnail")),
                src: p.url,
                crossorigin: f.crossorigin,
                alt: ""
              }, null, 10, ["src", "crossorigin"])) : oe("v-if", !0),
              p.status === "uploading" || f.listType !== "picture-card" ? (_(), B("div", {
                key: 1,
                class: $(s(l).be("list", "item-info"))
              }, [
                W("a", {
                  class: $(s(l).be("list", "item-name")),
                  onClick: Ze((h) => f.handlePreview(p), ["prevent"])
                }, [
                  q(s(ze), {
                    class: $(s(a).m("document"))
                  }, {
                    default: Q(() => [
                      q(s(tD))
                    ]),
                    _: 1
                  }, 8, ["class"]),
                  W("span", {
                    class: $(s(l).be("list", "item-file-name")),
                    title: p.name
                  }, ke(p.name), 11, ["title"])
                ], 10, ["onClick"]),
                p.status === "uploading" ? (_(), ae(s(YE), {
                  key: 0,
                  type: f.listType === "picture-card" ? "circle" : "line",
                  "stroke-width": f.listType === "picture-card" ? 6 : 2,
                  percentage: Number(p.percentage),
                  style: Ue(f.listType === "picture-card" ? "" : "margin-top: 0.5rem")
                }, null, 8, ["type", "stroke-width", "percentage", "style"])) : oe("v-if", !0)
              ], 2)) : oe("v-if", !0),
              W("label", {
                class: $(s(l).be("list", "item-status-label"))
              }, [
                f.listType === "text" ? (_(), ae(s(ze), {
                  key: 0,
                  class: $([s(a).m("upload-success"), s(a).m("circle-check")])
                }, {
                  default: Q(() => [
                    q(s(dh))
                  ]),
                  _: 1
                }, 8, ["class"])) : ["picture-card", "picture"].includes(f.listType) ? (_(), ae(s(ze), {
                  key: 1,
                  class: $([s(a).m("upload-success"), s(a).m("check")])
                }, {
                  default: Q(() => [
                    q(s(ou))
                  ]),
                  _: 1
                }, 8, ["class"])) : oe("v-if", !0)
              ], 2),
              s(i) ? oe("v-if", !0) : (_(), ae(s(ze), {
                key: 2,
                class: $(s(a).m("close")),
                onClick: (h) => d(p)
              }, {
                default: Q(() => [
                  q(s(Oo))
                ]),
                _: 2
              }, 1032, ["class", "onClick"])),
              oe(" Due to close btn only appears when li gets focused disappears after li gets blurred, thus keyboard navigation can never reach close btn"),
              oe(" This is a bug which needs to be fixed "),
              oe(" TODO: Fix the incorrect navigation interaction "),
              s(i) ? oe("v-if", !0) : (_(), B("i", {
                key: 3,
                class: $(s(a).m("close-tip"))
              }, ke(s(o)("el.upload.deleteTip")), 3)),
              f.listType === "picture-card" ? (_(), B("span", {
                key: 4,
                class: $(s(l).be("list", "item-actions"))
              }, [
                W("span", {
                  class: $(s(l).be("list", "item-preview")),
                  onClick: (h) => f.handlePreview(p)
                }, [
                  q(s(ze), {
                    class: $(s(a).m("zoom-in"))
                  }, {
                    default: Q(() => [
                      q(s(CC))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, ["onClick"]),
                s(i) ? oe("v-if", !0) : (_(), B("span", {
                  key: 0,
                  class: $(s(l).be("list", "item-delete")),
                  onClick: (h) => d(p)
                }, [
                  q(s(ze), {
                    class: $(s(a).m("delete"))
                  }, {
                    default: Q(() => [
                      q(s(QR))
                    ]),
                    _: 1
                  }, 8, ["class"])
                ], 10, ["onClick"]))
              ], 2)) : oe("v-if", !0)
            ])
          ], 42, ["tabindex", "aria-disabled", "onKeydown", "onFocus", "onBlur", "onClick"]))), 128)),
          ee(f.$slots, "append")
        ]),
        _: 3
      }, 8, ["class", "name"]));
    }
  });
  var r0 = /* @__PURE__ */ Ne(UY, [["__file", "upload-list.vue"]]);
  const YY = Te({
    disabled: Boolean
  }), qY = {
    file: (e) => ye(e)
  }, d_ = "ElUploadDrag", GY = /* @__PURE__ */ U({
    name: d_
  }), XY = /* @__PURE__ */ U({
    ...GY,
    props: YY,
    emits: qY,
    setup(e, { emit: t }) {
      Ve(i_) || Zt(d_, "usage: <el-upload><el-upload-dragger /></el-upload>");
      const o = he("upload"), l = A(!1), a = Cn(), r = (c) => {
        if (a.value)
          return;
        l.value = !1, c.stopPropagation();
        const d = Array.from(c.dataTransfer.files), f = c.dataTransfer.items || [];
        d.forEach((v, p) => {
          var m;
          const h = f[p], g = (m = h == null ? void 0 : h.webkitGetAsEntry) == null ? void 0 : m.call(h);
          g && (v.isDirectory = g.isDirectory);
        }), t("file", d);
      }, i = () => {
        a.value || (l.value = !0);
      }, u = (c) => {
        c.currentTarget.contains(c.relatedTarget) || (l.value = !1);
      };
      return (c, d) => (_(), B("div", {
        class: $([s(o).b("dragger"), s(o).is("dragover", l.value)]),
        onDrop: Ze(r, ["prevent"]),
        onDragover: Ze(i, ["prevent"]),
        onDragleave: Ze(u, ["prevent"])
      }, [
        ee(c.$slots, "default")
      ], 42, ["onDrop", "onDragover", "onDragleave"]));
    }
  });
  var JY = /* @__PURE__ */ Ne(XY, [["__file", "upload-dragger.vue"]]);
  const ZY = Te({
    ...c_,
    beforeUpload: {
      type: X(Function),
      default: It
    },
    onRemove: {
      type: X(Function),
      default: It
    },
    onStart: {
      type: X(Function),
      default: It
    },
    onSuccess: {
      type: X(Function),
      default: It
    },
    onProgress: {
      type: X(Function),
      default: It
    },
    onError: {
      type: X(Function),
      default: It
    },
    onExceed: {
      type: X(Function),
      default: It
    }
  }), QY = /* @__PURE__ */ U({
    name: "ElUploadContent",
    inheritAttrs: !1
  }), eq = /* @__PURE__ */ U({
    ...QY,
    props: ZY,
    setup(e, { expose: t }) {
      const n = e, o = he("upload"), l = Cn(), a = Ut({}), r = Ut(), i = (h) => {
        if (h.length === 0)
          return;
        const { autoUpload: g, limit: b, fileList: C, multiple: w, onStart: y, onExceed: E } = n;
        if (b && C.length + h.length > b) {
          E(h, C);
          return;
        }
        w || (h = h.slice(0, 1));
        for (const k of h) {
          const T = k;
          T.uid = vv(), y(T), g && u(T);
        }
      }, u = async (h) => {
        if (r.value.value = "", !n.beforeUpload)
          return d(h);
        let g, b = {};
        try {
          const w = n.data, y = n.beforeUpload(h);
          b = si(n.data) ? Ac(n.data) : n.data, g = await y, si(n.data) && ln(w, b) && (b = Ac(n.data));
        } catch {
          g = !1;
        }
        if (g === !1) {
          n.onRemove(h);
          return;
        }
        let C = h;
        g instanceof Blob && (g instanceof File ? C = g : C = new File([g], h.name, {
          type: h.type
        })), d(Object.assign(C, {
          uid: h.uid
        }), b);
      }, c = async (h, g) => Fe(h) ? h(g) : h, d = async (h, g) => {
        const {
          headers: b,
          data: C,
          method: w,
          withCredentials: y,
          name: E,
          action: k,
          onProgress: T,
          onSuccess: x,
          onError: I,
          httpRequest: P
        } = n;
        try {
          g = await c(g ?? C, h);
        } catch {
          n.onRemove(h);
          return;
        }
        const { uid: O } = h, N = {
          headers: b || {},
          withCredentials: y,
          file: h,
          data: g,
          method: w,
          filename: E,
          action: k,
          onProgress: (Y) => {
            T(Y, h);
          },
          onSuccess: (Y) => {
            x(Y, h), delete a.value[O];
          },
          onError: (Y) => {
            I(Y, h), delete a.value[O];
          }
        }, z = P(N);
        a.value[O] = z, z instanceof Promise && z.then(N.onSuccess, N.onError);
      }, f = (h) => {
        const g = h.target.files;
        g && i(Array.from(g));
      }, v = () => {
        l.value || (r.value.value = "", r.value.click());
      }, p = () => {
        v();
      };
      return t({
        abort: (h) => {
          uC(a.value).filter(h ? ([b]) => String(h.uid) === b : () => !0).forEach(([b, C]) => {
            C instanceof XMLHttpRequest && C.abort(), delete a.value[b];
          });
        },
        upload: u
      }), (h, g) => (_(), B("div", {
        class: $([
          s(o).b(),
          s(o).m(h.listType),
          s(o).is("drag", h.drag),
          s(o).is("disabled", s(l))
        ]),
        tabindex: s(l) ? void 0 : 0,
        "aria-disabled": s(l),
        role: "button",
        onClick: v,
        onKeydown: on(Ze(p, ["self"]), ["enter", "space"])
      }, [
        h.drag ? (_(), ae(JY, {
          key: 0,
          disabled: s(l),
          onFile: i
        }, {
          default: Q(() => [
            ee(h.$slots, "default")
          ]),
          _: 3
        }, 8, ["disabled"])) : ee(h.$slots, "default", { key: 1 }),
        W("input", {
          ref_key: "inputRef",
          ref: r,
          class: $(s(o).e("input")),
          name: h.name,
          disabled: s(l),
          multiple: h.multiple,
          accept: h.accept,
          type: "file",
          onChange: f,
          onClick: Ze(() => {
          }, ["stop"])
        }, null, 42, ["name", "disabled", "multiple", "accept", "onClick"])
      ], 42, ["tabindex", "aria-disabled", "onKeydown"]));
    }
  });
  var s0 = /* @__PURE__ */ Ne(eq, [["__file", "upload-content.vue"]]);
  const i0 = "ElUpload", u0 = (e) => {
    var t;
    (t = e.url) != null && t.startsWith("blob:") && URL.revokeObjectURL(e.url);
  }, tq = (e, t) => {
    const n = eC(e, "fileList", void 0, { passive: !0 }), o = (m) => n.value.find((h) => h.uid === m.uid);
    function l(m) {
      var h;
      (h = t.value) == null || h.abort(m);
    }
    function a(m = ["ready", "uploading", "success", "fail"]) {
      n.value = n.value.filter((h) => !m.includes(h.status));
    }
    function r(m) {
      n.value = n.value.filter((h) => h.uid !== m.uid);
    }
    const i = (m) => {
      Re(() => e.onChange(m, n.value));
    }, u = (m, h) => {
      const g = o(h);
      g && (console.error(m), g.status = "fail", r(g), e.onError(m, g, n.value), i(g));
    }, c = (m, h) => {
      const g = o(h);
      g && (e.onProgress(m, g, n.value), g.status = "uploading", g.percentage = Math.round(m.percent));
    }, d = (m, h) => {
      const g = o(h);
      g && (g.status = "success", g.response = m, e.onSuccess(m, g, n.value), i(g));
    }, f = (m) => {
      cn(m.uid) && (m.uid = vv());
      const h = {
        name: m.name,
        percentage: 0,
        status: "ready",
        size: m.size,
        raw: m,
        uid: m.uid
      };
      if (e.listType === "picture-card" || e.listType === "picture")
        try {
          h.url = URL.createObjectURL(m);
        } catch (g) {
          vt(i0, g.message), e.onError(g, h, n.value);
        }
      n.value = [...n.value, h], i(h);
    }, v = async (m) => {
      const h = m instanceof File ? o(m) : m;
      h || Zt(i0, "file to be removed not found");
      const g = (b) => {
        l(b), r(b), e.onRemove(b, n.value), u0(b);
      };
      e.beforeRemove ? await e.beforeRemove(h, n.value) !== !1 && g(h) : g(h);
    };
    function p() {
      n.value.filter(({ status: m }) => m === "ready").forEach(({ raw: m }) => {
        var h;
        return m && ((h = t.value) == null ? void 0 : h.upload(m));
      });
    }
    return de(() => e.listType, (m) => {
      m !== "picture-card" && m !== "picture" || (n.value = n.value.map((h) => {
        const { raw: g, url: b } = h;
        if (!b && g)
          try {
            h.url = URL.createObjectURL(g);
          } catch (C) {
            e.onError(C, h, n.value);
          }
        return h;
      }));
    }), de(n, (m) => {
      for (const h of m)
        h.uid || (h.uid = vv()), h.status || (h.status = "success");
    }, { immediate: !0, deep: !0 }), {
      uploadFiles: n,
      abort: l,
      clearFiles: a,
      handleError: u,
      handleProgress: c,
      handleStart: f,
      handleSuccess: d,
      handleRemove: v,
      submit: p,
      revokeFileObjectURL: u0
    };
  }, nq = /* @__PURE__ */ U({
    name: "ElUpload"
  }), oq = /* @__PURE__ */ U({
    ...nq,
    props: HY,
    setup(e, { expose: t }) {
      const n = e, o = Cn(), l = Ut(), {
        abort: a,
        submit: r,
        clearFiles: i,
        uploadFiles: u,
        handleStart: c,
        handleError: d,
        handleRemove: f,
        handleSuccess: v,
        handleProgress: p,
        revokeFileObjectURL: m
      } = tq(n, l), h = S(() => n.listType === "picture-card"), g = S(() => ({
        ...n,
        fileList: u.value,
        onStart: c,
        onProgress: p,
        onSuccess: v,
        onError: d,
        onRemove: f
      }));
      return Bt(() => {
        u.value.forEach(m);
      }), yt(i_, {
        accept: At(n, "accept")
      }), t({
        abort: a,
        submit: r,
        clearFiles: i,
        handleStart: c,
        handleRemove: f
      }), (b, C) => (_(), B("div", null, [
        s(h) && b.showFileList ? (_(), ae(r0, {
          key: 0,
          disabled: s(o),
          "list-type": b.listType,
          files: s(u),
          crossorigin: b.crossorigin,
          "handle-preview": b.onPreview,
          onRemove: s(f)
        }, io({
          append: Q(() => [
            q(s0, pt({
              ref_key: "uploadRef",
              ref: l
            }, s(g)), {
              default: Q(() => [
                b.$slots.trigger ? ee(b.$slots, "trigger", { key: 0 }) : oe("v-if", !0),
                !b.$slots.trigger && b.$slots.default ? ee(b.$slots, "default", { key: 1 }) : oe("v-if", !0)
              ]),
              _: 3
            }, 16)
          ]),
          _: 2
        }, [
          b.$slots.file ? {
            name: "default",
            fn: Q(({ file: w, index: y }) => [
              ee(b.$slots, "file", {
                file: w,
                index: y
              })
            ])
          } : void 0
        ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : oe("v-if", !0),
        !s(h) || s(h) && !b.showFileList ? (_(), ae(s0, pt({
          key: 1,
          ref_key: "uploadRef",
          ref: l
        }, s(g)), {
          default: Q(() => [
            b.$slots.trigger ? ee(b.$slots, "trigger", { key: 0 }) : oe("v-if", !0),
            !b.$slots.trigger && b.$slots.default ? ee(b.$slots, "default", { key: 1 }) : oe("v-if", !0)
          ]),
          _: 3
        }, 16)) : oe("v-if", !0),
        b.$slots.trigger ? ee(b.$slots, "default", { key: 2 }) : oe("v-if", !0),
        ee(b.$slots, "tip"),
        !s(h) && b.showFileList ? (_(), ae(r0, {
          key: 3,
          disabled: s(o),
          "list-type": b.listType,
          files: s(u),
          crossorigin: b.crossorigin,
          "handle-preview": b.onPreview,
          onRemove: s(f)
        }, io({
          _: 2
        }, [
          b.$slots.file ? {
            name: "default",
            fn: Q(({ file: w, index: y }) => [
              ee(b.$slots, "file", {
                file: w,
                index: y
              })
            ])
          } : void 0
        ]), 1032, ["disabled", "list-type", "files", "crossorigin", "handle-preview", "onRemove"])) : oe("v-if", !0)
      ]));
    }
  });
  var lq = /* @__PURE__ */ Ne(oq, [["__file", "upload.vue"]]);
  const aq = rt(lq), rq = Te({
    zIndex: {
      type: Number,
      default: 9
    },
    rotate: {
      type: Number,
      default: -22
    },
    width: Number,
    height: Number,
    image: String,
    content: {
      type: X([String, Array]),
      default: "Element Plus"
    },
    font: {
      type: X(Object)
    },
    gap: {
      type: X(Array),
      default: () => [100, 100]
    },
    offset: {
      type: X(Array)
    }
  });
  function sq(e) {
    return e.replace(/([A-Z])/g, "-$1").toLowerCase();
  }
  function iq(e) {
    return Object.keys(e).map((t) => `${sq(t)}: ${e[t]};`).join(" ");
  }
  function uq() {
    return window.devicePixelRatio || 1;
  }
  const cq = (e, t) => {
    let n = !1;
    return e.removedNodes.length && t && (n = Array.from(e.removedNodes).includes(t)), e.type === "attributes" && e.target === t && (n = !0), n;
  }, dq = {
    left: [0, 0.5],
    start: [0, 0.5],
    center: [0.5, 0],
    right: [1, -0.5],
    end: [1, -0.5]
  };
  function Yf(e, t, n = 1) {
    const o = document.createElement("canvas"), l = o.getContext("2d"), a = e * n, r = t * n;
    return o.setAttribute("width", `${a}px`), o.setAttribute("height", `${r}px`), l.save(), [l, o, a, r];
  }
  function fq() {
    function e(t, n, o, l, a, r, i, u, c) {
      const [d, f, v, p] = Yf(l, a, o);
      let m = 0;
      if (t instanceof HTMLImageElement)
        d.drawImage(t, 0, 0, v, p);
      else {
        const {
          color: K,
          fontSize: Z,
          fontStyle: J,
          fontWeight: ie,
          fontFamily: ue,
          textAlign: re,
          textBaseline: se
        } = r, ne = Number(Z) * o;
        d.font = `${J} normal ${ie} ${ne}px/${a}px ${ue}`, d.fillStyle = K, d.textAlign = re, d.textBaseline = se;
        const le = ye(t) ? t : [t];
        if (se !== "top" && le[0]) {
          const Ce = d.measureText(le[0]);
          d.textBaseline = "top";
          const j = d.measureText(le[0]);
          m = Ce.actualBoundingBoxAscent - j.actualBoundingBoxAscent;
        }
        le == null || le.forEach((Ce, j) => {
          const [te, ce] = dq[re];
          d.fillText(Ce ?? "", v * te + c * ce, j * (ne + r.fontGap * o));
        });
      }
      const h = Math.PI / 180 * Number(n), g = Math.max(l, a), [b, C, w] = Yf(g, g, o);
      b.translate(w / 2, w / 2), b.rotate(h), v > 0 && p > 0 && b.drawImage(f, -v / 2, -p / 2);
      function y(K, Z) {
        const J = K * Math.cos(h) - Z * Math.sin(h), ie = K * Math.sin(h) + Z * Math.cos(h);
        return [J, ie];
      }
      let E = 0, k = 0, T = 0, x = 0;
      const I = v / 2, P = p / 2;
      [
        [0 - I, 0 - P],
        [0 + I, 0 - P],
        [0 + I, 0 + P],
        [0 - I, 0 + P]
      ].forEach(([K, Z]) => {
        const [J, ie] = y(K, Z);
        E = Math.min(E, J), k = Math.max(k, J), T = Math.min(T, ie), x = Math.max(x, ie);
      });
      const N = E + w / 2, z = T + w / 2, Y = k - E, G = x - T, M = i * o, R = u * o, D = (Y + M) * 2, L = G + R, [V, F] = Yf(D, L);
      function H(K = 0, Z = 0) {
        V.drawImage(C, N, z, Y, G, K, Z + m, Y, G);
      }
      return H(), H(Y + M, -G / 2 - R / 2), H(Y + M, +G / 2 + R / 2), [F.toDataURL(), D / o, L / o];
    }
    return e;
  }
  const pq = /* @__PURE__ */ U({
    name: "ElWatermark"
  }), vq = /* @__PURE__ */ U({
    ...pq,
    props: rq,
    setup(e) {
      const t = e, n = {
        position: "relative"
      }, o = S(() => {
        var O, N;
        return (N = (O = t.font) == null ? void 0 : O.fontGap) != null ? N : 3;
      }), l = S(() => {
        var O, N;
        return (N = (O = t.font) == null ? void 0 : O.color) != null ? N : "rgba(0,0,0,.15)";
      }), a = S(() => {
        var O, N;
        return (N = (O = t.font) == null ? void 0 : O.fontSize) != null ? N : 16;
      }), r = S(() => {
        var O, N;
        return (N = (O = t.font) == null ? void 0 : O.fontWeight) != null ? N : "normal";
      }), i = S(() => {
        var O, N;
        return (N = (O = t.font) == null ? void 0 : O.fontStyle) != null ? N : "normal";
      }), u = S(() => {
        var O, N;
        return (N = (O = t.font) == null ? void 0 : O.fontFamily) != null ? N : "sans-serif";
      }), c = S(() => {
        var O, N;
        return (N = (O = t.font) == null ? void 0 : O.textAlign) != null ? N : "center";
      }), d = S(() => {
        var O, N;
        return (N = (O = t.font) == null ? void 0 : O.textBaseline) != null ? N : "hanging";
      }), f = S(() => t.gap[0]), v = S(() => t.gap[1]), p = S(() => f.value / 2), m = S(() => v.value / 2), h = S(() => {
        var O, N;
        return (N = (O = t.offset) == null ? void 0 : O[0]) != null ? N : p.value;
      }), g = S(() => {
        var O, N;
        return (N = (O = t.offset) == null ? void 0 : O[1]) != null ? N : m.value;
      }), b = () => {
        const O = {
          zIndex: t.zIndex,
          position: "absolute",
          left: 0,
          top: 0,
          width: "100%",
          height: "100%",
          pointerEvents: "none",
          backgroundRepeat: "repeat"
        };
        let N = h.value - p.value, z = g.value - m.value;
        return N > 0 && (O.left = `${N}px`, O.width = `calc(100% - ${N}px)`, N = 0), z > 0 && (O.top = `${z}px`, O.height = `calc(100% - ${z}px)`, z = 0), O.backgroundPosition = `${N}px ${z}px`, O;
      }, C = Ut(null), w = Ut(), y = A(!1), E = () => {
        w.value && (w.value.remove(), w.value = void 0);
      }, k = (O, N) => {
        var z;
        C.value && w.value && (y.value = !0, w.value.setAttribute("style", iq({
          ...b(),
          backgroundImage: `url('${O}')`,
          backgroundSize: `${Math.floor(N)}px`
        })), (z = C.value) == null || z.append(w.value), setTimeout(() => {
          y.value = !1;
        }));
      }, T = (O) => {
        let N = 120, z = 64, Y = 0;
        const { image: G, content: M, width: R, height: D, rotate: L } = t;
        if (!G && O.measureText) {
          O.font = `${Number(a.value)}px ${u.value}`;
          const V = ye(M) ? M : [M];
          let F = 0, H = 0;
          V.forEach((Z) => {
            const {
              width: J,
              fontBoundingBoxAscent: ie,
              fontBoundingBoxDescent: ue,
              actualBoundingBoxAscent: re,
              actualBoundingBoxDescent: se
            } = O.measureText(Z), ne = kt(ie) ? re + se : ie + ue;
            J > F && (F = Math.ceil(J)), ne > H && (H = Math.ceil(ne));
          }), N = F, z = H * V.length + (V.length - 1) * o.value;
          const K = Math.PI / 180 * Number(L);
          Y = Math.ceil(Math.abs(Math.sin(K) * z) / 2), N += Y;
        }
        return [R ?? N, D ?? z, Y];
      }, x = fq(), I = () => {
        const N = document.createElement("canvas").getContext("2d"), z = t.image, Y = t.content, G = t.rotate;
        if (N) {
          w.value || (w.value = document.createElement("div"));
          const M = uq(), [R, D, L] = T(N), V = (F) => {
            const [H, K] = x(F || "", G, M, R, D, {
              color: l.value,
              fontSize: a.value,
              fontStyle: i.value,
              fontWeight: r.value,
              fontFamily: u.value,
              fontGap: o.value,
              textAlign: c.value,
              textBaseline: d.value
            }, f.value, v.value, L);
            k(H, K);
          };
          if (z) {
            const F = new Image();
            F.onload = () => {
              V(F);
            }, F.onerror = () => {
              V(Y);
            }, F.crossOrigin = "anonymous", F.referrerPolicy = "no-referrer", F.src = z;
          } else
            V(Y);
        }
      };
      return ft(() => {
        I();
      }), de(() => t, () => {
        I();
      }, {
        deep: !0,
        flush: "post"
      }), Bt(() => {
        E();
      }), Q1(C, (O) => {
        y.value || O.forEach((N) => {
          cq(N, w.value) && (E(), I());
        });
      }, {
        attributes: !0,
        subtree: !0,
        childList: !0
      }), (O, N) => (_(), B("div", {
        ref_key: "containerRef",
        ref: C,
        style: Ue([n])
      }, [
        ee(O.$slots, "default")
      ], 4));
    }
  });
  var hq = /* @__PURE__ */ Ne(vq, [["__file", "watermark.vue"]]);
  const mq = rt(hq), gq = Te({
    zIndex: {
      type: Number,
      default: 1001
    },
    visible: Boolean,
    fill: {
      type: String,
      default: "rgba(0,0,0,0.5)"
    },
    pos: {
      type: X(Object)
    },
    targetAreaClickable: {
      type: Boolean,
      default: !0
    }
  }), vs = Math.min, sr = Math.max, ld = Math.round, Hu = Math.floor, ml = (e) => ({
    x: e,
    y: e
  }), bq = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  }, yq = {
    start: "end",
    end: "start"
  };
  function hv(e, t, n) {
    return sr(e, vs(t, n));
  }
  function mu(e, t) {
    return typeof e == "function" ? e(t) : e;
  }
  function vr(e) {
    return e.split("-")[0];
  }
  function gu(e) {
    return e.split("-")[1];
  }
  function f_(e) {
    return e === "x" ? "y" : "x";
  }
  function wm(e) {
    return e === "y" ? "height" : "width";
  }
  const wq = /* @__PURE__ */ new Set(["top", "bottom"]);
  function Ca(e) {
    return wq.has(vr(e)) ? "y" : "x";
  }
  function Cm(e) {
    return f_(Ca(e));
  }
  function Cq(e, t, n) {
    n === void 0 && (n = !1);
    const o = gu(e), l = Cm(e), a = wm(l);
    let r = l === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
    return t.reference[a] > t.floating[a] && (r = ad(r)), [r, ad(r)];
  }
  function Sq(e) {
    const t = ad(e);
    return [mv(e), t, mv(t)];
  }
  function mv(e) {
    return e.replace(/start|end/g, (t) => yq[t]);
  }
  const c0 = ["left", "right"], d0 = ["right", "left"], Eq = ["top", "bottom"], kq = ["bottom", "top"];
  function _q(e, t, n) {
    switch (e) {
      case "top":
      case "bottom":
        return n ? t ? d0 : c0 : t ? c0 : d0;
      case "left":
      case "right":
        return t ? Eq : kq;
      default:
        return [];
    }
  }
  function Tq(e, t, n, o) {
    const l = gu(e);
    let a = _q(vr(e), n === "start", o);
    return l && (a = a.map((r) => r + "-" + l), t && (a = a.concat(a.map(mv)))), a;
  }
  function ad(e) {
    return e.replace(/left|right|bottom|top/g, (t) => bq[t]);
  }
  function Nq(e) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...e
    };
  }
  function p_(e) {
    return typeof e != "number" ? Nq(e) : {
      top: e,
      right: e,
      bottom: e,
      left: e
    };
  }
  function rd(e) {
    const {
      x: t,
      y: n,
      width: o,
      height: l
    } = e;
    return {
      width: o,
      height: l,
      top: n,
      left: t,
      right: t + o,
      bottom: n + l,
      x: t,
      y: n
    };
  }
  function f0(e, t, n) {
    let {
      reference: o,
      floating: l
    } = e;
    const a = Ca(t), r = Cm(t), i = wm(r), u = vr(t), c = a === "y", d = o.x + o.width / 2 - l.width / 2, f = o.y + o.height / 2 - l.height / 2, v = o[i] / 2 - l[i] / 2;
    let p;
    switch (u) {
      case "top":
        p = {
          x: d,
          y: o.y - l.height
        };
        break;
      case "bottom":
        p = {
          x: d,
          y: o.y + o.height
        };
        break;
      case "right":
        p = {
          x: o.x + o.width,
          y: f
        };
        break;
      case "left":
        p = {
          x: o.x - l.width,
          y: f
        };
        break;
      default:
        p = {
          x: o.x,
          y: o.y
        };
    }
    switch (gu(t)) {
      case "start":
        p[r] -= v * (n && c ? -1 : 1);
        break;
      case "end":
        p[r] += v * (n && c ? -1 : 1);
        break;
    }
    return p;
  }
  const $q = async (e, t, n) => {
    const {
      placement: o = "bottom",
      strategy: l = "absolute",
      middleware: a = [],
      platform: r
    } = n, i = a.filter(Boolean), u = await (r.isRTL == null ? void 0 : r.isRTL(t));
    let c = await r.getElementRects({
      reference: e,
      floating: t,
      strategy: l
    }), {
      x: d,
      y: f
    } = f0(c, o, u), v = o, p = {}, m = 0;
    for (let h = 0; h < i.length; h++) {
      const {
        name: g,
        fn: b
      } = i[h], {
        x: C,
        y: w,
        data: y,
        reset: E
      } = await b({
        x: d,
        y: f,
        initialPlacement: o,
        placement: v,
        strategy: l,
        middlewareData: p,
        rects: c,
        platform: r,
        elements: {
          reference: e,
          floating: t
        }
      });
      d = C ?? d, f = w ?? f, p = {
        ...p,
        [g]: {
          ...p[g],
          ...y
        }
      }, E && m <= 50 && (m++, typeof E == "object" && (E.placement && (v = E.placement), E.rects && (c = E.rects === !0 ? await r.getElementRects({
        reference: e,
        floating: t,
        strategy: l
      }) : E.rects), {
        x: d,
        y: f
      } = f0(c, v, u)), h = -1);
    }
    return {
      x: d,
      y: f,
      placement: v,
      strategy: l,
      middlewareData: p
    };
  };
  async function Sm(e, t) {
    var n;
    t === void 0 && (t = {});
    const {
      x: o,
      y: l,
      platform: a,
      rects: r,
      elements: i,
      strategy: u
    } = e, {
      boundary: c = "clippingAncestors",
      rootBoundary: d = "viewport",
      elementContext: f = "floating",
      altBoundary: v = !1,
      padding: p = 0
    } = mu(t, e), m = p_(p), g = i[v ? f === "floating" ? "reference" : "floating" : f], b = rd(await a.getClippingRect({
      element: (n = await (a.isElement == null ? void 0 : a.isElement(g))) == null || n ? g : g.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(i.floating)),
      boundary: c,
      rootBoundary: d,
      strategy: u
    })), C = f === "floating" ? {
      x: o,
      y: l,
      width: r.floating.width,
      height: r.floating.height
    } : r.reference, w = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(i.floating)), y = await (a.isElement == null ? void 0 : a.isElement(w)) ? await (a.getScale == null ? void 0 : a.getScale(w)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    }, E = rd(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements: i,
      rect: C,
      offsetParent: w,
      strategy: u
    }) : C);
    return {
      top: (b.top - E.top + m.top) / y.y,
      bottom: (E.bottom - b.bottom + m.bottom) / y.y,
      left: (b.left - E.left + m.left) / y.x,
      right: (E.right - b.right + m.right) / y.x
    };
  }
  const Oq = (e) => ({
    name: "arrow",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: o,
        placement: l,
        rects: a,
        platform: r,
        elements: i,
        middlewareData: u
      } = t, {
        element: c,
        padding: d = 0
      } = mu(e, t) || {};
      if (c == null)
        return {};
      const f = p_(d), v = {
        x: n,
        y: o
      }, p = Cm(l), m = wm(p), h = await r.getDimensions(c), g = p === "y", b = g ? "top" : "left", C = g ? "bottom" : "right", w = g ? "clientHeight" : "clientWidth", y = a.reference[m] + a.reference[p] - v[p] - a.floating[m], E = v[p] - a.reference[p], k = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(c));
      let T = k ? k[w] : 0;
      (!T || !await (r.isElement == null ? void 0 : r.isElement(k))) && (T = i.floating[w] || a.floating[m]);
      const x = y / 2 - E / 2, I = T / 2 - h[m] / 2 - 1, P = vs(f[b], I), O = vs(f[C], I), N = P, z = T - h[m] - O, Y = T / 2 - h[m] / 2 + x, G = hv(N, Y, z), M = !u.arrow && gu(l) != null && Y !== G && a.reference[m] / 2 - (Y < N ? P : O) - h[m] / 2 < 0, R = M ? Y < N ? Y - N : Y - z : 0;
      return {
        [p]: v[p] + R,
        data: {
          [p]: G,
          centerOffset: Y - G - R,
          ...M && {
            alignmentOffset: R
          }
        },
        reset: M
      };
    }
  }), Iq = function(e) {
    return e === void 0 && (e = {}), {
      name: "flip",
      options: e,
      async fn(t) {
        var n, o;
        const {
          placement: l,
          middlewareData: a,
          rects: r,
          initialPlacement: i,
          platform: u,
          elements: c
        } = t, {
          mainAxis: d = !0,
          crossAxis: f = !0,
          fallbackPlacements: v,
          fallbackStrategy: p = "bestFit",
          fallbackAxisSideDirection: m = "none",
          flipAlignment: h = !0,
          ...g
        } = mu(e, t);
        if ((n = a.arrow) != null && n.alignmentOffset)
          return {};
        const b = vr(l), C = Ca(i), w = vr(i) === i, y = await (u.isRTL == null ? void 0 : u.isRTL(c.floating)), E = v || (w || !h ? [ad(i)] : Sq(i)), k = m !== "none";
        !v && k && E.push(...Tq(i, h, m, y));
        const T = [i, ...E], x = await Sm(t, g), I = [];
        let P = ((o = a.flip) == null ? void 0 : o.overflows) || [];
        if (d && I.push(x[b]), f) {
          const Y = Cq(l, r, y);
          I.push(x[Y[0]], x[Y[1]]);
        }
        if (P = [...P, {
          placement: l,
          overflows: I
        }], !I.every((Y) => Y <= 0)) {
          var O, N;
          const Y = (((O = a.flip) == null ? void 0 : O.index) || 0) + 1, G = T[Y];
          if (G && (!(f === "alignment" ? C !== Ca(G) : !1) || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          P.every((D) => Ca(D.placement) === C ? D.overflows[0] > 0 : !0)))
            return {
              data: {
                index: Y,
                overflows: P
              },
              reset: {
                placement: G
              }
            };
          let M = (N = P.filter((R) => R.overflows[0] <= 0).sort((R, D) => R.overflows[1] - D.overflows[1])[0]) == null ? void 0 : N.placement;
          if (!M)
            switch (p) {
              case "bestFit": {
                var z;
                const R = (z = P.filter((D) => {
                  if (k) {
                    const L = Ca(D.placement);
                    return L === C || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    L === "y";
                  }
                  return !0;
                }).map((D) => [D.placement, D.overflows.filter((L) => L > 0).reduce((L, V) => L + V, 0)]).sort((D, L) => D[1] - L[1])[0]) == null ? void 0 : z[0];
                R && (M = R);
                break;
              }
              case "initialPlacement":
                M = i;
                break;
            }
          if (l !== M)
            return {
              reset: {
                placement: M
              }
            };
        }
        return {};
      }
    };
  }, Mq = /* @__PURE__ */ new Set(["left", "top"]);
  async function xq(e, t) {
    const {
      placement: n,
      platform: o,
      elements: l
    } = e, a = await (o.isRTL == null ? void 0 : o.isRTL(l.floating)), r = vr(n), i = gu(n), u = Ca(n) === "y", c = Mq.has(r) ? -1 : 1, d = a && u ? -1 : 1, f = mu(t, e);
    let {
      mainAxis: v,
      crossAxis: p,
      alignmentAxis: m
    } = typeof f == "number" ? {
      mainAxis: f,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: f.mainAxis || 0,
      crossAxis: f.crossAxis || 0,
      alignmentAxis: f.alignmentAxis
    };
    return i && typeof m == "number" && (p = i === "end" ? m * -1 : m), u ? {
      x: p * d,
      y: v * c
    } : {
      x: v * c,
      y: p * d
    };
  }
  const Pq = function(e) {
    return e === void 0 && (e = 0), {
      name: "offset",
      options: e,
      async fn(t) {
        var n, o;
        const {
          x: l,
          y: a,
          placement: r,
          middlewareData: i
        } = t, u = await xq(t, e);
        return r === ((n = i.offset) == null ? void 0 : n.placement) && (o = i.arrow) != null && o.alignmentOffset ? {} : {
          x: l + u.x,
          y: a + u.y,
          data: {
            ...u,
            placement: r
          }
        };
      }
    };
  }, Rq = function(e) {
    return e === void 0 && (e = {}), {
      name: "shift",
      options: e,
      async fn(t) {
        const {
          x: n,
          y: o,
          placement: l
        } = t, {
          mainAxis: a = !0,
          crossAxis: r = !1,
          limiter: i = {
            fn: (g) => {
              let {
                x: b,
                y: C
              } = g;
              return {
                x: b,
                y: C
              };
            }
          },
          ...u
        } = mu(e, t), c = {
          x: n,
          y: o
        }, d = await Sm(t, u), f = Ca(vr(l)), v = f_(f);
        let p = c[v], m = c[f];
        if (a) {
          const g = v === "y" ? "top" : "left", b = v === "y" ? "bottom" : "right", C = p + d[g], w = p - d[b];
          p = hv(C, p, w);
        }
        if (r) {
          const g = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", C = m + d[g], w = m - d[b];
          m = hv(C, m, w);
        }
        const h = i.fn({
          ...t,
          [v]: p,
          [f]: m
        });
        return {
          ...h,
          data: {
            x: h.x - n,
            y: h.y - o,
            enabled: {
              [v]: a,
              [f]: r
            }
          }
        };
      }
    };
  };
  function Gd() {
    return typeof window < "u";
  }
  function Ns(e) {
    return v_(e) ? (e.nodeName || "").toLowerCase() : "#document";
  }
  function bo(e) {
    var t;
    return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
  }
  function $l(e) {
    var t;
    return (t = (v_(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
  }
  function v_(e) {
    return Gd() ? e instanceof Node || e instanceof bo(e).Node : !1;
  }
  function Jo(e) {
    return Gd() ? e instanceof Element || e instanceof bo(e).Element : !1;
  }
  function kl(e) {
    return Gd() ? e instanceof HTMLElement || e instanceof bo(e).HTMLElement : !1;
  }
  function p0(e) {
    return !Gd() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof bo(e).ShadowRoot;
  }
  const Dq = /* @__PURE__ */ new Set(["inline", "contents"]);
  function bu(e) {
    const {
      overflow: t,
      overflowX: n,
      overflowY: o,
      display: l
    } = Zo(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !Dq.has(l);
  }
  const Aq = /* @__PURE__ */ new Set(["table", "td", "th"]);
  function Vq(e) {
    return Aq.has(Ns(e));
  }
  const Lq = [":popover-open", ":modal"];
  function Xd(e) {
    return Lq.some((t) => {
      try {
        return e.matches(t);
      } catch {
        return !1;
      }
    });
  }
  const Bq = ["transform", "translate", "scale", "rotate", "perspective"], Fq = ["transform", "translate", "scale", "rotate", "perspective", "filter"], zq = ["paint", "layout", "strict", "content"];
  function Em(e) {
    const t = km(), n = Jo(e) ? Zo(e) : e;
    return Bq.some((o) => n[o] ? n[o] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || Fq.some((o) => (n.willChange || "").includes(o)) || zq.some((o) => (n.contain || "").includes(o));
  }
  function Hq(e) {
    let t = xa(e);
    for (; kl(t) && !hs(t); ) {
      if (Em(t))
        return t;
      if (Xd(t))
        return null;
      t = xa(t);
    }
    return null;
  }
  function km() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
  }
  const Kq = /* @__PURE__ */ new Set(["html", "body", "#document"]);
  function hs(e) {
    return Kq.has(Ns(e));
  }
  function Zo(e) {
    return bo(e).getComputedStyle(e);
  }
  function Jd(e) {
    return Jo(e) ? {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTop
    } : {
      scrollLeft: e.scrollX,
      scrollTop: e.scrollY
    };
  }
  function xa(e) {
    if (Ns(e) === "html")
      return e;
    const t = (
      // Step into the shadow DOM of the parent of a slotted node.
      e.assignedSlot || // DOM Element detected.
      e.parentNode || // ShadowRoot detected.
      p0(e) && e.host || // Fallback.
      $l(e)
    );
    return p0(t) ? t.host : t;
  }
  function h_(e) {
    const t = xa(e);
    return hs(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : kl(t) && bu(t) ? t : h_(t);
  }
  function Bi(e, t, n) {
    var o;
    t === void 0 && (t = []), n === void 0 && (n = !0);
    const l = h_(e), a = l === ((o = e.ownerDocument) == null ? void 0 : o.body), r = bo(l);
    if (a) {
      const i = gv(r);
      return t.concat(r, r.visualViewport || [], bu(l) ? l : [], i && n ? Bi(i) : []);
    }
    return t.concat(l, Bi(l, [], n));
  }
  function gv(e) {
    return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
  }
  function m_(e) {
    const t = Zo(e);
    let n = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0;
    const l = kl(e), a = l ? e.offsetWidth : n, r = l ? e.offsetHeight : o, i = ld(n) !== a || ld(o) !== r;
    return i && (n = a, o = r), {
      width: n,
      height: o,
      $: i
    };
  }
  function _m(e) {
    return Jo(e) ? e : e.contextElement;
  }
  function Xr(e) {
    const t = _m(e);
    if (!kl(t))
      return ml(1);
    const n = t.getBoundingClientRect(), {
      width: o,
      height: l,
      $: a
    } = m_(t);
    let r = (a ? ld(n.width) : n.width) / o, i = (a ? ld(n.height) : n.height) / l;
    return (!r || !Number.isFinite(r)) && (r = 1), (!i || !Number.isFinite(i)) && (i = 1), {
      x: r,
      y: i
    };
  }
  const Wq = /* @__PURE__ */ ml(0);
  function g_(e) {
    const t = bo(e);
    return !km() || !t.visualViewport ? Wq : {
      x: t.visualViewport.offsetLeft,
      y: t.visualViewport.offsetTop
    };
  }
  function jq(e, t, n) {
    return t === void 0 && (t = !1), !n || t && n !== bo(e) ? !1 : t;
  }
  function hr(e, t, n, o) {
    t === void 0 && (t = !1), n === void 0 && (n = !1);
    const l = e.getBoundingClientRect(), a = _m(e);
    let r = ml(1);
    t && (o ? Jo(o) && (r = Xr(o)) : r = Xr(e));
    const i = jq(a, n, o) ? g_(a) : ml(0);
    let u = (l.left + i.x) / r.x, c = (l.top + i.y) / r.y, d = l.width / r.x, f = l.height / r.y;
    if (a) {
      const v = bo(a), p = o && Jo(o) ? bo(o) : o;
      let m = v, h = gv(m);
      for (; h && o && p !== m; ) {
        const g = Xr(h), b = h.getBoundingClientRect(), C = Zo(h), w = b.left + (h.clientLeft + parseFloat(C.paddingLeft)) * g.x, y = b.top + (h.clientTop + parseFloat(C.paddingTop)) * g.y;
        u *= g.x, c *= g.y, d *= g.x, f *= g.y, u += w, c += y, m = bo(h), h = gv(m);
      }
    }
    return rd({
      width: d,
      height: f,
      x: u,
      y: c
    });
  }
  function Zd(e, t) {
    const n = Jd(e).scrollLeft;
    return t ? t.left + n : hr($l(e)).left + n;
  }
  function b_(e, t) {
    const n = e.getBoundingClientRect(), o = n.left + t.scrollLeft - Zd(e, n), l = n.top + t.scrollTop;
    return {
      x: o,
      y: l
    };
  }
  function Uq(e) {
    let {
      elements: t,
      rect: n,
      offsetParent: o,
      strategy: l
    } = e;
    const a = l === "fixed", r = $l(o), i = t ? Xd(t.floating) : !1;
    if (o === r || i && a)
      return n;
    let u = {
      scrollLeft: 0,
      scrollTop: 0
    }, c = ml(1);
    const d = ml(0), f = kl(o);
    if ((f || !f && !a) && ((Ns(o) !== "body" || bu(r)) && (u = Jd(o)), kl(o))) {
      const p = hr(o);
      c = Xr(o), d.x = p.x + o.clientLeft, d.y = p.y + o.clientTop;
    }
    const v = r && !f && !a ? b_(r, u) : ml(0);
    return {
      width: n.width * c.x,
      height: n.height * c.y,
      x: n.x * c.x - u.scrollLeft * c.x + d.x + v.x,
      y: n.y * c.y - u.scrollTop * c.y + d.y + v.y
    };
  }
  function Yq(e) {
    return Array.from(e.getClientRects());
  }
  function qq(e) {
    const t = $l(e), n = Jd(e), o = e.ownerDocument.body, l = sr(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), a = sr(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
    let r = -n.scrollLeft + Zd(e);
    const i = -n.scrollTop;
    return Zo(o).direction === "rtl" && (r += sr(t.clientWidth, o.clientWidth) - l), {
      width: l,
      height: a,
      x: r,
      y: i
    };
  }
  const v0 = 25;
  function Gq(e, t) {
    const n = bo(e), o = $l(e), l = n.visualViewport;
    let a = o.clientWidth, r = o.clientHeight, i = 0, u = 0;
    if (l) {
      a = l.width, r = l.height;
      const d = km();
      (!d || d && t === "fixed") && (i = l.offsetLeft, u = l.offsetTop);
    }
    const c = Zd(o);
    if (c <= 0) {
      const d = o.ownerDocument, f = d.body, v = getComputedStyle(f), p = d.compatMode === "CSS1Compat" && parseFloat(v.marginLeft) + parseFloat(v.marginRight) || 0, m = Math.abs(o.clientWidth - f.clientWidth - p);
      m <= v0 && (a -= m);
    } else c <= v0 && (a += c);
    return {
      width: a,
      height: r,
      x: i,
      y: u
    };
  }
  const Xq = /* @__PURE__ */ new Set(["absolute", "fixed"]);
  function Jq(e, t) {
    const n = hr(e, !0, t === "fixed"), o = n.top + e.clientTop, l = n.left + e.clientLeft, a = kl(e) ? Xr(e) : ml(1), r = e.clientWidth * a.x, i = e.clientHeight * a.y, u = l * a.x, c = o * a.y;
    return {
      width: r,
      height: i,
      x: u,
      y: c
    };
  }
  function h0(e, t, n) {
    let o;
    if (t === "viewport")
      o = Gq(e, n);
    else if (t === "document")
      o = qq($l(e));
    else if (Jo(t))
      o = Jq(t, n);
    else {
      const l = g_(e);
      o = {
        x: t.x - l.x,
        y: t.y - l.y,
        width: t.width,
        height: t.height
      };
    }
    return rd(o);
  }
  function y_(e, t) {
    const n = xa(e);
    return n === t || !Jo(n) || hs(n) ? !1 : Zo(n).position === "fixed" || y_(n, t);
  }
  function Zq(e, t) {
    const n = t.get(e);
    if (n)
      return n;
    let o = Bi(e, [], !1).filter((i) => Jo(i) && Ns(i) !== "body"), l = null;
    const a = Zo(e).position === "fixed";
    let r = a ? xa(e) : e;
    for (; Jo(r) && !hs(r); ) {
      const i = Zo(r), u = Em(r);
      !u && i.position === "fixed" && (l = null), (a ? !u && !l : !u && i.position === "static" && !!l && Xq.has(l.position) || bu(r) && !u && y_(e, r)) ? o = o.filter((d) => d !== r) : l = i, r = xa(r);
    }
    return t.set(e, o), o;
  }
  function Qq(e) {
    let {
      element: t,
      boundary: n,
      rootBoundary: o,
      strategy: l
    } = e;
    const r = [...n === "clippingAncestors" ? Xd(t) ? [] : Zq(t, this._c) : [].concat(n), o], i = r[0], u = r.reduce((c, d) => {
      const f = h0(t, d, l);
      return c.top = sr(f.top, c.top), c.right = vs(f.right, c.right), c.bottom = vs(f.bottom, c.bottom), c.left = sr(f.left, c.left), c;
    }, h0(t, i, l));
    return {
      width: u.right - u.left,
      height: u.bottom - u.top,
      x: u.left,
      y: u.top
    };
  }
  function eG(e) {
    const {
      width: t,
      height: n
    } = m_(e);
    return {
      width: t,
      height: n
    };
  }
  function tG(e, t, n) {
    const o = kl(t), l = $l(t), a = n === "fixed", r = hr(e, !0, a, t);
    let i = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const u = ml(0);
    function c() {
      u.x = Zd(l);
    }
    if (o || !o && !a)
      if ((Ns(t) !== "body" || bu(l)) && (i = Jd(t)), o) {
        const p = hr(t, !0, a, t);
        u.x = p.x + t.clientLeft, u.y = p.y + t.clientTop;
      } else l && c();
    a && !o && l && c();
    const d = l && !o && !a ? b_(l, i) : ml(0), f = r.left + i.scrollLeft - u.x - d.x, v = r.top + i.scrollTop - u.y - d.y;
    return {
      x: f,
      y: v,
      width: r.width,
      height: r.height
    };
  }
  function qf(e) {
    return Zo(e).position === "static";
  }
  function m0(e, t) {
    if (!kl(e) || Zo(e).position === "fixed")
      return null;
    if (t)
      return t(e);
    let n = e.offsetParent;
    return $l(e) === n && (n = n.ownerDocument.body), n;
  }
  function w_(e, t) {
    const n = bo(e);
    if (Xd(e))
      return n;
    if (!kl(e)) {
      let l = xa(e);
      for (; l && !hs(l); ) {
        if (Jo(l) && !qf(l))
          return l;
        l = xa(l);
      }
      return n;
    }
    let o = m0(e, t);
    for (; o && Vq(o) && qf(o); )
      o = m0(o, t);
    return o && hs(o) && qf(o) && !Em(o) ? n : o || Hq(e) || n;
  }
  const nG = async function(e) {
    const t = this.getOffsetParent || w_, n = this.getDimensions, o = await n(e.floating);
    return {
      reference: tG(e.reference, await t(e.floating), e.strategy),
      floating: {
        x: 0,
        y: 0,
        width: o.width,
        height: o.height
      }
    };
  };
  function oG(e) {
    return Zo(e).direction === "rtl";
  }
  const lG = {
    convertOffsetParentRelativeRectToViewportRelativeRect: Uq,
    getDocumentElement: $l,
    getClippingRect: Qq,
    getOffsetParent: w_,
    getElementRects: nG,
    getClientRects: Yq,
    getDimensions: eG,
    getScale: Xr,
    isElement: Jo,
    isRTL: oG
  };
  function C_(e, t) {
    return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
  }
  function aG(e, t) {
    let n = null, o;
    const l = $l(e);
    function a() {
      var i;
      clearTimeout(o), (i = n) == null || i.disconnect(), n = null;
    }
    function r(i, u) {
      i === void 0 && (i = !1), u === void 0 && (u = 1), a();
      const c = e.getBoundingClientRect(), {
        left: d,
        top: f,
        width: v,
        height: p
      } = c;
      if (i || t(), !v || !p)
        return;
      const m = Hu(f), h = Hu(l.clientWidth - (d + v)), g = Hu(l.clientHeight - (f + p)), b = Hu(d), w = {
        rootMargin: -m + "px " + -h + "px " + -g + "px " + -b + "px",
        threshold: sr(0, vs(1, u)) || 1
      };
      let y = !0;
      function E(k) {
        const T = k[0].intersectionRatio;
        if (T !== u) {
          if (!y)
            return r();
          T ? r(!1, T) : o = setTimeout(() => {
            r(!1, 1e-7);
          }, 1e3);
        }
        T === 1 && !C_(c, e.getBoundingClientRect()) && r(), y = !1;
      }
      try {
        n = new IntersectionObserver(E, {
          ...w,
          // Handle <iframe>s
          root: l.ownerDocument
        });
      } catch {
        n = new IntersectionObserver(E, w);
      }
      n.observe(e);
    }
    return r(!0), a;
  }
  function rG(e, t, n, o) {
    o === void 0 && (o = {});
    const {
      ancestorScroll: l = !0,
      ancestorResize: a = !0,
      elementResize: r = typeof ResizeObserver == "function",
      layoutShift: i = typeof IntersectionObserver == "function",
      animationFrame: u = !1
    } = o, c = _m(e), d = l || a ? [...c ? Bi(c) : [], ...Bi(t)] : [];
    d.forEach((b) => {
      l && b.addEventListener("scroll", n, {
        passive: !0
      }), a && b.addEventListener("resize", n);
    });
    const f = c && i ? aG(c, n) : null;
    let v = -1, p = null;
    r && (p = new ResizeObserver((b) => {
      let [C] = b;
      C && C.target === c && p && (p.unobserve(t), cancelAnimationFrame(v), v = requestAnimationFrame(() => {
        var w;
        (w = p) == null || w.observe(t);
      })), n();
    }), c && !u && p.observe(c), p.observe(t));
    let m, h = u ? hr(e) : null;
    u && g();
    function g() {
      const b = hr(e);
      h && !C_(h, b) && n(), h = b, m = requestAnimationFrame(g);
    }
    return n(), () => {
      var b;
      d.forEach((C) => {
        l && C.removeEventListener("scroll", n), a && C.removeEventListener("resize", n);
      }), f == null || f(), (b = p) == null || b.disconnect(), p = null, u && cancelAnimationFrame(m);
    };
  }
  const sG = Sm, iG = Pq, uG = Rq, cG = Iq, dG = Oq, fG = (e, t, n) => {
    const o = /* @__PURE__ */ new Map(), l = {
      platform: lG,
      ...n
    }, a = {
      ...l.platform,
      _c: o
    };
    return $q(e, t, {
      ...l,
      platform: a
    });
  }, pG = (e, t, n, o, l) => {
    const a = A(null), r = () => {
      let f;
      return Ae(e.value) ? f = document.querySelector(e.value) : Fe(e.value) ? f = e.value() : f = e.value, f;
    }, i = () => {
      const f = r();
      if (!f || !t.value) {
        a.value = null;
        return;
      }
      vG(f) || f.scrollIntoView(l.value);
      const { left: v, top: p, width: m, height: h } = f.getBoundingClientRect();
      a.value = {
        left: v,
        top: p,
        width: m,
        height: h,
        radius: 0
      };
    };
    ft(() => {
      de([t, e], () => {
        i();
      }, {
        immediate: !0
      }), window.addEventListener("resize", i);
    }), Bt(() => {
      window.removeEventListener("resize", i);
    });
    const u = (f) => {
      var v;
      return (v = ye(n.value.offset) ? n.value.offset[f] : n.value.offset) != null ? v : 6;
    }, c = S(() => {
      var f;
      if (!a.value)
        return a.value;
      const v = u(0), p = u(1), m = ((f = n.value) == null ? void 0 : f.radius) || 2;
      return {
        left: a.value.left - v,
        top: a.value.top - p,
        width: a.value.width + v * 2,
        height: a.value.height + p * 2,
        radius: m
      };
    }), d = S(() => {
      const f = r();
      return !o.value || !f || !window.DOMRect ? f || void 0 : {
        getBoundingClientRect() {
          var v, p, m, h;
          return window.DOMRect.fromRect({
            width: ((v = c.value) == null ? void 0 : v.width) || 0,
            height: ((p = c.value) == null ? void 0 : p.height) || 0,
            x: ((m = c.value) == null ? void 0 : m.left) || 0,
            y: ((h = c.value) == null ? void 0 : h.top) || 0
          });
        }
      };
    });
    return {
      mergedPosInfo: c,
      triggerTarget: d
    };
  }, Qd = Symbol("ElTour");
  function vG(e) {
    const t = window.innerWidth || document.documentElement.clientWidth, n = window.innerHeight || document.documentElement.clientHeight, { top: o, right: l, bottom: a, left: r } = e.getBoundingClientRect();
    return o >= 0 && r >= 0 && l <= t && a <= n;
  }
  const hG = (e, t, n, o, l, a, r, i) => {
    const u = A(), c = A(), d = A({}), f = {
      x: u,
      y: c,
      placement: o,
      strategy: l,
      middlewareData: d
    }, v = S(() => {
      const b = [
        iG(s(a)),
        cG(),
        uG(),
        mG()
      ];
      return s(i) && s(n) && b.push(dG({
        element: s(n)
      })), b;
    }), p = async () => {
      if (!xt)
        return;
      const b = s(e), C = s(t);
      if (!b || !C)
        return;
      const w = await fG(b, C, {
        placement: s(o),
        strategy: s(l),
        middleware: s(v)
      });
      Ci(f).forEach((y) => {
        f[y].value = w[y];
      });
    }, m = S(() => {
      if (!s(e))
        return {
          position: "fixed",
          top: "50%",
          left: "50%",
          transform: "translate3d(-50%, -50%, 0)",
          maxWidth: "100vw",
          zIndex: s(r)
        };
      const { overflow: b } = s(d);
      return {
        position: s(l),
        zIndex: s(r),
        top: s(c) != null ? `${s(c)}px` : "",
        left: s(u) != null ? `${s(u)}px` : "",
        maxWidth: b != null && b.maxWidth ? `${b == null ? void 0 : b.maxWidth}px` : ""
      };
    }), h = S(() => {
      if (!s(i))
        return {};
      const { arrow: b } = s(d);
      return {
        left: (b == null ? void 0 : b.x) != null ? `${b == null ? void 0 : b.x}px` : "",
        top: (b == null ? void 0 : b.y) != null ? `${b == null ? void 0 : b.y}px` : ""
      };
    });
    let g;
    return ft(() => {
      const b = s(e), C = s(t);
      b && C && (g = rG(b, C, p)), to(() => {
        p();
      });
    }), Bt(() => {
      g && g();
    }), {
      update: p,
      contentStyle: m,
      arrowStyle: h
    };
  }, mG = () => ({
    name: "overflow",
    async fn(e) {
      const t = await sG(e);
      let n = 0;
      return t.left > 0 && (n = t.left), t.right > 0 && (n = t.right), {
        data: {
          maxWidth: e.rects.floating.width - n
        }
      };
    }
  }), gG = /* @__PURE__ */ U({
    name: "ElTourMask",
    inheritAttrs: !1
  }), bG = /* @__PURE__ */ U({
    ...gG,
    props: gq,
    setup(e) {
      const t = e, { ns: n } = Ve(Qd), o = S(() => {
        var d, f;
        return (f = (d = t.pos) == null ? void 0 : d.radius) != null ? f : 2;
      }), l = S(() => {
        const d = o.value, f = `a${d},${d} 0 0 1`;
        return {
          topRight: `${f} ${d},${d}`,
          bottomRight: `${f} ${-d},${d}`,
          bottomLeft: `${f} ${-d},${-d}`,
          topLeft: `${f} ${d},${-d}`
        };
      }), { width: a, height: r } = sh(), i = S(() => {
        const d = a.value, f = r.value, v = l.value, p = `M${d},0 L0,0 L0,${f} L${d},${f} L${d},0 Z`, m = o.value;
        return t.pos ? `${p} M${t.pos.left + m},${t.pos.top} h${t.pos.width - m * 2} ${v.topRight} v${t.pos.height - m * 2} ${v.bottomRight} h${-t.pos.width + m * 2} ${v.bottomLeft} v${-t.pos.height + m * 2} ${v.topLeft} z` : p;
      }), u = S(() => ({
        position: "fixed",
        left: 0,
        right: 0,
        top: 0,
        bottom: 0,
        zIndex: t.zIndex,
        pointerEvents: t.pos && t.targetAreaClickable ? "none" : "auto"
      })), c = S(() => ({
        fill: t.fill,
        pointerEvents: "auto",
        cursor: "auto"
      }));
      return Wd(At(t, "visible"), {
        ns: n
      }), (d, f) => d.visible ? (_(), B("div", pt({
        key: 0,
        class: s(n).e("mask"),
        style: s(u)
      }, d.$attrs), [
        (_(), B("svg", { style: {
          width: "100%",
          height: "100%"
        } }, [
          W("path", {
            class: $(s(n).e("hollow")),
            style: Ue(s(c)),
            d: s(i)
          }, null, 14, ["d"])
        ]))
      ], 16)) : oe("v-if", !0);
    }
  });
  var yG = /* @__PURE__ */ Ne(bG, [["__file", "mask.vue"]]);
  const wG = ["absolute", "fixed"], CG = [
    "top-start",
    "top-end",
    "top",
    "bottom-start",
    "bottom-end",
    "bottom",
    "left-start",
    "left-end",
    "left",
    "right-start",
    "right-end",
    "right"
  ], Tm = Te({
    placement: {
      type: X(String),
      values: CG,
      default: "bottom"
    },
    reference: {
      type: X(Object),
      default: null
    },
    strategy: {
      type: X(String),
      values: wG,
      default: "absolute"
    },
    offset: {
      type: Number,
      default: 10
    },
    showArrow: Boolean,
    zIndex: {
      type: Number,
      default: 2001
    }
  }), SG = {
    close: () => !0
  }, EG = /* @__PURE__ */ U({
    name: "ElTourContent"
  }), kG = /* @__PURE__ */ U({
    ...EG,
    props: Tm,
    emits: SG,
    setup(e, { emit: t }) {
      const n = e, o = A(n.placement), l = A(n.strategy), a = A(null), r = A(null);
      de(() => n.placement, () => {
        o.value = n.placement;
      });
      const { contentStyle: i, arrowStyle: u } = hG(At(n, "reference"), a, r, o, l, At(n, "offset"), At(n, "zIndex"), At(n, "showArrow")), c = S(() => o.value.split("-")[0]), { ns: d } = Ve(Qd), f = () => {
        t("close");
      }, v = (p) => {
        p.detail.focusReason === "pointer" && p.preventDefault();
      };
      return (p, m) => (_(), B("div", {
        ref_key: "contentRef",
        ref: a,
        style: Ue(s(i)),
        class: $(s(d).e("content")),
        "data-side": s(c),
        tabindex: "-1"
      }, [
        q(s(_s), {
          loop: "",
          trapped: "",
          "focus-start-el": "container",
          "focus-trap-el": a.value || void 0,
          onReleaseRequested: f,
          onFocusoutPrevented: v
        }, {
          default: Q(() => [
            ee(p.$slots, "default")
          ]),
          _: 3
        }, 8, ["focus-trap-el"]),
        p.showArrow ? (_(), B("span", {
          key: 0,
          ref_key: "arrowRef",
          ref: r,
          style: Ue(s(u)),
          class: $(s(d).e("arrow"))
        }, null, 6)) : oe("v-if", !0)
      ], 14, ["data-side"]));
    }
  });
  var _G = /* @__PURE__ */ Ne(kG, [["__file", "content.vue"]]), TG = /* @__PURE__ */ U({
    name: "ElTourSteps",
    props: {
      current: {
        type: Number,
        default: 0
      }
    },
    emits: ["update-total"],
    setup(e, { slots: t, emit: n }) {
      let o = 0;
      return () => {
        var l, a;
        const r = (l = t.default) == null ? void 0 : l.call(t), i = [];
        let u = 0;
        function c(d) {
          ye(d) && d.forEach((f) => {
            var v;
            ((v = (f == null ? void 0 : f.type) || {}) == null ? void 0 : v.name) === "ElTourStep" && (i.push(f), u += 1);
          });
        }
        return r.length && c(cl((a = r[0]) == null ? void 0 : a.children)), o !== u && (o = u, n("update-total", u)), i.length ? i[e.current] : null;
      };
    }
  });
  const NG = Te({
    modelValue: Boolean,
    current: {
      type: Number,
      default: 0
    },
    showArrow: {
      type: Boolean,
      default: !0
    },
    showClose: {
      type: Boolean,
      default: !0
    },
    closeIcon: {
      type: Lt
    },
    placement: Tm.placement,
    contentStyle: {
      type: X([Object])
    },
    mask: {
      type: X([Boolean, Object]),
      default: !0
    },
    gap: {
      type: X(Object),
      default: () => ({
        offset: 6,
        radius: 2
      })
    },
    zIndex: {
      type: Number
    },
    scrollIntoViewOptions: {
      type: X([Boolean, Object]),
      default: () => ({
        block: "center"
      })
    },
    type: {
      type: X(String)
    },
    appendTo: {
      type: Bd.to.type,
      default: "body"
    },
    closeOnPressEscape: {
      type: Boolean,
      default: !0
    },
    targetAreaClickable: {
      type: Boolean,
      default: !0
    }
  }), $G = {
    [et]: (e) => Vt(e),
    "update:current": (e) => je(e),
    close: (e) => je(e),
    finish: () => !0,
    change: (e) => je(e)
  }, OG = /* @__PURE__ */ U({
    name: "ElTour"
  }), IG = /* @__PURE__ */ U({
    ...OG,
    props: NG,
    emits: $G,
    setup(e, { emit: t }) {
      const n = e, o = he("tour"), l = A(0), a = A(), r = eC(n, "current", t, {
        passive: !0
      }), i = S(() => {
        var I;
        return (I = a.value) == null ? void 0 : I.target;
      }), u = S(() => [
        o.b(),
        g.value === "primary" ? o.m("primary") : ""
      ]), c = S(() => {
        var I;
        return ((I = a.value) == null ? void 0 : I.placement) || n.placement;
      }), d = S(() => {
        var I, P;
        return (P = (I = a.value) == null ? void 0 : I.contentStyle) != null ? P : n.contentStyle;
      }), f = S(() => {
        var I, P;
        return (P = (I = a.value) == null ? void 0 : I.mask) != null ? P : n.mask;
      }), v = S(() => !!f.value && n.modelValue), p = S(() => Vt(f.value) ? void 0 : f.value), m = S(() => {
        var I, P;
        return !!i.value && ((P = (I = a.value) == null ? void 0 : I.showArrow) != null ? P : n.showArrow);
      }), h = S(() => {
        var I, P;
        return (P = (I = a.value) == null ? void 0 : I.scrollIntoViewOptions) != null ? P : n.scrollIntoViewOptions;
      }), g = S(() => {
        var I, P;
        return (P = (I = a.value) == null ? void 0 : I.type) != null ? P : n.type;
      }), { nextZIndex: b } = tu(), C = b(), w = S(() => {
        var I;
        return (I = n.zIndex) != null ? I : C;
      }), { mergedPosInfo: y, triggerTarget: E } = pG(i, At(n, "modelValue"), At(n, "gap"), f, h);
      de(() => n.modelValue, (I) => {
        I || (r.value = 0);
      });
      const k = () => {
        n.closeOnPressEscape && (t(et, !1), t("close", r.value));
      }, T = (I) => {
        l.value = I;
      }, x = hn();
      return yt(Qd, {
        currentStep: a,
        current: r,
        total: l,
        showClose: At(n, "showClose"),
        closeIcon: At(n, "closeIcon"),
        mergedType: g,
        ns: o,
        slots: x,
        updateModelValue(I) {
          t(et, I);
        },
        onClose() {
          t("close", r.value);
        },
        onFinish() {
          t("finish");
        },
        onChange() {
          t(gt, r.value);
        }
      }), (I, P) => (_(), B(We, null, [
        q(s(uu), { to: I.appendTo }, {
          default: Q(() => {
            var O, N;
            return [
              W("div", pt({ class: s(u) }, I.$attrs), [
                q(yG, {
                  visible: s(v),
                  fill: (O = s(p)) == null ? void 0 : O.color,
                  style: Ue((N = s(p)) == null ? void 0 : N.style),
                  pos: s(y),
                  "z-index": s(w),
                  "target-area-clickable": I.targetAreaClickable
                }, null, 8, ["visible", "fill", "style", "pos", "z-index", "target-area-clickable"]),
                I.modelValue ? (_(), ae(_G, {
                  key: s(r),
                  reference: s(E),
                  placement: s(c),
                  "show-arrow": s(m),
                  "z-index": s(w),
                  style: Ue(s(d)),
                  onClose: k
                }, {
                  default: Q(() => [
                    q(s(TG), {
                      current: s(r),
                      onUpdateTotal: T
                    }, {
                      default: Q(() => [
                        ee(I.$slots, "default")
                      ]),
                      _: 3
                    }, 8, ["current"])
                  ]),
                  _: 3
                }, 8, ["reference", "placement", "show-arrow", "z-index", "style"])) : oe("v-if", !0)
              ], 16)
            ];
          }),
          _: 3
        }, 8, ["to"]),
        oe(" just for IDE "),
        oe("v-if", !0)
      ], 64));
    }
  });
  var MG = /* @__PURE__ */ Ne(IG, [["__file", "tour.vue"]]);
  const xG = Te({
    target: {
      type: X([String, Object, Function])
    },
    title: String,
    description: String,
    showClose: {
      type: Boolean,
      default: void 0
    },
    closeIcon: {
      type: Lt
    },
    showArrow: {
      type: Boolean,
      default: void 0
    },
    placement: Tm.placement,
    mask: {
      type: X([Boolean, Object]),
      default: void 0
    },
    contentStyle: {
      type: X([Object])
    },
    prevButtonProps: {
      type: X(Object)
    },
    nextButtonProps: {
      type: X(Object)
    },
    scrollIntoViewOptions: {
      type: X([Boolean, Object]),
      default: void 0
    },
    type: {
      type: X(String)
    }
  }), PG = {
    close: () => !0
  }, RG = /* @__PURE__ */ U({
    name: "ElTourStep"
  }), DG = /* @__PURE__ */ U({
    ...RG,
    props: xG,
    emits: PG,
    setup(e, { emit: t }) {
      const n = e, { Close: o } = SC, { t: l } = _t(), {
        currentStep: a,
        current: r,
        total: i,
        showClose: u,
        closeIcon: c,
        mergedType: d,
        ns: f,
        slots: v,
        updateModelValue: p,
        onClose: m,
        onFinish: h,
        onChange: g
      } = Ve(Qd);
      de(n, (I) => {
        a.value = I;
      }, {
        immediate: !0
      });
      const b = S(() => {
        var I;
        return (I = n.showClose) != null ? I : u.value;
      }), C = S(() => {
        var I, P;
        return (P = (I = n.closeIcon) != null ? I : c.value) != null ? P : o;
      }), w = (I) => {
        if (I)
          return Md(I, ["children", "onClick"]);
      }, y = () => {
        var I, P;
        r.value -= 1, (I = n.prevButtonProps) != null && I.onClick && ((P = n.prevButtonProps) == null || P.onClick()), g();
      }, E = () => {
        var I;
        r.value >= i.value - 1 ? k() : r.value += 1, (I = n.nextButtonProps) != null && I.onClick && n.nextButtonProps.onClick(), g();
      }, k = () => {
        T(), h();
      }, T = () => {
        p(!1), m(), t("close");
      }, x = (I) => {
        const P = I.target;
        if (P != null && P.isContentEditable)
          return;
        switch (Ht(I)) {
          case _e.left:
            I.preventDefault(), r.value > 0 && y();
            break;
          case _e.right:
            I.preventDefault(), E();
            break;
        }
      };
      return ft(() => {
        window.addEventListener("keydown", x);
      }), Bt(() => {
        window.removeEventListener("keydown", x);
      }), (I, P) => (_(), B(We, null, [
        s(b) ? (_(), B("button", {
          key: 0,
          "aria-label": s(l)("el.tour.close"),
          class: $(s(f).e("closebtn")),
          type: "button",
          onClick: T
        }, [
          q(s(ze), {
            class: $(s(f).e("close"))
          }, {
            default: Q(() => [
              (_(), ae(ct(s(C))))
            ]),
            _: 1
          }, 8, ["class"])
        ], 10, ["aria-label"])) : oe("v-if", !0),
        W("header", {
          class: $([s(f).e("header"), { "show-close": s(u) }])
        }, [
          ee(I.$slots, "header", {}, () => [
            W("span", {
              role: "heading",
              class: $(s(f).e("title"))
            }, ke(I.title), 3)
          ])
        ], 2),
        W("div", {
          class: $(s(f).e("body"))
        }, [
          ee(I.$slots, "default", {}, () => [
            W("span", null, ke(I.description), 1)
          ])
        ], 2),
        W("footer", {
          class: $(s(f).e("footer"))
        }, [
          W("div", {
            class: $(s(f).b("indicators"))
          }, [
            s(v).indicators ? (_(), ae(ct(s(v).indicators), {
              key: 0,
              current: s(r),
              total: s(i)
            }, null, 8, ["current", "total"])) : (_(!0), B(We, { key: 1 }, bt(s(i), (O, N) => (_(), B("span", {
              key: O,
              class: $([s(f).b("indicator"), s(f).is("active", N === s(r))])
            }, null, 2))), 128))
          ], 2),
          W("div", {
            class: $(s(f).b("buttons"))
          }, [
            s(r) > 0 ? (_(), ae(s(_n), pt({
              key: 0,
              size: "small",
              type: s(d)
            }, w(I.prevButtonProps), { onClick: y }), {
              default: Q(() => {
                var O, N;
                return [
                  Ct(ke((N = (O = I.prevButtonProps) == null ? void 0 : O.children) != null ? N : s(l)("el.tour.previous")), 1)
                ];
              }),
              _: 1
            }, 16, ["type"])) : oe("v-if", !0),
            s(r) <= s(i) - 1 ? (_(), ae(s(_n), pt({
              key: 1,
              size: "small",
              type: s(d) === "primary" ? "default" : "primary"
            }, w(I.nextButtonProps), { onClick: E }), {
              default: Q(() => {
                var O, N;
                return [
                  Ct(ke((N = (O = I.nextButtonProps) == null ? void 0 : O.children) != null ? N : s(r) === s(i) - 1 ? s(l)("el.tour.finish") : s(l)("el.tour.next")), 1)
                ];
              }),
              _: 1
            }, 16, ["type"])) : oe("v-if", !0)
          ], 2)
        ], 2)
      ], 64));
    }
  });
  var S_ = /* @__PURE__ */ Ne(DG, [["__file", "step.vue"]]);
  const AG = rt(MG, {
    TourStep: S_
  }), VG = nn(S_), LG = Te({
    container: {
      type: X([
        String,
        Object
      ])
    },
    offset: {
      type: Number,
      default: 0
    },
    bound: {
      type: Number,
      default: 15
    },
    duration: {
      type: Number,
      default: 300
    },
    marker: {
      type: Boolean,
      default: !0
    },
    type: {
      type: X(String),
      default: "default"
    },
    direction: {
      type: X(String),
      default: "vertical"
    },
    selectScrollTop: Boolean
  }), BG = {
    change: (e) => Ae(e),
    click: (e, t) => e instanceof MouseEvent && (Ae(t) || kt(t))
  }, E_ = Symbol("anchor"), Ku = (e) => {
    if (!xt || e === "")
      return null;
    if (Ae(e))
      try {
        return document.querySelector(e);
      } catch {
        return null;
      }
    return e;
  };
  function FG(e) {
    let t = 0;
    const n = (...o) => {
      t && Yl(t), t = Ul(() => {
        e(...o), t = 0;
      });
    };
    return n.cancel = () => {
      Yl(t), t = 0;
    }, n;
  }
  const zG = /* @__PURE__ */ U({
    name: "ElAnchor"
  }), HG = /* @__PURE__ */ U({
    ...zG,
    props: LG,
    emits: BG,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = hn(), a = A(""), r = A({}), i = A(null), u = A(null), c = A(), d = {};
      let f = !1, v = 0;
      const p = he("anchor"), m = S(() => [
        p.b(),
        o.type === "underline" ? p.m("underline") : "",
        p.m(o.direction)
      ]), h = (P) => {
        d[P.href] = P.el;
      }, g = (P) => {
        delete d[P];
      }, b = (P) => {
        a.value !== P && (a.value = P, n(gt, P));
      };
      let C = null;
      const w = (P) => {
        if (!c.value)
          return;
        const O = Ku(P);
        if (!O)
          return;
        C && C(), f = !0;
        const N = yb(O, c.value), z = Mp(O, N), Y = N.scrollHeight - N.clientHeight, G = Math.min(z - o.offset, Y);
        C = CR(c.value, v, G, o.duration, () => {
          setTimeout(() => {
            f = !1;
          }, 20);
        });
      }, y = (P) => {
        P && (b(P), w(P));
      }, E = (P, O) => {
        n("click", P, O), y(O);
      }, k = FG(() => {
        c.value && (v = wb(c.value));
        const P = T();
        f || kt(P) || b(P);
      }), T = () => {
        if (!c.value)
          return;
        const P = wb(c.value), O = [];
        for (const N of Object.keys(d)) {
          const z = Ku(N);
          if (!z)
            continue;
          const Y = yb(z, c.value), G = Mp(z, Y);
          O.push({
            top: G - o.offset - o.bound,
            href: N
          });
        }
        O.sort((N, z) => N.top - z.top);
        for (let N = 0; N < O.length; N++) {
          const z = O[N], Y = O[N + 1];
          if (N === 0 && P === 0)
            return o.selectScrollTop ? z.href : "";
          if (z.top <= P && (!Y || Y.top > P))
            return z.href;
        }
      }, x = () => {
        const P = Ku(o.container);
        !P || Qi(P) ? c.value = window : c.value = P;
      };
      Dt(c, "scroll", k);
      const I = () => {
        Re(() => {
          if (!i.value || !u.value || !a.value) {
            r.value = {};
            return;
          }
          const P = d[a.value];
          if (!P) {
            r.value = {};
            return;
          }
          const O = i.value.getBoundingClientRect(), N = u.value.getBoundingClientRect(), z = P.getBoundingClientRect();
          if (o.direction === "horizontal") {
            const Y = z.left - O.left;
            r.value = {
              left: `${Y}px`,
              width: `${z.width}px`,
              opacity: 1
            };
          } else {
            const Y = z.top - O.top + (z.height - N.height) / 2;
            r.value = {
              top: `${Y}px`,
              opacity: 1
            };
          }
        });
      };
      return de(a, I), de(() => {
        var P;
        return (P = l.default) == null ? void 0 : P.call(l);
      }, I), ft(() => {
        x();
        const P = decodeURIComponent(window.location.hash);
        Ku(P) ? y(P) : k();
      }), de(() => o.container, () => {
        x();
      }), yt(E_, {
        ns: p,
        direction: o.direction,
        currentAnchor: a,
        addLink: h,
        removeLink: g,
        handleClick: E
      }), t({
        scrollTo: y
      }), (P, O) => (_(), B("div", {
        ref_key: "anchorRef",
        ref: i,
        class: $(s(m))
      }, [
        P.marker ? (_(), B("div", {
          key: 0,
          ref_key: "markerRef",
          ref: u,
          class: $(s(p).e("marker")),
          style: Ue(r.value)
        }, null, 6)) : oe("v-if", !0),
        W("div", {
          class: $(s(p).e("list"))
        }, [
          ee(P.$slots, "default")
        ], 2)
      ], 2));
    }
  });
  var KG = /* @__PURE__ */ Ne(HG, [["__file", "anchor.vue"]]);
  const WG = Te({
    title: String,
    href: String
  }), jG = /* @__PURE__ */ U({
    name: "ElAnchorLink"
  }), UG = /* @__PURE__ */ U({
    ...jG,
    props: WG,
    setup(e) {
      const t = e, n = A(null), {
        ns: o,
        direction: l,
        currentAnchor: a,
        addLink: r,
        removeLink: i,
        handleClick: u
      } = Ve(E_), c = S(() => [
        o.e("link"),
        o.is("active", a.value === t.href)
      ]), d = (f) => {
        u(f, t.href);
      };
      return de(() => t.href, (f, v) => {
        Re(() => {
          v && i(v), f && r({
            href: f,
            el: n.value
          });
        });
      }), ft(() => {
        const { href: f } = t;
        f && r({
          href: f,
          el: n.value
        });
      }), Bt(() => {
        const { href: f } = t;
        f && i(f);
      }), (f, v) => (_(), B("div", {
        class: $(s(o).e("item"))
      }, [
        W("a", {
          ref_key: "linkRef",
          ref: n,
          class: $(s(c)),
          href: f.href,
          onClick: d
        }, [
          ee(f.$slots, "default", {}, () => [
            Ct(ke(f.title), 1)
          ])
        ], 10, ["href"]),
        f.$slots["sub-link"] && s(l) === "vertical" ? (_(), B("div", {
          key: 0,
          class: $(s(o).e("list"))
        }, [
          ee(f.$slots, "sub-link")
        ], 2)) : oe("v-if", !0)
      ], 2));
    }
  });
  var k_ = /* @__PURE__ */ Ne(UG, [["__file", "anchor-link.vue"]]);
  const YG = rt(KG, {
    AnchorLink: k_
  }), qG = nn(k_), __ = {
    label: "label",
    value: "value",
    disabled: "disabled"
  }, GG = Te({
    direction: {
      type: X(String),
      default: "horizontal"
    },
    options: {
      type: X(Array),
      default: () => []
    },
    modelValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    props: {
      type: X(Object),
      default: () => __
    },
    block: Boolean,
    size: mn,
    disabled: Boolean,
    validateEvent: {
      type: Boolean,
      default: !0
    },
    id: String,
    name: String,
    ...Yn(["ariaLabel"])
  }), XG = {
    [et]: (e) => Ae(e) || je(e) || Vt(e),
    [gt]: (e) => Ae(e) || je(e) || Vt(e)
  }, JG = /* @__PURE__ */ U({
    name: "ElSegmented"
  }), ZG = /* @__PURE__ */ U({
    ...JG,
    props: GG,
    emits: XG,
    setup(e, { emit: t }) {
      const n = e, o = he("segmented"), l = xn(), a = vn(), r = Cn(), { formItem: i } = Nn(), { inputId: u, isLabeledByFormItem: c } = wo(n, {
        formItemContext: i
      }), d = A(null), f = KP(), v = Rt({
        isInit: !1,
        width: 0,
        height: 0,
        translateX: 0,
        translateY: 0,
        focusVisible: !1
      }), p = (O) => {
        const N = g(O);
        t(et, N), t(gt, N);
      }, m = S(() => ({ ...__, ...n.props })), h = (O) => O, g = (O) => ot(O) ? O[m.value.value] : O, b = (O) => ot(O) ? O[m.value.label] : O, C = (O) => !!(r.value || ot(O) && O[m.value.disabled]), w = (O) => n.modelValue === g(O), y = (O) => n.options.find((N) => g(N) === O), E = (O) => [
        o.e("item"),
        o.is("selected", w(O)),
        o.is("disabled", C(O))
      ], k = () => {
        if (!d.value)
          return;
        const O = d.value.querySelector(".is-selected"), N = d.value.querySelector(".is-selected input");
        if (!O || !N) {
          v.width = 0, v.height = 0, v.translateX = 0, v.translateY = 0, v.focusVisible = !1;
          return;
        }
        v.isInit = !0, n.direction === "vertical" ? (v.height = O.offsetHeight, v.translateY = O.offsetTop) : (v.width = O.offsetWidth, v.translateX = O.offsetLeft);
        try {
          v.focusVisible = N.matches(":focus-visible");
        } catch {
        }
      }, T = S(() => [
        o.b(),
        o.m(a.value),
        o.is("block", n.block)
      ]), x = S(() => ({
        width: n.direction === "vertical" ? "100%" : `${v.width}px`,
        height: n.direction === "vertical" ? `${v.height}px` : "100%",
        transform: n.direction === "vertical" ? `translateY(${v.translateY}px)` : `translateX(${v.translateX}px)`,
        display: v.isInit ? "block" : "none"
      })), I = S(() => [
        o.e("item-selected"),
        o.is("disabled", C(y(n.modelValue))),
        o.is("focus-visible", v.focusVisible)
      ]), P = S(() => n.name || l.value);
      return qt(d, k), de(f, k), de(() => n.modelValue, () => {
        var O;
        k(), n.validateEvent && ((O = i == null ? void 0 : i.validate) == null || O.call(i, "change").catch((N) => vt(N)));
      }, {
        flush: "post"
      }), (O, N) => O.options.length ? (_(), B("div", {
        key: 0,
        id: s(u),
        ref_key: "segmentedRef",
        ref: d,
        class: $(s(T)),
        role: "radiogroup",
        "aria-label": s(c) ? void 0 : O.ariaLabel || "segmented",
        "aria-labelledby": s(c) ? s(i).labelId : void 0
      }, [
        W("div", {
          class: $([s(o).e("group"), s(o).m(O.direction)])
        }, [
          W("div", {
            style: Ue(s(x)),
            class: $(s(I))
          }, null, 6),
          (_(!0), B(We, null, bt(O.options, (z, Y) => (_(), B("label", {
            key: Y,
            class: $(E(z))
          }, [
            W("input", {
              class: $(s(o).e("item-input")),
              type: "radio",
              name: s(P),
              disabled: C(z),
              checked: w(z),
              onChange: (G) => p(z)
            }, null, 42, ["name", "disabled", "checked", "onChange"]),
            W("div", {
              class: $(s(o).e("item-label"))
            }, [
              ee(O.$slots, "default", {
                item: h(z)
              }, () => [
                Ct(ke(b(z)), 1)
              ])
            ], 2)
          ], 2))), 128))
        ], 2)
      ], 10, ["id", "aria-label", "aria-labelledby"])) : oe("v-if", !0);
    }
  });
  var QG = /* @__PURE__ */ Ne(ZG, [["__file", "segmented.vue"]]);
  const eX = rt(QG), tX = (e, t) => {
    const n = e.toLowerCase();
    return (t.label || t.value || "").toLowerCase().includes(n);
  }, nX = (e, t, n) => {
    const { selectionEnd: o } = e;
    if (o === null)
      return;
    const l = e.value, a = En(t);
    let r = -1, i;
    for (let u = o - 1; u >= 0; --u) {
      const c = l[u];
      if (c === n || c === `
` || c === "\r") {
        r = u;
        continue;
      }
      if (a.includes(c)) {
        const d = r === -1 ? o : r;
        i = {
          pattern: l.slice(u + 1, d),
          start: u + 1,
          end: d,
          prefix: c,
          prefixIndex: u,
          splitIndex: r,
          selectionEnd: o
        };
        break;
      }
    }
    return i;
  }, oX = (e, t = {
    debug: !1,
    useSelectionEnd: !1
  }) => {
    const n = e.selectionStart !== null ? e.selectionStart : 0, o = e.selectionEnd !== null ? e.selectionEnd : 0, l = t.useSelectionEnd ? o : n, a = [
      "direction",
      "boxSizing",
      "width",
      "height",
      "overflowX",
      "overflowY",
      "borderTopWidth",
      "borderRightWidth",
      "borderBottomWidth",
      "borderLeftWidth",
      "borderStyle",
      "paddingTop",
      "paddingRight",
      "paddingBottom",
      "paddingLeft",
      "fontStyle",
      "fontVariant",
      "fontWeight",
      "fontStretch",
      "fontSize",
      "fontSizeAdjust",
      "lineHeight",
      "fontFamily",
      "textAlign",
      "textTransform",
      "textIndent",
      "textDecoration",
      "letterSpacing",
      "wordSpacing",
      "tabSize",
      "MozTabSize"
    ];
    if (t.debug) {
      const v = document.querySelector("#input-textarea-caret-position-mirror-div");
      v != null && v.parentNode && v.parentNode.removeChild(v);
    }
    const r = document.createElement("div");
    r.id = "input-textarea-caret-position-mirror-div", document.body.appendChild(r);
    const i = r.style, u = window.getComputedStyle(e), c = e.nodeName === "INPUT";
    i.whiteSpace = c ? "nowrap" : "pre-wrap", c || (i.wordWrap = "break-word"), i.position = "absolute", t.debug || (i.visibility = "hidden"), a.forEach((v) => {
      if (c && v === "lineHeight")
        if (u.boxSizing === "border-box") {
          const p = Number.parseInt(u.height), m = Number.parseInt(u.paddingTop) + Number.parseInt(u.paddingBottom) + Number.parseInt(u.borderTopWidth) + Number.parseInt(u.borderBottomWidth), h = m + Number.parseInt(u.lineHeight);
          p > h ? i.lineHeight = `${p - m}px` : p === h ? i.lineHeight = u.lineHeight : i.lineHeight = "0";
        } else
          i.lineHeight = u.height;
      else
        i[v] = u[v];
    }), vh() ? e.scrollHeight > Number.parseInt(u.height) && (i.overflowY = "scroll") : i.overflow = "hidden", r.textContent = e.value.slice(0, Math.max(0, l)), c && r.textContent && (r.textContent = r.textContent.replace(/\s/g, ""));
    const d = document.createElement("span");
    d.textContent = e.value.slice(Math.max(0, l)) || ".", d.style.position = "relative", d.style.left = `${-e.scrollLeft}px`, d.style.top = `${-e.scrollTop}px`, r.appendChild(d);
    const f = {
      top: d.offsetTop + Number.parseInt(u.borderTopWidth),
      left: d.offsetLeft + Number.parseInt(u.borderLeftWidth),
      height: Number.parseInt(u.fontSize) * 1.5
    };
    return t.debug ? d.style.backgroundColor = "#aaa" : document.body.removeChild(r), f.left >= e.clientWidth && (f.left = e.clientWidth), f;
  }, lX = Te({
    ...lu,
    options: {
      type: X(Array),
      default: () => []
    },
    prefix: {
      type: X([String, Array]),
      default: "@",
      validator: (e) => Ae(e) ? e.length === 1 : e.every((t) => Ae(t) && t.length === 1)
    },
    split: {
      type: String,
      default: " ",
      validator: (e) => e.length === 1
    },
    filterOption: {
      type: X([Boolean, Function]),
      default: () => tX,
      validator: (e) => e === !1 ? !0 : Fe(e)
    },
    placement: {
      type: X(String),
      default: "bottom"
    },
    showArrow: Boolean,
    offset: {
      type: Number,
      default: 0
    },
    whole: Boolean,
    checkIsWhole: {
      type: X(Function)
    },
    modelValue: String,
    loading: Boolean,
    popperClass: zt.popperClass,
    popperStyle: zt.popperStyle,
    popperOptions: {
      type: X(Object),
      default: () => ({})
    },
    props: {
      type: X(Object),
      default: () => T_
    }
  }), aX = {
    [et]: (e) => Ae(e),
    "whole-remove": (e, t) => Ae(e) && Ae(t),
    input: (e) => Ae(e),
    search: (e, t) => Ae(e) && Ae(t),
    select: (e, t) => ot(e) && Ae(t),
    focus: (e) => e instanceof FocusEvent,
    blur: (e) => e instanceof FocusEvent
  }, T_ = {
    value: "value",
    label: "label",
    disabled: "disabled"
  }, rX = Te({
    options: {
      type: X(Array),
      default: () => []
    },
    loading: Boolean,
    disabled: Boolean,
    contentId: String,
    ariaLabel: String
  }), sX = {
    select: (e) => Ae(e.value)
  }, iX = /* @__PURE__ */ U({
    name: "ElMentionDropdown"
  }), uX = /* @__PURE__ */ U({
    ...iX,
    props: rX,
    emits: sX,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = he("mention"), { t: a } = _t(), r = A(-1), i = A(), u = A(), c = A(), d = (w, y) => [
        l.be("dropdown", "item"),
        l.is("hovering", r.value === y),
        l.is("disabled", w.disabled || o.disabled)
      ], f = (w) => {
        w.disabled || o.disabled || n("select", w);
      }, v = (w) => {
        r.value = w;
      }, p = S(() => o.disabled || o.options.every((w) => w.disabled)), m = S(() => o.options[r.value]), h = () => {
        m.value && n("select", m.value);
      }, g = (w) => {
        const { options: y } = o;
        if (y.length === 0 || p.value)
          return;
        w === "next" ? (r.value++, r.value === y.length && (r.value = 0)) : w === "prev" && (r.value--, r.value < 0 && (r.value = y.length - 1));
        const E = y[r.value];
        if (E.disabled) {
          g(w);
          return;
        }
        Re(() => b(E));
      }, b = (w) => {
        var y, E, k, T;
        const { options: x } = o, I = x.findIndex((O) => O.value === w.value), P = (y = u.value) == null ? void 0 : y[I];
        if (P) {
          const O = (k = (E = c.value) == null ? void 0 : E.querySelector) == null ? void 0 : k.call(E, `.${l.be("dropdown", "wrap")}`);
          O && ch(O, P);
        }
        (T = i.value) == null || T.handleScroll();
      };
      return de(() => o.options, () => {
        p.value || o.options.length === 0 ? r.value = -1 : r.value = 0;
      }, {
        immediate: !0
      }), t({
        hoveringIndex: r,
        navigateOptions: g,
        selectHoverOption: h,
        hoverOption: m
      }), (w, y) => (_(), B("div", {
        ref_key: "dropdownRef",
        ref: c,
        class: $(s(l).b("dropdown"))
      }, [
        w.$slots.header ? (_(), B("div", {
          key: 0,
          class: $(s(l).be("dropdown", "header"))
        }, [
          ee(w.$slots, "header")
        ], 2)) : oe("v-if", !0),
        it(q(s(Go), {
          id: w.contentId,
          ref_key: "scrollbarRef",
          ref: i,
          tag: "ul",
          "wrap-class": s(l).be("dropdown", "wrap"),
          "view-class": s(l).be("dropdown", "list"),
          role: "listbox",
          "aria-label": w.ariaLabel,
          "aria-orientation": "vertical"
        }, {
          default: Q(() => [
            (_(!0), B(We, null, bt(w.options, (E, k) => (_(), B("li", {
              id: `${w.contentId}-${k}`,
              ref_for: !0,
              ref_key: "optionRefs",
              ref: u,
              key: k,
              class: $(d(E, k)),
              role: "option",
              "aria-disabled": E.disabled || w.disabled || void 0,
              "aria-selected": r.value === k,
              onMousemove: (T) => v(k),
              onClick: Ze((T) => f(E), ["stop"])
            }, [
              ee(w.$slots, "label", {
                item: E,
                index: k
              }, () => {
                var T;
                return [
                  W("span", null, ke((T = E.label) != null ? T : E.value), 1)
                ];
              })
            ], 42, ["id", "aria-disabled", "aria-selected", "onMousemove", "onClick"]))), 128))
          ]),
          _: 3
        }, 8, ["id", "wrap-class", "view-class", "aria-label"]), [
          [Mt, w.options.length > 0 && !w.loading]
        ]),
        w.loading ? (_(), B("div", {
          key: 1,
          class: $(s(l).be("dropdown", "loading"))
        }, [
          ee(w.$slots, "loading", {}, () => [
            Ct(ke(s(a)("el.mention.loading")), 1)
          ])
        ], 2)) : oe("v-if", !0),
        w.$slots.footer ? (_(), B("div", {
          key: 2,
          class: $(s(l).be("dropdown", "footer"))
        }, [
          ee(w.$slots, "footer")
        ], 2)) : oe("v-if", !0)
      ], 2));
    }
  });
  var cX = /* @__PURE__ */ Ne(uX, [["__file", "mention-dropdown.vue"]]);
  const dX = /* @__PURE__ */ U({
    name: "ElMention",
    inheritAttrs: !1
  }), fX = /* @__PURE__ */ U({
    ...dX,
    props: lX,
    emits: aX,
    setup(e, { expose: t, emit: n }) {
      const o = e, l = S(() => jl(o, Object.keys(lu))), a = he("mention"), r = Cn(), i = xn(), u = A(), c = A(), d = A(), f = A(!1), v = A(), p = A(), m = S(() => o.showArrow ? o.placement : `${o.placement}-start`), h = S(() => o.showArrow ? ["bottom", "top"] : ["bottom-start", "top-start"]), g = S(() => ({
        ...T_,
        ...o.props
      })), b = (M) => {
        const R = {
          label: M[g.value.label],
          value: M[g.value.value],
          disabled: M[g.value.disabled]
        };
        return { ...M, ...R };
      }, C = S(() => o.options.map(b)), w = S(() => {
        const { filterOption: M } = o;
        return !p.value || !M ? C.value : C.value.filter((R) => M(p.value.pattern, R));
      }), y = S(() => f.value && (!!w.value.length || o.loading)), E = S(() => {
        var M;
        return `${i.value}-${(M = d.value) == null ? void 0 : M.hoveringIndex}`;
      }), k = (M) => {
        n(et, M), n(fn, M), z();
      }, T = (M) => {
        var R, D, L, V;
        if ((R = u.value) != null && R.isComposing)
          return;
        const F = Ht(M);
        switch (F) {
          case _e.left:
          case _e.right:
            z();
            break;
          case _e.up:
          case _e.down:
            if (!f.value)
              return;
            M.preventDefault(), (D = d.value) == null || D.navigateOptions(F === _e.up ? "prev" : "next");
            break;
          case _e.enter:
          case _e.numpadEnter:
            if (!f.value) {
              o.type !== "textarea" && z();
              return;
            }
            M.preventDefault(), (L = d.value) != null && L.hoverOption ? (V = d.value) == null || V.selectHoverOption() : f.value = !1;
            break;
          case _e.esc:
            if (!f.value)
              return;
            M.preventDefault(), f.value = !1;
            break;
          case _e.backspace:
            if (o.whole && p.value) {
              const { splitIndex: H, selectionEnd: K, pattern: Z, prefixIndex: J, prefix: ie } = p.value, ue = N();
              if (!ue)
                return;
              const re = ue.value, se = C.value.find((le) => le.value === Z);
              if ((Fe(o.checkIsWhole) ? o.checkIsWhole(Z, ie) : se) && H !== -1 && H + 1 === K) {
                M.preventDefault();
                const le = re.slice(0, J) + re.slice(H + 1);
                n(et, le), n(fn, le), n("whole-remove", Z, ie);
                const Ce = J;
                Re(() => {
                  ue.selectionStart = Ce, ue.selectionEnd = Ce, G();
                });
              }
            }
        }
      }, { wrapperRef: x } = la(u, {
        disabled: r,
        afterFocus() {
          z();
        },
        beforeBlur(M) {
          var R;
          return (R = c.value) == null ? void 0 : R.isFocusInsideContent(M);
        },
        afterBlur() {
          f.value = !1;
        }
      }), I = () => {
        z();
      }, P = (M) => o.options.find((R) => M.value === R[g.value.value]), O = (M) => {
        if (!p.value)
          return;
        const R = N();
        if (!R)
          return;
        const D = R.value, { split: L } = o, V = D.slice(p.value.end), F = V.startsWith(L), H = `${M.value}${F ? "" : L}`, K = D.slice(0, p.value.start) + H + V;
        n(et, K), n(fn, K), n("select", P(M), p.value.prefix);
        const Z = p.value.start + H.length + (F ? 1 : 0);
        Re(() => {
          R.selectionStart = Z, R.selectionEnd = Z, R.focus(), G();
        });
      }, N = () => {
        var M, R;
        return o.type === "textarea" ? (M = u.value) == null ? void 0 : M.textarea : (R = u.value) == null ? void 0 : R.input;
      }, z = () => {
        setTimeout(() => {
          Y(), G(), Re(() => {
            var M;
            return (M = c.value) == null ? void 0 : M.updatePopper();
          });
        }, 0);
      }, Y = () => {
        const M = N();
        if (!M)
          return;
        const R = oX(M), D = M.getBoundingClientRect(), L = x.value.getBoundingClientRect();
        v.value = {
          position: "absolute",
          width: 0,
          height: `${R.height}px`,
          left: `${R.left + D.left - L.left}px`,
          top: `${R.top + D.top - L.top}px`
        };
      }, G = () => {
        const M = N();
        if (document.activeElement !== M) {
          f.value = !1;
          return;
        }
        const { prefix: R, split: D } = o;
        if (p.value = nX(M, R, D), p.value && p.value.splitIndex === -1) {
          f.value = !0, n("search", p.value.pattern, p.value.prefix);
          return;
        }
        f.value = !1;
      };
      return t({
        input: u,
        tooltip: c,
        dropdownVisible: y
      }), (M, R) => (_(), B("div", {
        ref_key: "wrapperRef",
        ref: x,
        class: $(s(a).b())
      }, [
        q(s(Wn), pt(pt(s(l), M.$attrs), {
          ref_key: "elInputRef",
          ref: u,
          "model-value": M.modelValue,
          disabled: s(r),
          role: s(y) ? "combobox" : void 0,
          "aria-activedescendant": s(y) ? s(E) || "" : void 0,
          "aria-controls": s(y) ? s(i) : void 0,
          "aria-expanded": s(y) || void 0,
          "aria-label": M.ariaLabel,
          "aria-autocomplete": s(y) ? "none" : void 0,
          "aria-haspopup": s(y) ? "listbox" : void 0,
          onInput: k,
          onKeydown: T,
          onMousedown: I
        }), io({
          _: 2
        }, [
          bt(M.$slots, (D, L) => ({
            name: L,
            fn: Q((V) => [
              ee(M.$slots, L, Bo(fl(V)))
            ])
          }))
        ]), 1040, ["model-value", "disabled", "role", "aria-activedescendant", "aria-controls", "aria-expanded", "aria-label", "aria-autocomplete", "aria-haspopup"]),
        q(s(Pn), {
          ref_key: "tooltipRef",
          ref: c,
          visible: s(y),
          "popper-class": [s(a).e("popper"), M.popperClass],
          "popper-style": M.popperStyle,
          "popper-options": M.popperOptions,
          placement: s(m),
          "fallback-placements": s(h),
          effect: "light",
          pure: "",
          offset: M.offset,
          "show-arrow": M.showArrow
        }, {
          default: Q(() => [
            W("div", {
              style: Ue(v.value)
            }, null, 4)
          ]),
          content: Q(() => {
            var D;
            return [
              q(cX, {
                ref_key: "dropdownRef",
                ref: d,
                options: s(w),
                disabled: s(r),
                loading: M.loading,
                "content-id": s(i),
                "aria-label": M.ariaLabel,
                onSelect: O,
                onClick: Ze((D = u.value) == null ? void 0 : D.focus, ["stop"])
              }, io({
                _: 2
              }, [
                bt(M.$slots, (L, V) => ({
                  name: V,
                  fn: Q((F) => [
                    ee(M.$slots, V, Bo(fl(F)))
                  ])
                }))
              ]), 1032, ["options", "disabled", "loading", "content-id", "aria-label", "onClick"])
            ];
          }),
          _: 3
        }, 8, ["visible", "popper-class", "popper-style", "popper-options", "placement", "fallback-placements", "offset", "show-arrow"])
      ], 2));
    }
  });
  var pX = /* @__PURE__ */ Ne(fX, [["__file", "mention.vue"]]);
  const vX = rt(pX), hX = Te({
    layout: {
      type: String,
      default: "horizontal",
      values: ["horizontal", "vertical"]
    },
    lazy: Boolean
  }), N_ = Symbol("splitterRootContextKey");
  function mX(e) {
    const t = A(), { width: n, height: o } = bp(t), l = S(() => e.value === "horizontal" ? n.value : o.value);
    return { containerEl: t, containerSize: l };
  }
  function Nm(e) {
    return Number(e.slice(0, -1)) / 100;
  }
  function $m(e) {
    return Number(e.slice(0, -2));
  }
  function Om(e) {
    return Ae(e) && e.endsWith("%");
  }
  function Im(e) {
    return Ae(e) && e.endsWith("px");
  }
  function gX(e, t) {
    const n = S(() => e.value.map((i) => i.size)), o = S(() => e.value.length), l = A([]);
    de([n, o, t], () => {
      var i;
      let u = [], c = 0;
      for (let f = 0; f < o.value; f += 1) {
        const v = (i = e.value[f]) == null ? void 0 : i.size;
        if (Om(v))
          u[f] = Nm(v);
        else if (Im(v))
          u[f] = $m(v) / t.value;
        else if (v || v === 0) {
          const p = Number(v);
          Number.isNaN(p) || (u[f] = p / t.value);
        } else
          c += 1, u[f] = void 0;
      }
      const d = u.reduce((f, v) => f + (v || 0), 0);
      if (d > 1 || !c) {
        const f = 1 / d;
        u = u.map((v) => v === void 0 ? 0 : v * f);
      } else {
        const f = (1 - d) / c;
        u = u.map((v) => v === void 0 ? f : v);
      }
      l.value = u;
    });
    const a = (i) => i * t.value, r = S(() => l.value.map(a));
    return { percentSizes: l, pxSizes: r };
  }
  function bX(e, t, n, o) {
    const l = (g) => g * t.value || 0;
    function a(g, b) {
      return Om(g) ? l(Nm(g)) : Im(g) ? $m(g) : g ?? b;
    }
    const r = A(0), i = A(null);
    let u = [], c = It;
    const d = S(() => e.value.map((g) => [g.min, g.max]));
    de(o, () => {
      if (r.value) {
        const g = new MouseEvent("mouseup", { bubbles: !0 });
        window.dispatchEvent(g);
      }
    });
    const f = (g) => {
      r.value = 0, i.value = { index: g, confirmed: !1 }, u = n.value;
    }, v = (g, b) => {
      var C, w;
      let y = null;
      if ((!i.value || !i.value.confirmed) && b !== 0) {
        if (b > 0)
          y = g, i.value = { index: g, confirmed: !0 };
        else
          for (let z = g; z >= 0; z -= 1)
            if (u[z] > 0) {
              y = z, i.value = { index: z, confirmed: !0 };
              break;
            }
      }
      const E = (w = y ?? ((C = i.value) == null ? void 0 : C.index)) != null ? w : g, k = [...u], T = E + 1, x = a(d.value[E][0], 0), I = a(d.value[T][0], 0), P = a(d.value[E][1], t.value || 0), O = a(d.value[T][1], t.value || 0);
      let N = b;
      k[E] + N < x && (N = x - k[E]), k[T] - N < I && (N = k[T] - I), k[E] + N > P && (N = P - k[E]), k[T] - N > O && (N = k[T] - O), k[E] += N, k[T] -= N, r.value = N, c = () => {
        e.value.forEach((z, Y) => {
          z.size = k[Y];
        }), c = It;
      }, o.value || c();
    }, p = () => {
      o.value && c(), r.value = 0, i.value = null, u = [];
    }, m = [];
    return {
      lazyOffset: r,
      onMoveStart: f,
      onMoving: v,
      onMoveEnd: p,
      movingIndex: i,
      onCollapse: (g, b) => {
        m.length || m.push(...n.value);
        const C = n.value, w = b === "start" ? g : g + 1, y = b === "start" ? g + 1 : g, E = C[w], k = C[y];
        if (E !== 0 && k !== 0)
          C[w] = 0, C[y] += E, m[g] = E;
        else {
          const T = E + k, x = m[g], I = T - x;
          C[y] = x, C[w] = I;
        }
        e.value.forEach((T, x) => {
          T.size = C[x];
        });
      }
    };
  }
  const yX = /* @__PURE__ */ U({
    name: "ElSplitter"
  }), wX = /* @__PURE__ */ U({
    ...yX,
    props: hX,
    emits: ["resizeStart", "resize", "resizeEnd", "collapse"],
    setup(e, { emit: t }) {
      const n = e, o = he("splitter"), l = At(n, "layout"), a = At(n, "lazy"), { containerEl: r, containerSize: i } = mX(l), {
        removeChild: u,
        children: c,
        addChild: d,
        ChildrenSorter: f
      } = Fd(dt(), "ElSplitterPanel");
      de(c, () => {
        c.value.forEach((I, P) => {
          I.setIndex(P);
        });
      });
      const { percentSizes: v, pxSizes: p } = gX(c, i), {
        lazyOffset: m,
        movingIndex: h,
        onMoveStart: g,
        onMoving: b,
        onMoveEnd: C,
        onCollapse: w
      } = bX(c, i, p, a), y = S(() => ({
        [o.cssVarBlockName("bar-offset")]: a.value ? `${m.value}px` : void 0
      }));
      return yt(N_, Rt({
        panels: c,
        percentSizes: v,
        pxSizes: p,
        layout: l,
        lazy: a,
        movingIndex: h,
        containerSize: i,
        onMoveStart: (I) => {
          g(I), t("resizeStart", I, p.value);
        },
        onMoving: (I, P) => {
          b(I, P), a.value || t("resize", I, p.value);
        },
        onMoveEnd: async (I) => {
          C(), await Re(), t("resizeEnd", I, p.value);
        },
        onCollapse: (I, P) => {
          w(I, P), t("collapse", I, P, p.value);
        },
        registerPanel: d,
        unregisterPanel: u
      })), (I, P) => (_(), B("div", {
        ref_key: "containerEl",
        ref: r,
        class: $([s(o).b(), s(o).e(s(l))]),
        style: Ue(s(y))
      }, [
        ee(I.$slots, "default"),
        q(s(f)),
        oe(" Prevent iframe touch events from breaking "),
        s(h) ? (_(), B("div", {
          key: 0,
          class: $([s(o).e("mask"), s(o).e(`mask-${s(l)}`)])
        }, null, 2)) : oe("v-if", !0)
      ], 6));
    }
  });
  var CX = /* @__PURE__ */ Ne(wX, [["__file", "splitter.vue"]]);
  function SX(e) {
    return e && ot(e) ? e : {
      start: !!e,
      end: !!e
    };
  }
  function g0(e, t, n, o) {
    return !!(e != null && e.collapsible.end && t > 0 || n != null && n.collapsible.start && o === 0 && t > 0);
  }
  const EX = /* @__PURE__ */ U({
    name: "ElSplitterBar"
  }), kX = /* @__PURE__ */ U({
    ...EX,
    props: {
      index: {
        type: Number,
        required: !0
      },
      layout: {
        type: String,
        values: ["horizontal", "vertical"],
        default: "horizontal"
      },
      resizable: {
        type: Boolean,
        default: !0
      },
      lazy: Boolean,
      startCollapsible: Boolean,
      endCollapsible: Boolean
    },
    emits: ["moveStart", "moving", "moveEnd", "collapse"],
    setup(e, { emit: t }) {
      const n = e, o = he("splitter-bar"), l = S(() => n.layout === "horizontal"), a = S(() => l.value ? { width: 0 } : { height: 0 }), r = S(() => ({
        width: l.value ? "16px" : "100%",
        height: l.value ? "100%" : "16px",
        cursor: n.resizable ? l.value ? "ew-resize" : "ns-resize" : "auto",
        touchAction: "none"
      })), i = S(() => {
        const b = o.e("dragger");
        return {
          [`${b}-horizontal`]: l.value,
          [`${b}-vertical`]: !l.value,
          [`${b}-active`]: !!u.value
        };
      }), u = A(null), c = (b) => {
        n.resizable && (u.value = [b.pageX, b.pageY], t("moveStart", n.index), window.addEventListener("mouseup", p), window.addEventListener("mousemove", f));
      }, d = (b) => {
        if (n.resizable && b.touches.length === 1) {
          b.preventDefault();
          const C = b.touches[0];
          u.value = [C.pageX, C.pageY], t("moveStart", n.index), window.addEventListener("touchend", m), window.addEventListener("touchmove", v);
        }
      }, f = (b) => {
        const { pageX: C, pageY: w } = b, y = C - u.value[0], E = w - u.value[1], k = l.value ? y : E;
        t("moving", n.index, k);
      }, v = (b) => {
        if (b.touches.length === 1) {
          b.preventDefault();
          const C = b.touches[0], w = C.pageX - u.value[0], y = C.pageY - u.value[1], E = l.value ? w : y;
          t("moving", n.index, E);
        }
      }, p = () => {
        u.value = null, window.removeEventListener("mouseup", p), window.removeEventListener("mousemove", f), t("moveEnd", n.index);
      }, m = () => {
        u.value = null, window.removeEventListener("touchend", m), window.removeEventListener("touchmove", v), t("moveEnd", n.index);
      }, h = S(() => l.value ? ql : Pd), g = S(() => l.value ? Un : Nl);
      return (b, C) => (_(), B("div", {
        class: $([s(o).b()]),
        style: Ue(s(a))
      }, [
        e.startCollapsible ? (_(), B("div", {
          key: 0,
          class: $([s(o).e("collapse-icon"), s(o).e(`${e.layout}-collapse-icon-start`)]),
          onClick: (w) => t("collapse", e.index, "start")
        }, [
          ee(b.$slots, "start-collapsible", {}, () => [
            (_(), ae(ct(s(h)), { style: { width: "12px", height: "12px" } }))
          ])
        ], 10, ["onClick"])) : oe("v-if", !0),
        W("div", {
          class: $([
            s(o).e("dragger"),
            s(i),
            s(o).is("disabled", !e.resizable),
            s(o).is("lazy", e.resizable && e.lazy)
          ]),
          style: Ue(s(r)),
          onMousedown: c,
          onTouchstart: d
        }, null, 38),
        e.endCollapsible ? (_(), B("div", {
          key: 1,
          class: $([s(o).e("collapse-icon"), s(o).e(`${e.layout}-collapse-icon-end`)]),
          onClick: (w) => t("collapse", e.index, "end")
        }, [
          ee(b.$slots, "end-collapsible", {}, () => [
            (_(), ae(ct(s(g)), { style: { width: "12px", height: "12px" } }))
          ])
        ], 10, ["onClick"])) : oe("v-if", !0)
      ], 6));
    }
  });
  var _X = /* @__PURE__ */ Ne(kX, [["__file", "split-bar.vue"]]);
  const TX = Te({
    min: {
      type: [String, Number]
    },
    max: {
      type: [String, Number]
    },
    size: {
      type: [String, Number]
    },
    resizable: {
      type: Boolean,
      default: !0
    },
    collapsible: Boolean
  }), $_ = "ElSplitterPanel", NX = /* @__PURE__ */ U({
    name: $_
  }), $X = /* @__PURE__ */ U({
    ...NX,
    props: TX,
    emits: ["update:size"],
    setup(e, { emit: t }) {
      const n = e, o = he("splitter-panel"), l = Ve(N_);
      l || Zt($_, "usage: <el-splitter><el-splitter-panel /></el-splitter/>");
      const { panels: a, layout: r, lazy: i, containerSize: u, pxSizes: c } = wn(l), {
        registerPanel: d,
        unregisterPanel: f,
        onCollapse: v,
        onMoveEnd: p,
        onMoveStart: m,
        onMoving: h
      } = l, g = A(), b = dt(), C = b.uid, w = A(0), y = S(() => a.value[w.value]), E = (M) => {
        w.value = M;
      }, k = S(() => {
        var M;
        return y.value && (M = c.value[w.value]) != null ? M : 0;
      }), T = S(() => {
        var M;
        return y.value && (M = c.value[w.value + 1]) != null ? M : 0;
      }), x = S(() => y.value ? a.value[w.value + 1] : null), I = S(() => {
        var M;
        return x.value ? n.resizable && ((M = x.value) == null ? void 0 : M.resizable) && (k.value !== 0 || !n.min) && (T.value !== 0 || !x.value.min) : !1;
      }), P = S(() => y.value ? w.value !== a.value.length - 1 : !1), O = S(() => g0(y.value, k.value, x.value, T.value)), N = S(() => g0(x.value, T.value, y.value, k.value));
      function z(M) {
        return Om(M) ? Nm(M) * u.value || 0 : Im(M) ? $m(M) : M ?? 0;
      }
      let Y = !1;
      de(() => n.size, () => {
        if (!Y && y.value) {
          if (!u.value) {
            y.value.size = n.size;
            return;
          }
          const M = z(n.size), R = z(n.max), D = z(n.min), L = Math.min(Math.max(M, D || 0), R || M);
          L !== M && t("update:size", L), y.value.size = L;
        }
      }), de(() => {
        var M;
        return (M = y.value) == null ? void 0 : M.size;
      }, (M) => {
        M !== n.size && (Y = !0, t("update:size", M), Re(() => Y = !1));
      }), de(() => n.resizable, (M) => {
        y.value && (y.value.resizable = M);
      });
      const G = Rt({
        el: g.value,
        uid: C,
        getVnode: () => b.vnode,
        setIndex: E,
        ...n,
        collapsible: S(() => SX(n.collapsible))
      });
      return d(G), Bt(() => f(G)), (M, R) => (_(), B(We, null, [
        W("div", pt({
          ref_key: "panelEl",
          ref: g,
          class: [s(o).b()],
          style: { flexBasis: `${s(k)}px` }
        }, M.$attrs), [
          ee(M.$slots, "default")
        ], 16),
        s(P) ? (_(), ae(_X, {
          key: 0,
          index: w.value,
          layout: s(r),
          lazy: s(i),
          resizable: s(I),
          "start-collapsible": s(O),
          "end-collapsible": s(N),
          onMoveStart: s(m),
          onMoving: s(h),
          onMoveEnd: s(p),
          onCollapse: s(v)
        }, {
          "start-collapsible": Q(() => [
            ee(M.$slots, "start-collapsible")
          ]),
          "end-collapsible": Q(() => [
            ee(M.$slots, "end-collapsible")
          ]),
          _: 3
        }, 8, ["index", "layout", "lazy", "resizable", "start-collapsible", "end-collapsible", "onMoveStart", "onMoving", "onMoveEnd", "onCollapse"])) : oe("v-if", !0)
      ], 64));
    }
  });
  var O_ = /* @__PURE__ */ Ne($X, [["__file", "split-panel.vue"]]);
  const OX = rt(CX, {
    SplitPanel: O_
  }), IX = nn(O_);
  var MX = [
    TR,
    UD,
    x4,
    sU,
    L4,
    j4,
    oS,
    o3,
    l3,
    _n,
    uS,
    Y3,
    Z3,
    vL,
    hL,
    h8,
    AS,
    C8,
    xo,
    $L,
    TS,
    T8,
    H8,
    K8,
    Hd,
    qS,
    bB,
    CB,
    PB,
    RB,
    DB,
    AB,
    VB,
    eF,
    hE,
    cF,
    dF,
    kF,
    kE,
    DF,
    yz,
    wz,
    Cz,
    PE,
    yH,
    wH,
    ze,
    MH,
    VE,
    Wn,
    LE,
    UH,
    ZH,
    g5,
    b5,
    y5,
    w5,
    T5,
    yK,
    _K,
    RK,
    QC,
    YE,
    RS,
    FL,
    BL,
    WK,
    GK,
    nW,
    Go,
    fr,
    qc,
    Q5,
    RW,
    KW,
    WW,
    uj,
    vj,
    rk,
    _j,
    Rj,
    Dj,
    zj,
    X9,
    J9,
    rU,
    SU,
    EU,
    Wl,
    hm,
    n6,
    PU,
    BU,
    FU,
    Pn,
    QU,
    od,
    yY,
    AY,
    aq,
    mq,
    AG,
    VG,
    YG,
    qG,
    eX,
    vX,
    OX,
    IX
  ];
  const fo = "ElInfiniteScroll", xX = 50, PX = 200, RX = 0, DX = {
    delay: {
      type: Number,
      default: PX
    },
    distance: {
      type: Number,
      default: RX
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    immediate: {
      type: Boolean,
      default: !0
    }
  }, Mm = (e, t) => Object.entries(DX).reduce((n, [o, l]) => {
    var a, r;
    const { type: i, default: u } = l, c = e.getAttribute(`infinite-scroll-${o}`);
    let d = (r = (a = t[c]) != null ? a : c) != null ? r : u;
    return d = d === "false" ? !1 : d, d = i(d), n[o] = Number.isNaN(d) ? u : d, n;
  }, {}), I_ = (e) => {
    const { observer: t } = e[fo];
    t && (t.disconnect(), delete e[fo].observer);
  }, AX = (e, t) => {
    const { container: n, containerEl: o, instance: l, observer: a, lastScrollTop: r } = e[fo], { disabled: i, distance: u } = Mm(e, l), { clientHeight: c, scrollHeight: d, scrollTop: f } = o, v = f - r;
    if (e[fo].lastScrollTop = f, a || i || v < 0)
      return;
    let p = !1;
    if (n === e)
      p = d - (c + f) <= u;
    else {
      const { clientTop: m, scrollHeight: h } = e, g = Mp(e, o);
      p = f + c >= g + m + h - u;
    }
    p && t.call(l);
  };
  function Gf(e, t) {
    const { containerEl: n, instance: o } = e[fo], { disabled: l } = Mm(e, o);
    l || n.clientHeight === 0 || (n.scrollHeight <= n.clientHeight ? t.call(o) : I_(e));
  }
  const VX = {
    async mounted(e, t) {
      const { instance: n, value: o } = t;
      hl({
        scope: fo,
        from: "the directive v-infinite-scroll",
        replacement: "the el-scrollbar infinite scroll",
        version: "3.0.0",
        ref: "https://element-plus.org/en-US/component/scrollbar#infinite-scroll"
      }, !0), Fe(o) || Zt(fo, "'v-infinite-scroll' binding value must be a function"), await Re();
      const { delay: l, immediate: a } = Mm(e, n), r = uh(e, !0), i = r === window ? document.documentElement : r, u = lr(AX.bind(null, e, o), l);
      if (r) {
        if (e[fo] = {
          instance: n,
          container: r,
          containerEl: i,
          delay: l,
          cb: o,
          onScroll: u,
          lastScrollTop: i.scrollTop
        }, a) {
          const c = new MutationObserver(lr(Gf.bind(null, e, o), xX));
          e[fo].observer = c, c.observe(e, { childList: !0, subtree: !0 }), Gf(e, o);
        }
        r.addEventListener("scroll", u);
      }
    },
    unmounted(e) {
      if (!e[fo])
        return;
      const { container: t, onScroll: n } = e[fo];
      t == null || t.removeEventListener("scroll", n), I_(e);
    },
    async updated(e) {
      if (!e[fo])
        await Re();
      else {
        const { containerEl: t, cb: n, observer: o } = e[fo];
        t.clientHeight && o && Gf(e, n);
      }
    }
  }, bv = VX;
  bv.install = (e) => {
    e.directive("InfiniteScroll", bv);
  };
  const LX = bv;
  function BX(e, t) {
    let n;
    const o = A(!1), l = Rt({
      ...e,
      originalPosition: "",
      originalOverflow: "",
      visible: !1
    });
    function a(p) {
      l.text = p;
    }
    function r() {
      const p = l.parent, m = v.ns;
      if (!p.vLoadingAddClassList) {
        let h = p.getAttribute("loading-number");
        h = Number.parseInt(h) - 1, h ? p.setAttribute("loading-number", h.toString()) : (jn(p, m.bm("parent", "relative")), p.removeAttribute("loading-number")), jn(p, m.bm("parent", "hidden"));
      }
      i(), f.unmount();
    }
    function i() {
      var p, m;
      (m = (p = v.$el) == null ? void 0 : p.parentNode) == null || m.removeChild(v.$el);
    }
    function u() {
      var p;
      e.beforeClose && !e.beforeClose() || (o.value = !0, clearTimeout(n), n = setTimeout(c, 400), l.visible = !1, (p = e.closed) == null || p.call(e));
    }
    function c() {
      if (!o.value)
        return;
      const p = l.parent;
      o.value = !1, p.vLoadingAddClassList = void 0, r();
    }
    const f = r1(/* @__PURE__ */ U({
      name: "ElLoading",
      setup(p, { expose: m }) {
        const { ns: h, zIndex: g } = xd("loading");
        return m({
          ns: h,
          zIndex: g
        }), () => {
          const b = l.spinner || l.svg, C = qe("svg", {
            class: "circular",
            viewBox: l.svgViewBox ? l.svgViewBox : "0 0 50 50",
            ...b ? { innerHTML: b } : {}
          }, [
            qe("circle", {
              class: "path",
              cx: "25",
              cy: "25",
              r: "20",
              fill: "none"
            })
          ]), w = l.text ? qe("p", { class: h.b("text") }, [l.text]) : void 0;
          return qe(Mn, {
            name: h.b("fade"),
            onAfterLeave: c
          }, {
            default: Q(() => [
              it(q("div", {
                style: {
                  backgroundColor: l.background || ""
                },
                class: [
                  h.b("mask"),
                  l.customClass,
                  h.is("fullscreen", l.fullscreen)
                ]
              }, [
                qe("div", {
                  class: h.b("spinner")
                }, [C, w])
              ]), [[Mt, l.visible]])
            ])
          });
        };
      }
    }));
    Object.assign(f._context, t ?? {});
    const v = f.mount(document.createElement("div"));
    return {
      ...wn(l),
      setText: a,
      removeElLoadingChild: i,
      close: u,
      handleAfterLeave: c,
      vm: v,
      get $el() {
        return v.$el;
      }
    };
  }
  let Wu;
  const Jr = function(e = {}, t) {
    if (!xt)
      return;
    const n = FX(e);
    if (n.fullscreen && Wu)
      return Wu;
    const o = BX({
      ...n,
      closed: () => {
        var a;
        (a = n.closed) == null || a.call(n), n.fullscreen && (Wu = void 0);
      }
    }, t ?? Jr._context);
    zX(n, n.parent, o), b0(n, n.parent, o), n.parent.vLoadingAddClassList = () => b0(n, n.parent, o);
    let l = n.parent.getAttribute("loading-number");
    return l ? l = `${Number.parseInt(l) + 1}` : l = "1", n.parent.setAttribute("loading-number", l), n.parent.appendChild(o.$el), Re(() => o.visible.value = n.visible), n.fullscreen && (Wu = o), o;
  }, FX = (e) => {
    var t, n, o, l;
    let a;
    return Ae(e.target) ? a = (t = document.querySelector(e.target)) != null ? t : document.body : a = e.target || document.body, {
      parent: a === document.body || e.body ? document.body : a,
      background: e.background || "",
      svg: e.svg || "",
      svgViewBox: e.svgViewBox || "",
      spinner: e.spinner || !1,
      text: e.text || "",
      fullscreen: a === document.body && ((n = e.fullscreen) != null ? n : !0),
      lock: (o = e.lock) != null ? o : !1,
      customClass: e.customClass || "",
      visible: (l = e.visible) != null ? l : !0,
      beforeClose: e.beforeClose,
      closed: e.closed,
      target: a
    };
  }, zX = async (e, t, n) => {
    const { nextZIndex: o } = n.vm.zIndex || n.vm._.exposed.zIndex, l = {};
    if (e.fullscreen)
      n.originalPosition.value = Bl(document.body, "position"), n.originalOverflow.value = Bl(document.body, "overflow"), l.zIndex = o();
    else if (e.parent === document.body) {
      n.originalPosition.value = Bl(document.body, "position"), await Re();
      for (const a of ["top", "left"]) {
        const r = a === "top" ? "scrollTop" : "scrollLeft";
        l[a] = `${e.target.getBoundingClientRect()[a] + document.body[r] + document.documentElement[r] - Number.parseInt(Bl(document.body, `margin-${a}`), 10)}px`;
      }
      for (const a of ["height", "width"])
        l[a] = `${e.target.getBoundingClientRect()[a]}px`;
    } else
      n.originalPosition.value = Bl(t, "position");
    for (const [a, r] of Object.entries(l))
      n.$el.style[a] = r;
  }, b0 = (e, t, n) => {
    const o = n.vm.ns || n.vm._.exposed.ns;
    ["absolute", "fixed", "sticky"].includes(n.originalPosition.value) ? jn(t, o.bm("parent", "relative")) : _o(t, o.bm("parent", "relative")), e.fullscreen && e.lock ? _o(t, o.bm("parent", "hidden")) : jn(t, o.bm("parent", "hidden"));
  };
  Jr._context = null;
  const Us = Symbol("ElLoading"), Ha = (e) => `element-loading-${gl(e)}`, y0 = (e, t) => {
    var n, o, l, a;
    const r = t.instance, i = (p) => ot(t.value) ? t.value[p] : void 0, u = (p) => {
      const m = Ae(p) && (r == null ? void 0 : r[p]) || p;
      return A(m);
    }, c = (p) => u(i(p) || e.getAttribute(Ha(p))), d = (n = i("fullscreen")) != null ? n : t.modifiers.fullscreen, f = {
      text: c("text"),
      svg: c("svg"),
      svgViewBox: c("svgViewBox"),
      spinner: c("spinner"),
      background: c("background"),
      customClass: c("customClass"),
      fullscreen: d,
      target: (o = i("target")) != null ? o : d ? void 0 : e,
      body: (l = i("body")) != null ? l : t.modifiers.body,
      lock: (a = i("lock")) != null ? a : t.modifiers.lock
    }, v = Jr(f);
    v._context = ri._context, e[Us] = {
      options: f,
      instance: v
    };
  }, HX = (e, t) => {
    for (const n of Object.keys(e))
      Kt(e[n]) && (e[n].value = t[n]);
  }, ri = {
    mounted(e, t) {
      t.value && y0(e, t);
    },
    updated(e, t) {
      const n = e[Us];
      if (!t.value) {
        n == null || n.instance.close(), e[Us] = null;
        return;
      }
      n ? HX(n.options, ot(t.value) ? t.value : {
        text: e.getAttribute(Ha("text")),
        svg: e.getAttribute(Ha("svg")),
        svgViewBox: e.getAttribute(Ha("svgViewBox")),
        spinner: e.getAttribute(Ha("spinner")),
        background: e.getAttribute(Ha("background")),
        customClass: e.getAttribute(Ha("customClass"))
      }) : y0(e, t);
    },
    unmounted(e) {
      var t;
      (t = e[Us]) == null || t.instance.close(), e[Us] = null;
    }
  };
  ri._context = null;
  const KX = {
    install(e) {
      Jr._context = e._context, ri._context = e._context, e.directive("loading", ri), e.config.globalProperties.$loading = Jr;
    },
    directive: ri,
    service: Jr
  }, M_ = [
    "primary",
    "success",
    "info",
    "warning",
    "error"
  ], x_ = [
    "top",
    "top-left",
    "top-right",
    "bottom",
    "bottom-left",
    "bottom-right"
  ], Zr = "top", Bn = en({
    customClass: "",
    dangerouslyUseHTMLString: !1,
    duration: 3e3,
    icon: void 0,
    id: "",
    message: "",
    onClose: void 0,
    showClose: !1,
    type: "info",
    plain: !1,
    offset: 16,
    placement: void 0,
    zIndex: 0,
    grouping: !1,
    repeatNum: 1,
    appendTo: xt ? document.body : void 0
  }), WX = Te({
    customClass: {
      type: String,
      default: Bn.customClass
    },
    dangerouslyUseHTMLString: {
      type: Boolean,
      default: Bn.dangerouslyUseHTMLString
    },
    duration: {
      type: Number,
      default: Bn.duration
    },
    icon: {
      type: Lt,
      default: Bn.icon
    },
    id: {
      type: String,
      default: Bn.id
    },
    message: {
      type: X([
        String,
        Object,
        Function
      ]),
      default: Bn.message
    },
    onClose: {
      type: X(Function),
      default: Bn.onClose
    },
    showClose: {
      type: Boolean,
      default: Bn.showClose
    },
    type: {
      type: String,
      values: M_,
      default: Bn.type
    },
    plain: {
      type: Boolean,
      default: Bn.plain
    },
    offset: {
      type: Number,
      default: Bn.offset
    },
    placement: {
      type: String,
      values: x_,
      default: Bn.placement
    },
    zIndex: {
      type: Number,
      default: Bn.zIndex
    },
    grouping: {
      type: Boolean,
      default: Bn.grouping
    },
    repeatNum: {
      type: Number,
      default: Bn.repeatNum
    }
  }), jX = {
    destroy: () => !0
  }, Ko = Nv({}), UX = (e) => (Ko[e] || (Ko[e] = Nv([])), Ko[e]), YX = (e, t) => {
    const n = Ko[t] || [], o = n.findIndex((r) => r.id === e), l = n[o];
    let a;
    return o > 0 && (a = n[o - 1]), { current: l, prev: a };
  }, qX = (e, t) => {
    const { prev: n } = YX(e, t);
    return n ? n.vm.exposed.bottom.value : 0;
  }, GX = (e, t, n) => (Ko[n] || []).findIndex((a) => a.id === e) > 0 ? 16 : t, XX = /* @__PURE__ */ U({
    name: "ElMessage"
  }), JX = /* @__PURE__ */ U({
    ...XX,
    props: WX,
    emits: jX,
    setup(e, { expose: t, emit: n }) {
      const o = e, { Close: l } = ph, a = A(!1), { ns: r, zIndex: i } = xd("message"), { currentZIndex: u, nextZIndex: c } = i, d = A(), f = A(!1), v = A(0);
      let p;
      const m = S(() => o.type ? o.type === "error" ? "danger" : o.type : "info"), h = S(() => {
        const N = o.type;
        return { [r.bm("icon", N)]: N && Ma[N] };
      }), g = S(() => o.icon || Ma[o.type] || ""), b = S(() => o.placement || Zr), C = S(() => qX(o.id, b.value)), w = S(() => GX(o.id, o.offset, b.value) + C.value), y = S(() => v.value + w.value), E = S(() => b.value.includes("left") ? r.is("left") : b.value.includes("right") ? r.is("right") : r.is("center")), k = S(() => b.value.startsWith("top") ? "top" : "bottom"), T = S(() => ({
        [k.value]: `${w.value}px`,
        zIndex: u.value
      }));
      function x() {
        o.duration !== 0 && ({ stop: p } = os(() => {
          P();
        }, o.duration));
      }
      function I() {
        p == null || p();
      }
      function P() {
        f.value = !1, Re(() => {
          var N;
          a.value || ((N = o.onClose) == null || N.call(o), n("destroy"));
        });
      }
      function O(N) {
        Ht(N) === _e.esc && P();
      }
      return ft(() => {
        x(), c(), f.value = !0;
      }), de(() => o.repeatNum, () => {
        I(), x();
      }), Dt(document, "keydown", O), qt(d, () => {
        v.value = d.value.getBoundingClientRect().height;
      }), t({
        visible: f,
        bottom: y,
        close: P
      }), (N, z) => (_(), ae(Mn, {
        name: s(r).b("fade"),
        onBeforeEnter: (Y) => a.value = !0,
        onBeforeLeave: N.onClose,
        onAfterLeave: (Y) => N.$emit("destroy"),
        persisted: ""
      }, {
        default: Q(() => [
          it(W("div", {
            id: N.id,
            ref_key: "messageRef",
            ref: d,
            class: $([
              s(r).b(),
              { [s(r).m(N.type)]: N.type },
              s(r).is("closable", N.showClose),
              s(r).is("plain", N.plain),
              s(r).is("bottom", s(k) === "bottom"),
              s(E),
              N.customClass
            ]),
            style: Ue(s(T)),
            role: "alert",
            onMouseenter: I,
            onMouseleave: x
          }, [
            N.repeatNum > 1 ? (_(), ae(s(oS), {
              key: 0,
              value: N.repeatNum,
              type: s(m),
              class: $(s(r).e("badge"))
            }, null, 8, ["value", "type", "class"])) : oe("v-if", !0),
            s(g) ? (_(), ae(s(ze), {
              key: 1,
              class: $([s(r).e("icon"), s(h)])
            }, {
              default: Q(() => [
                (_(), ae(ct(s(g))))
              ]),
              _: 1
            }, 8, ["class"])) : oe("v-if", !0),
            ee(N.$slots, "default", {}, () => [
              N.dangerouslyUseHTMLString ? (_(), B(We, { key: 1 }, [
                oe(" Caution here, message could've been compromised, never use user's input as message "),
                W("p", {
                  class: $(s(r).e("content")),
                  innerHTML: N.message
                }, null, 10, ["innerHTML"])
              ], 2112)) : (_(), B("p", {
                key: 0,
                class: $(s(r).e("content"))
              }, ke(N.message), 3))
            ]),
            N.showClose ? (_(), ae(s(ze), {
              key: 2,
              class: $(s(r).e("closeBtn")),
              onClick: Ze(P, ["stop"])
            }, {
              default: Q(() => [
                q(s(l))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : oe("v-if", !0)
          ], 46, ["id"]), [
            [Mt, f.value]
          ])
        ]),
        _: 3
      }, 8, ["name", "onBeforeEnter", "onBeforeLeave", "onAfterLeave"]));
    }
  });
  var ZX = /* @__PURE__ */ Ne(JX, [["__file", "message.vue"]]);
  let QX = 1;
  const eJ = (e) => {
    if (!e.appendTo)
      e.appendTo = document.body;
    else if (Ae(e.appendTo)) {
      let n = document.querySelector(e.appendTo);
      Qn(n) || (vt("ElMessage", "the appendTo option is not an HTMLElement. Falling back to document.body."), n = document.body), e.appendTo = n;
    }
  }, tJ = (e) => {
    !e.placement && Ae(Hn.placement) && Hn.placement && (e.placement = Hn.placement), e.placement || (e.placement = Zr), x_.includes(e.placement) || (vt("ElMessage", `Invalid placement: ${e.placement}. Falling back to '${Zr}'.`), e.placement = Zr);
  }, P_ = (e) => {
    const t = !e || Ae(e) || Wt(e) || Fe(e) ? { message: e } : e, n = {
      ...Bn,
      ...t
    };
    return eJ(n), tJ(n), Vt(Hn.grouping) && !n.grouping && (n.grouping = Hn.grouping), je(Hn.duration) && n.duration === 3e3 && (n.duration = Hn.duration), je(Hn.offset) && n.offset === 16 && (n.offset = Hn.offset), Vt(Hn.showClose) && !n.showClose && (n.showClose = Hn.showClose), Vt(Hn.plain) && !n.plain && (n.plain = Hn.plain), n;
  }, nJ = (e) => {
    const t = e.props.placement || Zr, n = Ko[t], o = n.indexOf(e);
    if (o === -1)
      return;
    n.splice(o, 1);
    const { handler: l } = e;
    l.close();
  }, oJ = ({ appendTo: e, ...t }, n) => {
    const o = `message_${QX++}`, l = t.onClose, a = document.createElement("div"), r = {
      ...t,
      id: o,
      onClose: () => {
        l == null || l(), nJ(d);
      },
      onDestroy: () => {
        Na(null, a);
      }
    }, i = q(ZX, r, Fe(r.message) || Wt(r.message) ? {
      default: Fe(r.message) ? r.message : () => r.message
    } : null);
    i.appContext = n || mr._context, Na(i, a), e.appendChild(a.firstElementChild);
    const u = i.component, d = {
      id: o,
      vnode: i,
      vm: u,
      handler: {
        close: () => {
          u.exposed.close();
        }
      },
      props: i.component.props
    };
    return d;
  }, mr = (e = {}, t) => {
    if (!xt)
      return { close: () => {
      } };
    const n = P_(e), o = UX(n.placement || Zr);
    if (n.grouping && o.length) {
      const a = o.find(({ vnode: r }) => {
        var i;
        return ((i = r.props) == null ? void 0 : i.message) === n.message;
      });
      if (a)
        return a.props.repeatNum += 1, a.props.type = n.type, a.handler;
    }
    if (je(Hn.max) && o.length >= Hn.max)
      return { close: () => {
      } };
    const l = oJ(n, t);
    return o.push(l), l.handler;
  };
  M_.forEach((e) => {
    mr[e] = (t = {}, n) => {
      const o = P_(t);
      return mr({ ...o, type: e }, n);
    };
  });
  function lJ(e) {
    for (const t in Ko)
      if (Ot(Ko, t)) {
        const n = [...Ko[t]];
        for (const o of n)
          (!e || e === o.props.type) && o.handler.close();
      }
  }
  function aJ(e) {
    if (!Ko[e])
      return;
    [...Ko[e]].forEach((n) => n.handler.close());
  }
  mr.closeAll = lJ;
  mr.closeAllByPlacement = aJ;
  mr._context = null;
  const rJ = vC(mr, "$message"), yv = "_trap-focus-children", Ja = [], w0 = (e) => {
    var t;
    if (Ja.length === 0)
      return;
    const n = Ht(e), o = Ja[Ja.length - 1][yv];
    if (o.length > 0 && n === _e.tab) {
      if (o.length === 1) {
        e.preventDefault(), document.activeElement !== o[0] && o[0].focus();
        return;
      }
      const l = e.shiftKey, a = e.target === o[0], r = e.target === o[o.length - 1];
      if (a && l && (e.preventDefault(), o[o.length - 1].focus()), r && !l && (e.preventDefault(), o[0].focus()), typeof process < "u" && process.env.NODE_ENV === "test") {
        const i = o.indexOf(e.target);
        i !== -1 && ((t = o[l ? i - 1 : i + 1]) == null || t.focus());
      }
    }
  }, sJ = {
    beforeMount(e) {
      e[yv] = Tb(e), Ja.push(e), Ja.length <= 1 && document.addEventListener("keydown", w0);
    },
    updated(e) {
      Re(() => {
        e[yv] = Tb(e);
      });
    },
    unmounted() {
      Ja.shift(), Ja.length === 0 && document.removeEventListener("keydown", w0);
    }
  }, iJ = /* @__PURE__ */ U({
    name: "ElMessageBox",
    directives: {
      TrapFocus: sJ
    },
    components: {
      ElButton: _n,
      ElFocusTrap: _s,
      ElInput: Wn,
      ElOverlay: Kh,
      ElIcon: ze,
      ...ph
    },
    inheritAttrs: !1,
    props: {
      buttonSize: {
        type: String,
        validator: uk
      },
      modal: {
        type: Boolean,
        default: !0
      },
      lockScroll: {
        type: Boolean,
        default: !0
      },
      showClose: {
        type: Boolean,
        default: !0
      },
      closeOnClickModal: {
        type: Boolean,
        default: !0
      },
      closeOnPressEscape: {
        type: Boolean,
        default: !0
      },
      closeOnHashChange: {
        type: Boolean,
        default: !0
      },
      center: Boolean,
      draggable: Boolean,
      overflow: Boolean,
      roundButton: Boolean,
      container: {
        type: String,
        default: "body"
      },
      boxType: {
        type: String,
        default: ""
      }
    },
    emits: ["vanish", "action"],
    setup(e, { emit: t }) {
      const {
        locale: n,
        zIndex: o,
        ns: l,
        size: a
      } = xd("message-box", S(() => e.buttonSize)), { t: r } = n, { nextZIndex: i } = o, u = A(!1), c = Rt({
        autofocus: !0,
        beforeClose: null,
        callback: null,
        cancelButtonText: "",
        cancelButtonClass: "",
        confirmButtonText: "",
        confirmButtonClass: "",
        customClass: "",
        customStyle: {},
        dangerouslyUseHTMLString: !1,
        distinguishCancelAndClose: !1,
        icon: "",
        closeIcon: "",
        inputPattern: null,
        inputPlaceholder: "",
        inputType: "text",
        inputValue: "",
        inputValidator: void 0,
        inputErrorMessage: "",
        message: "",
        modalFade: !0,
        modalClass: "",
        showCancelButton: !1,
        showConfirmButton: !0,
        type: "",
        title: void 0,
        showInput: !1,
        action: "",
        confirmButtonLoading: !1,
        cancelButtonLoading: !1,
        confirmButtonLoadingIcon: zl(Cl),
        cancelButtonLoadingIcon: zl(Cl),
        confirmButtonDisabled: !1,
        editorErrorMessage: "",
        validateError: !1,
        zIndex: i()
      }), d = S(() => {
        const R = c.type;
        return { [l.bm("icon", R)]: R && Ma[R] };
      }), f = xn(), v = xn(), p = S(() => {
        const R = c.type;
        return c.icon || R && Ma[R] || "";
      }), m = S(() => !!c.message), h = A(), g = A(), b = A(), C = A(), w = A(), y = S(() => c.confirmButtonClass);
      de(() => c.inputValue, async (R) => {
        await Re(), e.boxType === "prompt" && R && z();
      }, { immediate: !0 }), de(() => u.value, (R) => {
        var D, L;
        R && (e.boxType !== "prompt" && (c.autofocus ? b.value = (L = (D = w.value) == null ? void 0 : D.$el) != null ? L : h.value : b.value = h.value), c.zIndex = i()), e.boxType === "prompt" && (R ? Re().then(() => {
          var V;
          C.value && C.value.$el && (c.autofocus ? b.value = (V = Y()) != null ? V : h.value : b.value = h.value);
        }) : (c.editorErrorMessage = "", c.validateError = !1));
      });
      const E = S(() => e.draggable), k = S(() => e.overflow), { isDragging: T } = wE(h, g, E, k);
      ft(async () => {
        await Re(), e.closeOnHashChange && window.addEventListener("hashchange", x);
      }), Bt(() => {
        e.closeOnHashChange && window.removeEventListener("hashchange", x);
      });
      function x() {
        u.value && (u.value = !1, Re(() => {
          c.action && t("action", c.action);
        }));
      }
      const I = () => {
        e.closeOnClickModal && N(c.distinguishCancelAndClose ? "close" : "cancel");
      }, P = Hh(I), O = (R) => {
        if (c.inputType !== "textarea")
          return R.preventDefault(), N("confirm");
      }, N = (R) => {
        var D;
        e.boxType === "prompt" && R === "confirm" && !z() || (c.action = R, c.beforeClose ? (D = c.beforeClose) == null || D.call(c, R, c, x) : x());
      }, z = () => {
        if (e.boxType === "prompt") {
          const R = c.inputPattern;
          if (R && !R.test(c.inputValue || ""))
            return c.editorErrorMessage = c.inputErrorMessage || r("el.messagebox.error"), c.validateError = !0, !1;
          const D = c.inputValidator;
          if (Fe(D)) {
            const L = D(c.inputValue);
            if (L === !1)
              return c.editorErrorMessage = c.inputErrorMessage || r("el.messagebox.error"), c.validateError = !0, !1;
            if (Ae(L))
              return c.editorErrorMessage = L, c.validateError = !0, !1;
          }
        }
        return c.editorErrorMessage = "", c.validateError = !1, !0;
      }, Y = () => {
        var R, D;
        const L = (R = C.value) == null ? void 0 : R.$refs;
        return (D = L == null ? void 0 : L.input) != null ? D : L == null ? void 0 : L.textarea;
      }, G = () => {
        N("close");
      }, M = () => {
        e.closeOnPressEscape && G();
      };
      return e.lockScroll && Wd(u, { ns: l }), {
        ...wn(c),
        ns: l,
        overlayEvent: P,
        visible: u,
        hasMessage: m,
        typeClass: d,
        contentId: f,
        inputId: v,
        btnSize: a,
        iconComponent: p,
        confirmButtonClasses: y,
        rootRef: h,
        focusStartRef: b,
        headerRef: g,
        inputRef: C,
        isDragging: T,
        confirmRef: w,
        doClose: x,
        handleClose: G,
        onCloseRequested: M,
        handleWrapperClick: I,
        handleInputEnter: O,
        handleAction: N,
        t: r
      };
    }
  });
  function uJ(e, t, n, o, l, a) {
    const r = $t("el-icon"), i = $t("el-input"), u = $t("el-button"), c = $t("el-focus-trap"), d = $t("el-overlay");
    return _(), ae(Mn, {
      name: "fade-in-linear",
      onAfterLeave: (f) => e.$emit("vanish"),
      persisted: ""
    }, {
      default: Q(() => [
        it(q(d, {
          "z-index": e.zIndex,
          "overlay-class": [e.ns.is("message-box"), e.modalClass],
          mask: e.modal
        }, {
          default: Q(() => [
            W("div", {
              role: "dialog",
              "aria-label": e.title,
              "aria-modal": "true",
              "aria-describedby": e.showInput ? void 0 : e.contentId,
              class: $(`${e.ns.namespace.value}-overlay-message-box`),
              onClick: e.overlayEvent.onClick,
              onMousedown: e.overlayEvent.onMousedown,
              onMouseup: e.overlayEvent.onMouseup
            }, [
              q(c, {
                loop: "",
                trapped: e.visible,
                "focus-trap-el": e.rootRef,
                "focus-start-el": e.focusStartRef,
                onReleaseRequested: e.onCloseRequested
              }, {
                default: Q(() => [
                  W("div", {
                    ref: "rootRef",
                    class: $([
                      e.ns.b(),
                      e.customClass,
                      e.ns.is("draggable", e.draggable),
                      e.ns.is("dragging", e.isDragging),
                      { [e.ns.m("center")]: e.center }
                    ]),
                    style: Ue(e.customStyle),
                    tabindex: "-1",
                    onClick: Ze(() => {
                    }, ["stop"])
                  }, [
                    e.title !== null && e.title !== void 0 ? (_(), B("div", {
                      key: 0,
                      ref: "headerRef",
                      class: $([e.ns.e("header"), { "show-close": e.showClose }])
                    }, [
                      W("div", {
                        class: $(e.ns.e("title"))
                      }, [
                        e.iconComponent && e.center ? (_(), ae(r, {
                          key: 0,
                          class: $([e.ns.e("status"), e.typeClass])
                        }, {
                          default: Q(() => [
                            (_(), ae(ct(e.iconComponent)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : oe("v-if", !0),
                        W("span", null, ke(e.title), 1)
                      ], 2),
                      e.showClose ? (_(), B("button", {
                        key: 0,
                        type: "button",
                        class: $(e.ns.e("headerbtn")),
                        "aria-label": e.t("el.messagebox.close"),
                        onClick: (f) => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel"),
                        onKeydown: on(Ze((f) => e.handleAction(e.distinguishCancelAndClose ? "close" : "cancel"), ["prevent"]), ["enter"])
                      }, [
                        q(r, {
                          class: $(e.ns.e("close"))
                        }, {
                          default: Q(() => [
                            (_(), ae(ct(e.closeIcon || "close")))
                          ]),
                          _: 1
                        }, 8, ["class"])
                      ], 42, ["aria-label", "onClick", "onKeydown"])) : oe("v-if", !0)
                    ], 2)) : oe("v-if", !0),
                    W("div", {
                      id: e.contentId,
                      class: $(e.ns.e("content"))
                    }, [
                      W("div", {
                        class: $(e.ns.e("container"))
                      }, [
                        e.iconComponent && !e.center && e.hasMessage ? (_(), ae(r, {
                          key: 0,
                          class: $([e.ns.e("status"), e.typeClass])
                        }, {
                          default: Q(() => [
                            (_(), ae(ct(e.iconComponent)))
                          ]),
                          _: 1
                        }, 8, ["class"])) : oe("v-if", !0),
                        e.hasMessage ? (_(), B("div", {
                          key: 1,
                          class: $(e.ns.e("message"))
                        }, [
                          ee(e.$slots, "default", {}, () => [
                            e.dangerouslyUseHTMLString ? (_(), ae(ct(e.showInput ? "label" : "p"), {
                              key: 1,
                              for: e.showInput ? e.inputId : void 0,
                              innerHTML: e.message
                            }, null, 8, ["for", "innerHTML"])) : (_(), ae(ct(e.showInput ? "label" : "p"), {
                              key: 0,
                              for: e.showInput ? e.inputId : void 0,
                              textContent: ke(e.message)
                            }, null, 8, ["for", "textContent"]))
                          ])
                        ], 2)) : oe("v-if", !0)
                      ], 2),
                      it(W("div", {
                        class: $(e.ns.e("input"))
                      }, [
                        q(i, {
                          id: e.inputId,
                          ref: "inputRef",
                          modelValue: e.inputValue,
                          "onUpdate:modelValue": (f) => e.inputValue = f,
                          type: e.inputType,
                          placeholder: e.inputPlaceholder,
                          "aria-invalid": e.validateError,
                          class: $({ invalid: e.validateError }),
                          onKeydown: on(e.handleInputEnter, ["enter"])
                        }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "type", "placeholder", "aria-invalid", "class", "onKeydown"]),
                        W("div", {
                          class: $(e.ns.e("errormsg")),
                          style: Ue({
                            visibility: e.editorErrorMessage ? "visible" : "hidden"
                          })
                        }, ke(e.editorErrorMessage), 7)
                      ], 2), [
                        [Mt, e.showInput]
                      ])
                    ], 10, ["id"]),
                    W("div", {
                      class: $(e.ns.e("btns"))
                    }, [
                      e.showCancelButton ? (_(), ae(u, {
                        key: 0,
                        loading: e.cancelButtonLoading,
                        "loading-icon": e.cancelButtonLoadingIcon,
                        class: $([e.cancelButtonClass]),
                        round: e.roundButton,
                        size: e.btnSize,
                        onClick: (f) => e.handleAction("cancel"),
                        onKeydown: on(Ze((f) => e.handleAction("cancel"), ["prevent"]), ["enter"])
                      }, {
                        default: Q(() => [
                          Ct(ke(e.cancelButtonText || e.t("el.messagebox.cancel")), 1)
                        ]),
                        _: 1
                      }, 8, ["loading", "loading-icon", "class", "round", "size", "onClick", "onKeydown"])) : oe("v-if", !0),
                      it(q(u, {
                        ref: "confirmRef",
                        type: "primary",
                        loading: e.confirmButtonLoading,
                        "loading-icon": e.confirmButtonLoadingIcon,
                        class: $([e.confirmButtonClasses]),
                        round: e.roundButton,
                        disabled: e.confirmButtonDisabled,
                        size: e.btnSize,
                        onClick: (f) => e.handleAction("confirm"),
                        onKeydown: on(Ze((f) => e.handleAction("confirm"), ["prevent"]), ["enter"])
                      }, {
                        default: Q(() => [
                          Ct(ke(e.confirmButtonText || e.t("el.messagebox.confirm")), 1)
                        ]),
                        _: 1
                      }, 8, ["loading", "loading-icon", "class", "round", "disabled", "size", "onClick", "onKeydown"]), [
                        [Mt, e.showConfirmButton]
                      ])
                    ], 2)
                  ], 14, ["onClick"])
                ]),
                _: 3
              }, 8, ["trapped", "focus-trap-el", "focus-start-el", "onReleaseRequested"])
            ], 42, ["aria-label", "aria-describedby", "onClick", "onMousedown", "onMouseup"])
          ]),
          _: 3
        }, 8, ["z-index", "overlay-class", "mask"]), [
          [Mt, e.visible]
        ])
      ]),
      _: 3
    }, 8, ["onAfterLeave"]);
  }
  var cJ = /* @__PURE__ */ Ne(iJ, [["render", uJ], ["__file", "index.vue"]]);
  const Fi = /* @__PURE__ */ new Map(), dJ = (e) => {
    let t = document.body;
    return e.appendTo && (Ae(e.appendTo) && (t = document.querySelector(e.appendTo)), Qn(e.appendTo) && (t = e.appendTo), Qn(t) || (vt("ElMessageBox", "the appendTo option is not an HTMLElement. Falling back to document.body."), t = document.body)), t;
  }, fJ = (e, t, n = null) => {
    const o = q(cJ, e, Fe(e.message) || Wt(e.message) ? {
      default: Fe(e.message) ? e.message : () => e.message
    } : null);
    return o.appContext = n, Na(o, t), dJ(e).appendChild(t.firstElementChild), o.component;
  }, pJ = () => document.createElement("div"), vJ = (e, t) => {
    const n = pJ();
    e.onVanish = () => {
      Na(null, n), Fi.delete(l);
    }, e.onAction = (a) => {
      const r = Fi.get(l);
      let i;
      e.showInput ? i = { value: l.inputValue, action: a } : i = a, e.callback ? e.callback(i, o.proxy) : a === "cancel" || a === "close" ? e.distinguishCancelAndClose && a !== "cancel" ? r.reject("close") : r.reject("cancel") : r.resolve(i);
    };
    const o = fJ(e, n, t), l = o.proxy;
    for (const a in e)
      Ot(e, a) && !Ot(l.$props, a) && (a === "closeIcon" && ot(e[a]) ? l[a] = zl(e[a]) : l[a] = e[a]);
    return l.visible = !0, l;
  };
  function $s(e, t = null) {
    if (!xt)
      return Promise.reject();
    let n;
    return Ae(e) || Wt(e) ? e = {
      message: e
    } : n = e.callback, new Promise((o, l) => {
      const a = vJ(e, t ?? $s._context);
      Fi.set(a, {
        options: e,
        callback: n,
        resolve: o,
        reject: l
      });
    });
  }
  const hJ = ["alert", "confirm", "prompt"], mJ = {
    alert: { closeOnPressEscape: !1, closeOnClickModal: !1 },
    confirm: { showCancelButton: !0 },
    prompt: { showCancelButton: !0, showInput: !0 }
  };
  hJ.forEach((e) => {
    $s[e] = gJ(e);
  });
  function gJ(e) {
    return (t, n, o, l) => {
      let a = "";
      return ot(n) ? (o = n, a = "") : kt(n) ? a = "" : a = n, $s(Object.assign({
        title: a,
        message: t,
        type: "",
        ...mJ[e]
      }, o, {
        boxType: e
      }), l);
    };
  }
  $s.close = () => {
    Fi.forEach((e, t) => {
      t.doClose();
    }), Fi.clear();
  };
  $s._context = null;
  const pa = $s;
  pa.install = (e) => {
    pa._context = e._context, e.config.globalProperties.$msgbox = pa, e.config.globalProperties.$messageBox = pa, e.config.globalProperties.$alert = pa.alert, e.config.globalProperties.$confirm = pa.confirm, e.config.globalProperties.$prompt = pa.prompt;
  };
  const bJ = pa, R_ = [
    "primary",
    "success",
    "info",
    "warning",
    "error"
  ], yJ = Te({
    customClass: {
      type: String,
      default: ""
    },
    dangerouslyUseHTMLString: Boolean,
    duration: {
      type: Number,
      default: 4500
    },
    icon: {
      type: Lt
    },
    id: {
      type: String,
      default: ""
    },
    message: {
      type: X([
        String,
        Object,
        Function
      ]),
      default: ""
    },
    offset: {
      type: Number,
      default: 0
    },
    onClick: {
      type: X(Function),
      default: () => {
      }
    },
    onClose: {
      type: X(Function),
      required: !0
    },
    position: {
      type: String,
      values: ["top-right", "top-left", "bottom-right", "bottom-left"],
      default: "top-right"
    },
    showClose: {
      type: Boolean,
      default: !0
    },
    title: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      values: [...R_, ""],
      default: ""
    },
    zIndex: Number,
    closeIcon: {
      type: Lt,
      default: Oo
    }
  }), wJ = {
    destroy: () => !0
  }, CJ = /* @__PURE__ */ U({
    name: "ElNotification"
  }), SJ = /* @__PURE__ */ U({
    ...CJ,
    props: yJ,
    emits: wJ,
    setup(e, { expose: t }) {
      const n = e, { ns: o, zIndex: l } = xd("notification"), { nextZIndex: a, currentZIndex: r } = l, i = A(!1);
      let u;
      const c = S(() => {
        const C = n.type;
        return C && Ma[n.type] ? o.m(C) : "";
      }), d = S(() => n.type && Ma[n.type] || n.icon), f = S(() => n.position.endsWith("right") ? "right" : "left"), v = S(() => n.position.startsWith("top") ? "top" : "bottom"), p = S(() => {
        var C;
        return {
          [v.value]: `${n.offset}px`,
          zIndex: (C = n.zIndex) != null ? C : r.value
        };
      });
      function m() {
        n.duration > 0 && ({ stop: u } = os(() => {
          i.value && g();
        }, n.duration));
      }
      function h() {
        u == null || u();
      }
      function g() {
        i.value = !1;
      }
      function b(C) {
        switch (Ht(C)) {
          case _e.delete:
          case _e.backspace:
            h();
            break;
          case _e.esc:
            i.value && g();
            break;
          default:
            m();
            break;
        }
      }
      return ft(() => {
        m(), a(), i.value = !0;
      }), Dt(document, "keydown", b), t({
        visible: i,
        close: g
      }), (C, w) => (_(), ae(Mn, {
        name: s(o).b("fade"),
        onBeforeLeave: C.onClose,
        onAfterLeave: (y) => C.$emit("destroy"),
        persisted: ""
      }, {
        default: Q(() => [
          it(W("div", {
            id: C.id,
            class: $([s(o).b(), C.customClass, s(f)]),
            style: Ue(s(p)),
            role: "alert",
            onMouseenter: h,
            onMouseleave: m,
            onClick: C.onClick
          }, [
            s(d) ? (_(), ae(s(ze), {
              key: 0,
              class: $([s(o).e("icon"), s(c)])
            }, {
              default: Q(() => [
                (_(), ae(ct(s(d))))
              ]),
              _: 1
            }, 8, ["class"])) : oe("v-if", !0),
            W("div", {
              class: $(s(o).e("group"))
            }, [
              W("h2", {
                class: $(s(o).e("title")),
                textContent: ke(C.title)
              }, null, 10, ["textContent"]),
              it(W("div", {
                class: $(s(o).e("content")),
                style: Ue(C.title ? void 0 : { margin: 0 })
              }, [
                ee(C.$slots, "default", {}, () => [
                  C.dangerouslyUseHTMLString ? (_(), B(We, { key: 1 }, [
                    oe(" Caution here, message could've been compromised, never use user's input as message "),
                    W("p", { innerHTML: C.message }, null, 8, ["innerHTML"])
                  ], 2112)) : (_(), B("p", { key: 0 }, ke(C.message), 1))
                ])
              ], 6), [
                [Mt, C.message]
              ]),
              C.showClose ? (_(), ae(s(ze), {
                key: 0,
                class: $(s(o).e("closeBtn")),
                onClick: Ze(g, ["stop"])
              }, {
                default: Q(() => [
                  (_(), ae(ct(C.closeIcon)))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : oe("v-if", !0)
            ], 2)
          ], 46, ["id", "onClick"]), [
            [Mt, i.value]
          ])
        ]),
        _: 3
      }, 8, ["name", "onBeforeLeave", "onAfterLeave"]));
    }
  });
  var EJ = /* @__PURE__ */ Ne(SJ, [["__file", "notification.vue"]]);
  const ms = {
    "top-left": [],
    "top-right": [],
    "bottom-left": [],
    "bottom-right": []
  }, sd = 16;
  let kJ = 1;
  const gr = function(e = {}, t) {
    if (!xt)
      return { close: () => {
      } };
    (Ae(e) || Wt(e)) && (e = { message: e });
    const n = e.position || "top-right";
    let o = e.offset || 0;
    ms[n].forEach(({ vm: d }) => {
      var f;
      o += (((f = d.el) == null ? void 0 : f.offsetHeight) || 0) + sd;
    }), o += sd;
    const l = `notification_${kJ++}`, a = e.onClose, r = {
      ...e,
      offset: o,
      id: l,
      onClose: () => {
        _J(l, n, a);
      }
    };
    let i = document.body;
    Qn(e.appendTo) ? i = e.appendTo : Ae(e.appendTo) && (i = document.querySelector(e.appendTo)), Qn(i) || (vt("ElNotification", "the appendTo option is not an HTMLElement. Falling back to document.body."), i = document.body);
    const u = document.createElement("div"), c = q(EJ, r, Fe(r.message) ? r.message : Wt(r.message) ? () => r.message : null);
    return c.appContext = kt(t) ? gr._context : t, c.props.onDestroy = () => {
      Na(null, u);
    }, Na(c, u), ms[n].push({ vm: c }), i.appendChild(u.firstElementChild), {
      close: () => {
        c.component.exposed.visible.value = !1;
      }
    };
  };
  R_.forEach((e) => {
    gr[e] = (t = {}, n) => ((Ae(t) || Wt(t)) && (t = {
      message: t
    }), gr({ ...t, type: e }, n));
  });
  function _J(e, t, n) {
    const o = ms[t], l = o.findIndex(({ vm: c }) => {
      var d;
      return ((d = c.component) == null ? void 0 : d.props.id) === e;
    });
    if (l === -1)
      return;
    const { vm: a } = o[l];
    if (!a)
      return;
    n == null || n(a);
    const r = a.el.offsetHeight, i = t.split("-")[0];
    o.splice(l, 1);
    const u = o.length;
    if (!(u < 1))
      for (let c = l; c < u; c++) {
        const { el: d, component: f } = o[c].vm, v = Number.parseInt(d.style[i], 10) - r - sd;
        f.props.offset = v;
      }
  }
  function TJ() {
    for (const e of Object.values(ms))
      e.forEach(({ vm: t }) => {
        t.component.exposed.visible.value = !1;
      });
  }
  function NJ(e = "top-right") {
    var t, n, o, l;
    let a = ((o = (n = (t = ms[e][0]) == null ? void 0 : t.vm.component) == null ? void 0 : n.props) == null ? void 0 : o.offset) || 0;
    for (const { vm: r } of ms[e])
      r.component.props.offset = a, a += (((l = r.el) == null ? void 0 : l.offsetHeight) || 0) + sd;
  }
  gr.closeAll = TJ;
  gr.updateOffsets = NJ;
  gr._context = null;
  const $J = vC(gr, "$notify");
  var OJ = [
    LX,
    KX,
    rJ,
    bJ,
    $J,
    UE
  ], IJ = hR([...MX, ...OJ]);
  class MJ extends HTMLElement {
    constructor() {
      super(), this._props = { name: "", age: 0, listData: [] }, this.vueApp = null;
    }
    static get observedAttributes() {
      return ["name", "age"];
    }
    attributeChangedCallback(t, n, o) {
      t === "name" && (this._props.name = o), t === "age" && (this._props.age = Number(o)), this.renderVue();
    }
    set listData(t) {
      this._props.listData = t || [], this.renderVue();
    }
    connectedCallback() {
      this.renderVue();
    }
    disconnectedCallback() {
      this.vueApp && (this.vueApp.unmount(), this.vueApp = null);
    }
    renderVue() {
      this.isConnected && (this.vueApp || (this.vueApp = r1({
        render: () => qe(QN, this._props)
      }).use(IJ), this.vueApp.mount(this)));
    }
  }
  customElements.define("user-card", MJ);
});
export default xJ();
